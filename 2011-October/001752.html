<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2go-Commits] nxcomp.git - master (branch) updated:	3.5.0-1-5-ge9e2aeb
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2011-October/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2go-Commits%5D%20nxcomp.git%20-%20master%20%28branch%29%20updated%3A%0A%093.5.0-1-5-ge9e2aeb&In-Reply-To=%3C20111013205209.0C0A75DD11%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001751.html">
   <LINK REL="Next"  HREF="001753.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2go-Commits] nxcomp.git - master (branch) updated:	3.5.0-1-5-ge9e2aeb</H1>
    <B>X2go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2go-Commits%5D%20nxcomp.git%20-%20master%20%28branch%29%20updated%3A%0A%093.5.0-1-5-ge9e2aeb&In-Reply-To=%3C20111013205209.0C0A75DD11%40ymir%3E"
       TITLE="[X2go-Commits] nxcomp.git - master (branch) updated:	3.5.0-1-5-ge9e2aeb">git-admin at x2go.org
       </A><BR>
    <I>Thu Oct 13 22:52:08 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="001751.html">[X2go-Commits] x2goplasmabindings.git - master (branch) updated:	8570c908d70b578ab4e84bfa508c4c05b9b6837b
</A></li>
        <LI>Next message: <A HREF="001753.html">[X2go-Commits] nxcompext.git - master (branch) updated:	3.5.0-1-2-gfc96513
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1752">[ date ]</a>
              <a href="thread.html#1752">[ thread ]</a>
              <a href="subject.html#1752">[ subject ]</a>
              <a href="author.html#1752">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, master has been updated
       via  e9e2aeb9f3e6d3076444a5286837b2170f621857 (commit)
       via  d371fceea456f4917de74c9a9c39e9ff79ae183c (commit)
      from  2839639f0450cc782f7879aa31a9cc407df3f6c8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e9e2aeb9f3e6d3076444a5286837b2170f621857
Author: Reinhard Tartler &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">siretart at tauware.de</A>&gt;
Date:   Thu Oct 13 22:50:24 2011 +0200

    add additional missing replacement NX-X11 headers

commit d371fceea456f4917de74c9a9c39e9ff79ae183c
Author: Reinhard Tartler &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">siretart at tauware.de</A>&gt;
Date:   Thu Oct 13 22:20:47 2011 +0200

    add additional conflicts/replaces for x11proto-nx-dev

-----------------------------------------------------------------------

Summary of changes:
 X11/XIstubs.h                         |   76 +
 X11/Xlib.h                            | 4029 +++++++++++++++++++++++++++++++++
 X11/XlibConf.h                        |    7 +
 X11/Xlibint.h                         | 1346 +++++++++++
 X11/Xutil.h                           |  827 +++++++
 X11/bstore.h                          |   23 +
 X11/bstorestr.h                       |   58 +
 X11/closestr.h                        |  159 ++
 X11/{Xprotostr.h =&gt; closure.h}        |   38 +-
 X11/colormap.h                        |  184 ++
 X11/{Xprotostr.h =&gt; colormapst.h}     |  111 +-
 X11/cursor.h                          |  149 ++
 X11/{Xprotostr.h =&gt; cursorstr.h}      |   84 +-
 X11/dix.h                             |  817 +++++++
 X11/dixevents.h                       |  106 +
 X11/dixfont.h                         |  155 ++
 X11/dixfontstr.h                      |   95 +
 X11/dixgrabs.h                        |   59 +
 X11/dixstruct.h                       |  236 ++
 X11/exevents.h                        |  183 ++
 X11/{Xprotostr.h =&gt; extension.h}      |   37 +-
 X11/extinit.h                         |  166 ++
 X11/extnsionst.h                      |  152 ++
 X11/gc.h                              |  178 ++
 X11/gcstruct.h                        |  328 +++
 X11/globals.h                         |  192 ++
 X11/input.h                           |  391 ++++
 X11/inputstr.h                        |  314 +++
 X11/misc.h                            |  269 +++
 X11/{Xprotostr.h =&gt; miscstruct.h}     |   66 +-
 X11/opaque.h                          |   83 +
 X11/os.h                              |  546 +++++
 X11/{Xprotostr.h =&gt; pixmap.h}         |   80 +-
 X11/{Xprotostr.h =&gt; pixmapstr.h}      |   74 +-
 X11/{Xprotostr.h =&gt; property.h}       |   46 +-
 X11/{Xprotostr.h =&gt; propertyst.h}     |   60 +-
 X11/{Xprotostr.h =&gt; region.h}         |   34 +-
 X11/regionstr.h                       |  412 ++++
 X11/resource.h                        |  274 +++
 X11/{Xprotostr.h =&gt; rgb.h}            |   40 +-
 X11/{Xprotostr.h =&gt; screenint.h}      |   83 +-
 X11/scrnintstr.h                      |  733 ++++++
 X11/{Xprotostr.h =&gt; selection.h}      |   43 +-
 X11/servermd.h                        |  583 +++++
 X11/site.h                            |  139 ++
 X11/swaprep.h                         |  322 +++
 X11/swapreq.h                         |  120 +
 X11/{extensions/Xext.h =&gt; validate.h} |   43 +-
 X11/window.h                          |  265 +++
 X11/windowstr.h                       |  234 ++
 debian/control                        |   21 +-
 51 files changed, 14664 insertions(+), 406 deletions(-)
 create mode 100644 X11/XIstubs.h
 create mode 100644 X11/Xlib.h
 create mode 100644 X11/XlibConf.h
 create mode 100644 X11/Xlibint.h
 create mode 100644 X11/Xutil.h
 create mode 100644 X11/bstore.h
 create mode 100644 X11/bstorestr.h
 create mode 100644 X11/closestr.h
 copy X11/{Xprotostr.h =&gt; closure.h} (79%)
 create mode 100644 X11/colormap.h
 copy X11/{Xprotostr.h =&gt; colormapst.h} (52%)
 create mode 100644 X11/cursor.h
 copy X11/{Xprotostr.h =&gt; cursorstr.h} (61%)
 create mode 100644 X11/dix.h
 create mode 100644 X11/dixevents.h
 create mode 100644 X11/dixfont.h
 create mode 100644 X11/dixfontstr.h
 create mode 100644 X11/dixgrabs.h
 create mode 100644 X11/dixstruct.h
 create mode 100644 X11/exevents.h
 copy X11/{Xprotostr.h =&gt; extension.h} (79%)
 create mode 100644 X11/extinit.h
 create mode 100644 X11/extnsionst.h
 create mode 100644 X11/gc.h
 create mode 100644 X11/gcstruct.h
 create mode 100644 X11/globals.h
 create mode 100644 X11/input.h
 create mode 100644 X11/inputstr.h
 create mode 100644 X11/misc.h
 copy X11/{Xprotostr.h =&gt; miscstruct.h} (71%)
 create mode 100644 X11/opaque.h
 create mode 100644 X11/os.h
 copy X11/{Xprotostr.h =&gt; pixmap.h} (61%)
 copy X11/{Xprotostr.h =&gt; pixmapstr.h} (69%)
 copy X11/{Xprotostr.h =&gt; property.h} (78%)
 copy X11/{Xprotostr.h =&gt; propertyst.h} (70%)
 copy X11/{Xprotostr.h =&gt; region.h} (79%)
 create mode 100644 X11/regionstr.h
 create mode 100644 X11/resource.h
 copy X11/{Xprotostr.h =&gt; rgb.h} (79%)
 copy X11/{Xprotostr.h =&gt; screenint.h} (60%)
 create mode 100644 X11/scrnintstr.h
 copy X11/{Xprotostr.h =&gt; selection.h} (79%)
 create mode 100644 X11/servermd.h
 create mode 100644 X11/site.h
 create mode 100644 X11/swaprep.h
 create mode 100644 X11/swapreq.h
 copy X11/{extensions/Xext.h =&gt; validate.h} (66%)
 create mode 100644 X11/window.h
 create mode 100644 X11/windowstr.h

The diff of changes is:
diff --git a/X11/XIstubs.h b/X11/XIstubs.h
new file mode 100644
index 0000000..e005493
--- /dev/null
+++ b/X11/XIstubs.h
@@ -0,0 +1,76 @@
+/* $XFree86: xc/programs/Xserver/include/XIstubs.h,v 3.1 1996/04/15 11:34:22 dawes Exp $ */
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dickey at clark.net</A>&gt;
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef XI_STUBS_H
+#define XI_STUBS_H 1
+
+int
+ChangeKeyboardDevice (
+	DeviceIntPtr           /* old_dev */,
+	DeviceIntPtr           /* new_dev */);
+
+int
+ChangePointerDevice (
+	DeviceIntPtr           /* old_dev */,
+	DeviceIntPtr           /* new_dev */,
+	unsigned char          /* x */,
+	unsigned char          /* y */);
+
+void
+CloseInputDevice (
+	DeviceIntPtr           /* d */,
+	ClientPtr              /* client */);
+
+void
+AddOtherInputDevices (void);
+
+void
+OpenInputDevice (
+	DeviceIntPtr           /* dev */,
+	ClientPtr              /* client */,
+	int *                  /* status */);
+
+int
+SetDeviceMode (
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	int                    /* mode */);
+
+int
+SetDeviceValuators (
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	int *                  /* valuators */,
+	int                    /* first_valuator */,
+	int                    /* num_valuators */);
+
+int
+ChangeDeviceControl (
+	ClientPtr             /* client */,
+	DeviceIntPtr          /* dev */,
+	xDeviceCtl *          /* control */);
+
+#endif /* XI_STUBS_H */
diff --git a/X11/Xlib.h b/X11/Xlib.h
new file mode 100644
index 0000000..e21d9ff
--- /dev/null
+++ b/X11/Xlib.h
@@ -0,0 +1,4029 @@
+/* $XdotOrg: xc/lib/X11/Xlib.h,v 1.6 2005/11/08 06:33:25 jkj Exp $ */
+/* $Xorg: Xlib.h,v 1.6 2001/02/09 02:03:38 xorgcvs Exp $ */
+/* 
+
+Copyright 1985, 1986, 1987, 1991, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+/* $XFree86: xc/lib/X11/Xlib.h,v 3.25 2003/11/17 22:20:10 dawes Exp $ */
+
+
+/*
+ *	Xlib.h - Header definition and support file for the C subroutine
+ *	interface library (Xlib) to the X Window System Protocol (V11).
+ *	Structures and symbols starting with &quot;_&quot; are private to the library.
+ */
+#ifndef _XLIB_H_
+#define _XLIB_H_
+
+#define XlibSpecificationRelease 6
+
+#ifdef USG
+#ifndef __TYPES__
+#include &lt;sys/types.h&gt;			/* forgot to protect it... */
+#define __TYPES__
+#endif /* __TYPES__ */
+#else
+#if defined(_POSIX_SOURCE) &amp;&amp; defined(MOTOROLA)
+#undef _POSIX_SOURCE
+#include &lt;sys/types.h&gt;
+#define _POSIX_SOURCE
+#else
+#include &lt;sys/types.h&gt;
+#endif
+#endif /* USG */
+
+#if defined(__SCO__) || defined(__UNIXWARE__)
+#include &lt;stdint.h&gt;
+#endif
+
+#include &lt;X11/X.h&gt;
+
+/* applications should not depend on these two headers being included! */
+#include &lt;X11/Xfuncproto.h&gt;
+#include &lt;X11/Xosdefs.h&gt;
+
+#ifndef X_WCHAR
+#ifdef X_NOT_STDC_ENV
+#ifndef ISC
+#define X_WCHAR
+#endif
+#endif
+#endif
+
+#ifndef X_WCHAR
+#include &lt;stddef.h&gt;
+#else
+#ifdef __UNIXOS2__
+#include &lt;stdlib.h&gt;
+#else
+/* replace this with #include or typedef appropriate for your system */
+typedef unsigned long wchar_t;
+#endif
+#endif
+
+#if defined(ISC) &amp;&amp; defined(USE_XMBTOWC)
+#define wctomb(a,b)	_Xwctomb(a,b)
+#define mblen(a,b)	_Xmblen(a,b) 
+#ifndef USE_XWCHAR_STRING
+#define mbtowc(a,b,c)	_Xmbtowc(a,b,c)
+#endif
+#endif
+
+extern int
+_Xmblen(
+#ifdef ISC
+    char const *str,
+    size_t len
+#else
+    char *str,
+    int len
+#endif
+    );
+
+/* API mentioning &quot;UTF8&quot; or &quot;utf8&quot; is an XFree86 extension, introduced in
+   November 2000. Its presence is indicated through the following macro. */
+#define X_HAVE_UTF8_STRING 1
+
+typedef char *XPointer;
+
+#define Bool int
+#define Status int
+#define True 1
+#define False 0
+
+#define QueuedAlready 0
+#define QueuedAfterReading 1
+#define QueuedAfterFlush 2
+
+#define ConnectionNumber(dpy) 	(((_XPrivDisplay)dpy)-&gt;fd)
+#define RootWindow(dpy, scr) 	(ScreenOfDisplay(dpy,scr)-&gt;root)
+#define DefaultScreen(dpy) 	(((_XPrivDisplay)dpy)-&gt;default_screen)
+#define DefaultRootWindow(dpy) 	(ScreenOfDisplay(dpy,DefaultScreen(dpy))-&gt;root)
+#define DefaultVisual(dpy, scr) (ScreenOfDisplay(dpy,scr)-&gt;root_visual)
+#define DefaultGC(dpy, scr) 	(ScreenOfDisplay(dpy,scr)-&gt;default_gc)
+#define BlackPixel(dpy, scr) 	(ScreenOfDisplay(dpy,scr)-&gt;black_pixel)
+#define WhitePixel(dpy, scr) 	(ScreenOfDisplay(dpy,scr)-&gt;white_pixel)
+#define AllPlanes 		((unsigned long)~0L)
+#define QLength(dpy) 		(((_XPrivDisplay)dpy)-&gt;qlen)
+#define DisplayWidth(dpy, scr) 	(ScreenOfDisplay(dpy,scr)-&gt;width)
+#define DisplayHeight(dpy, scr) (ScreenOfDisplay(dpy,scr)-&gt;height)
+#define DisplayWidthMM(dpy, scr)(ScreenOfDisplay(dpy,scr)-&gt;mwidth)
+#define DisplayHeightMM(dpy, scr)(ScreenOfDisplay(dpy,scr)-&gt;mheight)
+#define DisplayPlanes(dpy, scr) (ScreenOfDisplay(dpy,scr)-&gt;root_depth)
+#define DisplayCells(dpy, scr) 	(DefaultVisual(dpy,scr)-&gt;map_entries)
+#define ScreenCount(dpy) 	(((_XPrivDisplay)dpy)-&gt;nscreens)
+#define ServerVendor(dpy) 	(((_XPrivDisplay)dpy)-&gt;vendor)
+#define ProtocolVersion(dpy) 	(((_XPrivDisplay)dpy)-&gt;proto_major_version)
+#define ProtocolRevision(dpy) 	(((_XPrivDisplay)dpy)-&gt;proto_minor_version)
+#define VendorRelease(dpy) 	(((_XPrivDisplay)dpy)-&gt;release)
+#define DisplayString(dpy) 	(((_XPrivDisplay)dpy)-&gt;display_name)
+#define DefaultDepth(dpy, scr) 	(ScreenOfDisplay(dpy,scr)-&gt;root_depth)
+#define DefaultColormap(dpy, scr)(ScreenOfDisplay(dpy,scr)-&gt;cmap)
+#define BitmapUnit(dpy) 	(((_XPrivDisplay)dpy)-&gt;bitmap_unit)
+#define BitmapBitOrder(dpy) 	(((_XPrivDisplay)dpy)-&gt;bitmap_bit_order)
+#define BitmapPad(dpy) 		(((_XPrivDisplay)dpy)-&gt;bitmap_pad)
+#define ImageByteOrder(dpy) 	(((_XPrivDisplay)dpy)-&gt;byte_order)
+#ifdef CRAY /* unable to get WORD64 without pulling in other symbols */
+#define NextRequest(dpy)	XNextRequest(dpy)
+#else
+#define NextRequest(dpy)	(((_XPrivDisplay)dpy)-&gt;request + 1)
+#endif
+#define LastKnownRequestProcessed(dpy)	(((_XPrivDisplay)dpy)-&gt;last_request_read)
+
+/* macros for screen oriented applications (toolkit) */
+#define ScreenOfDisplay(dpy, scr)(&amp;((_XPrivDisplay)dpy)-&gt;screens[scr])
+#define DefaultScreenOfDisplay(dpy) ScreenOfDisplay(dpy,DefaultScreen(dpy))
+#define DisplayOfScreen(s)	((s)-&gt;display)
+#define RootWindowOfScreen(s)	((s)-&gt;root)
+#define BlackPixelOfScreen(s)	((s)-&gt;black_pixel)
+#define WhitePixelOfScreen(s)	((s)-&gt;white_pixel)
+#define DefaultColormapOfScreen(s)((s)-&gt;cmap)
+#define DefaultDepthOfScreen(s)	((s)-&gt;root_depth)
+#define DefaultGCOfScreen(s)	((s)-&gt;default_gc)
+#define DefaultVisualOfScreen(s)((s)-&gt;root_visual)
+#define WidthOfScreen(s)	((s)-&gt;width)
+#define HeightOfScreen(s)	((s)-&gt;height)
+#define WidthMMOfScreen(s)	((s)-&gt;mwidth)
+#define HeightMMOfScreen(s)	((s)-&gt;mheight)
+#define PlanesOfScreen(s)	((s)-&gt;root_depth)
+#define CellsOfScreen(s)	(DefaultVisualOfScreen((s))-&gt;map_entries)
+#define MinCmapsOfScreen(s)	((s)-&gt;min_maps)
+#define MaxCmapsOfScreen(s)	((s)-&gt;max_maps)
+#define DoesSaveUnders(s)	((s)-&gt;save_unders)
+#define DoesBackingStore(s)	((s)-&gt;backing_store)
+#define EventMaskOfScreen(s)	((s)-&gt;root_input_mask)
+
+/*
+ * Extensions need a way to hang private data on some structures.
+ */
+typedef struct _XExtData {
+	int number;		/* number returned by XRegisterExtension */
+	struct _XExtData *next;	/* next item on list of data for structure */
+	int (*free_private)(	/* called to free private storage */
+	struct _XExtData *extension
+	);
+	XPointer private_data;	/* data private to this extension. */
+} XExtData;
+
+/*
+ * This file contains structures used by the extension mechanism.
+ */
+typedef struct {		/* public to extension, cannot be changed */
+	int extension;		/* extension number */
+	int major_opcode;	/* major op-code assigned by server */
+	int first_event;	/* first event number for the extension */
+	int first_error;	/* first error number for the extension */
+} XExtCodes;
+
+/*
+ * Data structure for retrieving info about pixmap formats.
+ */
+
+typedef struct {
+    int depth;
+    int bits_per_pixel;
+    int scanline_pad;
+} XPixmapFormatValues;
+
+
+/*
+ * Data structure for setting graphics context.
+ */
+typedef struct {
+	int function;		/* logical operation */
+	unsigned long plane_mask;/* plane mask */
+	unsigned long foreground;/* foreground pixel */
+	unsigned long background;/* background pixel */
+	int line_width;		/* line width */
+	int line_style;	 	/* LineSolid, LineOnOffDash, LineDoubleDash */
+	int cap_style;	  	/* CapNotLast, CapButt, 
+				   CapRound, CapProjecting */
+	int join_style;	 	/* JoinMiter, JoinRound, JoinBevel */
+	int fill_style;	 	/* FillSolid, FillTiled, 
+				   FillStippled, FillOpaeueStippled */
+	int fill_rule;	  	/* EvenOddRule, WindingRule */
+	int arc_mode;		/* ArcChord, ArcPieSlice */
+	Pixmap tile;		/* tile pixmap for tiling operations */
+	Pixmap stipple;		/* stipple 1 plane pixmap for stipping */
+	int ts_x_origin;	/* offset for tile or stipple operations */
+	int ts_y_origin;
+        Font font;	        /* default text font for text operations */
+	int subwindow_mode;     /* ClipByChildren, IncludeInferiors */
+	Bool graphics_exposures;/* boolean, should exposures be generated */
+	int clip_x_origin;	/* origin for clipping */
+	int clip_y_origin;
+	Pixmap clip_mask;	/* bitmap clipping; other calls for rects */
+	int dash_offset;	/* patterned/dashed line information */
+	char dashes;
+} XGCValues;
+
+/*
+ * Graphics context.  The contents of this structure are implementation
+ * dependent.  A GC should be treated as opaque by application code.
+ */
+
+typedef struct _XGC
+#ifdef XLIB_ILLEGAL_ACCESS
+{
+    XExtData *ext_data;	/* hook for extension to hang data */
+    GContext gid;	/* protocol ID for graphics context */
+    /* there is more to this structure, but it is private to Xlib */
+}
+#endif
+*GC;
+
+/*
+ * Visual structure; contains information about colormapping possible.
+ */
+typedef struct {
+	XExtData *ext_data;	/* hook for extension to hang data */
+	VisualID visualid;	/* visual id of this visual */
+#if defined(__cplusplus) || defined(c_plusplus)
+	int c_class;		/* C++ class of screen (monochrome, etc.) */
+#else
+	int class;		/* class of screen (monochrome, etc.) */
+#endif
+	unsigned long red_mask, green_mask, blue_mask;	/* mask values */
+	int bits_per_rgb;	/* log base 2 of distinct color values */
+	int map_entries;	/* color map entries */
+} Visual;
+
+/*
+ * Depth structure; contains information for each possible depth.
+ */	
+typedef struct {
+	int depth;		/* this depth (Z) of the depth */
+	int nvisuals;		/* number of Visual types at this depth */
+	Visual *visuals;	/* list of visuals possible at this depth */
+} Depth;
+
+/*
+ * Information about the screen.  The contents of this structure are
+ * implementation dependent.  A Screen should be treated as opaque
+ * by application code.
+ */
+
+struct _XDisplay;		/* Forward declare before use for C++ */
+
+typedef struct {
+	XExtData *ext_data;	/* hook for extension to hang data */
+	struct _XDisplay *display;/* back pointer to display structure */
+	Window root;		/* Root window id. */
+	int width, height;	/* width and height of screen */
+	int mwidth, mheight;	/* width and height of  in millimeters */
+	int ndepths;		/* number of depths possible */
+	Depth *depths;		/* list of allowable depths on the screen */
+	int root_depth;		/* bits per pixel */
+	Visual *root_visual;	/* root visual */
+	GC default_gc;		/* GC for the root root visual */
+	Colormap cmap;		/* default color map */
+	unsigned long white_pixel;
+	unsigned long black_pixel;	/* White and Black pixel values */
+	int max_maps, min_maps;	/* max and min color maps */
+	int backing_store;	/* Never, WhenMapped, Always */
+	Bool save_unders;	
+	long root_input_mask;	/* initial root input mask */
+} Screen;
+
+/*
+ * Format structure; describes ZFormat data the screen will understand.
+ */
+typedef struct {
+	XExtData *ext_data;	/* hook for extension to hang data */
+	int depth;		/* depth of this image format */
+	int bits_per_pixel;	/* bits/pixel at this depth */
+	int scanline_pad;	/* scanline must padded to this multiple */
+} ScreenFormat;
+
+/*
+ * Data structure for setting window attributes.
+ */
+typedef struct {
+    Pixmap background_pixmap;	/* background or None or ParentRelative */
+    unsigned long background_pixel;	/* background pixel */
+    Pixmap border_pixmap;	/* border of the window */
+    unsigned long border_pixel;	/* border pixel value */
+    int bit_gravity;		/* one of bit gravity values */
+    int win_gravity;		/* one of the window gravity values */
+    int backing_store;		/* NotUseful, WhenMapped, Always */
+    unsigned long backing_planes;/* planes to be preseved if possible */
+    unsigned long backing_pixel;/* value to use in restoring planes */
+    Bool save_under;		/* should bits under be saved? (popups) */
+    long event_mask;		/* set of events that should be saved */
+    long do_not_propagate_mask;	/* set of events that should not propagate */
+    Bool override_redirect;	/* boolean value for override-redirect */
+    Colormap colormap;		/* color map to be associated with window */
+    Cursor cursor;		/* cursor to be displayed (or None) */
+} XSetWindowAttributes;
+
+typedef struct {
+    int x, y;			/* location of window */
+    int width, height;		/* width and height of window */
+    int border_width;		/* border width of window */
+    int depth;          	/* depth of window */
+    Visual *visual;		/* the associated visual structure */
+    Window root;        	/* root of screen containing window */
+#if defined(__cplusplus) || defined(c_plusplus)
+    int c_class;		/* C++ InputOutput, InputOnly*/
+#else
+    int class;			/* InputOutput, InputOnly*/
+#endif
+    int bit_gravity;		/* one of bit gravity values */
+    int win_gravity;		/* one of the window gravity values */
+    int backing_store;		/* NotUseful, WhenMapped, Always */
+    unsigned long backing_planes;/* planes to be preserved if possible */
+    unsigned long backing_pixel;/* value to be used when restoring planes */
+    Bool save_under;		/* boolean, should bits under be saved? */
+    Colormap colormap;		/* color map to be associated with window */
+    Bool map_installed;		/* boolean, is color map currently installed*/
+    int map_state;		/* IsUnmapped, IsUnviewable, IsViewable */
+    long all_event_masks;	/* set of events all people have interest in*/
+    long your_event_mask;	/* my event mask */
+    long do_not_propagate_mask; /* set of events that should not propagate */
+    Bool override_redirect;	/* boolean value for override-redirect */
+    Screen *screen;		/* back pointer to correct screen */
+} XWindowAttributes;
+
+/*
+ * Data structure for host setting; getting routines.
+ *
+ */
+
+typedef struct {
+	int family;		/* for example FamilyInternet */
+	int length;		/* length of address, in bytes */
+	char *address;		/* pointer to where to find the bytes */
+} XHostAddress;
+
+/*
+ * Data structure for ServerFamilyInterpreted addresses in host routines
+ */
+typedef struct {
+	int typelength;		/* length of type string, in bytes */
+	int valuelength;	/* length of value string, in bytes */
+	char *type;		/* pointer to where to find the type string */
+	char *value;		/* pointer to where to find the address */
+} XServerInterpretedAddress;
+
+/*
+ * Data structure for &quot;image&quot; data, used by image manipulation routines.
+ */
+typedef struct _XImage {
+    int width, height;		/* size of image */
+    int xoffset;		/* number of pixels offset in X direction */
+    int format;			/* XYBitmap, XYPixmap, ZPixmap */
+    char *data;			/* pointer to image data */
+    int byte_order;		/* data byte order, LSBFirst, MSBFirst */
+    int bitmap_unit;		/* quant. of scanline 8, 16, 32 */
+    int bitmap_bit_order;	/* LSBFirst, MSBFirst */
+    int bitmap_pad;		/* 8, 16, 32 either XY or ZPixmap */
+    int depth;			/* depth of image */
+    int bytes_per_line;		/* accelarator to next line */
+    int bits_per_pixel;		/* bits per pixel (ZPixmap) */
+    unsigned long red_mask;	/* bits in z arrangment */
+    unsigned long green_mask;
+    unsigned long blue_mask;
+    XPointer obdata;		/* hook for the object routines to hang on */
+    struct funcs {		/* image manipulation routines */
+	struct _XImage *(*create_image)(
+		struct _XDisplay* /* display */,
+		Visual*		/* visual */,
+		unsigned int	/* depth */,
+		int		/* format */,
+		int		/* offset */,
+		char*		/* data */,
+		unsigned int	/* width */,
+		unsigned int	/* height */,
+		int		/* bitmap_pad */,
+		int		/* bytes_per_line */);
+	int (*destroy_image)        (struct _XImage *);
+	unsigned long (*get_pixel)  (struct _XImage *, int, int);
+	int (*put_pixel)            (struct _XImage *, int, int, unsigned long);
+	struct _XImage *(*sub_image)(struct _XImage *, int, int, unsigned int, unsigned int);
+	int (*add_pixel)            (struct _XImage *, long);
+	} f;
+} XImage;
+
+/* 
+ * Data structure for XReconfigureWindow
+ */
+typedef struct {
+    int x, y;
+    int width, height;
+    int border_width;
+    Window sibling;
+    int stack_mode;
+} XWindowChanges;
+
+/*
+ * Data structure used by color operations
+ */
+typedef struct {
+	unsigned long pixel;
+	unsigned short red, green, blue;
+	char flags;  /* do_red, do_green, do_blue */
+	char pad;
+} XColor;
+
+/* 
+ * Data structures for graphics operations.  On most machines, these are
+ * congruent with the wire protocol structures, so reformatting the data
+ * can be avoided on these architectures.
+ */
+typedef struct {
+    short x1, y1, x2, y2;
+} XSegment;
+
+typedef struct {
+    short x, y;
+} XPoint;
+    
+typedef struct {
+    short x, y;
+    unsigned short width, height;
+} XRectangle;
+    
+typedef struct {
+    short x, y;
+    unsigned short width, height;
+    short angle1, angle2;
+} XArc;
+
+
+/* Data structure for XChangeKeyboardControl */
+
+typedef struct {
+        int key_click_percent;
+        int bell_percent;
+        int bell_pitch;
+        int bell_duration;
+        int led;
+        int led_mode;
+        int key;
+        int auto_repeat_mode;   /* On, Off, Default */
+} XKeyboardControl;
+
+/* Data structure for XGetKeyboardControl */
+
+typedef struct {
+        int key_click_percent;
+	int bell_percent;
+	unsigned int bell_pitch, bell_duration;
+	unsigned long led_mask;
+	int global_auto_repeat;
+	char auto_repeats[32];
+} XKeyboardState;
+
+/* Data structure for XGetMotionEvents.  */
+
+typedef struct {
+        Time time;
+	short x, y;
+} XTimeCoord;
+
+/* Data structure for X{Set,Get}ModifierMapping */
+
+typedef struct {
+ 	int max_keypermod;	/* The server's max # of keys per modifier */
+ 	KeyCode *modifiermap;	/* An 8 by max_keypermod array of modifiers */
+} XModifierKeymap;
+
+
+/*
+ * Display datatype maintaining display specific data.
+ * The contents of this structure are implementation dependent.
+ * A Display should be treated as opaque by application code.
+ */
+#ifndef XLIB_ILLEGAL_ACCESS
+typedef struct _XDisplay Display;
+#endif
+
+struct _XPrivate;		/* Forward declare before use for C++ */
+struct _XrmHashBucketRec;
+
+typedef struct 
+#ifdef XLIB_ILLEGAL_ACCESS
+_XDisplay
+#endif
+{
+	XExtData *ext_data;	/* hook for extension to hang data */
+	struct _XPrivate *private1;
+	int fd;			/* Network socket. */
+	int private2;
+	int proto_major_version;/* major version of server's X protocol */
+	int proto_minor_version;/* minor version of servers X protocol */
+	char *vendor;		/* vendor of the server hardware */
+        XID private3;
+	XID private4;
+	XID private5;
+	int private6;
+	XID (*resource_alloc)(	/* allocator function */
+		struct _XDisplay*
+	);
+	int byte_order;		/* screen byte order, LSBFirst, MSBFirst */
+	int bitmap_unit;	/* padding and data requirements */
+	int bitmap_pad;		/* padding requirements on bitmaps */
+	int bitmap_bit_order;	/* LeastSignificant or MostSignificant */
+	int nformats;		/* number of pixmap formats in list */
+	ScreenFormat *pixmap_format;	/* pixmap format list */
+	int private8;
+	int release;		/* release of the server */
+	struct _XPrivate *private9, *private10;
+	int qlen;		/* Length of input event queue */
+	unsigned long last_request_read; /* seq number of last event read */
+	unsigned long request;	/* sequence number of last request. */
+	XPointer private11;
+	XPointer private12;
+	XPointer private13;
+	XPointer private14;
+	unsigned max_request_size; /* maximum number 32 bit words in request*/
+	struct _XrmHashBucketRec *db;
+	int (*private15)(
+		struct _XDisplay*
+		);
+	char *display_name;	/* &quot;host:display&quot; string used on this connect*/
+	int default_screen;	/* default screen for operations */
+	int nscreens;		/* number of screens on this server*/
+	Screen *screens;	/* pointer to list of screens */
+	unsigned long motion_buffer;	/* size of motion buffer */
+	unsigned long private16;
+	int min_keycode;	/* minimum defined keycode */
+	int max_keycode;	/* maximum defined keycode */
+	XPointer private17;
+	XPointer private18;
+	int private19;
+	char *xdefaults;	/* contents of defaults from server */
+	/* there is more to this structure, but it is private to Xlib */
+}
+#ifdef XLIB_ILLEGAL_ACCESS
+Display, 
+#endif
+*_XPrivDisplay;
+
+#undef _XEVENT_
+#ifndef _XEVENT_
+/*
+ * Definitions of specific events.
+ */
+typedef struct {
+	int type;		/* of event */
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;	        /* &quot;event&quot; window it is reported relative to */
+	Window root;	        /* root window that the event occurred on */
+	Window subwindow;	/* child window */
+	Time time;		/* milliseconds */
+	int x, y;		/* pointer x, y coordinates in event window */
+	int x_root, y_root;	/* coordinates relative to root */
+	unsigned int state;	/* key or button mask */
+	unsigned int keycode;	/* detail */
+	Bool same_screen;	/* same screen flag */
+} XKeyEvent;
+typedef XKeyEvent XKeyPressedEvent;
+typedef XKeyEvent XKeyReleasedEvent;
+
+typedef struct {
+	int type;		/* of event */
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;	        /* &quot;event&quot; window it is reported relative to */
+	Window root;	        /* root window that the event occurred on */
+	Window subwindow;	/* child window */
+	Time time;		/* milliseconds */
+	int x, y;		/* pointer x, y coordinates in event window */
+	int x_root, y_root;	/* coordinates relative to root */
+	unsigned int state;	/* key or button mask */
+	unsigned int button;	/* detail */
+	Bool same_screen;	/* same screen flag */
+} XButtonEvent;
+typedef XButtonEvent XButtonPressedEvent;
+typedef XButtonEvent XButtonReleasedEvent;
+
+typedef struct {
+	int type;		/* of event */
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;	        /* &quot;event&quot; window reported relative to */
+	Window root;	        /* root window that the event occurred on */
+	Window subwindow;	/* child window */
+	Time time;		/* milliseconds */
+	int x, y;		/* pointer x, y coordinates in event window */
+	int x_root, y_root;	/* coordinates relative to root */
+	unsigned int state;	/* key or button mask */
+	char is_hint;		/* detail */
+	Bool same_screen;	/* same screen flag */
+} XMotionEvent;
+typedef XMotionEvent XPointerMovedEvent;
+
+typedef struct {
+	int type;		/* of event */
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;	        /* &quot;event&quot; window reported relative to */
+	Window root;	        /* root window that the event occurred on */
+	Window subwindow;	/* child window */
+	Time time;		/* milliseconds */
+	int x, y;		/* pointer x, y coordinates in event window */
+	int x_root, y_root;	/* coordinates relative to root */
+	int mode;		/* NotifyNormal, NotifyGrab, NotifyUngrab */
+	int detail;
+	/*
+	 * NotifyAncestor, NotifyVirtual, NotifyInferior, 
+	 * NotifyNonlinear,NotifyNonlinearVirtual
+	 */
+	Bool same_screen;	/* same screen flag */
+	Bool focus;		/* boolean focus */
+	unsigned int state;	/* key or button mask */
+} XCrossingEvent;
+typedef XCrossingEvent XEnterWindowEvent;
+typedef XCrossingEvent XLeaveWindowEvent;
+
+typedef struct {
+	int type;		/* FocusIn or FocusOut */
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;		/* window of event */
+	int mode;		/* NotifyNormal, NotifyWhileGrabbed,
+				   NotifyGrab, NotifyUngrab */
+	int detail;
+	/*
+	 * NotifyAncestor, NotifyVirtual, NotifyInferior, 
+	 * NotifyNonlinear,NotifyNonlinearVirtual, NotifyPointer,
+	 * NotifyPointerRoot, NotifyDetailNone 
+	 */
+} XFocusChangeEvent;
+typedef XFocusChangeEvent XFocusInEvent;
+typedef XFocusChangeEvent XFocusOutEvent;
+
+/* generated on EnterWindow and FocusIn  when KeyMapState selected */
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	char key_vector[32];
+} XKeymapEvent;	
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	int x, y;
+	int width, height;
+	int count;		/* if non-zero, at least this many more */
+} XExposeEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Drawable drawable;
+	int x, y;
+	int width, height;
+	int count;		/* if non-zero, at least this many more */
+	int major_code;		/* core is CopyArea or CopyPlane */
+	int minor_code;		/* not defined in the core */
+} XGraphicsExposeEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Drawable drawable;
+	int major_code;		/* core is CopyArea or CopyPlane */
+	int minor_code;		/* not defined in the core */
+} XNoExposeEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	int state;		/* Visibility state */
+} XVisibilityEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window parent;		/* parent of the window */
+	Window window;		/* window id of window created */
+	int x, y;		/* window location */
+	int width, height;	/* size of window */
+	int border_width;	/* border width */
+	Bool override_redirect;	/* creation should be overridden */
+} XCreateWindowEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+} XDestroyWindowEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	Bool from_configure;
+} XUnmapEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	Bool override_redirect;	/* boolean, is override set... */
+} XMapEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window parent;
+	Window window;
+} XMapRequestEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	Window parent;
+	int x, y;
+	Bool override_redirect;
+} XReparentEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	int x, y;
+	int width, height;
+	int border_width;
+	Window above;
+	Bool override_redirect;
+} XConfigureEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	int x, y;
+} XGravityEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	int width, height;
+} XResizeRequestEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window parent;
+	Window window;
+	int x, y;
+	int width, height;
+	int border_width;
+	Window above;
+	int detail;		/* Above, Below, TopIf, BottomIf, Opposite */
+	unsigned long value_mask;
+} XConfigureRequestEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	int place;		/* PlaceOnTop, PlaceOnBottom */
+} XCirculateEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window parent;
+	Window window;
+	int place;		/* PlaceOnTop, PlaceOnBottom */
+} XCirculateRequestEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	Atom atom;
+	Time time;
+	int state;		/* NewValue, Deleted */
+} XPropertyEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	Atom selection;
+	Time time;
+} XSelectionClearEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window owner;
+	Window requestor;
+	Atom selection;
+	Atom target;
+	Atom property;
+	Time time;
+} XSelectionRequestEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window requestor;
+	Atom selection;
+	Atom target;
+	Atom property;		/* ATOM or None */
+	Time time;
+} XSelectionEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	Colormap colormap;	/* COLORMAP or None */
+#if defined(__cplusplus) || defined(c_plusplus)
+	Bool c_new;		/* C++ */
+#else
+	Bool new;
+#endif
+	int state;		/* ColormapInstalled, ColormapUninstalled */
+} XColormapEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	Atom message_type;
+	int format;
+	union {
+		char b[20];
+		short s[10];
+		long l[5];
+		} data;
+} XClientMessageEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;		/* unused */
+	int request;		/* one of MappingModifier, MappingKeyboard,
+				   MappingPointer */
+	int first_keycode;	/* first keycode */
+	int count;		/* defines range of change w. first_keycode*/
+} XMappingEvent;
+
+typedef struct {
+	int type;
+	Display *display;	/* Display the event was read from */
+	XID resourceid;		/* resource id */
+	unsigned long serial;	/* serial number of failed request */
+	unsigned char error_code;	/* error code of failed request */
+	unsigned char request_code;	/* Major op-code of failed request */
+	unsigned char minor_code;	/* Minor op-code of failed request */
+} XErrorEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	Bool send_event;	/* true if this came from a SendEvent request */
+	Display *display;/* Display the event was read from */
+	Window window;	/* window on which event was requested in event mask */
+} XAnyEvent;
+
+/*
+ * this union is defined so Xlib can always use the same sized
+ * event structure internally, to avoid memory fragmentation.
+ */
+typedef union _XEvent {
+        int type;		/* must not be changed; first element */
+	XAnyEvent xany;
+	XKeyEvent xkey;
+	XButtonEvent xbutton;
+	XMotionEvent xmotion;
+	XCrossingEvent xcrossing;
+	XFocusChangeEvent xfocus;
+	XExposeEvent xexpose;
+	XGraphicsExposeEvent xgraphicsexpose;
+	XNoExposeEvent xnoexpose;
+	XVisibilityEvent xvisibility;
+	XCreateWindowEvent xcreatewindow;
+	XDestroyWindowEvent xdestroywindow;
+	XUnmapEvent xunmap;
+	XMapEvent xmap;
+	XMapRequestEvent xmaprequest;
+	XReparentEvent xreparent;
+	XConfigureEvent xconfigure;
+	XGravityEvent xgravity;
+	XResizeRequestEvent xresizerequest;
+	XConfigureRequestEvent xconfigurerequest;
+	XCirculateEvent xcirculate;
+	XCirculateRequestEvent xcirculaterequest;
+	XPropertyEvent xproperty;
+	XSelectionClearEvent xselectionclear;
+	XSelectionRequestEvent xselectionrequest;
+	XSelectionEvent xselection;
+	XColormapEvent xcolormap;
+	XClientMessageEvent xclient;
+	XMappingEvent xmapping;
+	XErrorEvent xerror;
+	XKeymapEvent xkeymap;
+	long pad[24];
+} XEvent;
+#endif
+
+#define XAllocID(dpy) ((*((_XPrivDisplay)dpy)-&gt;resource_alloc)((dpy)))
+
+/*
+ * per character font metric information.
+ */
+typedef struct {
+    short	lbearing;	/* origin to left edge of raster */
+    short	rbearing;	/* origin to right edge of raster */
+    short	width;		/* advance to next char's origin */
+    short	ascent;		/* baseline to top edge of raster */
+    short	descent;	/* baseline to bottom edge of raster */
+    unsigned short attributes;	/* per char flags (not predefined) */
+} XCharStruct;
+
+/*
+ * To allow arbitrary information with fonts, there are additional properties
+ * returned.
+ */
+typedef struct {
+    Atom name;
+    unsigned long card32;
+} XFontProp;
+
+typedef struct {
+    XExtData	*ext_data;	/* hook for extension to hang data */
+    Font        fid;            /* Font id for this font */
+    unsigned	direction;	/* hint about direction the font is painted */
+    unsigned	min_char_or_byte2;/* first character */
+    unsigned	max_char_or_byte2;/* last character */
+    unsigned	min_byte1;	/* first row that exists */
+    unsigned	max_byte1;	/* last row that exists */
+    Bool	all_chars_exist;/* flag if all characters have non-zero size*/
+    unsigned	default_char;	/* char to print for undefined character */
+    int         n_properties;   /* how many properties there are */
+    XFontProp	*properties;	/* pointer to array of additional properties*/
+    XCharStruct	min_bounds;	/* minimum bounds over all existing char*/
+    XCharStruct	max_bounds;	/* maximum bounds over all existing char*/
+    XCharStruct	*per_char;	/* first_char to last_char information */
+    int		ascent;		/* log. extent above baseline for spacing */
+    int		descent;	/* log. descent below baseline for spacing */
+} XFontStruct;
+
+/*
+ * PolyText routines take these as arguments.
+ */
+typedef struct {
+    char *chars;		/* pointer to string */
+    int nchars;			/* number of characters */
+    int delta;			/* delta between strings */
+    Font font;			/* font to print it in, None don't change */
+} XTextItem;
+
+typedef struct {		/* normal 16 bit characters are two bytes */
+    unsigned char byte1;
+    unsigned char byte2;
+} XChar2b;
+
+typedef struct {
+    XChar2b *chars;		/* two byte characters */
+    int nchars;			/* number of characters */
+    int delta;			/* delta between strings */
+    Font font;			/* font to print it in, None don't change */
+} XTextItem16;
+
+
+typedef union { Display *display;
+		GC gc;
+		Visual *visual;
+		Screen *screen;
+		ScreenFormat *pixmap_format;
+		XFontStruct *font; } XEDataObject;
+
+typedef struct {
+    XRectangle      max_ink_extent;
+    XRectangle      max_logical_extent;
+} XFontSetExtents;
+
+/* unused:
+typedef void (*XOMProc)();
+ */
+
+typedef struct _XOM *XOM;
+typedef struct _XOC *XOC, *XFontSet;
+
+typedef struct {
+    char           *chars;
+    int             nchars;
+    int             delta;
+    XFontSet        font_set;
+} XmbTextItem;
+
+typedef struct {
+    wchar_t        *chars;
+    int             nchars;
+    int             delta;
+    XFontSet        font_set;
+} XwcTextItem;
+
+#define XNRequiredCharSet &quot;requiredCharSet&quot;
+#define XNQueryOrientation &quot;queryOrientation&quot;
+#define XNBaseFontName &quot;baseFontName&quot;
+#define XNOMAutomatic &quot;omAutomatic&quot;
+#define XNMissingCharSet &quot;missingCharSet&quot;
+#define XNDefaultString &quot;defaultString&quot;
+#define XNOrientation &quot;orientation&quot;
+#define XNDirectionalDependentDrawing &quot;directionalDependentDrawing&quot;
+#define XNContextualDrawing &quot;contextualDrawing&quot;
+#define XNFontInfo &quot;fontInfo&quot;
+
+typedef struct {
+    int charset_count;
+    char **charset_list;
+} XOMCharSetList;
+
+typedef enum {
+    XOMOrientation_LTR_TTB,
+    XOMOrientation_RTL_TTB,
+    XOMOrientation_TTB_LTR,
+    XOMOrientation_TTB_RTL,
+    XOMOrientation_Context
+} XOrientation;
+
+typedef struct {
+    int num_orientation;
+    XOrientation *orientation;	/* Input Text description */
+} XOMOrientation;
+
+typedef struct {
+    int num_font;
+    XFontStruct **font_struct_list;
+    char **font_name_list;
+} XOMFontInfo;
+
+typedef struct _XIM *XIM;
+typedef struct _XIC *XIC;
+
+typedef void (*XIMProc)(
+    XIM,
+    XPointer,
+    XPointer
+);
+
+typedef Bool (*XICProc)(
+    XIC,
+    XPointer,
+    XPointer
+);
+
+typedef void (*XIDProc)(
+    Display*,
+    XPointer,
+    XPointer
+);
+
+typedef unsigned long XIMStyle;
+
+typedef struct {
+    unsigned short count_styles;
+    XIMStyle *supported_styles;
+} XIMStyles;
+
+#define XIMPreeditArea		0x0001L
+#define XIMPreeditCallbacks	0x0002L
+#define XIMPreeditPosition	0x0004L
+#define XIMPreeditNothing	0x0008L
+#define XIMPreeditNone		0x0010L
+#define XIMStatusArea		0x0100L
+#define XIMStatusCallbacks	0x0200L
+#define XIMStatusNothing	0x0400L
+#define XIMStatusNone		0x0800L
+
+#define XNVaNestedList &quot;XNVaNestedList&quot;
+#define XNQueryInputStyle &quot;queryInputStyle&quot;
+#define XNClientWindow &quot;clientWindow&quot;
+#define XNInputStyle &quot;inputStyle&quot;
+#define XNFocusWindow &quot;focusWindow&quot;
+#define XNResourceName &quot;resourceName&quot;
+#define XNResourceClass &quot;resourceClass&quot;
+#define XNGeometryCallback &quot;geometryCallback&quot;
+#define XNDestroyCallback &quot;destroyCallback&quot;
+#define XNFilterEvents &quot;filterEvents&quot;
+#define XNPreeditStartCallback &quot;preeditStartCallback&quot;
+#define XNPreeditDoneCallback &quot;preeditDoneCallback&quot;
+#define XNPreeditDrawCallback &quot;preeditDrawCallback&quot;
+#define XNPreeditCaretCallback &quot;preeditCaretCallback&quot;
+#define XNPreeditStateNotifyCallback &quot;preeditStateNotifyCallback&quot;
+#define XNPreeditAttributes &quot;preeditAttributes&quot;
+#define XNStatusStartCallback &quot;statusStartCallback&quot;
+#define XNStatusDoneCallback &quot;statusDoneCallback&quot;
+#define XNStatusDrawCallback &quot;statusDrawCallback&quot;
+#define XNStatusAttributes &quot;statusAttributes&quot;
+#define XNArea &quot;area&quot;
+#define XNAreaNeeded &quot;areaNeeded&quot;
+#define XNSpotLocation &quot;spotLocation&quot;
+#define XNColormap &quot;colorMap&quot;
+#define XNStdColormap &quot;stdColorMap&quot;
+#define XNForeground &quot;foreground&quot;
+#define XNBackground &quot;background&quot;
+#define XNBackgroundPixmap &quot;backgroundPixmap&quot;
+#define XNFontSet &quot;fontSet&quot;
+#define XNLineSpace &quot;lineSpace&quot;
+#define XNCursor &quot;cursor&quot;
+
+#define XNQueryIMValuesList &quot;queryIMValuesList&quot;
+#define XNQueryICValuesList &quot;queryICValuesList&quot;
+#define XNVisiblePosition &quot;visiblePosition&quot;
+#define XNR6PreeditCallback &quot;r6PreeditCallback&quot;
+#define XNStringConversionCallback &quot;stringConversionCallback&quot;
+#define XNStringConversion &quot;stringConversion&quot;
+#define XNResetState &quot;resetState&quot;
+#define XNHotKey &quot;hotKey&quot;
+#define XNHotKeyState &quot;hotKeyState&quot;
+#define XNPreeditState &quot;preeditState&quot;
+#define XNSeparatorofNestedList &quot;separatorofNestedList&quot;
+
+#define XBufferOverflow		-1
+#define XLookupNone		1
+#define XLookupChars		2
+#define XLookupKeySym		3
+#define XLookupBoth		4
+
+typedef void *XVaNestedList;
+
+typedef struct {
+    XPointer client_data;
+    XIMProc callback;
+} XIMCallback;
+
+typedef struct {
+    XPointer client_data;
+    XICProc callback;
+} XICCallback;
+
+typedef unsigned long XIMFeedback;
+
+#define XIMReverse		1L
+#define XIMUnderline		(1L&lt;&lt;1) 
+#define XIMHighlight		(1L&lt;&lt;2)
+#define XIMPrimary	 	(1L&lt;&lt;5)
+#define XIMSecondary		(1L&lt;&lt;6)
+#define XIMTertiary	 	(1L&lt;&lt;7)
+#define XIMVisibleToForward 	(1L&lt;&lt;8)
+#define XIMVisibleToBackword 	(1L&lt;&lt;9)
+#define XIMVisibleToCenter 	(1L&lt;&lt;10)
+
+typedef struct _XIMText {
+    unsigned short length;
+    XIMFeedback *feedback;
+    Bool encoding_is_wchar; 
+    union {
+	char *multi_byte;
+	wchar_t *wide_char;
+    } string; 
+} XIMText;
+
+typedef	unsigned long	 XIMPreeditState;
+
+#define	XIMPreeditUnKnown	0L
+#define	XIMPreeditEnable	1L
+#define	XIMPreeditDisable	(1L&lt;&lt;1)
+
+typedef	struct	_XIMPreeditStateNotifyCallbackStruct {
+    XIMPreeditState state;
+} XIMPreeditStateNotifyCallbackStruct;
+
+typedef	unsigned long	 XIMResetState;
+
+#define	XIMInitialState		1L
+#define	XIMPreserveState	(1L&lt;&lt;1)
+
+typedef unsigned long XIMStringConversionFeedback;
+
+#define	XIMStringConversionLeftEdge	(0x00000001)
+#define	XIMStringConversionRightEdge	(0x00000002)
+#define	XIMStringConversionTopEdge	(0x00000004)
+#define	XIMStringConversionBottomEdge	(0x00000008)
+#define	XIMStringConversionConcealed	(0x00000010)
+#define	XIMStringConversionWrapped	(0x00000020)
+
+typedef struct _XIMStringConversionText {
+    unsigned short length;
+    XIMStringConversionFeedback *feedback;
+    Bool encoding_is_wchar; 
+    union {
+	char *mbs;
+	wchar_t *wcs;
+    } string; 
+} XIMStringConversionText;
+
+typedef	unsigned short	XIMStringConversionPosition;
+
+typedef	unsigned short	XIMStringConversionType;
+
+#define	XIMStringConversionBuffer	(0x0001)
+#define	XIMStringConversionLine		(0x0002)
+#define	XIMStringConversionWord		(0x0003)
+#define	XIMStringConversionChar		(0x0004)
+
+typedef	unsigned short	XIMStringConversionOperation;
+
+#define	XIMStringConversionSubstitution	(0x0001)
+#define	XIMStringConversionRetrieval	(0x0002)
+
+typedef enum {
+    XIMForwardChar, XIMBackwardChar,
+    XIMForwardWord, XIMBackwardWord,
+    XIMCaretUp, XIMCaretDown,
+    XIMNextLine, XIMPreviousLine,
+    XIMLineStart, XIMLineEnd, 
+    XIMAbsolutePosition,
+    XIMDontChange
+} XIMCaretDirection;
+
+typedef struct _XIMStringConversionCallbackStruct {
+    XIMStringConversionPosition position;
+    XIMCaretDirection direction;
+    XIMStringConversionOperation operation;
+    unsigned short factor;
+    XIMStringConversionText *text;
+} XIMStringConversionCallbackStruct;
+
+typedef struct _XIMPreeditDrawCallbackStruct {
+    int caret;		/* Cursor offset within pre-edit string */
+    int chg_first;	/* Starting change position */
+    int chg_length;	/* Length of the change in character count */
+    XIMText *text;
+} XIMPreeditDrawCallbackStruct;
+
+typedef enum {
+    XIMIsInvisible,	/* Disable caret feedback */ 
+    XIMIsPrimary,	/* UI defined caret feedback */
+    XIMIsSecondary	/* UI defined caret feedback */
+} XIMCaretStyle;
+
+typedef struct _XIMPreeditCaretCallbackStruct {
+    int position;		 /* Caret offset within pre-edit string */
+    XIMCaretDirection direction; /* Caret moves direction */
+    XIMCaretStyle style;	 /* Feedback of the caret */
+} XIMPreeditCaretCallbackStruct;
+
+typedef enum {
+    XIMTextType,
+    XIMBitmapType
+} XIMStatusDataType;
+	
+typedef struct _XIMStatusDrawCallbackStruct {
+    XIMStatusDataType type;
+    union {
+	XIMText *text;
+	Pixmap  bitmap;
+    } data;
+} XIMStatusDrawCallbackStruct;
+
+typedef struct _XIMHotKeyTrigger {
+    KeySym	 keysym;
+    int		 modifier;
+    int		 modifier_mask;
+} XIMHotKeyTrigger;
+
+typedef struct _XIMHotKeyTriggers {
+    int			 num_hot_key;
+    XIMHotKeyTrigger	*key;
+} XIMHotKeyTriggers;
+
+typedef	unsigned long	 XIMHotKeyState;
+
+#define	XIMHotKeyStateON	(0x0001L)
+#define	XIMHotKeyStateOFF	(0x0002L)
+
+typedef struct {
+    unsigned short count_values;
+    char **supported_values;
+} XIMValuesList;
+
+_XFUNCPROTOBEGIN
+
+#if defined(WIN32) &amp;&amp; !defined(_XLIBINT_)
+#define _Xdebug (*_Xdebug_p)
+#endif
+
+extern int _Xdebug;
+
+extern XFontStruct *XLoadQueryFont(
+    Display*		/* display */,
+    _Xconst char*	/* name */
+);
+
+extern XFontStruct *XQueryFont(
+    Display*		/* display */,
+    XID			/* font_ID */
+);
+
+
+extern XTimeCoord *XGetMotionEvents(
+    Display*		/* display */,
+    Window		/* w */,
+    Time		/* start */,
+    Time		/* stop */,
+    int*		/* nevents_return */
+);
+
+extern XModifierKeymap *XDeleteModifiermapEntry(
+    XModifierKeymap*	/* modmap */,
+#if NeedWidePrototypes
+    unsigned int	/* keycode_entry */,
+#else
+    KeyCode		/* keycode_entry */,
+#endif
+    int			/* modifier */
+);
+
+extern XModifierKeymap	*XGetModifierMapping(
+    Display*		/* display */
+);
+
+extern XModifierKeymap	*XInsertModifiermapEntry(
+    XModifierKeymap*	/* modmap */,
+#if NeedWidePrototypes
+    unsigned int	/* keycode_entry */,
+#else
+    KeyCode		/* keycode_entry */,
+#endif
+    int			/* modifier */    
+);
+
+extern XModifierKeymap *XNewModifiermap(
+    int			/* max_keys_per_mod */
+);
+
+extern XImage *XCreateImage(
+    Display*		/* display */,
+    Visual*		/* visual */,
+    unsigned int	/* depth */,
+    int			/* format */,
+    int			/* offset */,
+    char*		/* data */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    int			/* bitmap_pad */,
+    int			/* bytes_per_line */
+);
+extern Status XInitImage(
+    XImage*		/* image */
+);
+extern XImage *XGetImage(
+    Display*		/* display */,
+    Drawable		/* d */,
+    int			/* x */,
+    int			/* y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    unsigned long	/* plane_mask */,
+    int			/* format */
+);
+extern XImage *XGetSubImage(
+    Display*		/* display */,
+    Drawable		/* d */,
+    int			/* x */,
+    int			/* y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    unsigned long	/* plane_mask */,
+    int			/* format */,
+    XImage*		/* dest_image */,
+    int			/* dest_x */,
+    int			/* dest_y */
+);
+
+/* 
+ * X function declarations.
+ */
+extern Display *XOpenDisplay(
+    _Xconst char*	/* display_name */
+);
+
+extern void XrmInitialize(
+    void
+);
+
+extern char *XFetchBytes(
+    Display*		/* display */,
+    int*		/* nbytes_return */
+);
+extern char *XFetchBuffer(
+    Display*		/* display */,
+    int*		/* nbytes_return */,
+    int			/* buffer */
+);
+extern char *XGetAtomName(
+    Display*		/* display */,
+    Atom		/* atom */
+);
+extern Status XGetAtomNames(
+    Display*		/* dpy */,
+    Atom*		/* atoms */,
+    int			/* count */,
+    char**		/* names_return */
+);
+extern char *XGetDefault(
+    Display*		/* display */,
+    _Xconst char*	/* program */,
+    _Xconst char*	/* option */		  
+);
+extern char *XDisplayName(
+    _Xconst char*	/* string */
+);
+extern char *XKeysymToString(
+    KeySym		/* keysym */
+);
+
+extern int (*XSynchronize(
+    Display*		/* display */,
+    Bool		/* onoff */
+))(
+    Display*		/* display */
+);
+extern int (*XSetAfterFunction(
+    Display*		/* display */,
+    int (*) (
+	     Display*	/* display */
+            )		/* procedure */
+))(
+    Display*		/* display */
+);
+extern Atom XInternAtom(
+    Display*		/* display */,
+    _Xconst char*	/* atom_name */,
+    Bool		/* only_if_exists */		 
+);
+extern Status XInternAtoms(
+    Display*		/* dpy */,
+    char**		/* names */,
+    int			/* count */,
+    Bool		/* onlyIfExists */,
+    Atom*		/* atoms_return */
+);
+extern Colormap XCopyColormapAndFree(
+    Display*		/* display */,
+    Colormap		/* colormap */
+);
+extern Colormap XCreateColormap(
+    Display*		/* display */,
+    Window		/* w */,
+    Visual*		/* visual */,
+    int			/* alloc */			 
+);
+extern Cursor XCreatePixmapCursor(
+    Display*		/* display */,
+    Pixmap		/* source */,
+    Pixmap		/* mask */,
+    XColor*		/* foreground_color */,
+    XColor*		/* background_color */,
+    unsigned int	/* x */,
+    unsigned int	/* y */			   
+);
+extern Cursor XCreateGlyphCursor(
+    Display*		/* display */,
+    Font		/* source_font */,
+    Font		/* mask_font */,
+    unsigned int	/* source_char */,
+    unsigned int	/* mask_char */,
+    XColor _Xconst *	/* foreground_color */,
+    XColor _Xconst *	/* background_color */
+);
+extern Cursor XCreateFontCursor(
+    Display*		/* display */,
+    unsigned int	/* shape */
+);
+extern Font XLoadFont(
+    Display*		/* display */,
+    _Xconst char*	/* name */
+);
+extern GC XCreateGC(
+    Display*		/* display */,
+    Drawable		/* d */,
+    unsigned long	/* valuemask */,
+    XGCValues*		/* values */
+);
+extern GContext XGContextFromGC(
+    GC			/* gc */
+);
+extern void XFlushGC(
+    Display*		/* display */,
+    GC			/* gc */
+);
+extern Pixmap XCreatePixmap(
+    Display*		/* display */,
+    Drawable		/* d */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    unsigned int	/* depth */		        
+);
+extern Pixmap XCreateBitmapFromData(
+    Display*		/* display */,
+    Drawable		/* d */,
+    _Xconst char*	/* data */,
+    unsigned int	/* width */,
+    unsigned int	/* height */
+);
+extern Pixmap XCreatePixmapFromBitmapData(
+    Display*		/* display */,
+    Drawable		/* d */,
+    char*		/* data */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    unsigned long	/* fg */,
+    unsigned long	/* bg */,
+    unsigned int	/* depth */
+);
+extern Window XCreateSimpleWindow(
+    Display*		/* display */,
+    Window		/* parent */,
+    int			/* x */,
+    int			/* y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    unsigned int	/* border_width */,
+    unsigned long	/* border */,
+    unsigned long	/* background */
+);
+extern Window XGetSelectionOwner(
+    Display*		/* display */,
+    Atom		/* selection */
+);
+extern Window XCreateWindow(
+    Display*		/* display */,
+    Window		/* parent */,
+    int			/* x */,
+    int			/* y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    unsigned int	/* border_width */,
+    int			/* depth */,
+    unsigned int	/* class */,
+    Visual*		/* visual */,
+    unsigned long	/* valuemask */,
+    XSetWindowAttributes*	/* attributes */
+); 
+extern Colormap *XListInstalledColormaps(
+    Display*		/* display */,
+    Window		/* w */,
+    int*		/* num_return */
+);
+extern char **XListFonts(
+    Display*		/* display */,
+    _Xconst char*	/* pattern */,
+    int			/* maxnames */,
+    int*		/* actual_count_return */
+);
+extern char **XListFontsWithInfo(
+    Display*		/* display */,
+    _Xconst char*	/* pattern */,
+    int			/* maxnames */,
+    int*		/* count_return */,
+    XFontStruct**	/* info_return */
+);
+extern char **XGetFontPath(
+    Display*		/* display */,
+    int*		/* npaths_return */
+);
+extern char **XListExtensions(
+    Display*		/* display */,
+    int*		/* nextensions_return */
+);
+extern Atom *XListProperties(
+    Display*		/* display */,
+    Window		/* w */,
+    int*		/* num_prop_return */
+);
+extern XHostAddress *XListHosts(
+    Display*		/* display */,
+    int*		/* nhosts_return */,
+    Bool*		/* state_return */
+);
+extern KeySym XKeycodeToKeysym(
+    Display*		/* display */,
+#if NeedWidePrototypes
+    unsigned int	/* keycode */,
+#else
+    KeyCode		/* keycode */,
+#endif
+    int			/* index */
+);
+extern KeySym XLookupKeysym(
+    XKeyEvent*		/* key_event */,
+    int			/* index */
+);
+extern KeySym *XGetKeyboardMapping(
+    Display*		/* display */,
+#if NeedWidePrototypes
+    unsigned int	/* first_keycode */,
+#else
+    KeyCode		/* first_keycode */,
+#endif
+    int			/* keycode_count */,
+    int*		/* keysyms_per_keycode_return */
+);
+extern KeySym XStringToKeysym(
+    _Xconst char*	/* string */
+);
+extern long XMaxRequestSize(
+    Display*		/* display */
+);
+extern long XExtendedMaxRequestSize(
+    Display*		/* display */
+);
+extern char *XResourceManagerString(
+    Display*		/* display */
+);
+extern char *XScreenResourceString(
+	Screen*		/* screen */
+);
+extern unsigned long XDisplayMotionBufferSize(
+    Display*		/* display */
+);
+extern VisualID XVisualIDFromVisual(
+    Visual*		/* visual */
+);
+
+/* multithread routines */
+
+extern Status XInitThreads(
+    void
+);
+
+extern void XLockDisplay(
+    Display*		/* display */
+);
+
+extern void XUnlockDisplay(
+    Display*		/* display */
+);
+
+/* routines for dealing with extensions */
+
+extern XExtCodes *XInitExtension(
+    Display*		/* display */,
+    _Xconst char*	/* name */
+);
+
+extern XExtCodes *XAddExtension(
+    Display*		/* display */
+);
+extern XExtData *XFindOnExtensionList(
+    XExtData**		/* structure */,
+    int			/* number */
+);
+extern XExtData **XEHeadOfExtensionList(
+    XEDataObject	/* object */
+);
+
+/* these are routines for which there are also macros */
+extern Window XRootWindow(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+extern Window XDefaultRootWindow(
+    Display*		/* display */
+);
+extern Window XRootWindowOfScreen(
+    Screen*		/* screen */
+);
+extern Visual *XDefaultVisual(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+extern Visual *XDefaultVisualOfScreen(
+    Screen*		/* screen */
+);
+extern GC XDefaultGC(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+extern GC XDefaultGCOfScreen(
+    Screen*		/* screen */
+);
+extern unsigned long XBlackPixel(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+extern unsigned long XWhitePixel(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+extern unsigned long XAllPlanes(
+    void
+);
+extern unsigned long XBlackPixelOfScreen(
+    Screen*		/* screen */
+);
+extern unsigned long XWhitePixelOfScreen(
+    Screen*		/* screen */
+);
+extern unsigned long XNextRequest(
+    Display*		/* display */
+);
+extern unsigned long XLastKnownRequestProcessed(
+    Display*		/* display */
+);
+extern char *XServerVendor(
+    Display*		/* display */
+);
+extern char *XDisplayString(
+    Display*		/* display */
+);
+extern Colormap XDefaultColormap(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+extern Colormap XDefaultColormapOfScreen(
+    Screen*		/* screen */
+);
+extern Display *XDisplayOfScreen(
+    Screen*		/* screen */
+);
+extern Screen *XScreenOfDisplay(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+extern Screen *XDefaultScreenOfDisplay(
+    Display*		/* display */
+);
+extern long XEventMaskOfScreen(
+    Screen*		/* screen */
+);
+
+extern int XScreenNumberOfScreen(
+    Screen*		/* screen */
+);
+
+typedef int (*XErrorHandler) (	    /* WARNING, this type not in Xlib spec */
+    Display*		/* display */,
+    XErrorEvent*	/* error_event */
+);
+
+extern XErrorHandler XSetErrorHandler (
+    XErrorHandler	/* handler */
+);
+
+
+typedef int (*XIOErrorHandler) (    /* WARNING, this type not in Xlib spec */
+    Display*		/* display */
+);
+
+extern XIOErrorHandler XSetIOErrorHandler (
+    XIOErrorHandler	/* handler */
+);
+
+
+extern XPixmapFormatValues *XListPixmapFormats(
+    Display*		/* display */,
+    int*		/* count_return */
+);
+extern int *XListDepths(
+    Display*		/* display */,
+    int			/* screen_number */,
+    int*		/* count_return */
+);
+
+/* ICCCM routines for things that don't require special include files; */
+/* other declarations are given in Xutil.h                             */
+extern Status XReconfigureWMWindow(
+    Display*		/* display */,
+    Window		/* w */,
+    int			/* screen_number */,
+    unsigned int	/* mask */,
+    XWindowChanges*	/* changes */
+);
+
+extern Status XGetWMProtocols(
+    Display*		/* display */,
+    Window		/* w */,
+    Atom**		/* protocols_return */,
+    int*		/* count_return */
+);
+extern Status XSetWMProtocols(
+    Display*		/* display */,
+    Window		/* w */,
+    Atom*		/* protocols */,
+    int			/* count */
+);
+extern Status XIconifyWindow(
+    Display*		/* display */,
+    Window		/* w */,
+    int			/* screen_number */
+);
+extern Status XWithdrawWindow(
+    Display*		/* display */,
+    Window		/* w */,
+    int			/* screen_number */
+);
+extern Status XGetCommand(
+    Display*		/* display */,
+    Window		/* w */,
+    char***		/* argv_return */,
+    int*		/* argc_return */
+);
+extern Status XGetWMColormapWindows(
+    Display*		/* display */,
+    Window		/* w */,
+    Window**		/* windows_return */,
+    int*		/* count_return */
+);
+extern Status XSetWMColormapWindows(
+    Display*		/* display */,
+    Window		/* w */,
+    Window*		/* colormap_windows */,
+    int			/* count */
+);
+extern void XFreeStringList(
+    char**		/* list */
+);
+extern int XSetTransientForHint(
+    Display*		/* display */,
+    Window		/* w */,
+    Window		/* prop_window */
+);
+
+/* The following are given in alphabetical order */
+
+extern int XActivateScreenSaver(
+    Display*		/* display */
+);
+
+extern int XAddHost(
+    Display*		/* display */,
+    XHostAddress*	/* host */
+);
+
+extern int XAddHosts(
+    Display*		/* display */,
+    XHostAddress*	/* hosts */,
+    int			/* num_hosts */    
+);
+
+extern int XAddToExtensionList(
+    struct _XExtData**	/* structure */,
+    XExtData*		/* ext_data */
+);
+
+extern int XAddToSaveSet(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern Status XAllocColor(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    XColor*		/* screen_in_out */
+);
+
+extern Status XAllocColorCells(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    Bool	        /* contig */,
+    unsigned long*	/* plane_masks_return */,
+    unsigned int	/* nplanes */,
+    unsigned long*	/* pixels_return */,
+    unsigned int 	/* npixels */
+);
+
+extern Status XAllocColorPlanes(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    Bool		/* contig */,
+    unsigned long*	/* pixels_return */,
+    int			/* ncolors */,
+    int			/* nreds */,
+    int			/* ngreens */,
+    int			/* nblues */,
+    unsigned long*	/* rmask_return */,
+    unsigned long*	/* gmask_return */,
+    unsigned long*	/* bmask_return */
+);
+
+extern Status XAllocNamedColor(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    _Xconst char*	/* color_name */,
+    XColor*		/* screen_def_return */,
+    XColor*		/* exact_def_return */
+);
+
+extern int XAllowEvents(
+    Display*		/* display */,
+    int			/* event_mode */,
+    Time		/* time */
+);
+
+extern int XAutoRepeatOff(
+    Display*		/* display */
+);
+
+extern int XAutoRepeatOn(
+    Display*		/* display */
+);
+
+extern int XBell(
+    Display*		/* display */,
+    int			/* percent */
+);
+
+extern int XBitmapBitOrder(
+    Display*		/* display */
+);
+
+extern int XBitmapPad(
+    Display*		/* display */
+);
+
+extern int XBitmapUnit(
+    Display*		/* display */
+);
+
+extern int XCellsOfScreen(
+    Screen*		/* screen */
+);
+
+extern int XChangeActivePointerGrab(
+    Display*		/* display */,
+    unsigned int	/* event_mask */,
+    Cursor		/* cursor */,
+    Time		/* time */
+);
+
+extern int XChangeGC(
+    Display*		/* display */,
+    GC			/* gc */,
+    unsigned long	/* valuemask */,
+    XGCValues*		/* values */
+);
+
+extern int XChangeKeyboardControl(
+    Display*		/* display */,
+    unsigned long	/* value_mask */,
+    XKeyboardControl*	/* values */
+);
+
+extern int XChangeKeyboardMapping(
+    Display*		/* display */,
+    int			/* first_keycode */,
+    int			/* keysyms_per_keycode */,
+    KeySym*		/* keysyms */,
+    int			/* num_codes */
+);
+
+extern int XChangePointerControl(
+    Display*		/* display */,
+    Bool		/* do_accel */,
+    Bool		/* do_threshold */,
+    int			/* accel_numerator */,
+    int			/* accel_denominator */,
+    int			/* threshold */
+);
+
+extern int XChangeProperty(
+    Display*		/* display */,
+    Window		/* w */,
+    Atom		/* property */,
+    Atom		/* type */,
+    int			/* format */,
+    int			/* mode */,
+    _Xconst unsigned char*	/* data */,
+    int			/* nelements */
+);
+
+extern int XChangeSaveSet(
+    Display*		/* display */,
+    Window		/* w */,
+    int			/* change_mode */
+);
+
+extern int XChangeWindowAttributes(
+    Display*		/* display */,
+    Window		/* w */,
+    unsigned long	/* valuemask */,
+    XSetWindowAttributes* /* attributes */
+);
+
+extern Bool XCheckIfEvent(
+    Display*		/* display */,
+    XEvent*		/* event_return */,
+    Bool (*) (
+	       Display*			/* display */,
+               XEvent*			/* event */,
+               XPointer			/* arg */
+             )		/* predicate */,
+    XPointer		/* arg */
+);
+
+#ifdef NX_TRANS_SOCKET
+
+/*
+ * This is just like XCheckIfEvent() but doesn't
+ * flush the output buffer if it can't read new
+ * events.
+ */
+
+extern Bool XCheckIfEventNoFlush(
+    Display*		/* display */,
+    XEvent*		/* event_return */,
+    Bool (*) (
+	       Display*			/* display */,
+               XEvent*			/* event */,
+               XPointer			/* arg */
+             )		/* predicate */,
+    XPointer		/* arg */
+);
+
+#endif
+
+extern Bool XCheckMaskEvent(
+    Display*		/* display */,
+    long		/* event_mask */,
+    XEvent*		/* event_return */
+);
+
+extern Bool XCheckTypedEvent(
+    Display*		/* display */,
+    int			/* event_type */,
+    XEvent*		/* event_return */
+);
+
+extern Bool XCheckTypedWindowEvent(
+    Display*		/* display */,
+    Window		/* w */,
+    int			/* event_type */,
+    XEvent*		/* event_return */
+);
+
+extern Bool XCheckWindowEvent(
+    Display*		/* display */,
+    Window		/* w */,
+    long		/* event_mask */,
+    XEvent*		/* event_return */
+);
+
+extern int XCirculateSubwindows(
+    Display*		/* display */,
+    Window		/* w */,
+    int			/* direction */
+);
+
+extern int XCirculateSubwindowsDown(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XCirculateSubwindowsUp(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XClearArea(
+    Display*		/* display */,
+    Window		/* w */,
+    int			/* x */,
+    int			/* y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    Bool		/* exposures */
+);
+
+extern int XClearWindow(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XCloseDisplay(
+    Display*		/* display */
+);
+
+extern int XConfigureWindow(
+    Display*		/* display */,
+    Window		/* w */,
+    unsigned int	/* value_mask */,
+    XWindowChanges*	/* values */		 
+);
+
+extern int XConnectionNumber(
+    Display*		/* display */
+);
+
+extern int XConvertSelection(
+    Display*		/* display */,
+    Atom		/* selection */,
+    Atom 		/* target */,
+    Atom		/* property */,
+    Window		/* requestor */,
+    Time		/* time */
+);
+
+extern int XCopyArea(
+    Display*		/* display */,
+    Drawable		/* src */,
+    Drawable		/* dest */,
+    GC			/* gc */,
+    int			/* src_x */,
+    int			/* src_y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    int			/* dest_x */,
+    int			/* dest_y */
+);
+
+extern int XCopyGC(
+    Display*		/* display */,
+    GC			/* src */,
+    unsigned long	/* valuemask */,
+    GC			/* dest */
+);
+
+extern int XCopyPlane(
+    Display*		/* display */,
+    Drawable		/* src */,
+    Drawable		/* dest */,
+    GC			/* gc */,
+    int			/* src_x */,
+    int			/* src_y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    int			/* dest_x */,
+    int			/* dest_y */,
+    unsigned long	/* plane */
+);
+
+extern int XDefaultDepth(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+
+extern int XDefaultDepthOfScreen(
+    Screen*		/* screen */
+);
+
+extern int XDefaultScreen(
+    Display*		/* display */
+);
+
+extern int XDefineCursor(
+    Display*		/* display */,
+    Window		/* w */,
+    Cursor		/* cursor */
+);
+
+extern int XDeleteProperty(
+    Display*		/* display */,
+    Window		/* w */,
+    Atom		/* property */
+);
+
+extern int XDestroyWindow(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XDestroySubwindows(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XDoesBackingStore(
+    Screen*		/* screen */    
+);
+
+extern Bool XDoesSaveUnders(
+    Screen*		/* screen */
+);
+
+extern int XDisableAccessControl(
+    Display*		/* display */
+);
+
+
+extern int XDisplayCells(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+
+extern int XDisplayHeight(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+
+extern int XDisplayHeightMM(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+
+extern int XDisplayKeycodes(
+    Display*		/* display */,
+    int*		/* min_keycodes_return */,
+    int*		/* max_keycodes_return */
+);
+
+extern int XDisplayPlanes(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+
+extern int XDisplayWidth(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+
+extern int XDisplayWidthMM(
+    Display*		/* display */,
+    int			/* screen_number */
+);
+
+extern int XDrawArc(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    int			/* angle1 */,
+    int			/* angle2 */
+);
+
+extern int XDrawArcs(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    XArc*		/* arcs */,
+    int			/* narcs */
+);
+
+extern int XDrawImageString(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    _Xconst char*	/* string */,
+    int			/* length */
+);
+
+extern int XDrawImageString16(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    _Xconst XChar2b*	/* string */,
+    int			/* length */
+);
+
+extern int XDrawLine(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x1 */,
+    int			/* y1 */,
+    int			/* x2 */,
+    int			/* y2 */
+);
+
+extern int XDrawLines(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    XPoint*		/* points */,
+    int			/* npoints */,
+    int			/* mode */
+);
+
+extern int XDrawPoint(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */
+);
+
+extern int XDrawPoints(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    XPoint*		/* points */,
+    int			/* npoints */,
+    int			/* mode */
+);
+
+extern int XDrawRectangle(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */
+);
+
+extern int XDrawRectangles(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    XRectangle*		/* rectangles */,
+    int			/* nrectangles */
+);
+
+extern int XDrawSegments(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    XSegment*		/* segments */,
+    int			/* nsegments */
+);
+
+extern int XDrawString(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    _Xconst char*	/* string */,
+    int			/* length */
+);
+
+extern int XDrawString16(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    _Xconst XChar2b*	/* string */,
+    int			/* length */
+);
+
+extern int XDrawText(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    XTextItem*		/* items */,
+    int			/* nitems */
+);
+
+extern int XDrawText16(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    XTextItem16*	/* items */,
+    int			/* nitems */
+);
+
+extern int XEnableAccessControl(
+    Display*		/* display */
+);
+
+extern int XEventsQueued(
+    Display*		/* display */,
+    int			/* mode */
+);
+
+extern Status XFetchName(
+    Display*		/* display */,
+    Window		/* w */,
+    char**		/* window_name_return */
+);
+
+extern int XFillArc(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    int			/* angle1 */,
+    int			/* angle2 */
+);
+
+extern int XFillArcs(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    XArc*		/* arcs */,
+    int			/* narcs */
+);
+
+extern int XFillPolygon(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    XPoint*		/* points */,
+    int			/* npoints */,
+    int			/* shape */,
+    int			/* mode */
+);
+
+extern int XFillRectangle(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */
+);
+
+extern int XFillRectangles(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    XRectangle*		/* rectangles */,
+    int			/* nrectangles */
+);
+
+extern int XFlush(
+    Display*		/* display */
+);
+
+extern int XForceScreenSaver(
+    Display*		/* display */,
+    int			/* mode */
+);
+
+extern int XFree(
+    void*		/* data */
+);
+
+extern int XFreeColormap(
+    Display*		/* display */,
+    Colormap		/* colormap */
+);
+
+extern int XFreeColors(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    unsigned long*	/* pixels */,
+    int			/* npixels */,
+    unsigned long	/* planes */
+);
+
+extern int XFreeCursor(
+    Display*		/* display */,
+    Cursor		/* cursor */
+);
+
+extern int XFreeExtensionList(
+    char**		/* list */    
+);
+
+extern int XFreeFont(
+    Display*		/* display */,
+    XFontStruct*	/* font_struct */
+);
+
+extern int XFreeFontInfo(
+    char**		/* names */,
+    XFontStruct*	/* free_info */,
+    int			/* actual_count */
+);
+
+extern int XFreeFontNames(
+    char**		/* list */
+);
+
+extern int XFreeFontPath(
+    char**		/* list */
+);
+
+extern int XFreeGC(
+    Display*		/* display */,
+    GC			/* gc */
+);
+
+extern int XFreeModifiermap(
+    XModifierKeymap*	/* modmap */
+);
+
+extern int XFreePixmap(
+    Display*		/* display */,
+    Pixmap		/* pixmap */
+);
+
+extern int XGeometry(
+    Display*		/* display */,
+    int			/* screen */,
+    _Xconst char*	/* position */,
+    _Xconst char*	/* default_position */,
+    unsigned int	/* bwidth */,
+    unsigned int	/* fwidth */,
+    unsigned int	/* fheight */,
+    int			/* xadder */,
+    int			/* yadder */,
+    int*		/* x_return */,
+    int*		/* y_return */,
+    int*		/* width_return */,
+    int*		/* height_return */
+);
+
+extern int XGetErrorDatabaseText(
+    Display*		/* display */,
+    _Xconst char*	/* name */,
+    _Xconst char*	/* message */,
+    _Xconst char*	/* default_string */,
+    char*		/* buffer_return */,
+    int			/* length */
+);
+
+extern int XGetErrorText(
+    Display*		/* display */,
+    int			/* code */,
+    char*		/* buffer_return */,
+    int			/* length */
+);
+
+extern Bool XGetFontProperty(
+    XFontStruct*	/* font_struct */,
+    Atom		/* atom */,
+    unsigned long*	/* value_return */
+);
+
+extern Status XGetGCValues(
+    Display*		/* display */,
+    GC			/* gc */,
+    unsigned long	/* valuemask */,
+    XGCValues*		/* values_return */
+);
+
+extern Status XGetGeometry(
+    Display*		/* display */,
+    Drawable		/* d */,
+    Window*		/* root_return */,
+    int*		/* x_return */,
+    int*		/* y_return */,
+    unsigned int*	/* width_return */,
+    unsigned int*	/* height_return */,
+    unsigned int*	/* border_width_return */,
+    unsigned int*	/* depth_return */
+);
+
+extern Status XGetIconName(
+    Display*		/* display */,
+    Window		/* w */,
+    char**		/* icon_name_return */
+);
+
+extern int XGetInputFocus(
+    Display*		/* display */,
+    Window*		/* focus_return */,
+    int*		/* revert_to_return */
+);
+
+extern int XGetKeyboardControl(
+    Display*		/* display */,
+    XKeyboardState*	/* values_return */
+);
+
+extern int XGetPointerControl(
+    Display*		/* display */,
+    int*		/* accel_numerator_return */,
+    int*		/* accel_denominator_return */,
+    int*		/* threshold_return */
+);
+
+extern int XGetPointerMapping(
+    Display*		/* display */,
+    unsigned char*	/* map_return */,
+    int			/* nmap */
+);
+
+extern int XGetScreenSaver(
+    Display*		/* display */,
+    int*		/* timeout_return */,
+    int*		/* interval_return */,
+    int*		/* prefer_blanking_return */,
+    int*		/* allow_exposures_return */
+);
+
+extern Status XGetTransientForHint(
+    Display*		/* display */,
+    Window		/* w */,
+    Window*		/* prop_window_return */
+);
+
+extern int XGetWindowProperty(
+    Display*		/* display */,
+    Window		/* w */,
+    Atom		/* property */,
+    long		/* long_offset */,
+    long		/* long_length */,
+    Bool		/* delete */,
+    Atom		/* req_type */,
+    Atom*		/* actual_type_return */,
+    int*		/* actual_format_return */,
+    unsigned long*	/* nitems_return */,
+    unsigned long*	/* bytes_after_return */,
+    unsigned char**	/* prop_return */
+);
+
+extern Status XGetWindowAttributes(
+    Display*		/* display */,
+    Window		/* w */,
+    XWindowAttributes*	/* window_attributes_return */
+);
+
+extern int XGrabButton(
+    Display*		/* display */,
+    unsigned int	/* button */,
+    unsigned int	/* modifiers */,
+    Window		/* grab_window */,
+    Bool		/* owner_events */,
+    unsigned int	/* event_mask */,
+    int			/* pointer_mode */,
+    int			/* keyboard_mode */,
+    Window		/* confine_to */,
+    Cursor		/* cursor */
+);
+
+extern int XGrabKey(
+    Display*		/* display */,
+    int			/* keycode */,
+    unsigned int	/* modifiers */,
+    Window		/* grab_window */,
+    Bool		/* owner_events */,
+    int			/* pointer_mode */,
+    int			/* keyboard_mode */
+);
+
+extern int XGrabKeyboard(
+    Display*		/* display */,
+    Window		/* grab_window */,
+    Bool		/* owner_events */,
+    int			/* pointer_mode */,
+    int			/* keyboard_mode */,
+    Time		/* time */
+);
+
+extern int XGrabPointer(
+    Display*		/* display */,
+    Window		/* grab_window */,
+    Bool		/* owner_events */,
+    unsigned int	/* event_mask */,
+    int			/* pointer_mode */,
+    int			/* keyboard_mode */,
+    Window		/* confine_to */,
+    Cursor		/* cursor */,
+    Time		/* time */
+);
+
+extern int XGrabServer(
+    Display*		/* display */
+);
+
+extern int XHeightMMOfScreen(
+    Screen*		/* screen */
+);
+
+extern int XHeightOfScreen(
+    Screen*		/* screen */
+);
+
+extern int XIfEvent(
+    Display*		/* display */,
+    XEvent*		/* event_return */,
+    Bool (*) (
+	       Display*			/* display */,
+               XEvent*			/* event */,
+               XPointer			/* arg */
+             )		/* predicate */,
+    XPointer		/* arg */
+);
+
+extern int XImageByteOrder(
+    Display*		/* display */
+);
+
+extern int XInstallColormap(
+    Display*		/* display */,
+    Colormap		/* colormap */
+);
+
+extern KeyCode XKeysymToKeycode(
+    Display*		/* display */,
+    KeySym		/* keysym */
+);
+
+extern int XKillClient(
+    Display*		/* display */,
+    XID			/* resource */
+);
+
+extern Status XLookupColor(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    _Xconst char*	/* color_name */,
+    XColor*		/* exact_def_return */,
+    XColor*		/* screen_def_return */
+);
+
+extern int XLowerWindow(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XMapRaised(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XMapSubwindows(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XMapWindow(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XMaskEvent(
+    Display*		/* display */,
+    long		/* event_mask */,
+    XEvent*		/* event_return */
+);
+
+extern int XMaxCmapsOfScreen(
+    Screen*		/* screen */
+);
+
+extern int XMinCmapsOfScreen(
+    Screen*		/* screen */
+);
+
+extern int XMoveResizeWindow(
+    Display*		/* display */,
+    Window		/* w */,
+    int			/* x */,
+    int			/* y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */
+);
+
+extern int XMoveWindow(
+    Display*		/* display */,
+    Window		/* w */,
+    int			/* x */,
+    int			/* y */
+);
+
+extern int XNextEvent(
+    Display*		/* display */,
+    XEvent*		/* event_return */
+);
+
+extern int XNoOp(
+    Display*		/* display */
+);
+
+extern Status XParseColor(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    _Xconst char*	/* spec */,
+    XColor*		/* exact_def_return */
+);
+
+extern int XParseGeometry(
+    _Xconst char*	/* parsestring */,
+    int*		/* x_return */,
+    int*		/* y_return */,
+    unsigned int*	/* width_return */,
+    unsigned int*	/* height_return */
+);
+
+extern int XPeekEvent(
+    Display*		/* display */,
+    XEvent*		/* event_return */
+);
+
+extern int XPeekIfEvent(
+    Display*		/* display */,
+    XEvent*		/* event_return */,
+    Bool (*) (
+	       Display*		/* display */,
+               XEvent*		/* event */,
+               XPointer		/* arg */
+             )		/* predicate */,
+    XPointer		/* arg */
+);
+
+extern int XPending(
+    Display*		/* display */
+);
+
+extern int XPlanesOfScreen(
+    Screen*		/* screen */
+);
+
+extern int XProtocolRevision(
+    Display*		/* display */
+);
+
+extern int XProtocolVersion(
+    Display*		/* display */
+);
+
+
+extern int XPutBackEvent(
+    Display*		/* display */,
+    XEvent*		/* event */
+);
+
+extern int XPutImage(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    XImage*		/* image */,
+    int			/* src_x */,
+    int			/* src_y */,
+    int			/* dest_x */,
+    int			/* dest_y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */	  
+);
+
+extern int XQLength(
+    Display*		/* display */
+);
+
+extern Status XQueryBestCursor(
+    Display*		/* display */,
+    Drawable		/* d */,
+    unsigned int        /* width */,
+    unsigned int	/* height */,
+    unsigned int*	/* width_return */,
+    unsigned int*	/* height_return */
+);
+
+extern Status XQueryBestSize(
+    Display*		/* display */,
+    int			/* class */,
+    Drawable		/* which_screen */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    unsigned int*	/* width_return */,
+    unsigned int*	/* height_return */
+);
+
+extern Status XQueryBestStipple(
+    Display*		/* display */,
+    Drawable		/* which_screen */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    unsigned int*	/* width_return */,
+    unsigned int*	/* height_return */
+);
+
+extern Status XQueryBestTile(
+    Display*		/* display */,
+    Drawable		/* which_screen */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    unsigned int*	/* width_return */,
+    unsigned int*	/* height_return */
+);
+
+extern int XQueryColor(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    XColor*		/* def_in_out */
+);
+
+extern int XQueryColors(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    XColor*		/* defs_in_out */,
+    int			/* ncolors */
+);
+
+extern Bool XQueryExtension(
+    Display*		/* display */,
+    _Xconst char*	/* name */,
+    int*		/* major_opcode_return */,
+    int*		/* first_event_return */,
+    int*		/* first_error_return */
+);
+
+extern int XQueryKeymap(
+    Display*		/* display */,
+    char [32]		/* keys_return */
+);
+
+extern Bool XQueryPointer(
+    Display*		/* display */,
+    Window		/* w */,
+    Window*		/* root_return */,
+    Window*		/* child_return */,
+    int*		/* root_x_return */,
+    int*		/* root_y_return */,
+    int*		/* win_x_return */,
+    int*		/* win_y_return */,
+    unsigned int*       /* mask_return */
+);
+
+extern int XQueryTextExtents(
+    Display*		/* display */,
+    XID			/* font_ID */,
+    _Xconst char*	/* string */,
+    int			/* nchars */,
+    int*		/* direction_return */,
+    int*		/* font_ascent_return */,
+    int*		/* font_descent_return */,
+    XCharStruct*	/* overall_return */    
+);
+
+extern int XQueryTextExtents16(
+    Display*		/* display */,
+    XID			/* font_ID */,
+    _Xconst XChar2b*	/* string */,
+    int			/* nchars */,
+    int*		/* direction_return */,
+    int*		/* font_ascent_return */,
+    int*		/* font_descent_return */,
+    XCharStruct*	/* overall_return */
+);
+
+extern Status XQueryTree(
+    Display*		/* display */,
+    Window		/* w */,
+    Window*		/* root_return */,
+    Window*		/* parent_return */,
+    Window**		/* children_return */,
+    unsigned int*	/* nchildren_return */
+);
+
+extern int XRaiseWindow(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XReadBitmapFile(
+    Display*		/* display */,
+    Drawable 		/* d */,
+    _Xconst char*	/* filename */,
+    unsigned int*	/* width_return */,
+    unsigned int*	/* height_return */,
+    Pixmap*		/* bitmap_return */,
+    int*		/* x_hot_return */,
+    int*		/* y_hot_return */
+);
+
+extern int XReadBitmapFileData(
+    _Xconst char*	/* filename */,
+    unsigned int*	/* width_return */,
+    unsigned int*	/* height_return */,
+    unsigned char**	/* data_return */,
+    int*		/* x_hot_return */,
+    int*		/* y_hot_return */
+);
+
+extern int XRebindKeysym(
+    Display*		/* display */,
+    KeySym		/* keysym */,
+    KeySym*		/* list */,
+    int			/* mod_count */,
+    _Xconst unsigned char*	/* string */,
+    int			/* bytes_string */
+);
+
+extern int XRecolorCursor(
+    Display*		/* display */,
+    Cursor		/* cursor */,
+    XColor*		/* foreground_color */,
+    XColor*		/* background_color */
+);
+
+extern int XRefreshKeyboardMapping(
+    XMappingEvent*	/* event_map */    
+);
+
+extern int XRemoveFromSaveSet(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XRemoveHost(
+    Display*		/* display */,
+    XHostAddress*	/* host */
+);
+
+extern int XRemoveHosts(
+    Display*		/* display */,
+    XHostAddress*	/* hosts */,
+    int			/* num_hosts */
+);
+
+extern int XReparentWindow(
+    Display*		/* display */,
+    Window		/* w */,
+    Window		/* parent */,
+    int			/* x */,
+    int			/* y */
+);
+
+extern int XResetScreenSaver(
+    Display*		/* display */
+);
+
+extern int XResizeWindow(
+    Display*		/* display */,
+    Window		/* w */,
+    unsigned int	/* width */,
+    unsigned int	/* height */
+);
+
+extern int XRestackWindows(
+    Display*		/* display */,
+    Window*		/* windows */,
+    int			/* nwindows */
+);
+
+extern int XRotateBuffers(
+    Display*		/* display */,
+    int			/* rotate */
+);
+
+extern int XRotateWindowProperties(
+    Display*		/* display */,
+    Window		/* w */,
+    Atom*		/* properties */,
+    int			/* num_prop */,
+    int			/* npositions */
+);
+
+extern int XScreenCount(
+    Display*		/* display */
+);
+
+extern int XSelectInput(
+    Display*		/* display */,
+    Window		/* w */,
+    long		/* event_mask */
+);
+
+extern Status XSendEvent(
+    Display*		/* display */,
+    Window		/* w */,
+    Bool		/* propagate */,
+    long		/* event_mask */,
+    XEvent*		/* event_send */
+);
+
+extern int XSetAccessControl(
+    Display*		/* display */,
+    int			/* mode */
+);
+
+extern int XSetArcMode(
+    Display*		/* display */,
+    GC			/* gc */,
+    int			/* arc_mode */
+);
+
+extern int XSetBackground(
+    Display*		/* display */,
+    GC			/* gc */,
+    unsigned long	/* background */
+);
+
+extern int XSetClipMask(
+    Display*		/* display */,
+    GC			/* gc */,
+    Pixmap		/* pixmap */
+);
+
+extern int XSetClipOrigin(
+    Display*		/* display */,
+    GC			/* gc */,
+    int			/* clip_x_origin */,
+    int			/* clip_y_origin */
+);
+
+extern int XSetClipRectangles(
+    Display*		/* display */,
+    GC			/* gc */,
+    int			/* clip_x_origin */,
+    int			/* clip_y_origin */,
+    XRectangle*		/* rectangles */,
+    int			/* n */,
+    int			/* ordering */
+);
+
+extern int XSetCloseDownMode(
+    Display*		/* display */,
+    int			/* close_mode */
+);
+
+extern int XSetCommand(
+    Display*		/* display */,
+    Window		/* w */,
+    char**		/* argv */,
+    int			/* argc */
+);
+
+extern int XSetDashes(
+    Display*		/* display */,
+    GC			/* gc */,
+    int			/* dash_offset */,
+    _Xconst char*	/* dash_list */,
+    int			/* n */
+);
+
+extern int XSetFillRule(
+    Display*		/* display */,
+    GC			/* gc */,
+    int			/* fill_rule */
+);
+
+extern int XSetFillStyle(
+    Display*		/* display */,
+    GC			/* gc */,
+    int			/* fill_style */
+);
+
+extern int XSetFont(
+    Display*		/* display */,
+    GC			/* gc */,
+    Font		/* font */
+);
+
+extern int XSetFontPath(
+    Display*		/* display */,
+    char**		/* directories */,
+    int			/* ndirs */	     
+);
+
+extern int XSetForeground(
+    Display*		/* display */,
+    GC			/* gc */,
+    unsigned long	/* foreground */
+);
+
+extern int XSetFunction(
+    Display*		/* display */,
+    GC			/* gc */,
+    int			/* function */
+);
+
+extern int XSetGraphicsExposures(
+    Display*		/* display */,
+    GC			/* gc */,
+    Bool		/* graphics_exposures */
+);
+
+extern int XSetIconName(
+    Display*		/* display */,
+    Window		/* w */,
+    _Xconst char*	/* icon_name */
+);
+
+extern int XSetInputFocus(
+    Display*		/* display */,
+    Window		/* focus */,
+    int			/* revert_to */,
+    Time		/* time */
+);
+
+extern int XSetLineAttributes(
+    Display*		/* display */,
+    GC			/* gc */,
+    unsigned int	/* line_width */,
+    int			/* line_style */,
+    int			/* cap_style */,
+    int			/* join_style */
+);
+
+extern int XSetModifierMapping(
+    Display*		/* display */,
+    XModifierKeymap*	/* modmap */
+);
+
+extern int XSetPlaneMask(
+    Display*		/* display */,
+    GC			/* gc */,
+    unsigned long	/* plane_mask */
+);
+
+extern int XSetPointerMapping(
+    Display*		/* display */,
+    _Xconst unsigned char*	/* map */,
+    int			/* nmap */
+);
+
+extern int XSetScreenSaver(
+    Display*		/* display */,
+    int			/* timeout */,
+    int			/* interval */,
+    int			/* prefer_blanking */,
+    int			/* allow_exposures */
+);
+
+extern int XSetSelectionOwner(
+    Display*		/* display */,
+    Atom	        /* selection */,
+    Window		/* owner */,
+    Time		/* time */
+);
+
+extern int XSetState(
+    Display*		/* display */,
+    GC			/* gc */,
+    unsigned long 	/* foreground */,
+    unsigned long	/* background */,
+    int			/* function */,
+    unsigned long	/* plane_mask */
+);
+
+extern int XSetStipple(
+    Display*		/* display */,
+    GC			/* gc */,
+    Pixmap		/* stipple */
+);
+
+extern int XSetSubwindowMode(
+    Display*		/* display */,
+    GC			/* gc */,
+    int			/* subwindow_mode */
+);
+
+extern int XSetTSOrigin(
+    Display*		/* display */,
+    GC			/* gc */,
+    int			/* ts_x_origin */,
+    int			/* ts_y_origin */
+);
+
+extern int XSetTile(
+    Display*		/* display */,
+    GC			/* gc */,
+    Pixmap		/* tile */
+);
+
+extern int XSetWindowBackground(
+    Display*		/* display */,
+    Window		/* w */,
+    unsigned long	/* background_pixel */
+);
+
+extern int XSetWindowBackgroundPixmap(
+    Display*		/* display */,
+    Window		/* w */,
+    Pixmap		/* background_pixmap */
+);
+
+extern int XSetWindowBorder(
+    Display*		/* display */,
+    Window		/* w */,
+    unsigned long	/* border_pixel */
+);
+
+extern int XSetWindowBorderPixmap(
+    Display*		/* display */,
+    Window		/* w */,
+    Pixmap		/* border_pixmap */
+);
+
+extern int XSetWindowBorderWidth(
+    Display*		/* display */,
+    Window		/* w */,
+    unsigned int	/* width */
+);
+
+extern int XSetWindowColormap(
+    Display*		/* display */,
+    Window		/* w */,
+    Colormap		/* colormap */
+);
+
+extern int XStoreBuffer(
+    Display*		/* display */,
+    _Xconst char*	/* bytes */,
+    int			/* nbytes */,
+    int			/* buffer */
+);
+
+extern int XStoreBytes(
+    Display*		/* display */,
+    _Xconst char*	/* bytes */,
+    int			/* nbytes */
+);
+
+extern int XStoreColor(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    XColor*		/* color */
+);
+
+extern int XStoreColors(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    XColor*		/* color */,
+    int			/* ncolors */
+);
+
+extern int XStoreName(
+    Display*		/* display */,
+    Window		/* w */,
+    _Xconst char*	/* window_name */
+);
+
+extern int XStoreNamedColor(
+    Display*		/* display */,
+    Colormap		/* colormap */,
+    _Xconst char*	/* color */,
+    unsigned long	/* pixel */,
+    int			/* flags */
+);
+
+extern int XSync(
+    Display*		/* display */,
+    Bool		/* discard */
+);
+
+extern int XTextExtents(
+    XFontStruct*	/* font_struct */,
+    _Xconst char*	/* string */,
+    int			/* nchars */,
+    int*		/* direction_return */,
+    int*		/* font_ascent_return */,
+    int*		/* font_descent_return */,
+    XCharStruct*	/* overall_return */
+);
+
+extern int XTextExtents16(
+    XFontStruct*	/* font_struct */,
+    _Xconst XChar2b*	/* string */,
+    int			/* nchars */,
+    int*		/* direction_return */,
+    int*		/* font_ascent_return */,
+    int*		/* font_descent_return */,
+    XCharStruct*	/* overall_return */
+);
+
+extern int XTextWidth(
+    XFontStruct*	/* font_struct */,
+    _Xconst char*	/* string */,
+    int			/* count */
+);
+
+extern int XTextWidth16(
+    XFontStruct*	/* font_struct */,
+    _Xconst XChar2b*	/* string */,
+    int			/* count */
+);
+
+extern Bool XTranslateCoordinates(
+    Display*		/* display */,
+    Window		/* src_w */,
+    Window		/* dest_w */,
+    int			/* src_x */,
+    int			/* src_y */,
+    int*		/* dest_x_return */,
+    int*		/* dest_y_return */,
+    Window*		/* child_return */
+);
+
+extern int XUndefineCursor(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XUngrabButton(
+    Display*		/* display */,
+    unsigned int	/* button */,
+    unsigned int	/* modifiers */,
+    Window		/* grab_window */
+);
+
+extern int XUngrabKey(
+    Display*		/* display */,
+    int			/* keycode */,
+    unsigned int	/* modifiers */,
+    Window		/* grab_window */
+);
+
+extern int XUngrabKeyboard(
+    Display*		/* display */,
+    Time		/* time */
+);
+
+extern int XUngrabPointer(
+    Display*		/* display */,
+    Time		/* time */
+);
+
+extern int XUngrabServer(
+    Display*		/* display */
+);
+
+extern int XUninstallColormap(
+    Display*		/* display */,
+    Colormap		/* colormap */
+);
+
+extern int XUnloadFont(
+    Display*		/* display */,
+    Font		/* font */
+);
+
+extern int XUnmapSubwindows(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XUnmapWindow(
+    Display*		/* display */,
+    Window		/* w */
+);
+
+extern int XVendorRelease(
+    Display*		/* display */
+);
+
+extern int XWarpPointer(
+    Display*		/* display */,
+    Window		/* src_w */,
+    Window		/* dest_w */,
+    int			/* src_x */,
+    int			/* src_y */,
+    unsigned int	/* src_width */,
+    unsigned int	/* src_height */,
+    int			/* dest_x */,
+    int			/* dest_y */	     
+);
+
+extern int XWidthMMOfScreen(
+    Screen*		/* screen */
+);
+
+extern int XWidthOfScreen(
+    Screen*		/* screen */
+);
+
+extern int XWindowEvent(
+    Display*		/* display */,
+    Window		/* w */,
+    long		/* event_mask */,
+    XEvent*		/* event_return */
+);
+
+extern int XWriteBitmapFile(
+    Display*		/* display */,
+    _Xconst char*	/* filename */,
+    Pixmap		/* bitmap */,
+    unsigned int	/* width */,
+    unsigned int	/* height */,
+    int			/* x_hot */,
+    int			/* y_hot */		     
+);
+
+extern Bool XSupportsLocale (void);
+
+extern char *XSetLocaleModifiers(
+    const char*		/* modifier_list */
+);
+
+extern XOM XOpenOM(
+    Display*			/* display */,
+    struct _XrmHashBucketRec*	/* rdb */,
+    _Xconst char*		/* res_name */,
+    _Xconst char*		/* res_class */
+);
+
+extern Status XCloseOM(
+    XOM			/* om */
+);
+
+extern char *XSetOMValues(
+    XOM			/* om */,
+    ...
+) _X_SENTINEL(0);
+
+extern char *XGetOMValues(
+    XOM			/* om */,
+    ...
+) _X_SENTINEL(0);
+
+extern Display *XDisplayOfOM(
+    XOM			/* om */
+);
+
+extern char *XLocaleOfOM(
+    XOM			/* om */
+);
+
+extern XOC XCreateOC(
+    XOM			/* om */,
+    ...
+) _X_SENTINEL(0);
+
+extern void XDestroyOC(
+    XOC			/* oc */
+);
+
+extern XOM XOMOfOC(
+    XOC			/* oc */
+);
+
+extern char *XSetOCValues(
+    XOC			/* oc */,
+    ...
+) _X_SENTINEL(0);
+
+extern char *XGetOCValues(
+    XOC			/* oc */,
+    ...
+) _X_SENTINEL(0);
+
+extern XFontSet XCreateFontSet(
+    Display*		/* display */,
+    _Xconst char*	/* base_font_name_list */,
+    char***		/* missing_charset_list */,
+    int*		/* missing_charset_count */,
+    char**		/* def_string */
+);
+
+extern void XFreeFontSet(
+    Display*		/* display */,
+    XFontSet		/* font_set */
+);
+
+extern int XFontsOfFontSet(
+    XFontSet		/* font_set */,
+    XFontStruct***	/* font_struct_list */,
+    char***		/* font_name_list */
+);
+
+extern char *XBaseFontNameListOfFontSet(
+    XFontSet		/* font_set */
+);
+
+extern char *XLocaleOfFontSet(
+    XFontSet		/* font_set */
+);
+
+extern Bool XContextDependentDrawing(
+    XFontSet		/* font_set */
+);
+
+extern Bool XDirectionalDependentDrawing(
+    XFontSet		/* font_set */
+);
+
+extern Bool XContextualDrawing(
+    XFontSet		/* font_set */
+);
+
+extern XFontSetExtents *XExtentsOfFontSet(
+    XFontSet		/* font_set */
+);
+
+extern int XmbTextEscapement(
+    XFontSet		/* font_set */,
+    _Xconst char*	/* text */,
+    int			/* bytes_text */
+);
+
+extern int XwcTextEscapement(
+    XFontSet		/* font_set */,
+    _Xconst wchar_t*	/* text */,
+    int			/* num_wchars */
+);
+
+extern int Xutf8TextEscapement(
+    XFontSet		/* font_set */,
+    _Xconst char*	/* text */,
+    int			/* bytes_text */
+);
+
+extern int XmbTextExtents(
+    XFontSet		/* font_set */,
+    _Xconst char*	/* text */,
+    int			/* bytes_text */,
+    XRectangle*		/* overall_ink_return */,
+    XRectangle*		/* overall_logical_return */
+);
+
+extern int XwcTextExtents(
+    XFontSet		/* font_set */,
+    _Xconst wchar_t*	/* text */,
+    int			/* num_wchars */,
+    XRectangle*		/* overall_ink_return */,
+    XRectangle*		/* overall_logical_return */
+);
+
+extern int Xutf8TextExtents(
+    XFontSet		/* font_set */,
+    _Xconst char*	/* text */,
+    int			/* bytes_text */,
+    XRectangle*		/* overall_ink_return */,
+    XRectangle*		/* overall_logical_return */
+);
+
+extern Status XmbTextPerCharExtents(
+    XFontSet		/* font_set */,
+    _Xconst char*	/* text */,
+    int			/* bytes_text */,
+    XRectangle*		/* ink_extents_buffer */,
+    XRectangle*		/* logical_extents_buffer */,
+    int			/* buffer_size */,
+    int*		/* num_chars */,
+    XRectangle*		/* overall_ink_return */,
+    XRectangle*		/* overall_logical_return */
+);
+
+extern Status XwcTextPerCharExtents(
+    XFontSet		/* font_set */,
+    _Xconst wchar_t*	/* text */,
+    int			/* num_wchars */,
+    XRectangle*		/* ink_extents_buffer */,
+    XRectangle*		/* logical_extents_buffer */,
+    int			/* buffer_size */,
+    int*		/* num_chars */,
+    XRectangle*		/* overall_ink_return */,
+    XRectangle*		/* overall_logical_return */
+);
+
+extern Status Xutf8TextPerCharExtents(
+    XFontSet		/* font_set */,
+    _Xconst char*	/* text */,
+    int			/* bytes_text */,
+    XRectangle*		/* ink_extents_buffer */,
+    XRectangle*		/* logical_extents_buffer */,
+    int			/* buffer_size */,
+    int*		/* num_chars */,
+    XRectangle*		/* overall_ink_return */,
+    XRectangle*		/* overall_logical_return */
+);
+
+extern void XmbDrawText(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    XmbTextItem*	/* text_items */,
+    int			/* nitems */
+);
+
+extern void XwcDrawText(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    XwcTextItem*	/* text_items */,
+    int			/* nitems */
+);
+
+extern void Xutf8DrawText(
+    Display*		/* display */,
+    Drawable		/* d */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    XmbTextItem*	/* text_items */,
+    int			/* nitems */
+);
+
+extern void XmbDrawString(
+    Display*		/* display */,
+    Drawable		/* d */,
+    XFontSet		/* font_set */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    _Xconst char*	/* text */,
+    int			/* bytes_text */
+);
+
+extern void XwcDrawString(
+    Display*		/* display */,
+    Drawable		/* d */,
+    XFontSet		/* font_set */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    _Xconst wchar_t*	/* text */,
+    int			/* num_wchars */
+);
+
+extern void Xutf8DrawString(
+    Display*		/* display */,
+    Drawable		/* d */,
+    XFontSet		/* font_set */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    _Xconst char*	/* text */,
+    int			/* bytes_text */
+);
+
+extern void XmbDrawImageString(
+    Display*		/* display */,
+    Drawable		/* d */,
+    XFontSet		/* font_set */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    _Xconst char*	/* text */,
+    int			/* bytes_text */
+);
+
+extern void XwcDrawImageString(
+    Display*		/* display */,
+    Drawable		/* d */,
+    XFontSet		/* font_set */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    _Xconst wchar_t*	/* text */,
+    int			/* num_wchars */
+);
+
+extern void Xutf8DrawImageString(
+    Display*		/* display */,
+    Drawable		/* d */,
+    XFontSet		/* font_set */,
+    GC			/* gc */,
+    int			/* x */,
+    int			/* y */,
+    _Xconst char*	/* text */,
+    int			/* bytes_text */
+);
+
+extern XIM XOpenIM(
+    Display*			/* dpy */,
+    struct _XrmHashBucketRec*	/* rdb */,
+    char*			/* res_name */,
+    char*			/* res_class */
+);
+
+extern Status XCloseIM(
+    XIM /* im */
+);
+
+extern char *XGetIMValues(
+    XIM /* im */, ...
+) _X_SENTINEL(0);
+
+extern char *XSetIMValues(
+    XIM /* im */, ...
+) _X_SENTINEL(0);
+
+extern Display *XDisplayOfIM(
+    XIM /* im */
+);
+
+extern char *XLocaleOfIM(
+    XIM /* im*/
+);
+
+extern XIC XCreateIC(
+    XIM /* im */, ...
+) _X_SENTINEL(0);
+
+extern void XDestroyIC(
+    XIC /* ic */
+);
+
+extern void XSetICFocus(
+    XIC /* ic */
+);
+
+extern void XUnsetICFocus(
+    XIC /* ic */
+);
+
+extern wchar_t *XwcResetIC(
+    XIC /* ic */
+);
+
+extern char *XmbResetIC(
+    XIC /* ic */
+);
+
+extern char *Xutf8ResetIC(
+    XIC /* ic */
+);
+
+extern char *XSetICValues(
+    XIC /* ic */, ...
+) _X_SENTINEL(0);
+
+extern char *XGetICValues(
+    XIC /* ic */, ...
+) _X_SENTINEL(0);
+
+extern XIM XIMOfIC(
+    XIC /* ic */
+);
+
+extern Bool XFilterEvent(
+    XEvent*	/* event */,
+    Window	/* window */
+);
+
+extern int XmbLookupString(
+    XIC			/* ic */,
+    XKeyPressedEvent*	/* event */,
+    char*		/* buffer_return */,
+    int			/* bytes_buffer */,
+    KeySym*		/* keysym_return */,
+    Status*		/* status_return */
+);
+
+extern int XwcLookupString(
+    XIC			/* ic */,
+    XKeyPressedEvent*	/* event */,
+    wchar_t*		/* buffer_return */,
+    int			/* wchars_buffer */,
+    KeySym*		/* keysym_return */,
+    Status*		/* status_return */
+);
+
+extern int Xutf8LookupString(
+    XIC			/* ic */,
+    XKeyPressedEvent*	/* event */,
+    char*		/* buffer_return */,
+    int			/* bytes_buffer */,
+    KeySym*		/* keysym_return */,
+    Status*		/* status_return */
+);
+
+extern XVaNestedList XVaCreateNestedList(
+    int /*unused*/, ...
+) _X_SENTINEL(0);
+
+/* internal connections for IMs */
+
+extern Bool XRegisterIMInstantiateCallback(
+    Display*			/* dpy */,
+    struct _XrmHashBucketRec*	/* rdb */,
+    char*			/* res_name */,
+    char*			/* res_class */,
+    XIDProc			/* callback */,
+    XPointer			/* client_data */
+);
+
+extern Bool XUnregisterIMInstantiateCallback(
+    Display*			/* dpy */,
+    struct _XrmHashBucketRec*	/* rdb */,
+    char*			/* res_name */,
+    char*			/* res_class */,
+    XIDProc			/* callback */,
+    XPointer			/* client_data */
+);
+
+typedef void (*XConnectionWatchProc)(
+    Display*			/* dpy */,
+    XPointer			/* client_data */,
+    int				/* fd */,
+    Bool			/* opening */,	 /* open or close flag */
+    XPointer*			/* watch_data */ /* open sets, close uses */
+);
+    
+
+extern Status XInternalConnectionNumbers(
+    Display*			/* dpy */,
+    int**			/* fd_return */,
+    int*			/* count_return */
+);
+
+extern void XProcessInternalConnection(
+    Display*			/* dpy */,
+    int				/* fd */
+);
+
+extern Status XAddConnectionWatch(
+    Display*			/* dpy */,
+    XConnectionWatchProc	/* callback */,
+    XPointer			/* client_data */
+);
+
+extern void XRemoveConnectionWatch(
+    Display*			/* dpy */,
+    XConnectionWatchProc	/* callback */,
+    XPointer			/* client_data */
+);
+
+extern void XSetAuthorization(
+    char *			/* name */,
+    int				/* namelen */, 
+    char *			/* data */,
+    int				/* datalen */
+);
+
+extern int _Xmbtowc(
+    wchar_t *			/* wstr */,
+#ifdef ISC
+    char const *		/* str */,
+    size_t			/* len */
+#else
+    char *			/* str */,
+    int				/* len */
+#endif
+);
+
+extern int _Xwctomb(
+    char *			/* str */,
+    wchar_t			/* wc */
+);
+
+_XFUNCPROTOEND
+
+#endif /* _XLIB_H_ */
diff --git a/X11/XlibConf.h b/X11/XlibConf.h
new file mode 100644
index 0000000..32fc91b
--- /dev/null
+++ b/X11/XlibConf.h
@@ -0,0 +1,7 @@
+/* Defines needed to use Xlib from non-imake projects */
+#ifndef XTHREADS
+#define XTHREADS
+#endif
+#ifndef XUSE_MTSAFE_API
+#define XUSE_MTSAFE_API
+#endif
diff --git a/X11/Xlibint.h b/X11/Xlibint.h
new file mode 100644
index 0000000..56da234
--- /dev/null
+++ b/X11/Xlibint.h
@@ -0,0 +1,1346 @@
+/* $Xorg: Xlibint.h,v 1.5 2001/02/09 02:03:38 xorgcvs Exp $ */
+
+/*
+
+Copyright 1984, 1985, 1987, 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+/* $XFree86: xc/lib/X11/Xlibint.h,v 3.27 2003/05/27 22:26:26 tsi Exp $ */
+
+#ifndef _XLIBINT_H_
+#define _XLIBINT_H_ 1
+
+/*
+ *	Xlibint.h - Header definition and support file for the internal
+ *	support routines used by the C subroutine interface
+ *	library (Xlib) to the X Window System.
+ *
+ *	Warning, there be dragons here....
+ */
+
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xproto.h&gt;		/* to declare xEvent */
+#include &lt;X11/XlibConf.h&gt;	/* for configured options like XTHREADS */
+
+#ifdef NX_TRANS_SOCKET
+
+#include &quot;NXvars.h&quot;
+
+#define _XGetIOError(dpy) \
+    (dpy -&gt; flags &amp; XlibDisplayIOError)
+
+#endif
+
+#ifdef WIN32
+#define _XFlush _XFlushIt
+#endif
+
+/*
+ * If your BytesReadable correctly detects broken connections, then
+ * you should NOT define XCONN_CHECK_FREQ.
+ */
+#ifndef XCONN_CHECK_FREQ
+#define XCONN_CHECK_FREQ 256
+#endif
+
+struct _XGC
+{
+    XExtData *ext_data;	/* hook for extension to hang data */
+    GContext gid;	/* protocol ID for graphics context */
+    Bool rects;		/* boolean: TRUE if clipmask is list of rectangles */
+    Bool dashes;	/* boolean: TRUE if dash-list is really a list */
+    unsigned long dirty;/* cache dirty bits */
+    XGCValues values;	/* shadow structure of values */
+};
+
+struct _XDisplay
+{
+	XExtData *ext_data;	/* hook for extension to hang data */
+	struct _XFreeFuncs *free_funcs; /* internal free functions */
+	int fd;			/* Network socket. */
+	int conn_checker;         /* ugly thing used by _XEventsQueued */
+	int proto_major_version;/* maj. version of server's X protocol */
+	int proto_minor_version;/* minor version of server's X protocol */
+	char *vendor;		/* vendor of the server hardware */
+        XID resource_base;	/* resource ID base */
+	XID resource_mask;	/* resource ID mask bits */
+	XID resource_id;	/* allocator current ID */
+	int resource_shift;	/* allocator shift to correct bits */
+	XID (*resource_alloc)(	/* allocator function */
+		struct _XDisplay*
+		);
+	int byte_order;		/* screen byte order, LSBFirst, MSBFirst */
+	int bitmap_unit;	/* padding and data requirements */
+	int bitmap_pad;		/* padding requirements on bitmaps */
+	int bitmap_bit_order;	/* LeastSignificant or MostSignificant */
+	int nformats;		/* number of pixmap formats in list */
+	ScreenFormat *pixmap_format;	/* pixmap format list */
+	int vnumber;		/* Xlib's X protocol version number. */
+	int release;		/* release of the server */
+	struct _XSQEvent *head, *tail;	/* Input event queue. */
+	int qlen;		/* Length of input event queue */
+	unsigned long last_request_read; /* seq number of last event read */
+	unsigned long request;	/* sequence number of last request. */
+	char *last_req;		/* beginning of last request, or dummy */
+	char *buffer;		/* Output buffer starting address. */
+	char *bufptr;		/* Output buffer index pointer. */
+	char *bufmax;		/* Output buffer maximum+1 address. */
+	unsigned max_request_size; /* maximum number 32 bit words in request*/
+	struct _XrmHashBucketRec *db;
+	int (*synchandler)(	/* Synchronization handler */
+		struct _XDisplay*
+		);
+	char *display_name;	/* &quot;host:display&quot; string used on this connect*/
+	int default_screen;	/* default screen for operations */
+	int nscreens;		/* number of screens on this server*/
+	Screen *screens;	/* pointer to list of screens */
+	unsigned long motion_buffer;	/* size of motion buffer */
+	unsigned long flags;	   /* internal connection flags */
+	int min_keycode;	/* minimum defined keycode */
+	int max_keycode;	/* maximum defined keycode */
+	KeySym *keysyms;	/* This server's keysyms */
+	XModifierKeymap *modifiermap;	/* This server's modifier keymap */
+	int keysyms_per_keycode;/* number of rows */
+	char *xdefaults;	/* contents of defaults from server */
+	char *scratch_buffer;	/* place to hang scratch buffer */
+	unsigned long scratch_length;	/* length of scratch buffer */
+	int ext_number;		/* extension number on this display */
+	struct _XExten *ext_procs; /* extensions initialized on this display */
+	/*
+	 * the following can be fixed size, as the protocol defines how
+	 * much address space is available. 
+	 * While this could be done using the extension vector, there
+	 * may be MANY events processed, so a search through the extension
+	 * list to find the right procedure for each event might be
+	 * expensive if many extensions are being used.
+	 */
+	Bool (*event_vec[128])(	/* vector for wire to event */
+		Display *	/* dpy */,
+		XEvent *	/* re */,
+		xEvent *	/* event */
+		);
+	Status (*wire_vec[128])( /* vector for event to wire */
+		Display *	/* dpy */,
+		XEvent *	/* re */,
+		xEvent *	/* event */
+		);
+	KeySym lock_meaning;	   /* for XLookupString */
+	struct _XLockInfo *lock;   /* multi-thread state, display lock */
+	struct _XInternalAsync *async_handlers; /* for internal async */
+	unsigned long bigreq_size; /* max size of big requests */
+	struct _XLockPtrs *lock_fns; /* pointers to threads functions */
+	void (*idlist_alloc)(	   /* XID list allocator function */
+		Display *	/* dpy */,
+		XID *		/* ids */,
+		int		/* count */
+		);
+	/* things above this line should not move, for binary compatibility */
+	struct _XKeytrans *key_bindings; /* for XLookupString */
+	Font cursor_font;	   /* for XCreateFontCursor */
+	struct _XDisplayAtoms *atoms; /* for XInternAtom */
+	unsigned int mode_switch;  /* keyboard group modifiers */
+	unsigned int num_lock;  /* keyboard numlock modifiers */
+	struct _XContextDB *context_db; /* context database */
+	Bool (**error_vec)(	/* vector for wire to error */
+		Display     *	/* display */,
+		XErrorEvent *	/* he */,
+		xError      *	/* we */
+		);
+	/*
+	 * Xcms information
+	 */
+	struct {
+	   XPointer defaultCCCs;  /* pointer to an array of default XcmsCCC */
+	   XPointer clientCmaps;  /* pointer to linked list of XcmsCmapRec */
+	   XPointer perVisualIntensityMaps;
+				  /* linked list of XcmsIntensityMap */
+	} cms;
+	struct _XIMFilter *im_filters;
+	struct _XSQEvent *qfree; /* unallocated event queue elements */
+	unsigned long next_event_serial_num; /* inserted into next queue elt */
+	struct _XExten *flushes; /* Flush hooks */
+	struct _XConnectionInfo *im_fd_info; /* _XRegisterInternalConnection */
+	int im_fd_length;	/* number of im_fd_info */
+	struct _XConnWatchInfo *conn_watchers; /* XAddConnectionWatch */
+	int watcher_count;	/* number of conn_watchers */
+	XPointer filedes;	/* struct pollfd cache for _XWaitForReadable */
+	int (*savedsynchandler)( /* user synchandler when Xlib usurps */
+		Display *	/* dpy */
+		);
+	XID resource_max;	/* allocator max ID */
+	int xcmisc_opcode;	/* major opcode for XC-MISC */
+	struct _XkbInfoRec *xkb_info; /* XKB info */
+	struct _XtransConnInfo *trans_conn; /* transport connection object */
+};
+
+#define XAllocIDs(dpy,ids,n) (*(dpy)-&gt;idlist_alloc)(dpy,ids,n)
+
+/*
+ * define the following if you want the Data macro to be a procedure instead
+ */
+#ifdef CRAY
+#define DataRoutineIsProcedure
+#endif /* CRAY */
+
+#ifndef _XEVENT_
+/*
+ * _QEvent datatype for use in input queueing.
+ */
+typedef struct _XSQEvent
+{
+    struct _XSQEvent *next;
+    XEvent event;
+    unsigned long qserial_num;	/* so multi-threaded code can find new ones */
+} _XQEvent;
+#endif
+
+#ifdef XTHREADS			/* for xReply */
+#define NEED_REPLIES
+#endif
+
+#define NEED_EVENTS
+#define NEED_REPLIES
+#include &lt;X11/Xproto.h&gt;
+#ifdef __sgi
+#define _SGI_MP_SOURCE  /* turn this on to get MP safe errno */
+#endif
+#include &lt;errno.h&gt;
+#define _XBCOPYFUNC _Xbcopy
+#include &lt;X11/Xfuncs.h&gt;
+#include &lt;X11/Xosdefs.h&gt;
+
+/* Utek leaves kernel macros around in include files (bleah) */
+#ifdef dirty
+#undef dirty
+#endif
+
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;X11/Xfuncproto.h&gt;
+
+_XFUNCPROTOBEGIN
+
+/*
+ * The following definitions can be used for locking requests in multi-threaded
+ * address spaces.
+ */
+#ifdef XTHREADS
+/* Author: Stephen Gildea, MIT X Consortium
+ *
+ * declarations for C Threads locking
+ */
+
+typedef struct _LockInfoRec *LockInfoPtr;
+
+/* interfaces for locking.c */
+struct _XLockPtrs {
+    /* used by all, including extensions; do not move */
+    void (*lock_display)(
+		Display *dpy
+#if defined(XTHREADS_WARN) || defined(XTHREADS_FILE_LINE)
+		, char *file
+		, int line
+#endif
+	);
+    void (*unlock_display)(
+		Display *dpy
+#if defined(XTHREADS_WARN) || defined(XTHREADS_FILE_LINE)
+		, char *file
+		, int line
+#endif
+	);
+};
+
+#if defined(WIN32) &amp;&amp; !defined(_XLIBINT_)
+#define _XCreateMutex_fn (*_XCreateMutex_fn_p)
+#define _XFreeMutex_fn (*_XFreeMutex_fn_p)
+#define _XLockMutex_fn (*_XLockMutex_fn_p)
+#define _XUnlockMutex_fn (*_XUnlockMutex_fn_p)
+#define _Xglobal_lock (*_Xglobal_lock_p)
+#endif
+
+/* in XlibInt.c */
+extern void (*_XCreateMutex_fn)(
+    LockInfoPtr /* lock */
+);
+extern void (*_XFreeMutex_fn)(
+    LockInfoPtr /* lock */
+);
+extern void (*_XLockMutex_fn)(
+    LockInfoPtr	/* lock */
+#if defined(XTHREADS_WARN) || defined(XTHREADS_FILE_LINE)
+    , char * /* file */
+    , int /* line */
+#endif
+);
+extern void (*_XUnlockMutex_fn)(
+    LockInfoPtr	/* lock */
+#if defined(XTHREADS_WARN) || defined(XTHREADS_FILE_LINE)
+    , char * /* file */
+    , int /* line */
+#endif
+);
+
+extern LockInfoPtr _Xglobal_lock;
+
+#if defined(XTHREADS_WARN) || defined(XTHREADS_FILE_LINE)
+#define LockDisplay(d)	     if ((d)-&gt;lock_fns) (*(d)-&gt;lock_fns-&gt;lock_display)((d),__FILE__,__LINE__)
+#define UnlockDisplay(d)     if ((d)-&gt;lock_fns) (*(d)-&gt;lock_fns-&gt;unlock_display)((d),__FILE__,__LINE__)
+#define _XLockMutex(lock)		if (_XLockMutex_fn) (*_XLockMutex_fn)(lock,__FILE__,__LINE__)
+#define _XUnlockMutex(lock)	if (_XUnlockMutex_fn) (*_XUnlockMutex_fn)(lock,__FILE__,__LINE__)
+#else
+/* used everywhere, so must be fast if not using threads */
+#define LockDisplay(d)	     if ((d)-&gt;lock_fns) (*(d)-&gt;lock_fns-&gt;lock_display)(d)
+#define UnlockDisplay(d)     if ((d)-&gt;lock_fns) (*(d)-&gt;lock_fns-&gt;unlock_display)(d)
+#define _XLockMutex(lock)		if (_XLockMutex_fn) (*_XLockMutex_fn)(lock)
+#define _XUnlockMutex(lock)	if (_XUnlockMutex_fn) (*_XUnlockMutex_fn)(lock)
+#endif
+#define _XCreateMutex(lock)	if (_XCreateMutex_fn) (*_XCreateMutex_fn)(lock);
+#define _XFreeMutex(lock)	if (_XFreeMutex_fn) (*_XFreeMutex_fn)(lock);
+
+#else /* XTHREADS */
+#define LockDisplay(dis)
+#define _XLockMutex(lock)
+#define _XUnlockMutex(lock)
+#define UnlockDisplay(dis)
+#define _XCreateMutex(lock)
+#define _XFreeMutex(lock)
+#endif
+
+#define Xfree(ptr) free((ptr))
+
+/*
+ * Note that some machines do not return a valid pointer for malloc(0), in
+ * which case we provide an alternate under the control of the
+ * define MALLOC_0_RETURNS_NULL.  This is necessary because some
+ * Xlib code expects malloc(0) to return a valid pointer to storage.
+ */
+#ifdef MALLOC_0_RETURNS_NULL
+
+# define Xmalloc(size) malloc(((size) == 0 ? 1 : (size)))
+# define Xrealloc(ptr, size) realloc((ptr), ((size) == 0 ? 1 : (size)))
+# define Xcalloc(nelem, elsize) calloc(((nelem) == 0 ? 1 : (nelem)), (elsize))
+
+#else
+
+# define Xmalloc(size) malloc((size))
+# define Xrealloc(ptr, size) realloc((ptr), (size))
+# define Xcalloc(nelem, elsize) calloc((nelem), (elsize))
+
+#endif
+
+#include &lt;stddef.h&gt;
+
+#define LOCKED 1
+#define UNLOCKED 0
+
+#ifdef NX_TRANS_SOCKET
+#ifndef BUFSIZE                         /* Output buffer size is configurable  */
+#define BUFSIZE 8192                    /* but this is still used for reading. */
+#endif
+#else
+#ifndef BUFSIZE
+#define BUFSIZE 2048			/* X output buffer size. */
+#endif
+#endif
+#ifndef PTSPERBATCH
+#define PTSPERBATCH 1024		/* point batching */
+#endif
+#ifndef WLNSPERBATCH
+#define WLNSPERBATCH 50			/* wide line batching */
+#endif
+#ifndef ZLNSPERBATCH
+#define ZLNSPERBATCH 1024		/* thin line batching */
+#endif
+#ifndef WRCTSPERBATCH
+#define WRCTSPERBATCH 10		/* wide line rectangle batching */
+#endif
+#ifndef ZRCTSPERBATCH
+#define ZRCTSPERBATCH 256		/* thin line rectangle batching */
+#endif
+#ifndef FRCTSPERBATCH
+#define FRCTSPERBATCH 256		/* filled rectangle batching */
+#endif
+#ifndef FARCSPERBATCH
+#define FARCSPERBATCH 256		/* filled arc batching */
+#endif
+#ifndef CURSORFONT
+#define CURSORFONT &quot;cursor&quot;		/* standard cursor fonts */
+#endif
+
+/*
+ * Display flags
+ */
+#define XlibDisplayIOError	(1L &lt;&lt; 0)
+#define XlibDisplayClosing	(1L &lt;&lt; 1)
+#define XlibDisplayNoXkb	(1L &lt;&lt; 2)
+#define XlibDisplayPrivSync	(1L &lt;&lt; 3)
+#define XlibDisplayProcConni	(1L &lt;&lt; 4) /* in _XProcessInternalConnection */
+#define XlibDisplayReadEvents	(1L &lt;&lt; 5) /* in _XReadEvents */
+#define XlibDisplayReply	(1L &lt;&lt; 5) /* in _XReply */
+#define XlibDisplayWriting	(1L &lt;&lt; 6) /* in _XFlushInt, _XSend */
+#define XlibDisplayDfltRMDB     (1L &lt;&lt; 7) /* mark if RM db from XGetDefault */
+
+/*
+ * X Protocol packetizing macros.
+ */
+
+/*   Need to start requests on 64 bit word boundaries
+ *   on a CRAY computer so add a NoOp (127) if needed.
+ *   A character pointer on a CRAY computer will be non-zero
+ *   after shifting right 61 bits of it is not pointing to
+ *   a word boundary.
+ */
+#ifdef WORD64
+#define WORD64ALIGN if ((long)dpy-&gt;bufptr &gt;&gt; 61) {\
+           dpy-&gt;last_req = dpy-&gt;bufptr;\
+           *(dpy-&gt;bufptr)   = X_NoOperation;\
+           *(dpy-&gt;bufptr+1) =  0;\
+           *(dpy-&gt;bufptr+2) =  0;\
+           *(dpy-&gt;bufptr+3) =  1;\
+             dpy-&gt;request++;\
+             dpy-&gt;bufptr += 4;\
+         }
+#else /* else does not require alignment on 64-bit boundaries */
+#define WORD64ALIGN
+#endif /* WORD64 */
+
+
+/*
+ * GetReq - Get the next available X request packet in the buffer and
+ * return it. 
+ *
+ * &quot;name&quot; is the name of the request, e.g. CreatePixmap, OpenFont, etc.
+ * &quot;req&quot; is the name of the request pointer.
+ *
+ */
+
+#if !defined(UNIXCPP) || defined(ANSICPP)
+#define GetReq(name, req) \
+        WORD64ALIGN\
+	if ((dpy-&gt;bufptr + SIZEOF(x##name##Req)) &gt; dpy-&gt;bufmax)\
+		_XFlush(dpy);\
+	req = (x##name##Req *)(dpy-&gt;last_req = dpy-&gt;bufptr);\
+	req-&gt;reqType = X_##name;\
+	req-&gt;length = (SIZEOF(x##name##Req))&gt;&gt;2;\
+	dpy-&gt;bufptr += SIZEOF(x##name##Req);\
+	dpy-&gt;request++
+
+#else  /* non-ANSI C uses empty comment instead of &quot;##&quot; for token concatenation */
+#define GetReq(name, req) \
+        WORD64ALIGN\
+	if ((dpy-&gt;bufptr + SIZEOF(x/**/name/**/Req)) &gt; dpy-&gt;bufmax)\
+		_XFlush(dpy);\
+	req = (x/**/name/**/Req *)(dpy-&gt;last_req = dpy-&gt;bufptr);\
+	req-&gt;reqType = X_/**/name;\
+	req-&gt;length = (SIZEOF(x/**/name/**/Req))&gt;&gt;2;\
+	dpy-&gt;bufptr += SIZEOF(x/**/name/**/Req);\
+	dpy-&gt;request++
+#endif
+
+/* GetReqExtra is the same as GetReq, but allocates &quot;n&quot; additional
+   bytes after the request. &quot;n&quot; must be a multiple of 4!  */
+
+#if !defined(UNIXCPP) || defined(ANSICPP)
+#define GetReqExtra(name, n, req) \
+        WORD64ALIGN\
+	if ((dpy-&gt;bufptr + SIZEOF(x##name##Req) + n) &gt; dpy-&gt;bufmax)\
+		_XFlush(dpy);\
+	req = (x##name##Req *)(dpy-&gt;last_req = dpy-&gt;bufptr);\
+	req-&gt;reqType = X_##name;\
+	req-&gt;length = (SIZEOF(x##name##Req) + n)&gt;&gt;2;\
+	dpy-&gt;bufptr += SIZEOF(x##name##Req) + n;\
+	dpy-&gt;request++
+#else
+#define GetReqExtra(name, n, req) \
+        WORD64ALIGN\
+	if ((dpy-&gt;bufptr + SIZEOF(x/**/name/**/Req) + n) &gt; dpy-&gt;bufmax)\
+		_XFlush(dpy);\
+	req = (x/**/name/**/Req *)(dpy-&gt;last_req = dpy-&gt;bufptr);\
+	req-&gt;reqType = X_/**/name;\
+	req-&gt;length = (SIZEOF(x/**/name/**/Req) + n)&gt;&gt;2;\
+	dpy-&gt;bufptr += SIZEOF(x/**/name/**/Req) + n;\
+	dpy-&gt;request++
+#endif
+
+
+/*
+ * GetResReq is for those requests that have a resource ID 
+ * (Window, Pixmap, GContext, etc.) as their single argument.
+ * &quot;rid&quot; is the name of the resource. 
+ */
+
+#if !defined(UNIXCPP) || defined(ANSICPP)
+#define GetResReq(name, rid, req) \
+        WORD64ALIGN\
+	if ((dpy-&gt;bufptr + SIZEOF(xResourceReq)) &gt; dpy-&gt;bufmax)\
+	    _XFlush(dpy);\
+	req = (xResourceReq *) (dpy-&gt;last_req = dpy-&gt;bufptr);\
+	req-&gt;reqType = X_##name;\
+	req-&gt;length = 2;\
+	req-&gt;id = (rid);\
+	dpy-&gt;bufptr += SIZEOF(xResourceReq);\
+	dpy-&gt;request++
+#else
+#define GetResReq(name, rid, req) \
+        WORD64ALIGN\
+	if ((dpy-&gt;bufptr + SIZEOF(xResourceReq)) &gt; dpy-&gt;bufmax)\
+	    _XFlush(dpy);\
+	req = (xResourceReq *) (dpy-&gt;last_req = dpy-&gt;bufptr);\
+	req-&gt;reqType = X_/**/name;\
+	req-&gt;length = 2;\
+	req-&gt;id = (rid);\
+	dpy-&gt;bufptr += SIZEOF(xResourceReq);\
+	dpy-&gt;request++
+#endif
+
+/*
+ * GetEmptyReq is for those requests that have no arguments
+ * at all. 
+ */
+#if !defined(UNIXCPP) || defined(ANSICPP)
+#define GetEmptyReq(name, req) \
+        WORD64ALIGN\
+	if ((dpy-&gt;bufptr + SIZEOF(xReq)) &gt; dpy-&gt;bufmax)\
+	    _XFlush(dpy);\
+	req = (xReq *) (dpy-&gt;last_req = dpy-&gt;bufptr);\
+	req-&gt;reqType = X_##name;\
+	req-&gt;length = 1;\
+	dpy-&gt;bufptr += SIZEOF(xReq);\
+	dpy-&gt;request++
+#else
+#define GetEmptyReq(name, req) \
+        WORD64ALIGN\
+	if ((dpy-&gt;bufptr + SIZEOF(xReq)) &gt; dpy-&gt;bufmax)\
+	    _XFlush(dpy);\
+	req = (xReq *) (dpy-&gt;last_req = dpy-&gt;bufptr);\
+	req-&gt;reqType = X_/**/name;\
+	req-&gt;length = 1;\
+	dpy-&gt;bufptr += SIZEOF(xReq);\
+	dpy-&gt;request++
+#endif
+
+#ifdef WORD64
+#define MakeBigReq(req,n) \
+    { \
+    char _BRdat[4]; \
+    unsigned long _BRlen = req-&gt;length - 1; \
+    req-&gt;length = 0; \
+    memcpy(_BRdat, ((char *)req) + (_BRlen &lt;&lt; 2), 4); \
+    memmove(((char *)req) + 8, ((char *)req) + 4, _BRlen &lt;&lt; 2); \
+    memcpy(((char *)req) + 4, _BRdat, 4); \
+    Data32(dpy, (long *)&amp;_BRdat, 4); \
+    }
+#else
+#ifdef LONG64
+#define MakeBigReq(req,n) \
+    { \
+    CARD64 _BRdat; \
+    CARD32 _BRlen = req-&gt;length - 1; \
+    req-&gt;length = 0; \
+    _BRdat = ((CARD32 *)req)[_BRlen]; \
+    memmove(((char *)req) + 8, ((char *)req) + 4, _BRlen &lt;&lt; 2); \
+    ((CARD32 *)req)[1] = _BRlen + n + 2; \
+    Data32(dpy, &amp;_BRdat, 4); \
+    }
+#else
+#define MakeBigReq(req,n) \
+    { \
+    CARD32 _BRdat; \
+    CARD32 _BRlen = req-&gt;length - 1; \
+    req-&gt;length = 0; \
+    _BRdat = ((CARD32 *)req)[_BRlen]; \
+    memmove(((char *)req) + 8, ((char *)req) + 4, _BRlen &lt;&lt; 2); \
+    ((CARD32 *)req)[1] = _BRlen + n + 2; \
+    Data32(dpy, &amp;_BRdat, 4); \
+    }
+#endif
+#endif
+
+#define SetReqLen(req,n,badlen) \
+    if ((req-&gt;length + n) &gt; (unsigned)65535) { \
+	if (dpy-&gt;bigreq_size) { \
+	    MakeBigReq(req,n) \
+	} else { \
+	    n = badlen; \
+	    req-&gt;length += n; \
+	} \
+    } else \
+	req-&gt;length += n
+
+#define SyncHandle() \
+	if (dpy-&gt;synchandler) (*dpy-&gt;synchandler)(dpy)
+
+extern void _XFlushGCCache(Display *dpy, GC gc);
+#define FlushGC(dpy, gc) \
+	if ((gc)-&gt;dirty) _XFlushGCCache((dpy), (gc))
+/*
+ * Data - Place data in the buffer and pad the end to provide
+ * 32 bit word alignment.  Transmit if the buffer fills.
+ *
+ * &quot;dpy&quot; is a pointer to a Display.
+ * &quot;data&quot; is a pinter to a data buffer.
+ * &quot;len&quot; is the length of the data buffer.
+ */
+#ifndef DataRoutineIsProcedure
+#define Data(dpy, data, len) {\
+	if (dpy-&gt;bufptr + (len) &lt;= dpy-&gt;bufmax) {\
+		memcpy(dpy-&gt;bufptr, data, (int)len);\
+		dpy-&gt;bufptr += ((len) + 3) &amp; ~3;\
+	} else\
+		_XSend(dpy, data, len);\
+	}
+#endif /* DataRoutineIsProcedure */
+
+
+/* Allocate bytes from the buffer.  No padding is done, so if
+ * the length is not a multiple of 4, the caller must be
+ * careful to leave the buffer aligned after sending the
+ * current request.
+ *
+ * &quot;type&quot; is the type of the pointer being assigned to.
+ * &quot;ptr&quot; is the pointer being assigned to.
+ * &quot;n&quot; is the number of bytes to allocate.
+ *
+ * Example: 
+ *    xTextElt *elt;
+ *    BufAlloc (xTextElt *, elt, nbytes)
+ */
+
+#define BufAlloc(type, ptr, n) \
+    if (dpy-&gt;bufptr + (n) &gt; dpy-&gt;bufmax) \
+        _XFlush (dpy); \
+    ptr = (type) dpy-&gt;bufptr; \
+    (void)ptr; \
+    dpy-&gt;bufptr += (n);
+
+#ifdef WORD64
+#define Data16(dpy, data, len) _XData16(dpy, (short *)data, len)
+#define Data32(dpy, data, len) _XData32(dpy, (long *)data, len)
+#else
+#define Data16(dpy, data, len) Data((dpy), (char *)(data), (len))
+#define _XRead16Pad(dpy, data, len) _XReadPad((dpy), (char *)(data), (len))
+#define _XRead16(dpy, data, len) _XRead((dpy), (char *)(data), (len))
+#ifdef LONG64
+#define Data32(dpy, data, len) _XData32(dpy, (long *)data, len)
+extern int _XData32(
+	     Display *dpy,
+	     register long *data,
+	     unsigned len
+);
+extern void _XRead32(
+	     Display *dpy,
+	     register long *data,
+	     long len
+);
+#else
+#define Data32(dpy, data, len) Data((dpy), (char *)(data), (len))
+#define _XRead32(dpy, data, len) _XRead((dpy), (char *)(data), (len))
+#endif
+#endif /* not WORD64 */
+
+#define PackData16(dpy,data,len) Data16 (dpy, data, len)
+#define PackData32(dpy,data,len) Data32 (dpy, data, len)
+
+/* Xlib manual is bogus */
+#define PackData(dpy,data,len) PackData16 (dpy, data, len)
+
+#define min(a,b) (((a) &lt; (b)) ? (a) : (b))
+#define max(a,b) (((a) &gt; (b)) ? (a) : (b))
+
+#define CI_NONEXISTCHAR(cs) (((cs)-&gt;width == 0) &amp;&amp; \
+			     (((cs)-&gt;rbearing|(cs)-&gt;lbearing| \
+			       (cs)-&gt;ascent|(cs)-&gt;descent) == 0))
+
+/* 
+ * CI_GET_CHAR_INFO_1D - return the charinfo struct for the indicated 8bit
+ * character.  If the character is in the column and exists, then return the
+ * appropriate metrics (note that fonts with common per-character metrics will
+ * return min_bounds).  If none of these hold true, try again with the default
+ * char.
+ */
+#define CI_GET_CHAR_INFO_1D(fs,col,def,cs) \
+{ \
+    cs = def; \
+    if (col &gt;= fs-&gt;min_char_or_byte2 &amp;&amp; col &lt;= fs-&gt;max_char_or_byte2) { \
+	if (fs-&gt;per_char == NULL) { \
+	    cs = &amp;fs-&gt;min_bounds; \
+	} else { \
+	    cs = &amp;fs-&gt;per_char[(col - fs-&gt;min_char_or_byte2)]; \
+	    if (CI_NONEXISTCHAR(cs)) cs = def; \
+	} \
+    } \
+}
+
+#define CI_GET_DEFAULT_INFO_1D(fs,cs) \
+  CI_GET_CHAR_INFO_1D (fs, fs-&gt;default_char, NULL, cs)
+
+
+
+/*
+ * CI_GET_CHAR_INFO_2D - return the charinfo struct for the indicated row and 
+ * column.  This is used for fonts that have more than row zero.
+ */
+#define CI_GET_CHAR_INFO_2D(fs,row,col,def,cs) \
+{ \
+    cs = def; \
+    if (row &gt;= fs-&gt;min_byte1 &amp;&amp; row &lt;= fs-&gt;max_byte1 &amp;&amp; \
+	col &gt;= fs-&gt;min_char_or_byte2 &amp;&amp; col &lt;= fs-&gt;max_char_or_byte2) { \
+	if (fs-&gt;per_char == NULL) { \
+	    cs = &amp;fs-&gt;min_bounds; \
+	} else { \
+	    cs = &amp;fs-&gt;per_char[((row - fs-&gt;min_byte1) * \
+			        (fs-&gt;max_char_or_byte2 - \
+				 fs-&gt;min_char_or_byte2 + 1)) + \
+			       (col - fs-&gt;min_char_or_byte2)]; \
+	    if (CI_NONEXISTCHAR(cs)) cs = def; \
+        } \
+    } \
+}
+
+#define CI_GET_DEFAULT_INFO_2D(fs,cs) \
+{ \
+    unsigned int r = (fs-&gt;default_char &gt;&gt; 8); \
+    unsigned int c = (fs-&gt;default_char &amp; 0xff); \
+    CI_GET_CHAR_INFO_2D (fs, r, c, NULL, cs); \
+}
+
+
+#ifdef MUSTCOPY
+
+/* for when 32-bit alignment is not good enough */
+#define OneDataCard32(dpy,dstaddr,srcvar) \
+  { dpy-&gt;bufptr -= 4; Data32 (dpy, (char *) &amp;(srcvar), 4); }
+
+#else
+
+/* srcvar must be a variable for large architecture version */
+#define OneDataCard32(dpy,dstaddr,srcvar) \
+  { *(CARD32 *)(dstaddr) = (srcvar); }
+
+#endif /* MUSTCOPY */
+
+typedef struct _XInternalAsync {
+    struct _XInternalAsync *next;
+    /*
+     * handler arguments:
+     * rep is the generic reply that caused this handler
+     * to be invoked.  It must also be passed to _XGetAsyncReply.
+     * buf and len are opaque values that must be passed to
+     * _XGetAsyncReply or _XGetAsyncData.
+     * data is the closure stored in this struct.
+     * The handler returns True iff it handled this reply.
+     */
+    Bool (*handler)(
+		    Display*	/* dpy */,
+		    xReply*	/* rep */,
+		    char*	/* buf */,
+		    int		/* len */,
+		    XPointer	/* data */
+		    );
+    XPointer data;
+} _XAsyncHandler;
+
+typedef struct _XAsyncEState {
+    unsigned long min_sequence_number;
+    unsigned long max_sequence_number;
+    unsigned char error_code;
+    unsigned char major_opcode;
+    unsigned short minor_opcode;
+    unsigned char last_error_received;
+    int error_count;
+} _XAsyncErrorState;
+
+extern void _XDeqAsyncHandler(Display *dpy, _XAsyncHandler *handler);
+#define DeqAsyncHandler(dpy,handler) { \
+    if (dpy-&gt;async_handlers == (handler)) \
+	dpy-&gt;async_handlers = (handler)-&gt;next; \
+    else \
+	_XDeqAsyncHandler(dpy, handler); \
+    }
+
+typedef void (*FreeFuncType) (
+    Display*	/* display */
+);
+
+typedef int (*FreeModmapType) (
+    XModifierKeymap*	/* modmap */
+);
+
+/*
+ * This structure is private to the library.
+ */
+typedef struct _XFreeFuncs {
+    FreeFuncType atoms;		/* _XFreeAtomTable */
+    FreeModmapType modifiermap;	/* XFreeModifierMap */
+    FreeFuncType key_bindings;	/* _XFreeKeyBindings */
+    FreeFuncType context_db;	/* _XFreeContextDB */
+    FreeFuncType defaultCCCs;	/* _XcmsFreeDefaultCCCs */
+    FreeFuncType clientCmaps;	/* _XcmsFreeClientCmaps */
+    FreeFuncType intensityMaps;	/* _XcmsFreeIntensityMaps */
+    FreeFuncType im_filters;	/* _XFreeIMFilters */
+    FreeFuncType xkb;		/* _XkbFreeInfo */
+} _XFreeFuncRec;
+
+/* types for InitExt.c */
+typedef int (*CreateGCType) (
+    Display*	/* display */,
+    GC		/* gc */,
+    XExtCodes*	/* codes */
+);
+
+typedef int (*CopyGCType)(
+    Display*	/* display */,
+    GC		/* gc */,
+    XExtCodes*	/* codes */
+);
+
+typedef int (*FlushGCType) (
+    Display*	/* display */,
+    GC		/* gc */,
+    XExtCodes*	/* codes */
+);
+
+typedef int (*FreeGCType) (
+    Display*	/* display */,
+    GC		/* gc */,
+    XExtCodes*	/* codes */
+);
+
+typedef int (*CreateFontType) (
+    Display*	/* display */,
+    XFontStruct* /* fs */,
+    XExtCodes*	/* codes */
+);
+
+typedef int (*FreeFontType) (
+    Display*	/* display */,
+    XFontStruct* /* fs */,
+    XExtCodes*	/* codes */
+);
+
+typedef int (*CloseDisplayType) (
+    Display*	/* display */,
+    XExtCodes*	/* codes */
+);
+
+typedef int (*ErrorType) (
+    Display*	/* display */,
+    xError*	/* err */,
+    XExtCodes*	/* codes */,
+    int*	/* ret_code */
+);
+
+typedef char* (*ErrorStringType) (
+    Display*	/* display */,
+    int		/* code */,
+    XExtCodes*	/* codes */,
+    char*	/* buffer */,
+    int		/* nbytes */
+);
+
+typedef void (*PrintErrorType)(
+    Display*	/* display */,
+    XErrorEvent* /* ev */,
+    void*	/* fp */
+);
+
+typedef void (*BeforeFlushType)(
+    Display*	/* display */,
+    XExtCodes*	/* codes */,
+    _Xconst char* /* data */,
+    long	/* len */
+);
+
+/*
+ * This structure is private to the library.
+ */
+typedef struct _XExten {		/* private to extension mechanism */
+	struct _XExten *next;		/* next in list */
+	XExtCodes codes;		/* public information, all extension told */
+	CreateGCType create_GC;		/* routine to call when GC created */
+	CopyGCType copy_GC;		/* routine to call when GC copied */
+	FlushGCType flush_GC;		/* routine to call when GC flushed */
+	FreeGCType free_GC;		/* routine to call when GC freed */
+	CreateFontType create_Font;	/* routine to call when Font created */
+	FreeFontType free_Font;		/* routine to call when Font freed */
+	CloseDisplayType close_display;	/* routine to call when connection closed */
+	ErrorType error;		/* who to call when an error occurs */
+	ErrorStringType error_string;	/* routine to supply error string */
+	char *name;			/* name of this extension */
+	PrintErrorType error_values;	/* routine to supply error values */
+	BeforeFlushType before_flush;	/* routine to call when sending data */
+	struct _XExten *next_flush;	/* next in list of those with flushes */
+} _XExtension;
+
+/* extension hooks */
+
+#ifdef DataRoutineIsProcedure
+extern void Data(Display *dpy, char *data, long len);
+#endif
+extern int _XError(
+    Display*	/* dpy */,
+    xError*	/* rep */
+);
+extern int _XIOError(
+    Display*	/* dpy */
+);
+extern int (*_XIOErrorFunction)(
+    Display*	/* dpy */
+);
+extern int (*_XErrorFunction)(
+    Display*		/* dpy */,
+    XErrorEvent*	/* error_event */
+);
+extern void _XEatData(
+    Display*		/* dpy */,
+    unsigned long	/* n */
+);
+extern char *_XAllocScratch(
+    Display*		/* dpy */,
+    unsigned long	/* nbytes */
+);
+extern char *_XAllocTemp(
+    Display*		/* dpy */,
+    unsigned long	/* nbytes */
+);
+extern void _XFreeTemp(
+    Display*		/* dpy */,
+    char*		/* buf */,
+    unsigned long	/* nbytes */
+);
+extern Visual *_XVIDtoVisual(
+    Display*	/* dpy */,
+    VisualID	/* id */
+);
+extern unsigned long _XSetLastRequestRead(
+    Display*		/* dpy */,
+    xGenericReply*	/* rep */
+);
+extern int _XGetHostname(
+    char*	/* buf */,
+    int		/* maxlen */
+);
+extern Screen *_XScreenOfWindow(
+    Display*	/* dpy */,
+    Window	/* w */
+);
+extern Bool _XAsyncErrorHandler(
+    Display*	/* dpy */,
+    xReply*	/* rep */,
+    char*	/* buf */,
+    int		/* len */,
+    XPointer	/* data */
+);
+extern char *_XGetAsyncReply(
+    Display*	/* dpy */,
+    char*	/* replbuf */,
+    xReply*	/* rep */,
+    char*	/* buf */,
+    int		/* len */,
+    int		/* extra */,
+    Bool	/* discard */
+);
+extern void _XGetAsyncData(
+    Display*	/* dpy */,
+    char *	/* data */,
+    char *	/* buf */,
+    int		/* len */,
+    int		/* skip */,
+    int		/* datalen */,
+    int		/* discardtotal */
+);
+extern void _XFlush(
+    Display*	/* dpy */
+);
+extern int _XEventsQueued(
+    Display*	/* dpy */,
+    int 	/* mode */
+);
+extern void _XReadEvents(
+    Display*	/* dpy */
+);
+extern int _XRead(
+    Display*	/* dpy */,
+    char*	/* data */,
+    long	/* size */
+);
+extern void _XReadPad(
+    Display*	/* dpy */,
+    char*	/* data */,
+    long	/* size */
+);
+extern void _XSend(
+    Display*		/* dpy */,
+    _Xconst char*	/* data */,
+    long		/* size */
+);
+extern Status _XReply(
+    Display*	/* dpy */,
+    xReply*	/* rep */,
+    int		/* extra */,
+    Bool	/* discard */
+);
+extern void _XEnq(
+    Display*	/* dpy */,
+    xEvent*	/* event */
+);
+extern void _XDeq(
+    Display*	/* dpy */,
+    _XQEvent*	/* prev */,
+    _XQEvent*	/* qelt */
+);
+
+extern Bool _XUnknownWireEvent(
+    Display*	/* dpy */,
+    XEvent*	/* re */,
+    xEvent*	/* event */
+);
+extern Status _XUnknownNativeEvent(
+    Display*	/* dpy */,
+    XEvent*	/* re */,
+    xEvent*	/* event */
+);
+
+extern Bool _XWireToEvent(Display *dpy, XEvent *re, xEvent *event);
+extern Bool _XDefaultWireError(Display *display, XErrorEvent *he, xError *we);
+extern Bool _XPollfdCacheInit(Display *dpy);
+extern void _XPollfdCacheAdd(Display *dpy, int fd);
+extern void _XPollfdCacheDel(Display *dpy, int fd);
+extern XID _XAllocID(Display *dpy);
+extern void _XAllocIDs(Display *dpy, XID *ids, int count);
+
+extern int _XFreeExtData(
+    XExtData*	/* extension */
+);
+
+extern int (*XESetCreateGC(
+    Display*		/* display */,
+    int			/* extension */,
+    int (*) (
+	      Display*			/* display */,
+	      GC			/* gc */,
+	      XExtCodes*		/* codes */
+	    )		/* proc */
+))(
+    Display*, GC, XExtCodes*
+);
+
+extern int (*XESetCopyGC(
+    Display*		/* display */,
+    int			/* extension */,
+    int (*) (
+	      Display*			/* display */,
+              GC			/* gc */,
+              XExtCodes*		/* codes */
+            )		/* proc */	      
+))(
+    Display*, GC, XExtCodes*
+);
+
+extern int (*XESetFlushGC(
+    Display*		/* display */,
+    int			/* extension */,
+    int (*) (
+	      Display*			/* display */,
+              GC			/* gc */,
+              XExtCodes*		/* codes */
+            )		/* proc */	     
+))(
+    Display*, GC, XExtCodes*
+);
+
+extern int (*XESetFreeGC(
+    Display*		/* display */,
+    int			/* extension */,
+    int (*) (
+	      Display*			/* display */,
+              GC			/* gc */,
+              XExtCodes*		/* codes */
+            )		/* proc */	     
+))(
+    Display*, GC, XExtCodes*
+);
+
+extern int (*XESetCreateFont(
+    Display*		/* display */,
+    int			/* extension */,
+    int (*) (
+	      Display*			/* display */,
+              XFontStruct*		/* fs */,
+              XExtCodes*		/* codes */
+            )		/* proc */    
+))(
+    Display*, XFontStruct*, XExtCodes*
+);
+
+extern int (*XESetFreeFont(
+    Display*		/* display */,
+    int			/* extension */,
+    int (*) (
+	      Display*			/* display */,
+              XFontStruct*		/* fs */,
+              XExtCodes*		/* codes */
+            )		/* proc */    
+))(
+    Display*, XFontStruct*, XExtCodes*
+); 
+
+extern int (*XESetCloseDisplay(
+    Display*		/* display */,
+    int			/* extension */,
+    int (*) (
+	      Display*			/* display */,
+              XExtCodes*		/* codes */
+            )		/* proc */    
+))(
+    Display*, XExtCodes*
+);
+
+extern int (*XESetError(
+    Display*		/* display */,
+    int			/* extension */,
+    int (*) (
+	      Display*			/* display */,
+              xError*			/* err */,
+              XExtCodes*		/* codes */,
+              int*			/* ret_code */
+            )		/* proc */    
+))(
+    Display*, xError*, XExtCodes*, int*
+);
+
+extern char* (*XESetErrorString(
+    Display*		/* display */,
+    int			/* extension */,
+    char* (*) (
+	        Display*		/* display */,
+                int			/* code */,
+                XExtCodes*		/* codes */,
+                char*			/* buffer */,
+                int			/* nbytes */
+              )		/* proc */	       
+))(
+    Display*, int, XExtCodes*, char*, int
+);
+
+extern void (*XESetPrintErrorValues (
+    Display*		/* display */,
+    int			/* extension */,
+    void (*)(
+	      Display*			/* display */,
+	      XErrorEvent*		/* ev */,
+	      void*			/* fp */
+	     )		/* proc */
+))(
+    Display*, XErrorEvent*, void*
+);
+
+extern Bool (*XESetWireToEvent(
+    Display*		/* display */,
+    int			/* event_number */,
+    Bool (*) (
+	       Display*			/* display */,
+               XEvent*			/* re */,
+               xEvent*			/* event */
+             )		/* proc */    
+))(
+    Display*, XEvent*, xEvent*
+);
+
+extern Status (*XESetEventToWire(
+    Display*		/* display */,
+    int			/* event_number */,
+    Status (*) (
+	      Display*			/* display */,
+              XEvent*			/* re */,
+              xEvent*			/* event */
+            )		/* proc */   
+))(
+    Display*, XEvent*, xEvent*
+);
+
+extern Bool (*XESetWireToError(
+    Display*		/* display */,
+    int			/* error_number */,
+    Bool (*) (
+	       Display*			/* display */,
+	       XErrorEvent*		/* he */,
+	       xError*			/* we */
+            )		/* proc */   
+))(
+    Display*, XErrorEvent*, xError*
+);
+
+extern void (*XESetBeforeFlush(
+    Display*		/* display */,
+    int			/* error_number */,
+    void (*) (
+	       Display*			/* display */,
+	       XExtCodes*		/* codes */,
+	       _Xconst char*		/* data */,
+	       long			/* len */
+            )		/* proc */   
+))(
+    Display*, XExtCodes*, _Xconst char*, long
+);
+
+/* internal connections for IMs */
+
+typedef void (*_XInternalConnectionProc)(
+    Display*			/* dpy */,
+    int				/* fd */,
+    XPointer			/* call_data */
+);
+
+
+extern Status _XRegisterInternalConnection(
+    Display*			/* dpy */,
+    int				/* fd */,
+    _XInternalConnectionProc	/* callback */,
+    XPointer			/* call_data */
+);
+
+extern void _XUnregisterInternalConnection(
+    Display*			/* dpy */,
+    int				/* fd */
+);
+
+/* Display structure has pointers to these */
+
+struct _XConnectionInfo {	/* info from _XRegisterInternalConnection */
+    int fd;
+    _XInternalConnectionProc read_callback;
+    XPointer call_data;
+    XPointer *watch_data;	/* set/used by XConnectionWatchProc */
+    struct _XConnectionInfo *next;
+};
+
+struct _XConnWatchInfo {	/* info from XAddConnectionWatch */
+    XConnectionWatchProc fn;
+    XPointer client_data;
+    struct _XConnWatchInfo *next;
+};
+
+#ifdef __UNIXOS2__
+extern char* __XOS2RedirRoot(
+    char*
+);
+#endif
+
+extern int _XTextHeight(
+    XFontStruct*	/* font_struct */,
+    _Xconst char*	/* string */,
+    int			/* count */
+);
+
+extern int _XTextHeight16(
+    XFontStruct*	/* font_struct */,
+    _Xconst XChar2b*	/* string */,
+    int			/* count */
+);
+
+#if defined(WIN32)
+
+extern int _XOpenFile(
+    _Xconst char*	/* path */,
+    int			/* flags */
+);
+
+extern void* _XFopenFile(
+    _Xconst char*	/* path */,
+    _Xconst char*	/* mode */
+);
+
+extern int _XAccessFile(
+    _Xconst char*	/* path */
+);
+#else
+#define _XOpenFile(path,flags) open(path,flags)
+#define _XFopenFile(path,mode) fopen(path,mode)
+#endif
+
+/* EvToWire.c */
+extern Status _XEventToWire(Display *dpy, XEvent *re, xEvent *event);
+
+extern int _XF86LoadQueryLocaleFont(
+    Display*		/* dpy */,
+    _Xconst char*	/* name*/,
+    XFontStruct**	/* xfp*/,
+    Font*		/* fidp */
+);
+
+extern void _XProcessWindowAttributes (
+    register Display *dpy,
+    xChangeWindowAttributesReq *req,
+    register unsigned long valuemask,
+    register XSetWindowAttributes *attributes);
+
+extern int _XDefaultError(
+        Display *dpy,
+        XErrorEvent *event);
+
+extern int _XDefaultIOError(
+        Display *dpy);
+
+extern void _XSetClipRectangles (
+    register Display *dpy,
+    GC gc,
+    int clip_x_origin, int clip_y_origin,
+    XRectangle *rectangles,
+    int n,
+    int ordering);
+
+Status _XGetWindowAttributes(
+    register Display *dpy,
+    Window w,
+    XWindowAttributes *attr);
+
+int _XPutBackEvent (
+    register Display *dpy, 
+    register XEvent *event);
+
+_XFUNCPROTOEND
+
+#endif /* _XLIBINT_H_ */
diff --git a/X11/Xutil.h b/X11/Xutil.h
new file mode 100644
index 0000000..82dab7d
--- /dev/null
+++ b/X11/Xutil.h
@@ -0,0 +1,827 @@
+/* $Xorg: Xutil.h,v 1.8 2001/02/09 02:03:39 xorgcvs Exp $ */
+
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $XFree86: xc/lib/X11/Xutil.h,v 3.6 2003/04/13 19:22:20 dawes Exp $ */
+
+#ifndef _XUTIL_H_
+#define _XUTIL_H_
+
+/* You must include &lt;X11/Xlib.h&gt; before including this file */
+#include &lt;X11/Xlib.h&gt;
+
+/* 
+ * Bitmask returned by XParseGeometry().  Each bit tells if the corresponding
+ * value (x, y, width, height) was found in the parsed string.
+ */
+#define NoValue		0x0000
+#define XValue  	0x0001
+#define YValue		0x0002
+#define WidthValue  	0x0004
+#define HeightValue  	0x0008
+#define AllValues 	0x000F
+#define XNegative 	0x0010
+#define YNegative 	0x0020
+
+/*
+ * new version containing base_width, base_height, and win_gravity fields;
+ * used with WM_NORMAL_HINTS.
+ */
+typedef struct {
+    	long flags;	/* marks which fields in this structure are defined */
+	int x, y;		/* obsolete for new window mgrs, but clients */
+	int width, height;	/* should set so old wm's don't mess up */
+	int min_width, min_height;
+	int max_width, max_height;
+    	int width_inc, height_inc;
+	struct {
+		int x;	/* numerator */
+		int y;	/* denominator */
+	} min_aspect, max_aspect;
+	int base_width, base_height;		/* added by ICCCM version 1 */
+	int win_gravity;			/* added by ICCCM version 1 */
+} XSizeHints;
+
+/*
+ * The next block of definitions are for window manager properties that
+ * clients and applications use for communication.
+ */
+
+/* flags argument in size hints */
+#define USPosition	(1L &lt;&lt; 0) /* user specified x, y */
+#define USSize		(1L &lt;&lt; 1) /* user specified width, height */
+
+#define PPosition	(1L &lt;&lt; 2) /* program specified position */
+#define PSize		(1L &lt;&lt; 3) /* program specified size */
+#define PMinSize	(1L &lt;&lt; 4) /* program specified minimum size */
+#define PMaxSize	(1L &lt;&lt; 5) /* program specified maximum size */
+#define PResizeInc	(1L &lt;&lt; 6) /* program specified resize increments */
+#define PAspect		(1L &lt;&lt; 7) /* program specified min and max aspect ratios */
+#define PBaseSize	(1L &lt;&lt; 8) /* program specified base for incrementing */
+#define PWinGravity	(1L &lt;&lt; 9) /* program specified window gravity */
+
+/* obsolete */
+#define PAllHints (PPosition|PSize|PMinSize|PMaxSize|PResizeInc|PAspect)
+
+
+
+typedef struct {
+	long flags;	/* marks which fields in this structure are defined */
+	Bool input;	/* does this application rely on the window manager to
+			get keyboard input? */
+	int initial_state;	/* see below */
+	Pixmap icon_pixmap;	/* pixmap to be used as icon */
+	Window icon_window; 	/* window to be used as icon */
+	int icon_x, icon_y; 	/* initial position of icon */
+	Pixmap icon_mask;	/* icon mask bitmap */
+	XID window_group;	/* id of related window group */
+	/* this structure may be extended in the future */
+} XWMHints;
+
+/* definition for flags of XWMHints */
+
+#define InputHint 		(1L &lt;&lt; 0)
+#define StateHint 		(1L &lt;&lt; 1)
+#define IconPixmapHint		(1L &lt;&lt; 2)
+#define IconWindowHint		(1L &lt;&lt; 3)
+#define IconPositionHint 	(1L &lt;&lt; 4)
+#define IconMaskHint		(1L &lt;&lt; 5)
+#define WindowGroupHint		(1L &lt;&lt; 6)
+#define AllHints (InputHint|StateHint|IconPixmapHint|IconWindowHint| \
+IconPositionHint|IconMaskHint|WindowGroupHint)
+#define XUrgencyHint		(1L &lt;&lt; 8)
+
+/* definitions for initial window state */
+#define WithdrawnState 0	/* for windows that are not mapped */
+#define NormalState 1	/* most applications want to start this way */
+#define IconicState 3	/* application wants to start as an icon */
+
+/*
+ * Obsolete states no longer defined by ICCCM
+ */
+#define DontCareState 0	/* don't know or care */
+#define ZoomState 2	/* application wants to start zoomed */
+#define InactiveState 4	/* application believes it is seldom used; */
+			/* some wm's may put it on inactive menu */
+
+
+/*
+ * new structure for manipulating TEXT properties; used with WM_NAME, 
+ * WM_ICON_NAME, WM_CLIENT_MACHINE, and WM_COMMAND.
+ */
+typedef struct {
+    unsigned char *value;		/* same as Property routines */
+    Atom encoding;			/* prop type */
+    int format;				/* prop data format: 8, 16, or 32 */
+    unsigned long nitems;		/* number of data items in value */
+} XTextProperty;
+
+#define XNoMemory -1
+#define XLocaleNotSupported -2
+#define XConverterNotFound -3
+
+typedef enum {
+    XStringStyle,		/* STRING */
+    XCompoundTextStyle,		/* COMPOUND_TEXT */
+    XTextStyle,			/* text in owner's encoding (current locale)*/
+    XStdICCTextStyle,		/* STRING, else COMPOUND_TEXT */
+    /* The following is an XFree86 extension, introduced in November 2000 */
+    XUTF8StringStyle		/* UTF8_STRING */
+} XICCEncodingStyle;
+
+typedef struct {
+	int min_width, min_height;
+	int max_width, max_height;
+	int width_inc, height_inc;
+} XIconSize;
+
+typedef struct {
+	char *res_name;
+	char *res_class;
+} XClassHint;
+
+#ifdef XUTIL_DEFINE_FUNCTIONS
+extern int XDestroyImage(
+        XImage *ximage);
+extern unsigned long XGetPixel(
+        XImage *ximage,
+        int x, int y);
+extern int XPutPixel(
+        XImage *ximage,
+        int x, int y,
+        unsigned long pixel);
+extern XImage *XSubImage(
+        XImage *ximage,
+        int x, int y,
+        unsigned int width, unsigned int height);
+extern int XAddPixel(
+        XImage *ximage,
+        long value);
+#else
+/*
+ * These macros are used to give some sugar to the image routines so that
+ * naive people are more comfortable with them.
+ */
+#define XDestroyImage(ximage) \
+	((*((ximage)-&gt;f.destroy_image))((ximage)))
+#define XGetPixel(ximage, x, y) \
+	((*((ximage)-&gt;f.get_pixel))((ximage), (x), (y)))
+#define XPutPixel(ximage, x, y, pixel) \
+	((*((ximage)-&gt;f.put_pixel))((ximage), (x), (y), (pixel)))
+#define XSubImage(ximage, x, y, width, height)  \
+	((*((ximage)-&gt;f.sub_image))((ximage), (x), (y), (width), (height)))
+#define XAddPixel(ximage, value) \
+	((*((ximage)-&gt;f.add_pixel))((ximage), (value)))
+#endif
+
+/*
+ * Compose sequence status structure, used in calling XLookupString.
+ */
+typedef struct _XComposeStatus {
+    XPointer compose_ptr;	/* state table pointer */
+    int chars_matched;		/* match state */
+} XComposeStatus;
+
+/*
+ * Keysym macros, used on Keysyms to test for classes of symbols
+ */
+#define IsKeypadKey(keysym) \
+  (((KeySym)(keysym) &gt;= XK_KP_Space) &amp;&amp; ((KeySym)(keysym) &lt;= XK_KP_Equal))
+
+#define IsPrivateKeypadKey(keysym) \
+  (((KeySym)(keysym) &gt;= 0x11000000) &amp;&amp; ((KeySym)(keysym) &lt;= 0x1100FFFF))
+
+#define IsCursorKey(keysym) \
+  (((KeySym)(keysym) &gt;= XK_Home)     &amp;&amp; ((KeySym)(keysym) &lt;  XK_Select))
+
+#define IsPFKey(keysym) \
+  (((KeySym)(keysym) &gt;= XK_KP_F1)     &amp;&amp; ((KeySym)(keysym) &lt;= XK_KP_F4))
+
+#define IsFunctionKey(keysym) \
+  (((KeySym)(keysym) &gt;= XK_F1)       &amp;&amp; ((KeySym)(keysym) &lt;= XK_F35))
+
+#define IsMiscFunctionKey(keysym) \
+  (((KeySym)(keysym) &gt;= XK_Select)   &amp;&amp; ((KeySym)(keysym) &lt;= XK_Break))
+
+#ifdef XK_XKB_KEYS
+#define IsModifierKey(keysym) \
+  ((((KeySym)(keysym) &gt;= XK_Shift_L) &amp;&amp; ((KeySym)(keysym) &lt;= XK_Hyper_R)) \
+   || (((KeySym)(keysym) &gt;= XK_ISO_Lock) &amp;&amp; \
+       ((KeySym)(keysym) &lt;= XK_ISO_Last_Group_Lock)) \
+   || ((KeySym)(keysym) == XK_Mode_switch) \
+   || ((KeySym)(keysym) == XK_Num_Lock))
+#else
+#define IsModifierKey(keysym) \
+  ((((KeySym)(keysym) &gt;= XK_Shift_L) &amp;&amp; ((KeySym)(keysym) &lt;= XK_Hyper_R)) \
+   || ((KeySym)(keysym) == XK_Mode_switch) \
+   || ((KeySym)(keysym) == XK_Num_Lock))
+#endif
+/*
+ * opaque reference to Region data type 
+ */
+typedef struct _XRegion *Region; 
+
+/* Return values from XRectInRegion() */
+ 
+#define RectangleOut 0
+#define RectangleIn  1
+#define RectanglePart 2
+ 
+
+/*
+ * Information used by the visual utility routines to find desired visual
+ * type from the many visuals a display may support.
+ */
+
+typedef struct {
+  Visual *visual;
+  VisualID visualid;
+  int screen;
+  int depth;
+#if defined(__cplusplus) || defined(c_plusplus)
+  int c_class;					/* C++ */
+#else
+  int class;
+#endif
+  unsigned long red_mask;
+  unsigned long green_mask;
+  unsigned long blue_mask;
+  int colormap_size;
+  int bits_per_rgb;
+} XVisualInfo;
+
+#define VisualNoMask		0x0
+#define VisualIDMask 		0x1
+#define VisualScreenMask	0x2
+#define VisualDepthMask		0x4
+#define VisualClassMask		0x8
+#define VisualRedMaskMask	0x10
+#define VisualGreenMaskMask	0x20
+#define VisualBlueMaskMask	0x40
+#define VisualColormapSizeMask	0x80
+#define VisualBitsPerRGBMask	0x100
+#define VisualAllMask		0x1FF
+
+/*
+ * This defines a window manager property that clients may use to
+ * share standard color maps of type RGB_COLOR_MAP:
+ */
+typedef struct {
+	Colormap colormap;
+	unsigned long red_max;
+	unsigned long red_mult;
+	unsigned long green_max;
+	unsigned long green_mult;
+	unsigned long blue_max;
+	unsigned long blue_mult;
+	unsigned long base_pixel;
+	VisualID visualid;		/* added by ICCCM version 1 */
+	XID killid;			/* added by ICCCM version 1 */
+} XStandardColormap;
+
+#define ReleaseByFreeingColormap ((XID) 1L)  /* for killid field above */
+
+
+/*
+ * return codes for XReadBitmapFile and XWriteBitmapFile
+ */
+#define BitmapSuccess		0
+#define BitmapOpenFailed 	1
+#define BitmapFileInvalid 	2
+#define BitmapNoMemory		3
+
+/****************************************************************
+ *
+ * Context Management
+ *
+ ****************************************************************/
+
+
+/* Associative lookup table return codes */
+
+#define XCSUCCESS 0	/* No error. */
+#define XCNOMEM   1    /* Out of memory */
+#define XCNOENT   2    /* No entry in table */
+
+typedef int XContext;
+
+#define XUniqueContext()       ((XContext) XrmUniqueQuark())
+#define XStringToContext(string)   ((XContext) XrmStringToQuark(string))
+
+_XFUNCPROTOBEGIN
+
+/* The following declarations are alphabetized. */
+
+extern XClassHint *XAllocClassHint (
+    void
+);
+
+extern XIconSize *XAllocIconSize (
+    void
+);
+
+extern XSizeHints *XAllocSizeHints (
+    void
+);
+
+extern XStandardColormap *XAllocStandardColormap (
+    void
+);
+
+extern XWMHints *XAllocWMHints (
+    void
+);
+
+extern int XClipBox(
+    Region		/* r */,
+    XRectangle*		/* rect_return */
+);
+
+extern Region XCreateRegion(
+    void
+);
+
+extern const char *XDefaultString (void);
+
+extern int XDeleteContext(
+    Display*		/* display */,
+    XID			/* rid */,
+    XContext		/* context */
+);
+
+extern int XDestroyRegion(
+    Region		/* r */
+);
+
+extern int XEmptyRegion(
+    Region		/* r */
+);
+
+extern int XEqualRegion(
+    Region		/* r1 */,
+    Region		/* r2 */
+);
+
+extern int XFindContext(
+    Display*		/* display */,
+    XID			/* rid */,
+    XContext		/* context */,
+    XPointer*		/* data_return */
+);
+
+extern Status XGetClassHint(
+    Display*		/* display */,
+    Window		/* w */,
+    XClassHint*		/* class_hints_return */
+);
+
+extern Status XGetIconSizes(
+    Display*		/* display */,
+    Window		/* w */,
+    XIconSize**		/* size_list_return */,
+    int*		/* count_return */
+);
+
+extern Status XGetNormalHints(
+    Display*		/* display */,
+    Window		/* w */,
+    XSizeHints*		/* hints_return */
+);
+
+extern Status XGetRGBColormaps(
+    Display*		/* display */,
+    Window		/* w */,
+    XStandardColormap** /* stdcmap_return */,
+    int*		/* count_return */,
+    Atom		/* property */
+);
+
+extern Status XGetSizeHints(
+    Display*		/* display */,
+    Window		/* w */,
+    XSizeHints*		/* hints_return */,
+    Atom		/* property */
+);
+
+extern Status XGetStandardColormap(
+    Display*		/* display */,
+    Window		/* w */,
+    XStandardColormap*	/* colormap_return */,
+    Atom		/* property */			    
+);
+
+extern Status XGetTextProperty(
+    Display*		/* display */,
+    Window		/* window */,
+    XTextProperty*	/* text_prop_return */,
+    Atom		/* property */
+);
+
+extern XVisualInfo *XGetVisualInfo(
+    Display*		/* display */,
+    long		/* vinfo_mask */,
+    XVisualInfo*	/* vinfo_template */,
+    int*		/* nitems_return */
+);
+
+extern Status XGetWMClientMachine(
+    Display*		/* display */,
+    Window		/* w */,
+    XTextProperty*	/* text_prop_return */
+);
+
+extern XWMHints *XGetWMHints(
+    Display*		/* display */,
+    Window		/* w */		      
+);
+
+extern Status XGetWMIconName(
+    Display*		/* display */,
+    Window		/* w */,
+    XTextProperty*	/* text_prop_return */
+);
+
+extern Status XGetWMName(
+    Display*		/* display */,
+    Window		/* w */,
+    XTextProperty*	/* text_prop_return */
+);
+
+extern Status XGetWMNormalHints(
+    Display*		/* display */,
+    Window		/* w */,
+    XSizeHints*		/* hints_return */,
+    long*		/* supplied_return */ 
+);
+
+extern Status XGetWMSizeHints(
+    Display*		/* display */,
+    Window		/* w */,
+    XSizeHints*		/* hints_return */,
+    long*		/* supplied_return */,
+    Atom		/* property */
+);
+
+extern Status XGetZoomHints(
+    Display*		/* display */,
+    Window		/* w */,
+    XSizeHints*		/* zhints_return */
+);
+
+extern int XIntersectRegion(
+    Region		/* sra */,
+    Region		/* srb */,
+    Region		/* dr_return */
+);
+
+extern void XConvertCase(
+    KeySym		/* sym */,
+    KeySym*		/* lower */,
+    KeySym*		/* upper */
+);
+
+extern int XLookupString(
+    XKeyEvent*		/* event_struct */,
+    char*		/* buffer_return */,
+    int			/* bytes_buffer */,
+    KeySym*		/* keysym_return */,
+    XComposeStatus*	/* status_in_out */
+);
+
+extern Status XMatchVisualInfo(
+    Display*		/* display */,
+    int			/* screen */,
+    int			/* depth */,
+    int			/* class */,
+    XVisualInfo*	/* vinfo_return */
+);
+
+extern int XOffsetRegion(
+    Region		/* r */,
+    int			/* dx */,
+    int			/* dy */
+);
+
+extern Bool XPointInRegion(
+    Region		/* r */,
+    int			/* x */,
+    int			/* y */
+);
+
+extern Region XPolygonRegion(
+    XPoint*		/* points */,
+    int			/* n */,
+    int			/* fill_rule */
+);
+
+extern int XRectInRegion(
+    Region		/* r */,
+    int			/* x */,
+    int			/* y */,
+    unsigned int	/* width */,
+    unsigned int	/* height */
+);
+
+extern int XSaveContext(
+    Display*		/* display */,
+    XID			/* rid */,
+    XContext		/* context */,
+    _Xconst char*	/* data */
+);
+
+extern int XSetClassHint(
+    Display*		/* display */,
+    Window		/* w */,
+    XClassHint*		/* class_hints */
+);
+
+extern int XSetIconSizes(
+    Display*		/* display */,
+    Window		/* w */,
+    XIconSize*		/* size_list */,
+    int			/* count */    
+);
+
+extern int XSetNormalHints(
+    Display*		/* display */,
+    Window		/* w */,
+    XSizeHints*		/* hints */
+);
+
+extern void XSetRGBColormaps(
+    Display*		/* display */,
+    Window		/* w */,
+    XStandardColormap*	/* stdcmaps */,
+    int			/* count */,
+    Atom		/* property */
+);
+
+extern int XSetSizeHints(
+    Display*		/* display */,
+    Window		/* w */,
+    XSizeHints*		/* hints */,
+    Atom		/* property */
+);
+
+extern int XSetStandardProperties(
+    Display*		/* display */,
+    Window		/* w */,
+    _Xconst char*	/* window_name */,
+    _Xconst char*	/* icon_name */,
+    Pixmap		/* icon_pixmap */,
+    char**		/* argv */,
+    int			/* argc */,
+    XSizeHints*		/* hints */
+);
+
+extern void XSetTextProperty(
+    Display*		/* display */,
+    Window		/* w */,
+    XTextProperty*	/* text_prop */,
+    Atom		/* property */
+);
+
+extern void XSetWMClientMachine(
+    Display*		/* display */,
+    Window		/* w */,
+    XTextProperty*	/* text_prop */
+);
+
+extern int XSetWMHints(
+    Display*		/* display */,
+    Window		/* w */,
+    XWMHints*		/* wm_hints */
+);
+
+extern void XSetWMIconName(
+    Display*		/* display */,
+    Window		/* w */,
+    XTextProperty*	/* text_prop */
+);
+
+extern void XSetWMName(
+    Display*		/* display */,
+    Window		/* w */,
+    XTextProperty*	/* text_prop */
+);
+
+extern void XSetWMNormalHints(
+    Display*		/* display */,
+    Window		/* w */,
+    XSizeHints*		/* hints */
+);
+
+extern void XSetWMProperties(
+    Display*		/* display */,
+    Window		/* w */,
+    XTextProperty*	/* window_name */,
+    XTextProperty*	/* icon_name */,
+    char**		/* argv */,
+    int			/* argc */,
+    XSizeHints*		/* normal_hints */,
+    XWMHints*		/* wm_hints */,
+    XClassHint*		/* class_hints */
+);
+
+extern void XmbSetWMProperties(
+    Display*		/* display */,
+    Window		/* w */,
+    _Xconst char*	/* window_name */,
+    _Xconst char*	/* icon_name */,
+    char**		/* argv */,
+    int			/* argc */,
+    XSizeHints*		/* normal_hints */,
+    XWMHints*		/* wm_hints */,
+    XClassHint*		/* class_hints */
+);
+
+extern void Xutf8SetWMProperties(
+    Display*		/* display */,
+    Window		/* w */,
+    _Xconst char*	/* window_name */,
+    _Xconst char*	/* icon_name */,
+    char**		/* argv */,
+    int			/* argc */,
+    XSizeHints*		/* normal_hints */,
+    XWMHints*		/* wm_hints */,
+    XClassHint*		/* class_hints */
+);
+
+extern void XSetWMSizeHints(
+    Display*		/* display */,
+    Window		/* w */,
+    XSizeHints*		/* hints */,
+    Atom		/* property */
+);
+
+extern int XSetRegion(
+    Display*		/* display */,
+    GC			/* gc */,
+    Region		/* r */
+);
+
+extern void XSetStandardColormap(
+    Display*		/* display */,
+    Window		/* w */,
+    XStandardColormap*	/* colormap */,
+    Atom		/* property */
+);
+
+extern int XSetZoomHints(
+    Display*		/* display */,
+    Window		/* w */,
+    XSizeHints*		/* zhints */
+);
+
+extern int XShrinkRegion(
+    Region		/* r */,
+    int			/* dx */,
+    int			/* dy */
+);
+
+extern Status XStringListToTextProperty(
+    char**		/* list */,
+    int			/* count */,
+    XTextProperty*	/* text_prop_return */
+);
+
+extern int XSubtractRegion(
+    Region		/* sra */,
+    Region		/* srb */,
+    Region		/* dr_return */
+);
+
+extern int XmbTextListToTextProperty(
+    Display*		display,
+    char**		list,
+    int			count,
+    XICCEncodingStyle	style,
+    XTextProperty*	text_prop_return
+);
+
+extern int XwcTextListToTextProperty(
+    Display*		display,
+    wchar_t**		list,
+    int			count,
+    XICCEncodingStyle	style,
+    XTextProperty*	text_prop_return
+);
+
+extern int Xutf8TextListToTextProperty(
+    Display*		display,
+    char**		list,
+    int			count,
+    XICCEncodingStyle	style,
+    XTextProperty*	text_prop_return
+);
+
+extern void XwcFreeStringList(
+    wchar_t**		list
+);
+
+extern Status XTextPropertyToStringList(
+    XTextProperty*	/* text_prop */,
+    char***		/* list_return */,
+    int*		/* count_return */
+);
+
+extern int XmbTextPropertyToTextList(
+    Display*		display,
+    const XTextProperty* text_prop,
+    char***		list_return,
+    int*		count_return
+);
+
+extern int XwcTextPropertyToTextList(
+    Display*		display,
+    const XTextProperty* text_prop,
+    wchar_t***		list_return,
+    int*		count_return
+);
+
+extern int Xutf8TextPropertyToTextList(
+    Display*		display,
+    const XTextProperty* text_prop,
+    char***		list_return,
+    int*		count_return
+);
+
+extern int XUnionRectWithRegion(
+    XRectangle*		/* rectangle */,
+    Region		/* src_region */,
+    Region		/* dest_region_return */
+);
+
+extern int XUnionRegion(
+    Region		/* sra */,
+    Region		/* srb */,
+    Region		/* dr_return */
+);
+
+extern int XWMGeometry(
+    Display*		/* display */,
+    int			/* screen_number */,
+    _Xconst char*	/* user_geometry */,
+    _Xconst char*	/* default_geometry */,
+    unsigned int	/* border_width */,
+    XSizeHints*		/* hints */,
+    int*		/* x_return */,
+    int*		/* y_return */,
+    int*		/* width_return */,
+    int*		/* height_return */,
+    int*		/* gravity_return */
+);
+
+extern int XXorRegion(
+    Region		/* sra */,
+    Region		/* srb */,
+    Region		/* dr_return */
+);
+
+_XFUNCPROTOEND
+
+#endif /* _XUTIL_H_ */
diff --git a/X11/bstore.h b/X11/bstore.h
new file mode 100644
index 0000000..098abcd
--- /dev/null
+++ b/X11/bstore.h
@@ -0,0 +1,23 @@
+/* $XFree86: xc/programs/Xserver/include/bstore.h,v 1.1 1998/04/05 16:44:25 robin Exp $*/
+/*
+ * Copyright (c) 1987 by the Regents of the University of California
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted, provided
+ * that the above copyright notice appear in all copies.  The University of
+ * California makes no representations about the suitability of this software
+ * for any purpose.  It is provided &quot;as is&quot; without express or implied
+ * warranty.
+ */
+
+/*
+ * Moved here from mi to allow wrapping of lower level backing store functions.
+ * -- 1997.10.27  Marc Aurele La France (<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">tsi at xfree86.org</A>)
+ */
+
+#ifndef _BSTORE_H_
+#define _BSTORE_H_
+
+#include &quot;bstorestr.h&quot;
+
+#endif /* _BSTORE_H_ */
diff --git a/X11/bstorestr.h b/X11/bstorestr.h
new file mode 100644
index 0000000..8f21855
--- /dev/null
+++ b/X11/bstorestr.h
@@ -0,0 +1,58 @@
+/* $XFree86: xc/programs/Xserver/include/bstorestr.h,v 1.2 2001/01/06 20:58:12 tsi Exp $*/
+/*
+ * Copyright (c) 1987 by the Regents of the University of California
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted, provided
+ * that the above copyright notice appear in all copies.  The University of
+ * California makes no representations about the suitability of this software
+ * for any purpose.  It is provided &quot;as is&quot; without express or implied
+ * warranty.
+ */
+
+/*
+ * Moved here from mi to allow wrapping of lower level backing store functions.
+ * -- 1997.10.27  Marc Aurele La France (<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">tsi at xfree86.org</A>)
+ */
+
+#ifndef _BSTORESTR_H_
+#define _BSTORESTR_H_
+
+#include &quot;gc.h&quot;
+#include &quot;pixmap.h&quot;
+#include &quot;region.h&quot;
+#include &quot;window.h&quot;
+
+typedef    void (* BackingStoreSaveAreasProcPtr)(
+	PixmapPtr /*pBackingPixmap*/,
+	RegionPtr /*pObscured*/,
+	int /*x*/,
+	int /*y*/,
+	WindowPtr /*pWin*/);
+
+typedef    void (* BackingStoreRestoreAreasProcPtr)(
+	PixmapPtr /*pBackingPixmap*/,
+	RegionPtr /*pExposed*/,
+	int /*x*/,
+	int /*y*/,
+	WindowPtr /*pWin*/);
+
+typedef    void (* BackingStoreSetClipmaskRgnProcPtr)(
+	GCPtr /*pBackingGC*/,
+	RegionPtr /*pbackingCompositeClip*/);
+
+typedef    PixmapPtr (* BackingStoreGetImagePixmapProcPtr)(void);
+
+typedef    PixmapPtr (* BackingStoreGetSpansPixmapProcPtr)(void);
+
+typedef struct _BSFuncs {
+
+	BackingStoreSaveAreasProcPtr SaveAreas;
+	BackingStoreRestoreAreasProcPtr RestoreAreas;
+	BackingStoreSetClipmaskRgnProcPtr SetClipmaskRgn;
+	BackingStoreGetImagePixmapProcPtr GetImagePixmap;
+	BackingStoreGetSpansPixmapProcPtr GetSpansPixmap;
+
+} BSFuncRec, *BSFuncPtr;
+
+#endif /* _BSTORESTR_H_ */
diff --git a/X11/closestr.h b/X11/closestr.h
new file mode 100644
index 0000000..d70f754
--- /dev/null
+++ b/X11/closestr.h
@@ -0,0 +1,159 @@
+/* $Xorg: closestr.h,v 1.4 2001/02/09 02:05:14 xorgcvs Exp $ */
+/*
+
+Copyright 1991, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+/* $XFree86: xc/programs/Xserver/include/closestr.h,v 3.4 2001/12/14 19:59:53 dawes Exp $ */
+
+
+#ifndef CLOSESTR_H
+#define CLOSESTR_H
+
+#define	NEED_REPLIES
+#include &lt;X11/Xproto.h&gt;
+#include &quot;closure.h&quot;
+#include &quot;dix.h&quot;
+#include &quot;misc.h&quot;
+#include &quot;gcstruct.h&quot;
+
+/* closure structures */
+
+/* OpenFont */
+
+typedef struct _OFclosure {
+    ClientPtr   client;
+    short       current_fpe;
+    short       num_fpes;
+    FontPathElementPtr *fpe_list;
+    Mask        flags;
+    Bool        slept;
+
+/* XXX -- get these from request buffer instead? */
+    char       *origFontName;
+    int		origFontNameLen;
+    XID         fontid;
+    char       *fontname;
+    int         fnamelen;
+    FontPtr	non_cachable_font;
+}           OFclosureRec;
+
+/* ListFontsWithInfo */
+
+#define XLFDMAXFONTNAMELEN	256
+typedef struct _LFWIstate {
+    char	pattern[XLFDMAXFONTNAMELEN];
+    int		patlen;
+    int		current_fpe;
+    int		max_names;
+    Bool	list_started;
+    pointer	private;
+} LFWIstateRec, *LFWIstatePtr;
+
+typedef struct _LFWIclosure {
+    ClientPtr		client;
+    int			num_fpes;
+    FontPathElementPtr	*fpe_list;
+    xListFontsWithInfoReply *reply;
+    int			length;
+    LFWIstateRec	current;
+    LFWIstateRec	saved;
+    int			savedNumFonts;
+    Bool		haveSaved;
+    Bool		slept;
+    char		*savedName;
+} LFWIclosureRec;
+
+/* ListFonts */
+
+typedef struct _LFclosure {
+    ClientPtr   client;
+    int         num_fpes;
+    FontPathElementPtr *fpe_list;
+    FontNamesPtr names;
+    LFWIstateRec current;
+    LFWIstateRec saved;
+    Bool        haveSaved;
+    Bool        slept;
+    char	*savedName;
+    int		savedNameLen;
+}	LFclosureRec;
+
+/* PolyText */
+
+typedef
+    int			(* PolyTextPtr)(
+			DrawablePtr /* pDraw */,
+			GCPtr /* pGC */,
+			int /* x */,
+			int /* y */,
+			int /* count */,
+			void * /* chars or shorts */
+			);
+
+typedef struct _PTclosure {
+    ClientPtr		client;
+    DrawablePtr		pDraw;
+    GC			*pGC;
+    unsigned char	*pElt;
+    unsigned char	*endReq;
+    unsigned char	*data;
+    int			xorg;
+    int			yorg;
+    CARD8		reqType;
+    PolyTextPtr		polyText;
+    int			itemSize;
+    XID			did;
+    int			err;
+    Bool		slept;
+} PTclosureRec;
+
+/* ImageText */
+
+typedef
+    void		(* ImageTextPtr)(
+			DrawablePtr /* pDraw */,
+			GCPtr /* pGC */,
+			int /* x */,
+			int /* y */,
+			int /* count */,
+			void * /* chars or shorts */
+			);
+
+typedef struct _ITclosure {
+    ClientPtr		client;
+    DrawablePtr		pDraw;
+    GC			*pGC;
+    BYTE		nChars;
+    unsigned char	*data;
+    int			xorg;
+    int			yorg;
+    CARD8		reqType;
+    ImageTextPtr	imageText;
+    int			itemSize;
+    XID			did;
+    Bool		slept;
+} ITclosureRec;
+#endif				/* CLOSESTR_H */
diff --git a/X11/Xprotostr.h b/X11/closure.h
similarity index 79%
copy from X11/Xprotostr.h
copy to X11/closure.h
index f343d98..839303c 100644
--- a/X11/Xprotostr.h
+++ b/X11/closure.h
@@ -1,7 +1,4 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
+/* $Xorg: closure.h,v 1.4 2001/02/09 02:05:14 xorgcvs Exp $ */
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
@@ -48,31 +45,14 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
-
-/* Used by PolySegment */
-
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
-
-/* POINT */
-
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
-
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
 
-/*  ARC  */
+#ifndef CLOSURE_H
+#define CLOSURE_H 1
 
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
+typedef struct _LFclosure	*LFclosurePtr;
+typedef struct _LFWIclosure	*LFWIclosurePtr;
+typedef struct _OFclosure	*OFclosurePtr;
+typedef struct _PTclosure	*PTclosurePtr;
+typedef struct _ITclosure	*ITclosurePtr;
 
-#endif /* XPROTOSTRUCTS_H */
+#endif /* CLOSURE_H */
diff --git a/X11/colormap.h b/X11/colormap.h
new file mode 100644
index 0000000..1f2c330
--- /dev/null
+++ b/X11/colormap.h
@@ -0,0 +1,184 @@
+/* $XFree86: xc/programs/Xserver/include/colormap.h,v 1.5 2001/12/14 19:59:53 dawes Exp $ */
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+*/
+/* $Xorg: colormap.h,v 1.4 2001/02/09 02:05:14 xorgcvs Exp $ */
+
+#ifndef CMAP_H
+#define CMAP_H 1
+
+#include &lt;X11/Xproto.h&gt;
+#include &quot;screenint.h&quot;
+#include &quot;window.h&quot;
+
+/* these follow X.h's AllocNone and AllocAll */
+#define CM_PSCREEN 2
+#define CM_PWIN	   3
+/* Passed internally in colormap.c */
+#define REDMAP 0
+#define GREENMAP 1
+#define BLUEMAP 2
+#define PSEUDOMAP 3
+#define AllocPrivate (-1)
+#define AllocTemporary (-2)
+#define DynamicClass  1
+
+/* Values for the flags field of a colormap. These should have 1 bit set
+ * and not overlap */
+#define IsDefault 1
+#define AllAllocated 2
+#define BeingCreated 4
+
+
+typedef CARD32 Pixel;
+typedef struct _CMEntry *EntryPtr;
+/* moved to screenint.h: typedef struct _ColormapRec *ColormapPtr */
+typedef struct _colorResource *colorResourcePtr;
+
+extern int CreateColormap(
+    Colormap /*mid*/,
+    ScreenPtr /*pScreen*/,
+    VisualPtr /*pVisual*/,
+    ColormapPtr* /*ppcmap*/,
+    int /*alloc*/,
+    int /*client*/);
+
+extern int FreeColormap(
+    pointer /*pmap*/,
+    XID /*mid*/);
+
+extern int TellLostMap(
+    WindowPtr /*pwin*/,
+    pointer /* Colormap *pmid */);
+
+extern int TellGainedMap(
+    WindowPtr /*pwin*/,
+    pointer /* Colormap *pmid */);
+
+extern int CopyColormapAndFree(
+    Colormap /*mid*/,
+    ColormapPtr /*pSrc*/,
+    int /*client*/);
+
+extern int AllocColor(
+    ColormapPtr /*pmap*/,
+    unsigned short* /*pred*/,
+    unsigned short* /*pgreen*/,
+    unsigned short* /*pblue*/,
+    Pixel* /*pPix*/,
+    int /*client*/);
+
+extern void FakeAllocColor(
+    ColormapPtr /*pmap*/,
+    xColorItem * /*item*/);
+
+extern void FakeFreeColor(
+    ColormapPtr /*pmap*/,
+    Pixel /*pixel*/);
+
+typedef int (*ColorCompareProcPtr)(
+    EntryPtr /*pent*/,
+    xrgb * /*prgb*/);
+
+extern int FindColor(
+    ColormapPtr /*pmap*/,
+    EntryPtr /*pentFirst*/,
+    int /*size*/,
+    xrgb* /*prgb*/,
+    Pixel* /*pPixel*/,
+    int /*channel*/,
+    int /*client*/,
+    ColorCompareProcPtr /*comp*/);
+
+extern int QueryColors(
+    ColormapPtr /*pmap*/,
+    int /*count*/,
+    Pixel* /*ppixIn*/,
+    xrgb* /*prgbList*/);
+
+extern int FreeClientPixels(
+    pointer /*pcr*/,
+    XID /*fakeid*/);
+
+extern int AllocColorCells(
+    int /*client*/,
+    ColormapPtr /*pmap*/,
+    int /*colors*/,
+    int /*planes*/,
+    Bool /*contig*/,
+    Pixel* /*ppix*/,
+    Pixel* /*masks*/);
+
+extern int AllocColorPlanes(
+    int /*client*/,
+    ColormapPtr /*pmap*/,
+    int /*colors*/,
+    int /*r*/,
+    int /*g*/,
+    int /*b*/,
+    Bool /*contig*/,
+    Pixel* /*pixels*/,
+    Pixel* /*prmask*/,
+    Pixel* /*pgmask*/,
+    Pixel* /*pbmask*/);
+
+extern int FreeColors(
+    ColormapPtr /*pmap*/,
+    int /*client*/,
+    int /*count*/,
+    Pixel* /*pixels*/,
+    Pixel /*mask*/);
+
+extern int StoreColors(
+    ColormapPtr /*pmap*/,
+    int /*count*/,
+    xColorItem* /*defs*/);
+
+extern int IsMapInstalled(
+    Colormap /*map*/,
+    WindowPtr /*pWin*/);
+
+#endif /* CMAP_H */
diff --git a/X11/Xprotostr.h b/X11/colormapst.h
similarity index 52%
copy from X11/Xprotostr.h
copy to X11/colormapst.h
index f343d98..5ceee98 100644
--- a/X11/Xprotostr.h
+++ b/X11/colormapst.h
@@ -1,8 +1,4 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
-/***********************************************************
+/*
 
 Copyright 1987, 1998  The Open Group
 
@@ -47,32 +43,79 @@ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
-******************************************************************/
-#include &lt;X11/Xmd.h&gt;
-
-/* Used by PolySegment */
-
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
-
-/* POINT */
-
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
-
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
-
-/*  ARC  */
-
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
-
-#endif /* XPROTOSTRUCTS_H */
+*/
+/* $Xorg: colormapst.h,v 1.4 2001/02/09 02:05:14 xorgcvs Exp $ */
+
+#ifndef CMAPSTRUCT_H
+#define CMAPSTRUCT_H 1
+
+#include &quot;colormap.h&quot;
+#include &quot;screenint.h&quot;
+
+/* Shared color -- the color is used by AllocColorPlanes */
+typedef struct
+{
+    unsigned short color;
+    short  refcnt;
+} SHAREDCOLOR;
+
+/* LOCO -- a local color for a PseudoColor cell. DirectColor maps always
+ * use the first value (called red) in the structure.  What channel they
+ * are really talking about depends on which map they are in. */
+typedef struct
+{
+    unsigned short	red, green, blue;
+} LOCO;
+
+/* SHCO -- a shared color for a PseudoColor cell. Used with AllocColorPlanes.
+ * DirectColor maps always use the first value (called red) in the structure.
+ * What channel they are really talking about depends on which map they
+ * are in. */
+typedef struct 
+{
+    SHAREDCOLOR *red, *green, *blue;
+} SHCO;
+
+
+/* color map entry */
+typedef struct _CMEntry
+{
+    union
+    {
+	LOCO	local;
+	SHCO	shco;
+    } co;
+    short	refcnt;
+    Bool	fShared;
+} Entry;
+
+/* COLORMAPs can be used for either Direct or Pseudo color.  PseudoColor
+ * only needs one cell table, we arbitrarily pick red.  We keep track
+ * of that table with freeRed, numPixelsRed, and clientPixelsRed */
+
+typedef struct _ColormapRec
+{
+    VisualPtr	pVisual;
+    short	class;		/* PseudoColor or DirectColor */
+    long	mid;		/* client's name for colormap */
+    ScreenPtr	pScreen;	/* screen map is associated with */
+    short	flags;		/* 1 = IsDefault
+				 * 2 = AllAllocated */
+    int		freeRed;
+    int		freeGreen;
+    int		freeBlue;
+    int		*numPixelsRed;	
+    int		*numPixelsGreen;	
+    int		*numPixelsBlue;	
+    Pixel	**clientPixelsRed;
+    Pixel	**clientPixelsGreen;
+    Pixel	**clientPixelsBlue;
+    Entry	*red;
+    Entry 	*green;
+    Entry	*blue;
+    pointer	devPriv;
+    DevUnion	*devPrivates;	/* dynamic devPrivates added after devPriv
+				   already existed - must keep devPriv */
+} ColormapRec;
+	      
+#endif /* COLORMAP_H */
diff --git a/X11/cursor.h b/X11/cursor.h
new file mode 100644
index 0000000..9eb799e
--- /dev/null
+++ b/X11/cursor.h
@@ -0,0 +1,149 @@
+/* $XdotOrg: xc/programs/Xserver/include/cursor.h,v 1.6 2005/08/24 11:18:30 daniels Exp $ */
+/* $XFree86: xc/programs/Xserver/include/cursor.h,v 1.6 2002/09/17 01:15:14 dawes Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $Xorg: cursor.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+
+#ifndef CURSOR_H
+#define CURSOR_H 
+
+#include &quot;misc.h&quot;
+#include &quot;screenint.h&quot;
+#include &quot;window.h&quot;
+
+#define NullCursor ((CursorPtr)NULL)
+
+/* Provide support for alpha composited cursors */
+#ifdef RENDER
+#define ARGB_CURSOR
+#endif
+
+typedef struct _Cursor *CursorPtr;
+typedef struct _CursorMetric *CursorMetricPtr;
+
+extern CursorPtr rootCursor;
+
+extern int FreeCursor(
+    pointer /*pCurs*/,
+    XID /*cid*/);
+
+/* Quartz support on Mac OS X pulls in the QuickDraw
+   framework whose AllocCursor function conflicts here. */ 
+#ifdef __DARWIN__
+#define AllocCursor Darwin_X_AllocCursor
+#endif
+extern CursorPtr AllocCursor(
+    unsigned char* /*psrcbits*/,
+    unsigned char* /*pmaskbits*/,
+    CursorMetricPtr /*cm*/,
+    unsigned /*foreRed*/,
+    unsigned /*foreGreen*/,
+    unsigned /*foreBlue*/,
+    unsigned /*backRed*/,
+    unsigned /*backGreen*/,
+    unsigned /*backBlue*/);
+
+extern CursorPtr AllocCursorARGB(
+    unsigned char* /*psrcbits*/,
+    unsigned char* /*pmaskbits*/,
+    CARD32* /*argb*/,
+    CursorMetricPtr /*cm*/,
+    unsigned /*foreRed*/,
+    unsigned /*foreGreen*/,
+    unsigned /*foreBlue*/,
+    unsigned /*backRed*/,
+    unsigned /*backGreen*/,
+    unsigned /*backBlue*/);
+
+extern int AllocGlyphCursor(
+    Font /*source*/,
+    unsigned int /*sourceChar*/,
+    Font /*mask*/,
+    unsigned int /*maskChar*/,
+    unsigned /*foreRed*/,
+    unsigned /*foreGreen*/,
+    unsigned /*foreBlue*/,
+    unsigned /*backRed*/,
+    unsigned /*backGreen*/,
+    unsigned /*backBlue*/,
+    CursorPtr* /*ppCurs*/,
+    ClientPtr /*client*/);
+
+extern CursorPtr CreateRootCursor(
+    char* /*pfilename*/,
+    unsigned int /*glyph*/);
+
+extern int ServerBitsFromGlyph(
+    FontPtr /*pfont*/,
+    unsigned int /*ch*/,
+    register CursorMetricPtr /*cm*/,
+    unsigned char ** /*ppbits*/);
+
+extern Bool CursorMetricsFromGlyph(
+    FontPtr /*pfont*/,
+    unsigned /*ch*/,
+    CursorMetricPtr /*cm*/);
+
+extern void CheckCursorConfinement(
+    WindowPtr /*pWin*/);
+
+extern void NewCurrentScreen(
+    ScreenPtr /*newScreen*/,
+    int /*x*/,
+    int /*y*/);
+
+extern Bool PointerConfinedToScreen(void);
+
+extern void GetSpritePosition(
+    int * /*px*/,
+    int * /*py*/);
+
+#ifdef PANORAMIX
+extern int XineramaGetCursorScreen(void);
+#endif /* PANORAMIX */
+
+#endif /* CURSOR_H */
diff --git a/X11/Xprotostr.h b/X11/cursorstr.h
similarity index 61%
copy from X11/Xprotostr.h
copy to X11/cursorstr.h
index f343d98..c877d6c 100644
--- a/X11/Xprotostr.h
+++ b/X11/cursorstr.h
@@ -1,7 +1,4 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
+/* $Xorg: cursorstr.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
@@ -48,31 +45,54 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
-
-/* Used by PolySegment */
-
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
-
-/* POINT */
-
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
-
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
-
-/*  ARC  */
-
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
-
-#endif /* XPROTOSTRUCTS_H */
+/* $XFree86: xc/programs/Xserver/include/cursorstr.h,v 1.8 2002/11/30 06:21:51 keithp Exp $ */
+
+#ifndef CURSORSTRUCT_H
+#define CURSORSTRUCT_H 
+
+#include &quot;cursor.h&quot;
+/* 
+ * device-independent cursor storage
+ */
+
+/*
+ * source and mask point directly to the bits, which are in the server-defined
+ * bitmap format.
+ */
+typedef struct _CursorBits {
+    unsigned char *source;			/* points to bits */
+    unsigned char *mask;			/* points to bits */
+    Bool emptyMask;				/* all zeros mask */
+    unsigned short width, height, xhot, yhot;	/* metrics */
+    int refcnt;					/* can be shared */
+    pointer devPriv[MAXSCREENS];		/* set by pScr-&gt;RealizeCursor*/
+#ifdef ARGB_CURSOR
+    CARD32 *argb;				/* full-color alpha blended */
+#endif
+} CursorBits, *CursorBitsPtr;
+
+typedef struct _Cursor {
+    CursorBitsPtr bits;
+    unsigned short foreRed, foreGreen, foreBlue; /* device-independent color */
+    unsigned short backRed, backGreen, backBlue; /* device-independent color */
+    int refcnt;
+    pointer devPriv[MAXSCREENS];		/* set by pScr-&gt;RealizeCursor*/
+#ifdef XFIXES
+    CARD32 serialNumber;
+    Atom name;
+#endif
+} CursorRec;
+
+typedef struct _CursorMetric {
+    unsigned short width, height, xhot, yhot;
+} CursorMetricRec;
+
+typedef struct {
+    int                x, y;
+    ScreenPtr  pScreen;
+} HotSpot;
+
+#ifdef XEVIE
+extern HotSpot xeviehot;
+#endif
+#endif /* CURSORSTRUCT_H */
diff --git a/X11/dix.h b/X11/dix.h
new file mode 100644
index 0000000..1b8fc42
--- /dev/null
+++ b/X11/dix.h
@@ -0,0 +1,817 @@
+/* $XFree86: xc/programs/Xserver/include/dix.h,v 3.26 2003/01/12 02:44:27 dawes Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $Xorg: dix.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+
+#ifndef DIX_H
+#define DIX_H
+
+#include &quot;gc.h&quot;
+#include &quot;window.h&quot;
+#include &quot;input.h&quot;
+
+#define EARLIER -1
+#define SAMETIME 0
+#define LATER 1
+
+#define NullClient ((ClientPtr) 0)
+#define REQUEST(type) \
+	register type *stuff = (type *)client-&gt;requestBuffer
+
+
+#define REQUEST_SIZE_MATCH(req)\
+    if ((sizeof(req) &gt;&gt; 2) != client-&gt;req_len)\
+         return(BadLength)
+
+#define REQUEST_AT_LEAST_SIZE(req) \
+    if ((sizeof(req) &gt;&gt; 2) &gt; client-&gt;req_len )\
+         return(BadLength)
+
+#define REQUEST_FIXED_SIZE(req, n)\
+    if (((sizeof(req) &gt;&gt; 2) &gt; client-&gt;req_len) || \
+        (((sizeof(req) + (n) + 3) &gt;&gt; 2) != client-&gt;req_len)) \
+         return(BadLength)
+
+#define LEGAL_NEW_RESOURCE(id,client)\
+    if (!LegalNewID(id,client)) \
+    {\
+	client-&gt;errorValue = id;\
+        return(BadIDChoice);\
+    }
+
+/* XXX if you are using this macro, you are probably not generating Match
+ * errors where appropriate */
+#define LOOKUP_DRAWABLE(did, client)\
+    ((client-&gt;lastDrawableID == did) ? \
+     client-&gt;lastDrawable : (DrawablePtr)LookupDrawable(did, client))
+
+#ifdef XCSECURITY
+
+#define SECURITY_VERIFY_DRAWABLE(pDraw, did, client, mode)\
+    if (client-&gt;lastDrawableID == did &amp;&amp; !client-&gt;trustLevel)\
+	pDraw = client-&gt;lastDrawable;\
+    else \
+    {\
+	pDraw = (DrawablePtr) SecurityLookupIDByClass(client, did, \
+						      RC_DRAWABLE, mode);\
+	if (!pDraw) \
+	{\
+	    client-&gt;errorValue = did; \
+	    return BadDrawable;\
+	}\
+	if (pDraw-&gt;type == UNDRAWABLE_WINDOW)\
+	    return BadMatch;\
+    }
+
+#define SECURITY_VERIFY_GEOMETRABLE(pDraw, did, client, mode)\
+    if (client-&gt;lastDrawableID == did &amp;&amp; !client-&gt;trustLevel)\
+	pDraw = client-&gt;lastDrawable;\
+    else \
+    {\
+	pDraw = (DrawablePtr) SecurityLookupIDByClass(client, did, \
+						      RC_DRAWABLE, mode);\
+	if (!pDraw) \
+	{\
+	    client-&gt;errorValue = did; \
+	    return BadDrawable;\
+	}\
+    }
+
+#define SECURITY_VERIFY_GC(pGC, rid, client, mode)\
+    if (client-&gt;lastGCID == rid &amp;&amp; !client-&gt;trustLevel)\
+        pGC = client-&gt;lastGC;\
+    else\
+	pGC = (GC *) SecurityLookupIDByType(client, rid, RT_GC, mode);\
+    if (!pGC)\
+    {\
+	client-&gt;errorValue = rid;\
+	return (BadGC);\
+    }
+
+#define VERIFY_DRAWABLE(pDraw, did, client)\
+	SECURITY_VERIFY_DRAWABLE(pDraw, did, client, SecurityUnknownAccess)
+
+#define VERIFY_GEOMETRABLE(pDraw, did, client)\
+	SECURITY_VERIFY_GEOMETRABLE(pDraw, did, client, SecurityUnknownAccess)
+
+#define VERIFY_GC(pGC, rid, client)\
+	SECURITY_VERIFY_GC(pGC, rid, client, SecurityUnknownAccess)
+
+#else /* not XCSECURITY */
+
+#define VERIFY_DRAWABLE(pDraw, did, client)\
+    if (client-&gt;lastDrawableID == did)\
+	pDraw = client-&gt;lastDrawable;\
+    else \
+    {\
+	pDraw = (DrawablePtr) LookupIDByClass(did, RC_DRAWABLE);\
+	if (!pDraw) \
+	{\
+	    client-&gt;errorValue = did; \
+	    return BadDrawable;\
+	}\
+	if (pDraw-&gt;type == UNDRAWABLE_WINDOW)\
+	    return BadMatch;\
+    }
+
+#define VERIFY_GEOMETRABLE(pDraw, did, client)\
+    if (client-&gt;lastDrawableID == did)\
+	pDraw = client-&gt;lastDrawable;\
+    else \
+    {\
+	pDraw = (DrawablePtr) LookupIDByClass(did, RC_DRAWABLE);\
+	if (!pDraw) \
+	{\
+	    client-&gt;errorValue = did; \
+	    return BadDrawable;\
+	}\
+    }
+
+#define VERIFY_GC(pGC, rid, client)\
+    if (client-&gt;lastGCID == rid)\
+        pGC = client-&gt;lastGC;\
+    else\
+	pGC = (GC *)LookupIDByType(rid, RT_GC);\
+    if (!pGC)\
+    {\
+	client-&gt;errorValue = rid;\
+	return (BadGC);\
+    }
+
+#define SECURITY_VERIFY_DRAWABLE(pDraw, did, client, mode)\
+	VERIFY_DRAWABLE(pDraw, did, client)
+
+#define SECURITY_VERIFY_GEOMETRABLE(pDraw, did, client, mode)\
+	VERIFY_GEOMETRABLE(pDraw, did, client)
+
+#define SECURITY_VERIFY_GC(pGC, rid, client, mode)\
+	VERIFY_GC(pGC, rid, client)
+
+#endif /* XCSECURITY */
+
+/*
+ * We think that most hardware implementations of DBE will want
+ * LookupID*(dbe_back_buffer_id) to return the window structure that the
+ * id is a back buffer for.  Since both front and back buffers will
+ * return the same structure, you need to be able to distinguish
+ * somewhere what kind of buffer (front/back) was being asked for, so
+ * that ddx can render to the right place.  That's the problem that the
+ * following code solves.  Note: we couldn't embed this in the LookupID*
+ * functions because the VALIDATE_DRAWABLE_AND_GC macro often circumvents
+ * those functions by checking a one-element cache.  That's why we're
+ * mucking with VALIDATE_DRAWABLE_AND_GC.
+ * 
+ * If you put -DNEED_DBE_BUF_BITS into PervasiveDBEDefines, the window
+ * structure will have two additional bits defined, srcBuffer and
+ * dstBuffer, and their values will be maintained via the macros
+ * SET_DBE_DSTBUF and SET_DBE_SRCBUF (below).  If you also
+ * put -DNEED_DBE_BUF_VALIDATE into PervasiveDBEDefines, the function
+ * DbeValidateBuffer will be called any time the bits change to give you
+ * a chance to do some setup.  See the DBE code for more details on this
+ * function.  We put in these levels of conditionality so that you can do
+ * just what you need to do, and no more.  If neither of these defines
+ * are used, the bits won't be there, and VALIDATE_DRAWABLE_AND_GC will
+ * be unchanged.	dpw
+ */
+
+#if defined(NEED_DBE_BUF_BITS)
+#define SET_DBE_DSTBUF(_pDraw, _drawID) \
+        SET_DBE_BUF(_pDraw, _drawID, dstBuffer, TRUE)
+#define SET_DBE_SRCBUF(_pDraw, _drawID) \
+        SET_DBE_BUF(_pDraw, _drawID, srcBuffer, FALSE)
+#if defined (NEED_DBE_BUF_VALIDATE)
+#define SET_DBE_BUF(_pDraw, _drawID, _whichBuffer, _dstbuf) \
+    if (_pDraw-&gt;type == DRAWABLE_WINDOW)\
+    {\
+	int thisbuf = (_pDraw-&gt;id == _drawID);\
+	if (thisbuf != ((WindowPtr)_pDraw)-&gt;_whichBuffer)\
+	{\
+	     ((WindowPtr)_pDraw)-&gt;_whichBuffer = thisbuf;\
+	     DbeValidateBuffer((WindowPtr)_pDraw, _drawID, _dstbuf);\
+	}\
+     }
+#else /* want buffer bits, but don't need to call DbeValidateBuffer */
+#define SET_DBE_BUF(_pDraw, _drawID, _whichBuffer, _dstbuf) \
+    if (_pDraw-&gt;type == DRAWABLE_WINDOW)\
+    {\
+	((WindowPtr)_pDraw)-&gt;_whichBuffer = (_pDraw-&gt;id == _drawID);\
+    }
+#endif /* NEED_DBE_BUF_VALIDATE */
+#else /* don't want buffer bits in window */
+#define SET_DBE_DSTBUF(_pDraw, _drawID) /**/
+#define SET_DBE_SRCBUF(_pDraw, _drawID) /**/
+#endif /* NEED_DBE_BUF_BITS */
+
+#define VALIDATE_DRAWABLE_AND_GC(drawID, pDraw, pGC, client)\
+    if ((stuff-&gt;gc == INVALID) || (client-&gt;lastGCID != stuff-&gt;gc) ||\
+	(client-&gt;lastDrawableID != drawID))\
+    {\
+	SECURITY_VERIFY_GEOMETRABLE(pDraw, drawID, client, SecurityWriteAccess);\
+	SECURITY_VERIFY_GC(pGC, stuff-&gt;gc, client, SecurityReadAccess);\
+	if ((pGC-&gt;depth != pDraw-&gt;depth) ||\
+	    (pGC-&gt;pScreen != pDraw-&gt;pScreen))\
+	    return (BadMatch);\
+	client-&gt;lastDrawable = pDraw;\
+	client-&gt;lastDrawableID = drawID;\
+	client-&gt;lastGC = pGC;\
+	client-&gt;lastGCID = stuff-&gt;gc;\
+    }\
+    else\
+    {\
+        pGC = client-&gt;lastGC;\
+        pDraw = client-&gt;lastDrawable;\
+    }\
+    SET_DBE_DSTBUF(pDraw, drawID);\
+    if (pGC-&gt;serialNumber != pDraw-&gt;serialNumber)\
+	ValidateGC(pDraw, pGC);
+
+
+#define WriteReplyToClient(pClient, size, pReply) { \
+   if ((pClient)-&gt;swapped) \
+      (*ReplySwapVector[((xReq *)(pClient)-&gt;requestBuffer)-&gt;reqType]) \
+           (pClient, (int)(size), pReply); \
+      else (void) WriteToClient(pClient, (int)(size), (char *)(pReply)); }
+
+#define WriteSwappedDataToClient(pClient, size, pbuf) \
+   if ((pClient)-&gt;swapped) \
+      (*(pClient)-&gt;pSwapReplyFunc)(pClient, (int)(size), pbuf); \
+   else (void) WriteToClient (pClient, (int)(size), (char *)(pbuf));
+
+typedef struct _TimeStamp *TimeStampPtr;
+
+#ifndef _XTYPEDEF_CLIENTPTR
+typedef struct _Client *ClientPtr; /* also in misc.h */
+#define _XTYPEDEF_CLIENTPTR
+#endif
+
+typedef struct _WorkQueue	*WorkQueuePtr;
+
+extern ClientPtr requestingClient;
+extern ClientPtr *clients;
+extern ClientPtr serverClient;
+extern int currentMaxClients;
+
+typedef int HWEventQueueType;
+typedef HWEventQueueType* HWEventQueuePtr;
+
+extern HWEventQueuePtr checkForInput[2];
+
+typedef struct _TimeStamp {
+    CARD32 months;	/* really ~49.7 days */
+    CARD32 milliseconds;
+}           TimeStamp;
+
+/* dispatch.c */
+
+extern void SetInputCheck(
+    HWEventQueuePtr /*c0*/,
+    HWEventQueuePtr /*c1*/);
+
+extern void CloseDownClient(
+    ClientPtr /*client*/);
+
+extern void UpdateCurrentTime(void);
+
+extern void UpdateCurrentTimeIf(void);
+
+extern void InitSelections(void);
+
+extern void FlushClientCaches(XID /*id*/);
+
+extern int dixDestroyPixmap(
+    pointer /*value*/,
+    XID /*pid*/);
+
+extern void CloseDownRetainedResources(void);
+
+extern void InitClient(
+    ClientPtr /*client*/,
+    int /*i*/,
+    pointer /*ospriv*/);
+
+extern ClientPtr NextAvailableClient(
+    pointer /*ospriv*/);
+
+extern void SendErrorToClient(
+    ClientPtr /*client*/,
+    unsigned int /*majorCode*/,
+    unsigned int /*minorCode*/,
+    XID /*resId*/,
+    int /*errorCode*/);
+
+extern void DeleteWindowFromAnySelections(
+    WindowPtr /*pWin*/);
+
+extern void MarkClientException(
+    ClientPtr /*client*/);
+
+extern int GetGeometry(
+    ClientPtr /*client*/,
+    xGetGeometryReply* /* wa */);
+
+extern int SendConnSetup(
+    ClientPtr /*client*/,
+    char* /*reason*/);
+
+extern int DoGetImage(
+    ClientPtr	/*client*/,
+    int /*format*/,
+    Drawable /*drawable*/,
+    int /*x*/, 
+    int /*y*/, 
+    int /*width*/, 
+    int /*height*/,
+    Mask /*planemask*/,
+    xGetImageReply ** /*im_return*/);
+
+#ifdef LBX
+extern void IncrementClientCount(void);
+#endif /* LBX */
+
+#if defined(DDXBEFORERESET)
+extern void ddxBeforeReset (void);
+#endif
+
+/* dixutils.c */
+
+extern void CopyISOLatin1Lowered(
+    unsigned char * /*dest*/,
+    unsigned char * /*source*/,
+    int /*length*/);
+
+extern int CompareISOLatin1Lowered(
+    unsigned char * /*a*/,
+    int alen,
+    unsigned char * /*b*/,
+    int blen);
+
+#ifdef XCSECURITY
+
+extern WindowPtr SecurityLookupWindow(
+    XID /*rid*/,
+    ClientPtr /*client*/,
+    Mask /*access_mode*/);
+
+extern pointer SecurityLookupDrawable(
+    XID /*rid*/,
+    ClientPtr /*client*/,
+    Mask /*access_mode*/);
+
+extern WindowPtr LookupWindow(
+    XID /*rid*/,
+    ClientPtr /*client*/);
+
+extern pointer LookupDrawable(
+    XID /*rid*/,
+    ClientPtr /*client*/);
+
+#else
+
+extern WindowPtr LookupWindow(
+    XID /*rid*/,
+    ClientPtr /*client*/);
+
+extern pointer LookupDrawable(
+    XID /*rid*/,
+    ClientPtr /*client*/);
+
+#define SecurityLookupWindow(rid, client, access_mode) \
+	LookupWindow(rid, client)
+
+#define SecurityLookupDrawable(rid, client, access_mode) \
+	LookupDrawable(rid, client)
+
+#endif /* XCSECURITY */
+
+extern ClientPtr LookupClient(
+    XID /*rid*/,
+    ClientPtr /*client*/);
+
+extern void NoopDDA(void);
+
+extern int AlterSaveSetForClient(
+    ClientPtr /*client*/,
+    WindowPtr /*pWin*/,
+    unsigned /*mode*/,
+    Bool /*toRoot*/,
+    Bool /*remap*/);
+  
+extern void DeleteWindowFromAnySaveSet(
+    WindowPtr /*pWin*/);
+
+extern void BlockHandler(
+    pointer /*pTimeout*/,
+    pointer /*pReadmask*/);
+
+extern void WakeupHandler(
+    int /*result*/,
+    pointer /*pReadmask*/);
+
+typedef void (* WakeupHandlerProcPtr)(
+    pointer /* blockData */,
+    int /* result */,
+    pointer /* pReadmask */);
+
+extern Bool RegisterBlockAndWakeupHandlers(
+    BlockHandlerProcPtr /*blockHandler*/,
+    WakeupHandlerProcPtr /*wakeupHandler*/,
+    pointer /*blockData*/);
+
+extern void RemoveBlockAndWakeupHandlers(
+    BlockHandlerProcPtr /*blockHandler*/,
+    WakeupHandlerProcPtr /*wakeupHandler*/,
+    pointer /*blockData*/);
+
+extern void InitBlockAndWakeupHandlers(void);
+
+extern void ProcessWorkQueue(void);
+
+extern void ProcessWorkQueueZombies(void);
+
+extern Bool QueueWorkProc(
+    Bool (* /*function*/)(
+        ClientPtr /*clientUnused*/,
+        pointer /*closure*/),
+    ClientPtr /*client*/,
+    pointer /*closure*/
+);
+
+typedef Bool (* ClientSleepProcPtr)(
+    ClientPtr /*client*/,
+    pointer /*closure*/);
+
+extern Bool ClientSleep(
+    ClientPtr /*client*/,
+    ClientSleepProcPtr /* function */,
+    pointer /*closure*/);
+
+#ifndef ___CLIENTSIGNAL_DEFINED___
+#define ___CLIENTSIGNAL_DEFINED___
+extern Bool ClientSignal(
+    ClientPtr /*client*/);
+#endif /* ___CLIENTSIGNAL_DEFINED___ */
+
+extern void ClientWakeup(
+    ClientPtr /*client*/);
+
+extern Bool ClientIsAsleep(
+    ClientPtr /*client*/);
+
+/* atom.c */
+
+extern Atom MakeAtom(
+    char * /*string*/,
+    unsigned /*len*/,
+    Bool /*makeit*/);
+
+extern Bool ValidAtom(
+    Atom /*atom*/);
+
+extern char *NameForAtom(
+    Atom /*atom*/);
+
+extern void AtomError(void);
+
+extern void FreeAllAtoms(void);
+
+extern void InitAtoms(void);
+
+/* events.c */
+
+extern void SetMaskForEvent(
+    Mask /* mask */,
+    int /* event */);
+
+
+extern Bool IsParent(
+    WindowPtr /* maybeparent */,
+    WindowPtr /* child */);
+
+extern WindowPtr GetCurrentRootWindow(void);
+
+extern WindowPtr GetSpriteWindow(void);
+
+
+extern void NoticeEventTime(xEventPtr /* xE */);
+
+extern void EnqueueEvent(
+    xEventPtr /* xE */,
+    DeviceIntPtr /* device */,
+    int	/* count */);
+
+extern void ComputeFreezes(void);
+
+extern void CheckGrabForSyncs(
+    DeviceIntPtr /* dev */,
+    Bool /* thisMode */,
+    Bool /* otherMode */);
+
+extern void ActivatePointerGrab(
+    DeviceIntPtr /* mouse */,
+    GrabPtr /* grab */,
+    TimeStamp /* time */,
+    Bool /* autoGrab */);
+
+extern void DeactivatePointerGrab(
+    DeviceIntPtr /* mouse */);
+
+extern void ActivateKeyboardGrab(
+    DeviceIntPtr /* keybd */,
+    GrabPtr /* grab */,
+    TimeStamp /* time */,
+    Bool /* passive */);
+
+extern void DeactivateKeyboardGrab(
+    DeviceIntPtr /* keybd */);
+
+extern void AllowSome(
+    ClientPtr	/* client */,
+    TimeStamp /* time */,
+    DeviceIntPtr /* thisDev */,
+    int /* newState */);
+
+extern void ReleaseActiveGrabs(
+    ClientPtr client);
+
+extern int DeliverEventsToWindow(
+    WindowPtr /* pWin */,
+    xEventPtr /* pEvents */,
+    int /* count */,
+    Mask /* filter */,
+    GrabPtr /* grab */,
+    int /* mskidx */);
+
+extern int DeliverDeviceEvents(
+    WindowPtr /* pWin */,
+    xEventPtr /* xE */,
+    GrabPtr /* grab */,
+    WindowPtr /* stopAt */,
+    DeviceIntPtr /* dev */,
+    int /* count */);
+
+extern void DefineInitialRootWindow(
+    WindowPtr /* win */);
+
+extern void WindowHasNewCursor(
+    WindowPtr /* pWin */);
+
+extern Bool CheckDeviceGrabs(
+    DeviceIntPtr /* device */,
+    xEventPtr /* xE */,
+    int /* checkFirst */,
+    int /* count */);
+
+extern void DeliverFocusedEvent(
+    DeviceIntPtr /* keybd */,
+    xEventPtr /* xE */,
+    WindowPtr /* window */,
+    int /* count */);
+
+extern void DeliverGrabbedEvent(
+    xEventPtr /* xE */,
+    DeviceIntPtr /* thisDev */,
+    Bool /* deactivateGrab */,
+    int /* count */);
+
+#ifdef XKB
+extern void FixKeyState(
+    xEvent * /* xE */,
+    DeviceIntPtr /* keybd */);
+#endif /* XKB */
+
+extern void RecalculateDeliverableEvents(
+    WindowPtr /* pWin */);
+
+extern int OtherClientGone(
+    pointer /* value */,
+    XID /* id */);
+
+extern void DoFocusEvents(
+    DeviceIntPtr /* dev */,
+    WindowPtr /* fromWin */,
+    WindowPtr /* toWin */,
+    int /* mode */);
+
+extern int SetInputFocus(
+    ClientPtr /* client */,
+    DeviceIntPtr /* dev */,
+    Window /* focusID */,
+    CARD8 /* revertTo */,
+    Time /* ctime */,
+    Bool /* followOK */);
+
+extern int GrabDevice(
+    ClientPtr /* client */,
+    DeviceIntPtr /* dev */,
+    unsigned /* this_mode */,
+    unsigned /* other_mode */,
+    Window /* grabWindow */,
+    unsigned /* ownerEvents */,
+    Time /* ctime */,
+    Mask /* mask */,
+    CARD8 * /* status */);
+
+extern void InitEvents(void);
+
+extern void CloseDownEvents(void);
+
+extern void DeleteWindowFromAnyEvents(
+    WindowPtr	/* pWin */,
+    Bool /* freeResources */);
+
+
+extern Mask EventMaskForClient(
+    WindowPtr /* pWin */,
+    ClientPtr /* client */);
+
+
+
+extern int DeliverEvents(
+    WindowPtr /*pWin*/,
+    xEventPtr /*xE*/,
+    int /*count*/,
+    WindowPtr /*otherParent*/);
+
+
+extern void WriteEventsToClient(
+    ClientPtr /*pClient*/,
+    int	     /*count*/,
+    xEventPtr /*events*/);
+
+extern int TryClientEvents(
+    ClientPtr /*client*/,
+    xEventPtr /*pEvents*/,
+    int /*count*/,
+    Mask /*mask*/,
+    Mask /*filter*/,
+    GrabPtr /*grab*/);
+
+extern void WindowsRestructured(void);
+
+
+#ifdef RANDR
+void
+ScreenRestructured (ScreenPtr pScreen);
+#endif
+
+extern void ResetClientPrivates(void);
+
+extern int AllocateClientPrivateIndex(void);
+
+extern Bool AllocateClientPrivate(
+    int /*index*/,
+    unsigned /*amount*/);
+
+/*
+ *  callback manager stuff
+ */
+
+#ifndef _XTYPEDEF_CALLBACKLISTPTR
+typedef struct _CallbackList *CallbackListPtr; /* also in misc.h */
+#define _XTYPEDEF_CALLBACKLISTPTR
+#endif
+
+typedef void (*CallbackProcPtr) (
+    CallbackListPtr *, pointer, pointer);
+
+typedef Bool (*AddCallbackProcPtr) (
+    CallbackListPtr *, CallbackProcPtr, pointer);
+
+typedef Bool (*DeleteCallbackProcPtr) (
+    CallbackListPtr *, CallbackProcPtr, pointer);
+
+typedef void (*CallCallbacksProcPtr) (
+    CallbackListPtr *, pointer);
+
+typedef void (*DeleteCallbackListProcPtr) (
+    CallbackListPtr *);
+
+typedef struct _CallbackProcs {
+    AddCallbackProcPtr		AddCallback;
+    DeleteCallbackProcPtr	DeleteCallback;
+    CallCallbacksProcPtr	CallCallbacks;
+    DeleteCallbackListProcPtr	DeleteCallbackList;
+} CallbackFuncsRec, *CallbackFuncsPtr;
+
+extern Bool CreateCallbackList(
+    CallbackListPtr * /*pcbl*/,
+    CallbackFuncsPtr /*cbfuncs*/);
+
+extern Bool AddCallback(
+    CallbackListPtr * /*pcbl*/,
+    CallbackProcPtr /*callback*/,
+    pointer /*data*/);
+
+extern Bool DeleteCallback(
+    CallbackListPtr * /*pcbl*/,
+    CallbackProcPtr /*callback*/,
+    pointer /*data*/);
+
+extern void CallCallbacks(
+    CallbackListPtr * /*pcbl*/,
+    pointer /*call_data*/);
+
+extern void DeleteCallbackList(
+    CallbackListPtr * /*pcbl*/);
+
+extern void InitCallbackManager(void);
+
+/*
+ *  ServerGrabCallback stuff
+ */
+
+extern CallbackListPtr ServerGrabCallback;
+
+typedef enum {SERVER_GRABBED, SERVER_UNGRABBED,
+	      CLIENT_PERVIOUS, CLIENT_IMPERVIOUS } ServerGrabState;
+
+typedef struct {
+    ClientPtr client;
+    ServerGrabState grabstate;
+} ServerGrabInfoRec;
+
+/*
+ *  EventCallback stuff
+ */
+
+extern CallbackListPtr EventCallback;
+
+typedef struct {
+    ClientPtr client;
+    xEventPtr events;
+    int count;
+} EventInfoRec;
+
+/*
+ *  DeviceEventCallback stuff
+ */
+
+extern CallbackListPtr DeviceEventCallback;
+
+typedef struct {
+    xEventPtr events;
+    int count;
+} DeviceEventInfoRec;
+
+/*
+ * SelectionCallback stuff
+ */
+
+extern CallbackListPtr SelectionCallback;
+
+typedef enum {
+    SelectionSetOwner,
+    SelectionWindowDestroy,
+    SelectionClientClose
+} SelectionCallbackKind;
+
+typedef struct {
+    struct _Selection	    *selection;
+    SelectionCallbackKind   kind;
+} SelectionInfoRec;
+
+#endif /* DIX_H */
diff --git a/X11/dixevents.h b/X11/dixevents.h
new file mode 100644
index 0000000..46a5fae
--- /dev/null
+++ b/X11/dixevents.h
@@ -0,0 +1,106 @@
+/* $XFree86: xc/programs/Xserver/include/dixevents.h,v 3.4 2001/09/04 14:03:27 dawes Exp $ */
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dickey at clark.net</A>&gt;
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef DIXEVENTS_H
+#define DIXEVENTS_H
+
+extern void SetCriticalEvent(int /* event */);
+
+extern CursorPtr GetSpriteCursor(void);
+
+extern int ProcAllowEvents(ClientPtr /* client */);
+
+extern int MaybeDeliverEventsToClient(
+	WindowPtr              /* pWin */,
+	xEvent *               /* pEvents */,
+	int                    /* count */,
+	Mask                   /* filter */,
+	ClientPtr              /* dontClient */);
+
+extern int ProcWarpPointer(ClientPtr /* client */);
+
+#if 0
+extern void
+#ifdef XKB
+CoreProcessKeyboardEvent (
+#else
+ProcessKeyboardEvent (
+#endif
+	xEvent *               /* xE */,
+	DeviceIntPtr           /* keybd */,
+	int                    /* count */);
+
+extern void
+#ifdef XKB
+CoreProcessPointerEvent (
+#else
+ProcessPointerEvent (
+#endif
+	xEvent *               /* xE */,
+	DeviceIntPtr           /* mouse */,
+	int                    /* count */);
+#endif
+
+extern int EventSelectForWindow(
+	WindowPtr              /* pWin */,
+	ClientPtr              /* client */,
+	Mask                   /* mask */);
+
+extern int EventSuppressForWindow(
+	WindowPtr              /* pWin */,
+	ClientPtr              /* client */,
+	Mask                   /* mask */,
+	Bool *                 /* checkOptional */);
+
+extern int ProcSetInputFocus(ClientPtr /* client */);
+
+extern int ProcGetInputFocus(ClientPtr /* client */);
+
+extern int ProcGrabPointer(ClientPtr /* client */);
+
+extern int ProcChangeActivePointerGrab(ClientPtr /* client */);
+
+extern int ProcUngrabPointer(ClientPtr /* client */);
+
+extern int ProcGrabKeyboard(ClientPtr /* client */);
+
+extern int ProcUngrabKeyboard(ClientPtr /* client */);
+
+extern int ProcQueryPointer(ClientPtr /* client */);
+
+extern int ProcSendEvent(ClientPtr /* client */);
+
+extern int ProcUngrabKey(ClientPtr /* client */);
+
+extern int ProcGrabKey(ClientPtr /* client */);
+
+extern int ProcGrabButton(ClientPtr /* client */);
+
+extern int ProcUngrabButton(ClientPtr /* client */);
+
+extern int ProcRecolorCursor(ClientPtr /* client */);
+
+#endif /* DIXEVENTS_H */
diff --git a/X11/dixfont.h b/X11/dixfont.h
new file mode 100644
index 0000000..c6b8676
--- /dev/null
+++ b/X11/dixfont.h
@@ -0,0 +1,155 @@
+/* $Xorg: dixfont.h,v 1.3 2000/08/17 19:53:29 cpqbld Exp $ */
+/***********************************************************
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $XFree86: xc/programs/Xserver/include/dixfont.h,v 3.7 2001/02/02 21:39:02 herrb Exp $ */
+
+#ifndef DIXFONT_H
+#define DIXFONT_H 1
+
+#include &quot;dix.h&quot;
+#include &lt;X11/fonts/font.h&gt;
+#include &quot;closure.h&quot;
+#include &lt;X11/fonts/fontstruct.h&gt;
+
+#define NullDIXFontProp ((DIXFontPropPtr)0)
+
+typedef struct _DIXFontProp *DIXFontPropPtr;
+
+extern FPEFunctions *fpe_functions;
+
+extern int FontToXError(int /*err*/);
+
+extern Bool SetDefaultFont(char * /*defaultfontname*/);
+
+extern void QueueFontWakeup(FontPathElementPtr /*fpe*/);
+
+extern void RemoveFontWakeup(FontPathElementPtr /*fpe*/);
+
+extern void FontWakeup(pointer /*data*/,
+		       int /*count*/,
+		       pointer /*LastSelectMask*/);
+
+extern int OpenFont(ClientPtr /*client*/,
+		    XID /*fid*/,
+		    Mask /*flags*/,
+		    unsigned /*lenfname*/,
+		    char * /*pfontname*/);
+
+extern int CloseFont(pointer /*pfont*/,
+		     XID /*fid*/);
+
+typedef struct _xQueryFontReply *xQueryFontReplyPtr;
+
+extern void QueryFont(FontPtr /*pFont*/,
+		      xQueryFontReplyPtr /*pReply*/,
+		      int /*nProtoCCIStructs*/);
+
+extern int ListFonts(ClientPtr /*client*/,
+		     unsigned char * /*pattern*/,
+		     unsigned int /*length*/,
+		     unsigned int /*max_names*/);
+
+int
+doListFontsWithInfo(ClientPtr /*client*/,
+		    LFWIclosurePtr /*c*/);
+
+extern int doPolyText(ClientPtr /*client*/,
+		      PTclosurePtr /*c*/
+);
+
+extern int PolyText(ClientPtr /*client*/,
+		    DrawablePtr /*pDraw*/,
+		    GCPtr /*pGC*/,
+		    unsigned char * /*pElt*/,
+		    unsigned char * /*endReq*/,
+		    int /*xorg*/,
+		    int /*yorg*/,
+		    int /*reqType*/,
+		    XID /*did*/);
+
+extern int doImageText(ClientPtr /*client*/,
+		       ITclosurePtr /*c*/);
+
+extern int ImageText(ClientPtr /*client*/,
+		     DrawablePtr /*pDraw*/,
+		     GCPtr /*pGC*/,
+		     int /*nChars*/,
+		     unsigned char * /*data*/,
+		     int /*xorg*/,
+		     int /*yorg*/,
+		     int /*reqType*/,
+		     XID /*did*/);
+
+extern int SetFontPath(ClientPtr /*client*/,
+		       int /*npaths*/,
+		       unsigned char * /*paths*/,
+		       int * /*error*/);
+
+extern int SetDefaultFontPath(char * /*path*/);
+
+extern unsigned char *GetFontPath(int * /*count*/,
+				  int * /*length*/);
+
+extern int LoadGlyphs(ClientPtr /*client*/,
+		      FontPtr /*pfont*/,
+		      unsigned /*nchars*/,
+		      int /*item_size*/,
+		      unsigned char * /*data*/);
+
+extern void DeleteClientFontStuff(ClientPtr /*client*/);
+
+/* Quartz support on Mac OS X pulls in the QuickDraw
+   framework whose InitFonts function conflicts here. */
+#ifdef __DARWIN__
+#define InitFonts Darwin_X_InitFonts
+#endif
+extern void InitFonts(void);
+
+extern void FreeFonts(void);
+
+extern FontPtr find_old_font(XID /*id*/);
+
+extern void GetGlyphs(FontPtr     /*font*/,
+		      unsigned long /*count*/,
+		      unsigned char * /*chars*/,
+		      FontEncoding /*fontEncoding*/,
+		      unsigned long * /*glyphcount*/,
+		      CharInfoPtr * /*glyphs*/);
+
+extern void QueryGlyphExtents(FontPtr     /*pFont*/,
+			      CharInfoPtr * /*charinfo*/,
+			      unsigned long /*count*/,
+			      ExtentInfoPtr /*info*/);
+
+extern Bool QueryTextExtents(FontPtr     /*pFont*/,
+			     unsigned long /*count*/,
+			     unsigned char * /*chars*/,
+			     ExtentInfoPtr /*info*/);
+
+extern Bool ParseGlyphCachingMode(char * /*str*/);
+
+extern void InitGlyphCaching(void);
+
+extern void SetGlyphCachingMode(int /*newmode*/);
+
+#endif				/* DIXFONT_H */
diff --git a/X11/dixfontstr.h b/X11/dixfontstr.h
new file mode 100644
index 0000000..948bf1a
--- /dev/null
+++ b/X11/dixfontstr.h
@@ -0,0 +1,95 @@
+/* $Xorg: dixfontstr.h,v 1.3 2000/08/17 19:53:29 cpqbld Exp $ */
+/***********************************************************
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIXFONTSTRUCT_H
+#define DIXFONTSTRUCT_H
+
+#include &quot;servermd.h&quot;
+#include &quot;dixfont.h&quot;
+#include &lt;X11/fonts/fontstruct.h&gt;
+#include &quot;closure.h&quot;
+#define NEED_REPLIES
+#include &lt;X11/Xproto.h&gt; /* for xQueryFontReply */
+
+#define FONTCHARSET(font)	  (font)
+#define FONTMAXBOUNDS(font,field) (font)-&gt;info.maxbounds.field
+#define FONTMINBOUNDS(font,field) (font)-&gt;info.minbounds.field
+#define TERMINALFONT(font)	  (font)-&gt;info.terminalFont
+#define FONTASCENT(font)	  (font)-&gt;info.fontAscent
+#define FONTDESCENT(font)	  (font)-&gt;info.fontDescent
+#define FONTGLYPHS(font)	  0
+#define FONTCONSTMETRICS(font)	  (font)-&gt;info.constantMetrics
+#define FONTCONSTWIDTH(font)	  (font)-&gt;info.constantWidth
+#define FONTALLEXIST(font)	  (font)-&gt;info.allExist
+#define FONTFIRSTCOL(font)	  (font)-&gt;info.firstCol
+#define FONTLASTCOL(font)	  (font)-&gt;info.lastCol
+#define FONTFIRSTROW(font)	  (font)-&gt;info.firstRow
+#define FONTLASTROW(font)	  (font)-&gt;info.lastRow
+#define FONTDEFAULTCH(font)	  (font)-&gt;info.defaultCh
+#define FONTINKMIN(font)	  (&amp;((font)-&gt;info.ink_minbounds))
+#define FONTINKMAX(font)	  (&amp;((font)-&gt;info.ink_maxbounds))
+#define FONTPROPS(font)		  (font)-&gt;info.props
+#define FONTGLYPHBITS(base,pci)	  ((unsigned char *) (pci)-&gt;bits)
+#define FONTINFONPROPS(font)	  (font)-&gt;info.nprops
+
+/* some things haven't changed names, but we'll be careful anyway */
+
+#define FONTREFCNT(font)	  (font)-&gt;refcnt
+
+/*
+ * for linear char sets
+ */
+#define N1dChars(pfont)	(FONTLASTCOL(pfont) - FONTFIRSTCOL(pfont) + 1)
+
+/*
+ * for 2D char sets
+ */
+#define N2dChars(pfont)	(N1dChars(pfont) * \
+			 (FONTLASTROW(pfont) - FONTFIRSTROW(pfont) + 1))
+
+#ifndef GLYPHPADBYTES
+#define GLYPHPADBYTES -1
+#endif
+
+#if GLYPHPADBYTES == 0 || GLYPHPADBYTES == 1
+#define	GLYPHWIDTHBYTESPADDED(pci)	(GLYPHWIDTHBYTES(pci))
+#define	PADGLYPHWIDTHBYTES(w)		(((w)+7)&gt;&gt;3)
+#endif
+
+#if GLYPHPADBYTES == 2
+#define	GLYPHWIDTHBYTESPADDED(pci)	((GLYPHWIDTHBYTES(pci)+1) &amp; ~0x1)
+#define	PADGLYPHWIDTHBYTES(w)		(((((w)+7)&gt;&gt;3)+1) &amp; ~0x1)
+#endif
+
+#if GLYPHPADBYTES == 4
+#define	GLYPHWIDTHBYTESPADDED(pci)	((GLYPHWIDTHBYTES(pci)+3) &amp; ~0x3)
+#define	PADGLYPHWIDTHBYTES(w)		(((((w)+7)&gt;&gt;3)+3) &amp; ~0x3)
+#endif
+
+#if GLYPHPADBYTES == 8 /* for a cray? */
+#define	GLYPHWIDTHBYTESPADDED(pci)	((GLYPHWIDTHBYTES(pci)+7) &amp; ~0x7)
+#define	PADGLYPHWIDTHBYTES(w)		(((((w)+7)&gt;&gt;3)+7) &amp; ~0x7)
+#endif
+
+#endif				/* DIXFONTSTRUCT_H */
diff --git a/X11/dixgrabs.h b/X11/dixgrabs.h
new file mode 100644
index 0000000..042e063
--- /dev/null
+++ b/X11/dixgrabs.h
@@ -0,0 +1,59 @@
+/* $XFree86: xc/programs/Xserver/include/dixgrabs.h,v 3.0 1996/04/15 11:34:27 dawes Exp $ */
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dickey at clark.net</A>&gt;
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef DIXGRABS_H
+#define DIXGRABS_H 1
+
+extern GrabPtr CreateGrab(
+	int /* client */,
+	DeviceIntPtr /* device */,
+	WindowPtr /* window */,
+	Mask /* eventMask */,
+	Bool /* ownerEvents */,
+	Bool /* keyboardMode */,
+	Bool /* pointerMode */,
+	DeviceIntPtr /* modDevice */,
+	unsigned short /* modifiers */,
+	int /* type */,
+	KeyCode /* keybut */,
+	WindowPtr /* confineTo */,
+	CursorPtr /* cursor */);
+
+extern int DeletePassiveGrab(
+	pointer /* value */,
+	XID /* id */);
+
+extern Bool GrabMatchesSecond(
+	GrabPtr /* pFirstGrab */,
+	GrabPtr /* pSecondGrab */);
+
+extern int AddPassiveGrabToList(
+	GrabPtr /* pGrab */);
+
+extern Bool DeletePassiveGrabFromList(
+	GrabPtr /* pMinuendGrab */);
+
+#endif /* DIXGRABS_H */
diff --git a/X11/dixstruct.h b/X11/dixstruct.h
new file mode 100644
index 0000000..6266ec9
--- /dev/null
+++ b/X11/dixstruct.h
@@ -0,0 +1,236 @@
+/* $XFree86: xc/programs/Xserver/include/dixstruct.h,v 3.19tsi Exp $ */
+/***********************************************************
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $Xorg: dixstruct.h,v 1.3 2000/08/17 19:53:29 cpqbld Exp $ */
+
+#ifndef DIXSTRUCT_H
+#define DIXSTRUCT_H
+
+#include &quot;dix.h&quot;
+#include &quot;resource.h&quot;
+#include &quot;cursor.h&quot;
+#include &quot;gc.h&quot;
+#include &quot;pixmap.h&quot;
+#include &lt;X11/Xmd.h&gt;
+
+/*
+ * 	direct-mapped hash table, used by resource manager to store
+ *      translation from client ids to server addresses.
+ */
+
+#ifdef DEBUG
+#define MAX_REQUEST_LOG 100
+#endif
+
+extern CallbackListPtr ClientStateCallback;
+
+typedef struct {
+    ClientPtr 		client;
+    xConnSetupPrefix 	*prefix; 
+    xConnSetup  	*setup;
+} NewClientInfoRec;
+
+typedef void (*ReplySwapPtr) (
+		ClientPtr	/* pClient */,
+		int		/* size */,
+		void *		/* pbuf */);
+
+extern void ReplyNotSwappd (
+		ClientPtr	/* pClient */,
+		int		/* size */,
+		void *		/* pbuf */);
+
+typedef enum {ClientStateInitial,
+	      ClientStateAuthenticating,
+	      ClientStateRunning,
+	      ClientStateRetained,
+	      ClientStateGone,
+	      ClientStateCheckingSecurity,
+	      ClientStateCheckedSecurity} ClientState;
+
+#ifdef XFIXES
+typedef struct _saveSet {
+    struct _Window  *windowPtr;
+    Bool	    toRoot;
+    Bool	    remap;
+} SaveSetElt;
+#define SaveSetWindow(ss)   ((ss).windowPtr)
+#define SaveSetToRoot(ss)   ((ss).toRoot)
+#define SaveSetRemap(ss)    ((ss).remap)
+#define SaveSetAssignWindow(ss,w)   ((ss).windowPtr = (w))
+#define SaveSetAssignToRoot(ss,tr)  ((ss).toRoot = (tr))
+#define SaveSetAssignRemap(ss,rm)  ((ss).remap = (rm))
+#else
+typedef struct _Window *SaveSetElt;
+#define SaveSetWindow(ss)   (ss)
+#define SaveSetToRoot(ss)   FALSE
+#define SaveSetRemap(ss)    TRUE
+#define SaveSetAssignWindow(ss,w)   ((ss) = (w))
+#define SaveSetAssignToRoot(ss,tr)
+#define SaveSetAssignRemap(ss,rm)
+#endif
+
+typedef struct _Client {
+    int         index;
+    Mask        clientAsMask;
+    pointer     requestBuffer;
+    pointer     osPrivate;	/* for OS layer, including scheduler */
+    Bool        swapped;
+    ReplySwapPtr pSwapReplyFunc;
+    XID         errorValue;
+    int         sequence;
+    int         closeDownMode;
+    int         clientGone;
+    int         noClientException;	/* this client died or needs to be
+					 * killed */
+    DrawablePtr lastDrawable;
+    Drawable    lastDrawableID;
+    GCPtr       lastGC;
+    GContext    lastGCID;
+    SaveSetElt	*saveSet;
+    int         numSaved;
+    pointer     screenPrivate[MAXSCREENS];
+    int         (**requestVector) (
+		ClientPtr /* pClient */);
+    CARD32	req_len;		/* length of current request */
+    Bool	big_requests;		/* supports large requests */
+    int		priority;
+    ClientState clientState;
+    DevUnion	*devPrivates;
+#ifdef XKB
+    unsigned short	xkbClientFlags;
+    unsigned short	mapNotifyMask;
+    unsigned short	newKeyboardNotifyMask;
+    unsigned short	vMajor,vMinor;
+    KeyCode		minKC,maxKC;
+#endif
+
+#ifdef DEBUG
+    unsigned char requestLog[MAX_REQUEST_LOG];
+    int         requestLogIndex;
+#endif
+#ifdef LBX
+    int		(*readRequest)(ClientPtr /*client*/);
+#endif
+    unsigned long replyBytesRemaining;
+#ifdef XCSECURITY
+    XID		authId;
+    unsigned int trustLevel;
+    pointer (* CheckAccess)(
+	    ClientPtr /*pClient*/,
+	    XID /*id*/,
+	    RESTYPE /*classes*/,
+	    Mask /*access_mode*/,
+	    pointer /*resourceval*/);
+#endif
+#ifdef XAPPGROUP
+    struct _AppGroupRec*	appgroup;
+#endif
+    struct _FontResolution * (*fontResFunc) (    /* no need for font.h */
+		ClientPtr	/* pClient */,
+		int *		/* num */);
+#ifdef SMART_SCHEDULE
+    int	    smart_priority;
+    long    smart_start_tick;
+    long    smart_stop_tick;
+    long    smart_check_tick;
+#endif
+}           ClientRec;
+
+#ifdef SMART_SCHEDULE
+/*
+ * Scheduling interface
+ */
+extern long SmartScheduleTime;
+extern long SmartScheduleInterval;
+extern long SmartScheduleSlice;
+extern long SmartScheduleMaxSlice;
+extern unsigned long SmartScheduleIdleCount;
+extern Bool SmartScheduleDisable;
+extern Bool SmartScheduleIdle;
+extern Bool SmartScheduleTimerStopped;
+extern Bool SmartScheduleStartTimer(void);
+#ifdef NXAGENT_SERVER
+extern Bool SmartScheduleStopTimer(void);
+#endif
+#define SMART_MAX_PRIORITY  (20)
+#define SMART_MIN_PRIORITY  (-20)
+
+extern Bool SmartScheduleInit(void);
+
+#endif
+
+/* This prototype is used pervasively in Xext, dix */
+#define DISPATCH_PROC(func) int func(ClientPtr /* client */)
+
+typedef struct _WorkQueue {
+    struct _WorkQueue *next;
+    Bool        (*function) (
+		ClientPtr	/* pClient */,
+		pointer		/* closure */
+);
+    ClientPtr   client;
+    pointer     closure;
+}           WorkQueueRec;
+
+extern TimeStamp currentTime;
+extern TimeStamp lastDeviceEventTime;
+
+extern int CompareTimeStamps(
+    TimeStamp /*a*/,
+    TimeStamp /*b*/);
+
+extern TimeStamp ClientTimeToServerTime(CARD32 /*c*/);
+
+typedef struct _CallbackRec {
+  CallbackProcPtr proc;
+  pointer data;
+  Bool deleted;
+  struct _CallbackRec *next;
+} CallbackRec, *CallbackPtr;
+
+typedef struct _CallbackList {
+  CallbackFuncsRec funcs;
+  int inCallback;
+  Bool deleted;
+  int numDeleted;
+  CallbackPtr list;
+} CallbackListRec;
+
+/* proc vectors */
+
+extern int (* InitialVector[3]) (ClientPtr /*client*/);
+
+extern int (* ProcVector[256]) (ClientPtr /*client*/);
+
+extern int (* SwappedProcVector[256]) (ClientPtr /*client*/);
+
+#ifdef K5AUTH
+extern int (*k5_Vector[256])(ClientPtr /*client*/);
+#endif
+
+extern ReplySwapPtr ReplySwapVector[256];
+
+extern int ProcBadRequest(ClientPtr /*client*/);
+
+#endif				/* DIXSTRUCT_H */
diff --git a/X11/exevents.h b/X11/exevents.h
new file mode 100644
index 0000000..91c7acb
--- /dev/null
+++ b/X11/exevents.h
@@ -0,0 +1,183 @@
+/* $XFree86: xc/programs/Xserver/include/exevents.h,v 3.1 1996/04/15 11:34:29 dawes Exp $ */
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dickey at clark.net</A>&gt;
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+/********************************************************************
+ * Interface of 'exevents.c'
+ */
+
+#ifndef EXEVENTS_H
+#define EXEVENTS_H
+
+extern void RegisterOtherDevice (
+	DeviceIntPtr           /* device */);
+
+extern void ProcessOtherEvent (
+	xEventPtr /* FIXME deviceKeyButtonPointer * xE */,
+	DeviceIntPtr           /* other */,
+	int                    /* count */);
+
+extern int InitProximityClassDeviceStruct(
+	DeviceIntPtr           /* dev */);
+
+extern void InitValuatorAxisStruct(
+	DeviceIntPtr           /* dev */,
+	int                    /* axnum */,
+	int                    /* minval */,
+	int                    /* maxval */,
+	int                    /* resolution */,
+	int                    /* min_res */,
+	int                    /* max_res */);
+
+extern void DeviceFocusEvent(
+	DeviceIntPtr           /* dev */,
+	int                    /* type */,
+	int                    /* mode */,
+	int                    /* detail */,
+	WindowPtr              /* pWin */);
+
+extern int GrabButton(
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	BYTE                   /* this_device_mode */,
+	BYTE                   /* other_devices_mode */,
+	CARD16                 /* modifiers */,
+	DeviceIntPtr           /* modifier_device */,
+	CARD8                  /* button */,
+	Window                 /* grabWindow */,
+	BOOL                   /* ownerEvents */,
+	Cursor                 /* rcursor */,
+	Window                 /* rconfineTo */,
+	Mask                   /* eventMask */);
+
+extern int GrabKey(
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	BYTE                   /* this_device_mode */,
+	BYTE                   /* other_devices_mode */,
+	CARD16                 /* modifiers */,
+	DeviceIntPtr           /* modifier_device */,
+	CARD8                  /* key */,
+	Window                 /* grabWindow */,
+	BOOL                   /* ownerEvents */,
+	Mask                   /* mask */);
+
+extern int SelectForWindow(
+	DeviceIntPtr           /* dev */,
+	WindowPtr              /* pWin */,
+	ClientPtr              /* client */,
+	Mask                   /* mask */,
+	Mask                   /* exclusivemasks */,
+	Mask                   /* validmasks */);
+
+extern int AddExtensionClient (
+	WindowPtr              /* pWin */,
+	ClientPtr              /* client */,
+	Mask                   /* mask */,
+	int                    /* mskidx */);
+
+extern void RecalculateDeviceDeliverableEvents(
+	WindowPtr              /* pWin */);
+
+extern int InputClientGone(
+	WindowPtr              /* pWin */,
+	XID                    /* id */);
+
+extern int SendEvent (
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* d */,
+	Window                 /* dest */,
+	Bool                   /* propagate */,
+	xEvent *               /* ev */,
+	Mask                   /* mask */,
+	int                    /* count */);
+
+extern int SetButtonMapping (
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	int                    /* nElts */,
+	BYTE *                 /* map */);
+
+extern int SetModifierMapping(
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	int                    /* len */,
+	int                    /* rlen */,
+	int                    /* numKeyPerModifier */,
+	KeyCode *              /* inputMap */,
+	KeyClassPtr *          /* k */);
+
+extern void SendDeviceMappingNotify(
+	CARD8                  /* request, */,
+	KeyCode                /* firstKeyCode */,
+	CARD8                  /* count */,
+	DeviceIntPtr           /* dev */);
+
+extern int ChangeKeyMapping(
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	unsigned               /* len */,
+	int                    /* type */,
+	KeyCode                /* firstKeyCode */,
+	CARD8                  /* keyCodes */,
+	CARD8                  /* keySymsPerKeyCode */,
+	KeySym *               /* map */);
+
+extern void DeleteWindowFromAnyExtEvents(
+	WindowPtr              /* pWin */,
+	Bool                   /* freeResources */);
+
+extern void DeleteDeviceFromAnyExtEvents(
+	WindowPtr              /* pWin */,
+	DeviceIntPtr           /* dev */);
+
+extern int MaybeSendDeviceMotionNotifyHint (
+	deviceKeyButtonPointer * /* pEvents */,
+	Mask                   /* mask */);
+
+extern void CheckDeviceGrabAndHintWindow (
+	WindowPtr              /* pWin */,
+	int                    /* type */,
+	deviceKeyButtonPointer * /* xE */,
+	GrabPtr                /* grab */,
+	ClientPtr              /* client */,
+	Mask                   /* deliveryMask */);
+
+extern Mask DeviceEventMaskForClient(
+	DeviceIntPtr           /* dev */,
+	WindowPtr              /* pWin */,
+	ClientPtr              /* client */);
+
+extern void MaybeStopDeviceHint(
+	DeviceIntPtr           /* dev */,
+	ClientPtr              /* client */);
+
+extern int DeviceEventSuppressForWindow(
+	WindowPtr              /* pWin */,
+	ClientPtr              /* client */,
+	Mask                   /* mask */,
+	int                    /* maskndx */);
+
+#endif /* EXEVENTS_H */
diff --git a/X11/Xprotostr.h b/X11/extension.h
similarity index 79%
copy from X11/Xprotostr.h
copy to X11/extension.h
index f343d98..3475017 100644
--- a/X11/Xprotostr.h
+++ b/X11/extension.h
@@ -1,7 +1,4 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
+/* $Xorg: extension.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
@@ -48,31 +45,23 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
+/* $XFree86: xc/programs/Xserver/include/extension.h,v 1.5 2001/12/14 19:59:54 dawes Exp $ */
+
+#ifndef EXTENSION_H
+#define EXTENSION_H 
 
-/* Used by PolySegment */
+_XFUNCPROTOBEGIN
 
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
+extern unsigned short StandardMinorOpcode(ClientPtr /*client*/);
 
-/* POINT */
+extern unsigned short MinorOpcodeOfRequest(ClientPtr /*client*/);
 
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
+extern void InitExtensions(int argc, char **argv);
 
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
+extern void InitVisualWrap(void);
 
-/*  ARC  */
+extern void CloseDownExtensions(void);
 
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
+_XFUNCPROTOEND
 
-#endif /* XPROTOSTRUCTS_H */
+#endif /* EXTENSION_H */
diff --git a/X11/extinit.h b/X11/extinit.h
new file mode 100644
index 0000000..37fa9a2
--- /dev/null
+++ b/X11/extinit.h
@@ -0,0 +1,166 @@
+/* $XFree86: xc/programs/Xserver/include/extinit.h,v 3.2 2001/08/01 00:44:58 tsi Exp $ */
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dickey at clark.net</A>&gt;
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+/********************************************************************
+ * Interface of extinit.c
+ */
+
+#ifndef EXTINIT_H
+#define EXTINIT_H
+
+#include &quot;extnsionst.h&quot;
+
+void
+XInputExtensionInit(
+	void
+	);
+
+
+int
+ProcIDispatch (
+	ClientPtr              /* client */
+	);
+
+int
+SProcIDispatch(
+	ClientPtr              /* client */
+	);
+
+void
+SReplyIDispatch (
+	ClientPtr              /* client */,
+	int                    /* len */,
+	xGrabDeviceReply *     /* rep */
+	);
+
+void
+SEventIDispatch (
+	xEvent *               /* from */,
+	xEvent *               /* to */
+	);
+
+void
+SEventDeviceValuator (
+	deviceValuator *       /* from */,
+	deviceValuator *       /* to */
+	);
+
+void
+SEventFocus (
+	deviceFocus *          /* from */,
+	deviceFocus *          /* to */
+	);
+
+void
+SDeviceStateNotifyEvent (
+	deviceStateNotify *    /* from */,
+	deviceStateNotify *    /* to */
+	);
+
+void
+SDeviceKeyStateNotifyEvent (
+	deviceKeyStateNotify * /* from */,
+	deviceKeyStateNotify * /* to */
+	);
+
+void
+SDeviceButtonStateNotifyEvent (
+	deviceButtonStateNotify * /* from */,
+	deviceButtonStateNotify * /* to */
+	);
+
+void
+SChangeDeviceNotifyEvent (
+	changeDeviceNotify *   /* from */,
+	changeDeviceNotify *   /* to */
+	);
+
+void
+SDeviceMappingNotifyEvent (
+	deviceMappingNotify *  /* from */,
+	deviceMappingNotify *  /* to */
+	);
+
+void
+FixExtensionEvents (
+	ExtensionEntry 	*      /* extEntry */
+	);
+
+void
+RestoreExtensionEvents (
+	void
+	);
+
+void
+IResetProc(
+	ExtensionEntry *       /* unused */
+	);
+
+void
+AssignTypeAndName (
+	DeviceIntPtr           /* dev */,
+	Atom                   /* type */,
+	char *                 /* name */
+	);
+
+void
+MakeDeviceTypeAtoms (
+	void
+);
+
+DeviceIntPtr
+LookupDeviceIntRec (
+	CARD8                  /* id */
+	);
+
+void
+SetExclusiveAccess (
+	Mask                   /* mask */
+	);
+
+void
+AllowPropagateSuppress (
+	Mask                   /* mask */
+	);
+
+Mask
+GetNextExtEventMask (
+	void
+);
+
+void
+SetMaskForExtEvent(
+	Mask                   /* mask */,
+	int                    /* event */
+	);
+
+void
+SetEventInfo(
+	Mask                   /* mask */,
+	int                    /* constant */
+	);
+
+#endif /* EXTINIT_H */
diff --git a/X11/extnsionst.h b/X11/extnsionst.h
new file mode 100644
index 0000000..daf37bf
--- /dev/null
+++ b/X11/extnsionst.h
@@ -0,0 +1,152 @@
+/* $Xorg: extnsionst.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $XFree86: xc/programs/Xserver/include/extnsionst.h,v 3.8 2003/04/27 21:31:04 herrb Exp $ */
+
+#ifndef EXTENSIONSTRUCT_H
+#define EXTENSIONSTRUCT_H 
+
+#include &quot;misc.h&quot;
+#include &quot;screenint.h&quot;
+#include &quot;extension.h&quot;
+#include &quot;gc.h&quot;
+
+typedef struct _ExtensionEntry {
+    int index;
+    void (* CloseDown)(	/* called at server shutdown */
+	struct _ExtensionEntry * /* extension */);
+    char *name;               /* extension name */
+    int base;                 /* base request number */
+    int eventBase;            
+    int eventLast;
+    int errorBase;
+    int errorLast;
+    int num_aliases;
+    char **aliases;
+    pointer extPrivate;
+    unsigned short (* MinorOpcode)(	/* called for errors */
+	ClientPtr /* client */);
+#ifdef XCSECURITY
+    Bool secure;		/* extension visible to untrusted clients? */
+#endif
+} ExtensionEntry;
+
+/* 
+ * The arguments may be different for extension event swapping functions.
+ * Deal with this by casting when initializing the event's EventSwapVector[]
+ * entries.
+ */
+typedef void (*EventSwapPtr) (xEvent *, xEvent *);
+
+extern EventSwapPtr EventSwapVector[128];
+
+extern void NotImplemented (	/* FIXME: this may move to another file... */
+	xEvent *,
+	xEvent *);
+
+typedef void (* ExtensionLookupProc)(
+#ifdef EXTENSION_PROC_ARGS
+    EXTENSION_PROC_ARGS
+#else
+    /* args no longer indeterminate */
+    char *name,
+    GCPtr pGC
+#endif
+);
+
+typedef struct _ProcEntry {
+    char *name;
+    ExtensionLookupProc proc;
+} ProcEntryRec, *ProcEntryPtr;
+
+typedef struct _ScreenProcEntry {
+    int num;
+    ProcEntryPtr procList;
+} ScreenProcEntry;
+
+#define    SetGCVector(pGC, VectorElement, NewRoutineAddress, Atom)    \
+    pGC-&gt;VectorElement = NewRoutineAddress;
+
+#define    GetGCValue(pGC, GCElement)    (pGC-&gt;GCElement)
+
+
+extern ExtensionEntry *AddExtension(
+    char* /*name*/,
+    int /*NumEvents*/,
+    int /*NumErrors*/,
+    int (* /*MainProc*/)(ClientPtr /*client*/),
+    int (* /*SwappedMainProc*/)(ClientPtr /*client*/),
+    void (* /*CloseDownProc*/)(ExtensionEntry * /*extension*/),
+    unsigned short (* /*MinorOpcodeProc*/)(ClientPtr /*client*/)
+);
+
+extern Bool AddExtensionAlias(
+    char* /*alias*/,
+    ExtensionEntry * /*extension*/);
+
+extern ExtensionEntry *CheckExtension(const char *extname);
+
+extern ExtensionLookupProc LookupProc(
+    char* /*name*/,
+    GCPtr /*pGC*/);
+
+extern Bool RegisterProc(
+    char* /*name*/,
+    GCPtr /*pGC*/,
+    ExtensionLookupProc /*proc*/);
+
+extern Bool RegisterScreenProc(
+    char* /*name*/,
+    ScreenPtr /*pScreen*/,
+    ExtensionLookupProc /*proc*/);
+
+extern void DeclareExtensionSecurity(
+    char * /*extname*/,
+    Bool /*secure*/);
+
+#endif /* EXTENSIONSTRUCT_H */
+
diff --git a/X11/gc.h b/X11/gc.h
new file mode 100644
index 0000000..77c2f20
--- /dev/null
+++ b/X11/gc.h
@@ -0,0 +1,178 @@
+/* $XFree86: xc/programs/Xserver/include/gc.h,v 1.5 2001/12/14 19:59:54 dawes Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $Xorg: gc.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+
+#ifndef GC_H
+#define GC_H 
+
+#include &lt;X11/X.h&gt;	/* for GContext, Mask */
+#include &lt;X11/Xdefs.h&gt;	/* for Bool */
+#include &lt;X11/Xproto.h&gt;
+#include &quot;screenint.h&quot;	/* for ScreenPtr */
+#include &quot;pixmap.h&quot;	/* for DrawablePtr */
+
+/* clientClipType field in GC */
+#define CT_NONE			0
+#define CT_PIXMAP		1
+#define CT_REGION		2
+#define CT_UNSORTED		6
+#define CT_YSORTED		10
+#define CT_YXSORTED		14
+#define CT_YXBANDED		18
+
+#define GCQREASON_VALIDATE	1
+#define GCQREASON_CHANGE	2
+#define GCQREASON_COPY_SRC	3
+#define GCQREASON_COPY_DST	4
+#define GCQREASON_DESTROY	5
+
+#define GC_CHANGE_SERIAL_BIT        (((unsigned long)1)&lt;&lt;31)
+#define GC_CALL_VALIDATE_BIT        (1L&lt;&lt;30)
+#define GCExtensionInterest   (1L&lt;&lt;29)
+
+#define DRAWABLE_SERIAL_BITS        (~(GC_CHANGE_SERIAL_BIT))
+
+#define MAX_SERIAL_NUM     (1L&lt;&lt;28)
+
+#define NEXT_SERIAL_NUMBER ((++globalSerialNumber) &gt; MAX_SERIAL_NUM ? \
+	    (globalSerialNumber  = 1): globalSerialNumber)
+
+typedef struct _GCInterest *GCInterestPtr;
+typedef struct _GC    *GCPtr;
+typedef struct _GCOps *GCOpsPtr;
+
+extern void ValidateGC(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/);
+
+extern int ChangeGC(
+    GCPtr/*pGC*/,
+    BITS32 /*mask*/,
+    XID* /*pval*/);
+
+extern int DoChangeGC(
+    GCPtr/*pGC*/,
+    BITS32 /*mask*/,
+    XID* /*pval*/,
+    int /*fPointer*/);
+
+typedef union {
+    CARD32 val;
+    pointer ptr;
+} ChangeGCVal, *ChangeGCValPtr;
+
+extern int dixChangeGC(
+    ClientPtr /*client*/,
+    GCPtr /*pGC*/,
+    BITS32 /*mask*/,
+    CARD32 * /*pval*/,
+    ChangeGCValPtr /*pCGCV*/);
+
+extern GCPtr CreateGC(
+    DrawablePtr /*pDrawable*/,
+    BITS32 /*mask*/,
+    XID* /*pval*/,
+    int* /*pStatus*/);
+
+extern int CopyGC(
+    GCPtr/*pgcSrc*/,
+    GCPtr/*pgcDst*/,
+    BITS32 /*mask*/);
+
+extern int FreeGC(
+    pointer /*pGC*/,
+    XID /*gid*/);
+
+extern void SetGCMask(
+    GCPtr /*pGC*/,
+    Mask /*selectMask*/,
+    Mask /*newDataMask*/);
+
+extern GCPtr CreateScratchGC(
+    ScreenPtr /*pScreen*/,
+    unsigned /*depth*/);
+
+extern void FreeGCperDepth(
+    int /*screenNum*/);
+
+extern Bool CreateGCperDepth(
+    int /*screenNum*/);
+
+extern Bool CreateDefaultStipple(
+    int /*screenNum*/);
+
+extern void FreeDefaultStipple(
+    int /*screenNum*/);
+
+extern int SetDashes(
+    GCPtr /*pGC*/,
+    unsigned /*offset*/,
+    unsigned /*ndash*/,
+    unsigned char* /*pdash*/);
+
+extern int VerifyRectOrder(
+    int /*nrects*/,
+    xRectangle* /*prects*/,
+    int /*ordering*/);
+
+extern int SetClipRects(
+    GCPtr /*pGC*/,
+    int /*xOrigin*/,
+    int /*yOrigin*/,
+    int /*nrects*/,
+    xRectangle* /*prects*/,
+    int /*ordering*/);
+
+extern GCPtr GetScratchGC(
+    unsigned /*depth*/,
+    ScreenPtr /*pScreen*/);
+
+extern void FreeScratchGC(
+    GCPtr /*pGC*/);
+
+#endif /* GC_H */
diff --git a/X11/gcstruct.h b/X11/gcstruct.h
new file mode 100644
index 0000000..c2226ba
--- /dev/null
+++ b/X11/gcstruct.h
@@ -0,0 +1,328 @@
+/* $Xorg: gcstruct.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+
+/* $XFree86: xc/programs/Xserver/include/gcstruct.h,v 1.7 2003/04/27 21:31:04 herrb Exp $ */
+
+#ifndef GCSTRUCT_H
+#define GCSTRUCT_H
+
+#include &quot;gc.h&quot;
+
+#include &quot;regionstr.h&quot;
+#include &quot;region.h&quot;
+#include &quot;pixmap.h&quot;
+#include &quot;screenint.h&quot;
+#include &lt;X11/Xprotostr.h&gt;
+
+/*
+ * functions which modify the state of the GC
+ */
+
+typedef struct _GCFuncs {
+    void	(* ValidateGC)(
+		GCPtr /*pGC*/,
+		unsigned long /*stateChanges*/,
+		DrawablePtr /*pDrawable*/);
+
+    void	(* ChangeGC)(
+		GCPtr /*pGC*/,
+		unsigned long /*mask*/);
+
+    void	(* CopyGC)(
+		GCPtr /*pGCSrc*/,
+		unsigned long /*mask*/,
+		GCPtr /*pGCDst*/);
+
+    void	(* DestroyGC)(
+		GCPtr /*pGC*/);
+
+    void	(* ChangeClip)(
+		GCPtr /*pGC*/,
+		int /*type*/,
+		pointer /*pvalue*/,
+		int /*nrects*/);
+
+    void	(* DestroyClip)(
+		GCPtr /*pGC*/);
+
+    void	(* CopyClip)(
+		GCPtr /*pgcDst*/,
+		GCPtr /*pgcSrc*/);
+    DevUnion	devPrivate;
+} GCFuncs;
+
+/*
+ * graphics operations invoked through a GC
+ */
+
+typedef struct _GCOps {
+    void	(* FillSpans)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*nInit*/,
+		DDXPointPtr /*pptInit*/,
+		int * /*pwidthInit*/,
+		int /*fSorted*/);
+
+    void	(* SetSpans)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		char * /*psrc*/,
+		DDXPointPtr /*ppt*/,
+		int * /*pwidth*/,
+		int /*nspans*/,
+		int /*fSorted*/);
+
+    void	(* PutImage)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*depth*/,
+		int /*x*/,
+		int /*y*/,
+		int /*w*/,
+		int /*h*/,
+		int /*leftPad*/,
+		int /*format*/,
+		char * /*pBits*/);
+
+    RegionPtr	(* CopyArea)(
+		DrawablePtr /*pSrc*/,
+		DrawablePtr /*pDst*/,
+		GCPtr /*pGC*/,
+		int /*srcx*/,
+		int /*srcy*/,
+		int /*w*/,
+		int /*h*/,
+		int /*dstx*/,
+		int /*dsty*/);
+
+    RegionPtr	(* CopyPlane)(
+		DrawablePtr /*pSrcDrawable*/,
+		DrawablePtr /*pDstDrawable*/,
+		GCPtr /*pGC*/,
+		int /*srcx*/,
+		int /*srcy*/,
+		int /*width*/,
+		int /*height*/,
+		int /*dstx*/,
+		int /*dsty*/,
+		unsigned long /*bitPlane*/);
+    void	(* PolyPoint)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*mode*/,
+		int /*npt*/,
+		DDXPointPtr /*pptInit*/);
+
+    void	(* Polylines)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*mode*/,
+		int /*npt*/,
+		DDXPointPtr /*pptInit*/);
+
+    void	(* PolySegment)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*nseg*/,
+		xSegment * /*pSegs*/);
+
+    void	(* PolyRectangle)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*nrects*/,
+		xRectangle * /*pRects*/);
+
+    void	(* PolyArc)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*narcs*/,
+		xArc * /*parcs*/);
+
+    void	(* FillPolygon)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*shape*/,
+		int /*mode*/,
+		int /*count*/,
+		DDXPointPtr /*pPts*/);
+
+    void	(* PolyFillRect)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*nrectFill*/,
+		xRectangle * /*prectInit*/);
+
+    void	(* PolyFillArc)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*narcs*/,
+		xArc * /*parcs*/);
+
+    int		(* PolyText8)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		int /*count*/,
+		char * /*chars*/);
+
+    int		(* PolyText16)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		int /*count*/,
+		unsigned short * /*chars*/);
+
+    void	(* ImageText8)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		int /*count*/,
+		char * /*chars*/);
+
+    void	(* ImageText16)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		int /*count*/,
+		unsigned short * /*chars*/);
+
+    void	(* ImageGlyphBlt)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		unsigned int /*nglyph*/,
+		CharInfoPtr * /*ppci*/,
+		pointer /*pglyphBase*/);
+
+    void	(* PolyGlyphBlt)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		unsigned int /*nglyph*/,
+		CharInfoPtr * /*ppci*/,
+		pointer /*pglyphBase*/);
+
+    void	(* PushPixels)(
+		GCPtr /*pGC*/,
+		PixmapPtr /*pBitMap*/,
+		DrawablePtr /*pDst*/,
+		int /*w*/,
+		int /*h*/,
+		int /*x*/,
+		int /*y*/);
+
+#ifdef NEED_LINEHELPER
+    void	(* LineHelper)();
+#endif
+
+    DevUnion	devPrivate;
+} GCOps;
+
+/* there is padding in the bit fields because the Sun compiler doesn't
+ * force alignment to 32-bit boundaries.  losers.
+ */
+typedef struct _GC {
+    ScreenPtr		pScreen;		
+    unsigned char	depth;    
+    unsigned char	alu;
+    unsigned short	lineWidth;          
+    unsigned short	dashOffset;
+    unsigned short	numInDashList;
+    unsigned char	*dash;
+    unsigned int	lineStyle : 2;
+    unsigned int	capStyle : 2;
+    unsigned int	joinStyle : 2;
+    unsigned int	fillStyle : 2;
+    unsigned int	fillRule : 1;
+    unsigned int 	arcMode : 1;
+    unsigned int	subWindowMode : 1;
+    unsigned int	graphicsExposures : 1;
+    unsigned int	clientClipType : 2; /* CT_&lt;kind&gt; */
+    unsigned int	miTranslate:1; /* should mi things translate? */
+    unsigned int	tileIsPixel:1; /* tile is solid pixel */
+    unsigned int	fExpose:1;     /* Call exposure handling */
+    unsigned int	freeCompClip:1;  /* Free composite clip */
+    unsigned int	unused:14; /* see comment above */
+    unsigned long	planemask;
+    unsigned long	fgPixel;
+    unsigned long	bgPixel;
+    /*
+     * alas -- both tile and stipple must be here as they
+     * are independently specifiable
+     */
+    PixUnion		tile;
+    PixmapPtr		stipple;
+    DDXPointRec		patOrg;		/* origin for (tile, stipple) */
+    struct _Font	*font;
+    DDXPointRec		clipOrg;
+    DDXPointRec		lastWinOrg;	/* position of window last validated */
+    pointer		clientClip;
+    unsigned long	stateChanges;	/* masked with GC_&lt;kind&gt; */
+    unsigned long       serialNumber;
+    GCFuncs		*funcs;
+    GCOps		*ops;
+    DevUnion		*devPrivates;
+    /*
+     * The following were moved here from private storage to allow device-
+     * independent access to them from screen wrappers.
+     * --- 1997.11.03  Marc Aurele La France (<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">tsi at xfree86.org</A>)
+     */
+    PixmapPtr		pRotatedPixmap; /* tile/stipple rotated for alignment */
+    RegionPtr		pCompositeClip;
+    /* fExpose &amp; freeCompClip defined above */
+} GC;
+
+#endif /* GCSTRUCT_H */
diff --git a/X11/globals.h b/X11/globals.h
new file mode 100644
index 0000000..0f28648
--- /dev/null
+++ b/X11/globals.h
@@ -0,0 +1,192 @@
+/* $XdotOrg: xc/programs/Xserver/include/globals.h,v 1.9 2005/08/24 11:18:31 daniels Exp $ */
+/* $XFree86: xc/programs/Xserver/include/globals.h,v 1.3 1999/09/25 14:38:21 dawes Exp $ */
+
+#ifndef _XSERV_GLOBAL_H_
+#define _XSERV_GLOBAL_H_
+
+#include &quot;window.h&quot;	/* for WindowPtr */
+
+/* Global X server variables that are visible to mi, dix, os, and ddx */
+
+extern CARD32 defaultScreenSaverTime;
+extern CARD32 defaultScreenSaverInterval;
+extern CARD32 ScreenSaverTime;
+extern CARD32 ScreenSaverInterval;
+
+extern char *defaultFontPath;
+extern char *rgbPath;
+extern int monitorResolution;
+extern Bool loadableFonts;
+extern int defaultColorVisualClass;
+
+extern Bool Must_have_memory;
+extern WindowPtr *WindowTable;
+extern int GrabInProgress;
+extern Bool noTestExtensions;
+
+extern DDXPointRec dixScreenOrigins[MAXSCREENS];
+
+#ifdef DPMSExtension
+extern CARD32 defaultDPMSStandbyTime;
+extern CARD32 defaultDPMSSuspendTime;
+extern CARD32 defaultDPMSOffTime;
+extern CARD32 DPMSStandbyTime;
+extern CARD32 DPMSSuspendTime;
+extern CARD32 DPMSOffTime;
+extern CARD16 DPMSPowerLevel;
+extern Bool defaultDPMSEnabled;
+extern Bool DPMSEnabled;
+extern Bool DPMSEnabledSwitch;
+extern Bool DPMSDisabledSwitch;
+extern Bool DPMSCapableFlag;
+#endif
+
+#ifdef PANORAMIX
+extern Bool PanoramiXMapped;
+extern Bool PanoramiXVisibilityNotifySent;
+extern Bool PanoramiXWindowExposureSent;
+extern Bool PanoramiXOneExposeRequest;
+#endif
+
+#ifdef BIGREQS
+extern Bool noBigReqExtension;
+#endif
+
+#ifdef COMPOSITE
+extern Bool noCompositeExtension;
+#endif
+
+#ifdef DAMAGE
+extern Bool noDamageExtension;
+#endif
+
+#ifdef DBE
+extern Bool noDbeExtension;
+#endif
+
+#ifdef DPSEXT
+extern Bool noDPSExtension;
+#endif
+
+#ifdef DPMSExtension
+extern Bool noDPMSExtension;
+#endif
+
+#ifdef EVI
+extern Bool noEVIExtension;
+#endif
+
+#ifdef FONTCACHE
+extern Bool noFontCacheExtension;
+#endif
+
+#ifdef GLXEXT
+extern Bool noGlxExtension;
+#endif
+
+#ifdef LBX
+extern Bool noLbxExtension;
+#endif
+
+#ifdef SCREENSAVER
+extern Bool noScreenSaverExtension;
+#endif
+
+#ifdef MITSHM
+extern Bool noMITShmExtension;
+#endif
+
+#ifdef MITMISC
+extern Bool noMITMiscExtension;
+#endif
+
+#ifdef MULTIBUFFER
+extern Bool noMultibufferExtension;
+#endif
+
+#ifdef RANDR
+extern Bool noRRExtension;
+#endif
+
+#ifdef RENDER
+extern Bool noRenderExtension;
+#endif
+
+#ifdef SHAPE
+extern Bool noShapeExtension;
+#endif
+
+#ifdef XCSECURITY
+extern Bool noSecurityExtension;
+#endif
+
+#ifdef XSYNC
+extern Bool noSyncExtension;
+#endif
+
+#ifdef TOGCUP
+extern Bool noXcupExtension;
+#endif
+
+#ifdef RES
+extern Bool noResExtension;
+#endif
+
+#ifdef XAPPGROUP
+extern Bool noXagExtension;
+#endif
+
+#ifdef XCMISC
+extern Bool noXCMiscExtension;
+#endif
+
+#ifdef XEVIE
+extern Bool noXevieExtension;
+#endif
+
+#ifdef XF86BIGFONT
+extern Bool noXFree86BigfontExtension;
+#endif
+
+#ifdef XFreeXDGA
+extern Bool noXFree86DGAExtension;
+#endif
+
+#ifdef XF86DRI
+extern Bool noXFree86DRIExtension;
+#endif
+
+#ifdef XF86MISC
+extern Bool noXFree86MiscExtension;
+#endif
+
+#ifdef XF86VIDMODE
+extern Bool noXFree86VidModeExtension;
+#endif
+
+#ifdef XFIXES
+extern Bool noXFixesExtension;
+#endif
+
+#ifdef XKB
+/* |noXkbExtension| is defined in xc/programs/Xserver/xkb/xkbInit.c */
+extern Bool noXkbExtension;
+#endif
+
+#ifdef PANORAMIX
+extern Bool noPanoramiXExtension;
+#endif
+
+#ifdef XINPUT
+extern Bool noXInputExtension;
+#endif
+
+#ifdef XIDLE
+extern Bool noXIdleExtension;
+#endif
+
+#ifdef XV
+extern Bool noXvExtension;
+#endif
+
+#endif /* !_XSERV_GLOBAL_H_ */
diff --git a/X11/input.h b/X11/input.h
new file mode 100644
index 0000000..bcaa01e
--- /dev/null
+++ b/X11/input.h
@@ -0,0 +1,391 @@
+/* $Xorg: input.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+/************************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+********************************************************/
+/* $XFree86: xc/programs/Xserver/include/input.h,v 3.8 2003/04/27 21:31:04 herrb Exp $ */
+
+#ifndef INPUT_H
+#define INPUT_H
+
+#include &quot;misc.h&quot;
+#include &quot;screenint.h&quot;
+#include &lt;X11/Xmd.h&gt;
+#include &lt;X11/Xproto.h&gt;
+#include &quot;window.h&quot;     /* for WindowPtr */
+
+#define DEVICE_INIT	0
+#define DEVICE_ON	1
+#define DEVICE_OFF	2
+#define DEVICE_CLOSE	3
+
+#define MAP_LENGTH	256
+#define DOWN_LENGTH	32	/* 256/8 =&gt; number of bytes to hold 256 bits */
+#define NullGrab ((GrabPtr)NULL)
+#define PointerRootWin ((WindowPtr)PointerRoot)
+#define NoneWin ((WindowPtr)None)
+#define NullDevice ((DevicePtr)NULL)
+
+#ifndef FollowKeyboard
+#define FollowKeyboard 		3
+#endif
+#ifndef FollowKeyboardWin
+#define FollowKeyboardWin  ((WindowPtr) FollowKeyboard)
+#endif
+#ifndef RevertToFollowKeyboard
+#define RevertToFollowKeyboard	3
+#endif
+
+typedef unsigned long Leds;
+typedef struct _OtherClients *OtherClientsPtr;
+typedef struct _InputClients *InputClientsPtr;
+typedef struct _DeviceIntRec *DeviceIntPtr;
+
+typedef int (*DeviceProc)(
+    DeviceIntPtr /*device*/,
+    int /*what*/);
+
+typedef void (*ProcessInputProc)(
+    xEventPtr /*events*/,
+    DeviceIntPtr /*device*/,
+    int /*count*/);
+
+typedef Bool (*DeviceHandleProc)(
+    DeviceIntPtr /*device*/,
+    void* /*data*/
+    );
+
+typedef void (*DeviceUnwrapProc)(
+    DeviceIntPtr /*device*/,
+    DeviceHandleProc /*proc*/,
+    void* /*data*/
+    );
+
+typedef struct _DeviceRec {
+    pointer	devicePrivate;
+    ProcessInputProc processInputProc;	/* current */
+    ProcessInputProc realInputProc;	/* deliver */
+    ProcessInputProc enqueueInputProc;	/* enqueue */
+    Bool	on;			/* used by DDX to keep state */
+} DeviceRec, *DevicePtr;
+
+typedef struct {
+    int			click, bell, bell_pitch, bell_duration;
+    Bool		autoRepeat;
+    unsigned char	autoRepeats[32];
+    Leds		leds;
+    unsigned char	id;
+} KeybdCtrl;
+
+typedef struct {
+    KeySym  *map;
+    KeyCode minKeyCode,
+	    maxKeyCode;
+    int     mapWidth;
+} KeySymsRec, *KeySymsPtr;
+
+typedef struct {
+    int		num, den, threshold;
+    unsigned char id;
+} PtrCtrl;
+
+typedef struct {
+    int         resolution, min_value, max_value;
+    int         integer_displayed;
+    unsigned char id;
+} IntegerCtrl;
+
+typedef struct {
+    int         max_symbols, num_symbols_supported;
+    int         num_symbols_displayed;
+    KeySym      *symbols_supported;
+    KeySym      *symbols_displayed;
+    unsigned char id;
+} StringCtrl;
+
+typedef struct {
+    int         percent, pitch, duration;
+    unsigned char id;
+} BellCtrl;
+
+typedef struct {
+    Leds        led_values;
+    Mask        led_mask;
+    unsigned char id;
+} LedCtrl;
+
+extern int AllocateDevicePrivateIndex(void);
+extern Bool AllocateDevicePrivate(DeviceIntPtr device, int index);
+extern void ResetDevicePrivateIndex(void);
+
+extern KeybdCtrl	defaultKeyboardControl;
+extern PtrCtrl		defaultPointerControl;
+
+#undef  AddInputDevice
+extern DevicePtr AddInputDevice(
+    DeviceProc /*deviceProc*/,
+    Bool /*autoStart*/);
+
+#define AddInputDevice(deviceProc, autoStart) \
+       _AddInputDevice(deviceProc, autoStart)
+
+extern DeviceIntPtr _AddInputDevice(
+    DeviceProc /*deviceProc*/,
+    Bool /*autoStart*/);
+
+extern Bool EnableDevice(
+    DeviceIntPtr /*device*/);
+
+extern Bool DisableDevice(
+    DeviceIntPtr /*device*/);
+
+extern int InitAndStartDevices(void);
+
+extern void CloseDownDevices(void);
+
+extern void RemoveDevice(
+    DeviceIntPtr /*dev*/);
+
+extern int NumMotionEvents(void);
+
+#undef  RegisterPointerDevice
+extern void RegisterPointerDevice(
+    DevicePtr /*device*/);
+
+#define RegisterPointerDevice(device) \
+       _RegisterPointerDevice(device)
+
+extern void _RegisterPointerDevice(
+    DeviceIntPtr /*device*/);
+
+#undef  RegisterKeyboardDevice
+extern void RegisterKeyboardDevice(
+    DevicePtr /*device*/);
+
+#define RegisterKeyboardDevice(device) \
+       _RegisterKeyboardDevice(device)
+
+extern void _RegisterKeyboardDevice(
+    DeviceIntPtr /*device*/);
+
+extern DevicePtr LookupKeyboardDevice(void);
+
+extern DevicePtr LookupPointerDevice(void);
+
+extern DevicePtr LookupDevice(
+    int /* id */);
+
+extern void QueryMinMaxKeyCodes(
+    KeyCode* /*minCode*/,
+    KeyCode* /*maxCode*/);
+
+extern Bool SetKeySymsMap(
+    KeySymsPtr /*dst*/,
+    KeySymsPtr /*src*/);
+
+extern Bool InitKeyClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    KeySymsPtr /*pKeySyms*/,
+    CARD8 /*pModifiers*/[]);
+
+extern Bool InitButtonClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    int /*numButtons*/,
+    CARD8* /*map*/);
+
+typedef int (*ValuatorMotionProcPtr)(
+		DeviceIntPtr /*pdevice*/,
+		xTimecoord * /*coords*/,
+		unsigned long /*start*/,
+		unsigned long /*stop*/,
+		ScreenPtr /*pScreen*/);
+
+extern Bool InitValuatorClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    int /*numAxes*/,
+    ValuatorMotionProcPtr /* motionProc */,
+    int /*numMotionEvents*/,
+    int /*mode*/);
+
+extern Bool InitFocusClassDeviceStruct(
+    DeviceIntPtr /*device*/);
+
+typedef void (*BellProcPtr)(
+    int /*percent*/,
+    DeviceIntPtr /*device*/,
+    pointer /*ctrl*/,
+    int);
+
+typedef void (*KbdCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    KeybdCtrl * /*ctrl*/);
+
+extern Bool InitKbdFeedbackClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    BellProcPtr /*bellProc*/,
+    KbdCtrlProcPtr /*controlProc*/);
+
+typedef void (*PtrCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    PtrCtrl * /*ctrl*/);
+
+extern Bool InitPtrFeedbackClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    PtrCtrlProcPtr /*controlProc*/);
+
+typedef void (*StringCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    StringCtrl * /*ctrl*/);
+
+extern Bool InitStringFeedbackClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    StringCtrlProcPtr /*controlProc*/,
+    int /*max_symbols*/,
+    int /*num_symbols_supported*/,
+    KeySym* /*symbols*/);
+
+typedef void (*BellCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    BellCtrl * /*ctrl*/);
+
+extern Bool InitBellFeedbackClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    BellProcPtr /*bellProc*/,
+    BellCtrlProcPtr /*controlProc*/);
+
+typedef void (*LedCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    LedCtrl * /*ctrl*/);
+
+extern Bool InitLedFeedbackClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    LedCtrlProcPtr /*controlProc*/);
+
+typedef void (*IntegerCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    IntegerCtrl * /*ctrl*/);
+
+
+extern Bool InitIntegerFeedbackClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    IntegerCtrlProcPtr /*controlProc*/);
+
+extern Bool InitPointerDeviceStruct(
+    DevicePtr /*device*/,
+    CARD8* /*map*/,
+    int /*numButtons*/,
+    ValuatorMotionProcPtr /*motionProc*/,
+    PtrCtrlProcPtr /*controlProc*/,
+    int /*numMotionEvents*/);
+
+extern Bool InitKeyboardDeviceStruct(
+    DevicePtr /*device*/,
+    KeySymsPtr /*pKeySyms*/,
+    CARD8 /*pModifiers*/[],
+    BellProcPtr /*bellProc*/,
+    KbdCtrlProcPtr /*controlProc*/);
+
+extern void SendMappingNotify(
+    unsigned int /*request*/,
+    unsigned int /*firstKeyCode*/,
+    unsigned int /*count*/,
+    ClientPtr	/* client */);
+
+extern Bool BadDeviceMap(
+    BYTE* /*buff*/,
+    int /*length*/,
+    unsigned /*low*/,
+    unsigned /*high*/,
+    XID* /*errval*/);
+
+extern Bool AllModifierKeysAreUp(
+    DeviceIntPtr /*device*/,
+    CARD8* /*map1*/,
+    int /*per1*/,
+    CARD8* /*map2*/,
+    int /*per2*/);
+
+extern void NoteLedState(
+    DeviceIntPtr /*keybd*/,
+    int /*led*/,
+    Bool /*on*/);
+
+extern void MaybeStopHint(
+    DeviceIntPtr /*device*/,
+    ClientPtr /*client*/);
+
+extern void ProcessPointerEvent(
+    xEventPtr /*xE*/,
+    DeviceIntPtr /*mouse*/,
+    int /*count*/);
+
+extern void ProcessKeyboardEvent(
+    xEventPtr /*xE*/,
+    DeviceIntPtr /*keybd*/,
+    int /*count*/);
+
+#ifdef XKB
+extern void CoreProcessPointerEvent(
+    xEventPtr /*xE*/,
+    DeviceIntPtr /*mouse*/,
+    int /*count*/);
+
+extern void CoreProcessKeyboardEvent(
+    xEventPtr /*xE*/,
+    DeviceIntPtr /*keybd*/,
+    int /*count*/);
+#endif
+
+extern Bool LegalModifier(
+    unsigned int /*key*/, 
+    DevicePtr /*pDev*/);
+
+extern void ProcessInputEvents(void);
+
+extern void InitInput(
+    int  /*argc*/,
+    char ** /*argv*/);
+
+#endif /* INPUT_H */
diff --git a/X11/inputstr.h b/X11/inputstr.h
new file mode 100644
index 0000000..b54e8a1
--- /dev/null
+++ b/X11/inputstr.h
@@ -0,0 +1,314 @@
+/* $XFree86: xc/programs/Xserver/include/inputstr.h,v 1.6 2003/04/27 21:31:04 herrb Exp $ */
+/************************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+********************************************************/
+
+/* $Xorg: inputstr.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+
+#ifndef INPUTSTRUCT_H
+#define INPUTSTRUCT_H
+
+#include &quot;input.h&quot;
+#include &quot;window.h&quot;
+#include &quot;dixstruct.h&quot;
+
+#define BitIsOn(ptr, bit) (((BYTE *) (ptr))[(bit)&gt;&gt;3] &amp; (1 &lt;&lt; ((bit) &amp; 7)))
+
+#define SameClient(obj,client) \
+	(CLIENT_BITS((obj)-&gt;resource) == (client)-&gt;clientAsMask)
+
+#define MAX_DEVICES	20
+
+#define EMASKSIZE	MAX_DEVICES
+
+/* Kludge: OtherClients and InputClients must be compatible, see code */
+
+typedef struct _OtherClients {
+    OtherClientsPtr	next;
+    XID			resource; /* id for putting into resource manager */
+    Mask		mask;
+} OtherClients;
+
+typedef struct _InputClients {
+    InputClientsPtr	next;
+    XID			resource; /* id for putting into resource manager */
+    Mask		mask[EMASKSIZE];
+} InputClients;
+
+typedef struct _OtherInputMasks {
+    Mask		deliverableEvents[EMASKSIZE];
+    Mask		inputEvents[EMASKSIZE];
+    Mask		dontPropagateMask[EMASKSIZE];
+    InputClientsPtr	inputClients;
+} OtherInputMasks;
+
+/*
+ * The following structure gets used for both active and passive grabs. For
+ * active grabs some of the fields (e.g. modifiers) are not used. However,
+ * that is not much waste since there aren't many active grabs (one per
+ * keyboard/pointer device) going at once in the server.
+ */
+
+#define MasksPerDetailMask 8		/* 256 keycodes and 256 possible
+						modifier combinations, but only	
+						3 buttons. */
+
+  typedef struct _DetailRec {		/* Grab details may be bit masks */
+	unsigned short exact;
+	Mask *pMask;
+  } DetailRec;
+
+  typedef struct _GrabRec {
+    GrabPtr		next;		/* for chain of passive grabs */
+    XID			resource;
+    DeviceIntPtr	device;
+    WindowPtr		window;
+    unsigned		ownerEvents:1;
+    unsigned		keyboardMode:1;
+    unsigned		pointerMode:1;
+    unsigned		coreGrab:1;	/* grab is on core device */
+    unsigned		coreMods:1;	/* modifiers are on core keyboard */
+    CARD8		type;		/* event type */
+    DetailRec		modifiersDetail;
+    DeviceIntPtr	modifierDevice;
+    DetailRec		detail;		/* key or button */
+    WindowPtr		confineTo;	/* always NULL for keyboards */
+    CursorPtr		cursor;		/* always NULL for keyboards */
+    Mask		eventMask;
+} GrabRec;
+
+typedef struct _KeyClassRec {
+    CARD8		down[DOWN_LENGTH];
+    KeyCode 		*modifierKeyMap;
+    KeySymsRec		curKeySyms;
+    int			modifierKeyCount[8];
+    CARD8		modifierMap[MAP_LENGTH];
+    CARD8		maxKeysPerModifier;
+    unsigned short	state;
+    unsigned short	prev_state;
+#ifdef XKB
+    struct _XkbSrvInfo *xkbInfo;
+#endif
+} KeyClassRec, *KeyClassPtr;
+
+typedef struct _AxisInfo {
+    int		resolution;
+    int		min_resolution;
+    int		max_resolution;
+    int		min_value;
+    int		max_value;
+} AxisInfo, *AxisInfoPtr;
+
+typedef struct _ValuatorClassRec {
+    ValuatorMotionProcPtr GetMotionProc;
+    int		 	numMotionEvents;
+    WindowPtr    	motionHintWindow;
+    AxisInfoPtr 	axes;
+    unsigned short	numAxes;
+    int			*axisVal;
+    CARD8	 	mode;
+} ValuatorClassRec, *ValuatorClassPtr;
+
+typedef struct _ButtonClassRec {
+    CARD8		numButtons;
+    CARD8		buttonsDown;	/* number of buttons currently down */
+    unsigned short	state;
+    Mask		motionMask;
+    CARD8		down[DOWN_LENGTH];
+    CARD8		map[MAP_LENGTH];
+#ifdef XKB
+    union _XkbAction *	xkb_acts;
+#endif
+} ButtonClassRec, *ButtonClassPtr;
+
+typedef struct _FocusClassRec {
+    WindowPtr	win;
+    int		revert;
+    TimeStamp	time;
+    WindowPtr	*trace;
+    int		traceSize;
+    int		traceGood;
+} FocusClassRec, *FocusClassPtr;
+
+typedef struct _ProximityClassRec {
+    char	pad;
+} ProximityClassRec, *ProximityClassPtr;
+
+typedef struct _KbdFeedbackClassRec *KbdFeedbackPtr;
+typedef struct _PtrFeedbackClassRec *PtrFeedbackPtr;
+typedef struct _IntegerFeedbackClassRec *IntegerFeedbackPtr;
+typedef struct _StringFeedbackClassRec *StringFeedbackPtr;
+typedef struct _BellFeedbackClassRec *BellFeedbackPtr;
+typedef struct _LedFeedbackClassRec *LedFeedbackPtr;
+
+typedef struct _KbdFeedbackClassRec {
+    BellProcPtr		BellProc;
+    KbdCtrlProcPtr	CtrlProc;
+    KeybdCtrl	 	ctrl;
+    KbdFeedbackPtr	next;
+#ifdef XKB
+    struct _XkbSrvLedInfo *xkb_sli;
+#endif
+} KbdFeedbackClassRec;
+
+typedef struct _PtrFeedbackClassRec {
+    PtrCtrlProcPtr	CtrlProc;
+    PtrCtrl		ctrl;
+    PtrFeedbackPtr	next;
+} PtrFeedbackClassRec;
+
+typedef struct _IntegerFeedbackClassRec {
+    IntegerCtrlProcPtr	CtrlProc;
+    IntegerCtrl	 	ctrl;
+    IntegerFeedbackPtr	next;
+} IntegerFeedbackClassRec;
+
+typedef struct _StringFeedbackClassRec {
+    StringCtrlProcPtr	CtrlProc;
+    StringCtrl	 	ctrl;
+    StringFeedbackPtr	next;
+} StringFeedbackClassRec;
+
+typedef struct _BellFeedbackClassRec {
+    BellProcPtr		BellProc;
+    BellCtrlProcPtr	CtrlProc;
+    BellCtrl	 	ctrl;
+    BellFeedbackPtr	next;
+} BellFeedbackClassRec;
+
+typedef struct _LedFeedbackClassRec {
+    LedCtrlProcPtr	CtrlProc;
+    LedCtrl	 	ctrl;
+    LedFeedbackPtr	next;
+#ifdef XKB
+    struct _XkbSrvLedInfo *xkb_sli;
+#endif
+} LedFeedbackClassRec;
+
+/* states for devices */
+
+#define NOT_GRABBED		0
+#define THAWED			1
+#define THAWED_BOTH		2	/* not a real state */
+#define FREEZE_NEXT_EVENT	3
+#define FREEZE_BOTH_NEXT_EVENT	4
+#define FROZEN			5	/* any state &gt;= has device frozen */
+#define FROZEN_NO_EVENT		5
+#define FROZEN_WITH_EVENT	6
+#define THAW_OTHERS		7
+
+typedef struct _DeviceIntRec {
+    DeviceRec	public;
+    DeviceIntPtr next;
+    TimeStamp	grabTime;
+    Bool	startup;		/* true if needs to be turned on at
+				          server intialization time */
+    DeviceProc	deviceProc;		/* proc(DevicePtr, DEVICE_xx). It is
+					  used to initialize, turn on, or
+					  turn off the device */
+    Bool	inited;			/* TRUE if INIT returns Success */
+    GrabPtr	grab;			/* the grabber - used by DIX */
+    struct {
+	Bool		frozen;
+	int		state;
+	GrabPtr		other;		/* if other grab has this frozen */
+	xEvent		*event;		/* saved to be replayed */
+	int		evcount;
+    } sync;
+    Atom		type;
+    char		*name;
+    CARD8		id;
+    CARD8		activatingKey;
+    Bool		fromPassiveGrab;
+    GrabRec		activeGrab;
+    void		(*ActivateGrab) (
+			DeviceIntPtr /*device*/,
+			GrabPtr /*grab*/,
+			TimeStamp /*time*/,
+			Bool /*autoGrab*/);
+    void		(*DeactivateGrab)(
+			DeviceIntPtr /*device*/);
+    KeyClassPtr		key;
+    ValuatorClassPtr	valuator;
+    ButtonClassPtr	button;
+    FocusClassPtr	focus;
+    ProximityClassPtr	proximity;
+    KbdFeedbackPtr	kbdfeed;
+    PtrFeedbackPtr	ptrfeed;
+    IntegerFeedbackPtr	intfeed;
+    StringFeedbackPtr	stringfeed;
+    BellFeedbackPtr	bell;
+    LedFeedbackPtr	leds;
+#ifdef XKB
+    struct _XkbInterest *	xkb_interest;
+#endif
+    DevUnion		*devPrivates;
+    int			nPrivates;
+    DeviceUnwrapProc    unwrapProc;
+} DeviceIntRec;
+
+typedef struct {
+    int			numDevices;	/* total number of devices */
+    DeviceIntPtr	devices;	/* all devices turned on */
+    DeviceIntPtr	off_devices;	/* all devices turned off */
+    DeviceIntPtr	keyboard;	/* the main one for the server */
+    DeviceIntPtr	pointer;
+} InputInfo;
+
+extern InputInfo inputInfo;
+
+/* for keeping the events for devices grabbed synchronously */
+typedef struct _QdEvent *QdEventPtr;
+typedef struct _QdEvent {
+    QdEventPtr		next;
+    DeviceIntPtr	device;
+    ScreenPtr		pScreen;	/* what screen the pointer was on */
+    unsigned long	months;		/* milliseconds is in the event */
+    xEvent		*event;
+    int			evcount;
+} QdEventRec;    
+
+#endif /* INPUTSTRUCT_H */
diff --git a/X11/misc.h b/X11/misc.h
new file mode 100644
index 0000000..5944a42
--- /dev/null
+++ b/X11/misc.h
@@ -0,0 +1,269 @@
+/* $XFree86: xc/programs/Xserver/include/misc.h,v 3.28 2001/12/14 19:59:55 dawes Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+Copyright 1992, 1993 Data General Corporation;
+Copyright 1992, 1993 OMRON Corporation  
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that the
+above copyright notice appear in all copies and that both that copyright
+notice and this permission notice appear in supporting documentation, and that
+neither the name OMRON or DATA GENERAL be used in advertising or publicity
+pertaining to distribution of the software without specific, written prior
+permission of the party whose name is to be used.  Neither OMRON or 
+DATA GENERAL make any representation about the suitability of this software
+for any purpose.  It is provided &quot;as is&quot; without express or implied warranty.  
+
+OMRON AND DATA GENERAL EACH DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
+IN NO EVENT SHALL OMRON OR DATA GENERAL BE LIABLE FOR ANY SPECIAL, INDIRECT
+OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+OF THIS SOFTWARE.
+
+******************************************************************/
+/* $Xorg: misc.h,v 1.5 2001/02/09 02:05:15 xorgcvs Exp $ */
+#ifndef MISC_H
+#define MISC_H 1
+/*
+ *  X internal definitions 
+ *
+ */
+
+extern unsigned long globalSerialNumber;
+extern unsigned long serverGeneration;
+
+#include &lt;X11/Xosdefs.h&gt;
+#include &lt;X11/Xfuncproto.h&gt;
+#include &lt;X11/Xmd.h&gt;
+#include &lt;X11/X.h&gt;
+#include &lt;X11/Xdefs.h&gt;
+
+#ifndef IN_MODULE
+#ifndef NULL
+#include &lt;stddef.h&gt;
+#endif
+#endif
+
+#ifndef MAXSCREENS
+#define MAXSCREENS	16
+#endif
+#define MAXCLIENTS	256
+#define MAXDITS		1
+#define MAXEXTENSIONS	128
+#define MAXFORMATS	8
+#define MAXVISUALS_PER_SCREEN 50
+
+typedef unsigned long PIXEL;
+typedef unsigned long ATOM;
+
+
+#ifndef TRUE
+#define TRUE 1
+#define FALSE 0
+#endif
+
+#ifndef _XTYPEDEF_CALLBACKLISTPTR
+typedef struct _CallbackList *CallbackListPtr; /* also in dix.h */
+#define _XTYPEDEF_CALLBACKLISTPTR
+#endif
+
+typedef struct _xReq *xReqPtr;
+
+#include &quot;os.h&quot; 	/* for ALLOCATE_LOCAL and DEALLOCATE_LOCAL */
+#ifndef IN_MODULE
+#include &lt;X11/Xfuncs.h&gt; /* for bcopy, bzero, and bcmp */
+#endif
+
+#define NullBox ((BoxPtr)0)
+#define MILLI_PER_MIN (1000 * 60)
+#define MILLI_PER_SECOND (1000)
+
+    /* this next is used with None and ParentRelative to tell
+       PaintWin() what to use to paint the background. Also used
+       in the macro IS_VALID_PIXMAP */
+
+#define USE_BACKGROUND_PIXEL 3
+#define USE_BORDER_PIXEL 3
+
+
+/* byte swap a 32-bit literal */
+#define lswapl(x) ((((x) &amp; 0xff) &lt;&lt; 24) |\
+		   (((x) &amp; 0xff00) &lt;&lt; 8) |\
+		   (((x) &amp; 0xff0000) &gt;&gt; 8) |\
+		   (((x) &gt;&gt; 24) &amp; 0xff))
+
+/* byte swap a short literal */
+#define lswaps(x) ((((x) &amp; 0xff) &lt;&lt; 8) | (((x) &gt;&gt; 8) &amp; 0xff))
+
+#undef min
+#undef max
+
+#define min(a, b) (((a) &lt; (b)) ? (a) : (b))
+#define max(a, b) (((a) &gt; (b)) ? (a) : (b))
+#ifndef IN_MODULE
+/* abs() is a function, not a macro; include the file declaring
+ * it in case we haven't done that yet.
+ */  
+#include &lt;stdlib.h&gt;
+#endif /* IN_MODULE */
+#ifndef Fabs
+#define Fabs(a) ((a) &gt; 0.0 ? (a) : -(a))	/* floating absolute value */
+#endif
+#define sign(x) ((x) &lt; 0 ? -1 : ((x) &gt; 0 ? 1 : 0))
+/* this assumes b &gt; 0 */
+#define modulus(a, b, d)    if (((d) = (a) % (b)) &lt; 0) (d) += (b)
+/*
+ * return the least significant bit in x which is set
+ *
+ * This works on 1's complement and 2's complement machines.
+ * If you care about the extra instruction on 2's complement
+ * machines, change to ((x) &amp; (-(x)))
+ */
+#define lowbit(x) ((x) &amp; (~(x) + 1))
+
+#ifndef IN_MODULE
+/* XXX Not for modules */
+#include &lt;limits.h&gt;
+#if !defined(MAXSHORT) || !defined(MINSHORT) || \
+    !defined(MAXINT) || !defined(MININT)
+/*
+ * Some implementations #define these through &lt;math.h&gt;, so preclude
+ * #include'ing it later.
+ */
+
+#include &lt;math.h&gt;
+#endif
+#undef MAXSHORT
+#define MAXSHORT SHRT_MAX
+#undef MINSHORT
+#define MINSHORT SHRT_MIN
+#undef MAXINT
+#define MAXINT INT_MAX
+#undef MININT
+#define MININT INT_MIN
+
+#include &lt;assert.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;stdio.h&gt;	/* for fopen, etc... */
+
+#endif
+
+/* some macros to help swap requests, replies, and events */
+
+#define LengthRestB(stuff) \
+    ((client-&gt;req_len &lt;&lt; 2) - sizeof(*stuff))
+
+#define LengthRestS(stuff) \
+    ((client-&gt;req_len &lt;&lt; 1) - (sizeof(*stuff) &gt;&gt; 1))
+
+#define LengthRestL(stuff) \
+    (client-&gt;req_len - (sizeof(*stuff) &gt;&gt; 2))
+
+#define SwapRestS(stuff) \
+    SwapShorts((short *)(stuff + 1), LengthRestS(stuff))
+
+#define SwapRestL(stuff) \
+    SwapLongs((CARD32 *)(stuff + 1), LengthRestL(stuff))
+
+/* byte swap a 32-bit value */
+#define swapl(x, n) { \
+		 n = ((char *) (x))[0];\
+		 ((char *) (x))[0] = ((char *) (x))[3];\
+		 ((char *) (x))[3] = n;\
+		 n = ((char *) (x))[1];\
+		 ((char *) (x))[1] = ((char *) (x))[2];\
+		 ((char *) (x))[2] = n; }
+
+/* byte swap a short */
+#define swaps(x, n) { \
+		 n = ((char *) (x))[0];\
+		 ((char *) (x))[0] = ((char *) (x))[1];\
+		 ((char *) (x))[1] = n; }
+
+/* copy 32-bit value from src to dst byteswapping on the way */
+#define cpswapl(src, dst) { \
+                 ((char *)&amp;(dst))[0] = ((char *) &amp;(src))[3];\
+                 ((char *)&amp;(dst))[1] = ((char *) &amp;(src))[2];\
+                 ((char *)&amp;(dst))[2] = ((char *) &amp;(src))[1];\
+                 ((char *)&amp;(dst))[3] = ((char *) &amp;(src))[0]; }
+
+/* copy short from src to dst byteswapping on the way */
+#define cpswaps(src, dst) { \
+		 ((char *) &amp;(dst))[0] = ((char *) &amp;(src))[1];\
+		 ((char *) &amp;(dst))[1] = ((char *) &amp;(src))[0]; }
+
+extern void SwapLongs(
+    CARD32 *list,
+    unsigned long count);
+
+extern void SwapShorts(
+    short *list,
+    unsigned long count);
+
+extern void MakePredeclaredAtoms(void);
+
+extern int Ones(
+    unsigned long /*mask*/);
+
+typedef struct _xPoint *DDXPointPtr;
+typedef struct _Box *BoxPtr;
+typedef struct _xEvent *xEventPtr;
+typedef struct _xRectangle *xRectanglePtr;
+typedef struct _GrabRec *GrabPtr;
+
+/*  typedefs from other places - duplicated here to minimize the amount
+ *  of unnecessary junk that one would normally have to include to get
+ *  these symbols defined
+ */
+
+#ifndef _XTYPEDEF_CHARINFOPTR
+typedef struct _CharInfo *CharInfoPtr; /* also in fonts/include/font.h */
+#define _XTYPEDEF_CHARINFOPTR
+#endif
+
+#endif /* MISC_H */
diff --git a/X11/Xprotostr.h b/X11/miscstruct.h
similarity index 71%
copy from X11/Xprotostr.h
copy to X11/miscstruct.h
index f343d98..6a16007 100644
--- a/X11/Xprotostr.h
+++ b/X11/miscstruct.h
@@ -1,7 +1,4 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
+/* $Xorg: miscstruct.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
@@ -48,31 +45,36 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
-
-/* Used by PolySegment */
-
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
-
-/* POINT */
-
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
-
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
-
-/*  ARC  */
-
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
-
-#endif /* XPROTOSTRUCTS_H */
+/* $XFree86: xc/programs/Xserver/include/miscstruct.h,v 3.4 2003/04/27 21:31:04 herrb Exp $ */
+
+#ifndef MISCSTRUCT_H
+#define MISCSTRUCT_H 1
+
+#include &quot;misc.h&quot;
+#include &lt;X11/Xprotostr.h&gt;
+#include &quot;gc.h&quot;
+
+typedef xPoint DDXPointRec;
+
+typedef struct _Box {
+    short x1, y1, x2, y2;
+} BoxRec;
+
+typedef union _DevUnion {
+    pointer		ptr;
+    long		val;
+    unsigned long	uval;
+    RegionPtr   	(*fptr)(
+        DrawablePtr         /* pSrcDrawable */,
+        DrawablePtr         /* pDstDrawable */,
+        GCPtr               /* pGC */,
+        int                 /* srcx */,
+        int                 /* srcy */,
+        int                 /* width */,
+        int                 /* height */,
+        int                 /* dstx */,
+        int                 /* dsty */,
+        unsigned long       /* bitPlane */);
+} DevUnion;
+
+#endif /* MISCSTRUCT_H */
diff --git a/X11/opaque.h b/X11/opaque.h
new file mode 100644
index 0000000..ca29afd
--- /dev/null
+++ b/X11/opaque.h
@@ -0,0 +1,83 @@
+/* $Xorg: opaque.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+/* $XFree86: xc/programs/Xserver/include/opaque.h,v 1.13 2003/07/24 13:50:25 eich Exp $ */
+
+#ifndef OPAQUE_H
+#define OPAQUE_H
+
+#include &lt;X11/Xmd.h&gt;
+
+#include &quot;globals.h&quot;
+
+extern char *defaultTextFont;
+extern char *defaultCursorFont;
+extern int MaxClients;
+extern volatile char isItTimeToYield;
+extern volatile char dispatchException;
+
+/* bit values for dispatchException */
+#define DE_RESET     1
+#define DE_TERMINATE 2
+#define DE_PRIORITYCHANGE 4  /* set when a client's priority changes */
+
+extern CARD32 TimeOutValue;
+extern int ScreenSaverBlanking;
+extern int ScreenSaverAllowExposures;
+extern int defaultScreenSaverBlanking;
+extern int defaultScreenSaverAllowExposures;
+extern int argcGlobal;
+extern char **argvGlobal;
+extern char *display;
+
+extern int defaultBackingStore;
+extern Bool disableBackingStore;
+extern Bool enableBackingStore;
+extern Bool disableSaveUnders;
+extern Bool PartialNetwork;
+#ifndef NOLOGOHACK
+extern int logoScreenSaver;
+#endif
+#ifdef RLIMIT_DATA
+extern int limitDataSpace;
+#endif
+#ifdef RLIMIT_STACK
+extern int limitStackSpace;
+#endif
+#ifdef RLIMIT_NOFILE
+extern int limitNoFile;
+#endif
+extern Bool permitOldBugs;
+extern Bool defeatAccessControl;
+extern long maxBigRequestSize;
+extern Bool blackRoot;
+
+extern Bool CoreDump;
+
+
+#endif /* OPAQUE_H */
diff --git a/X11/os.h b/X11/os.h
new file mode 100644
index 0000000..0b3354e
--- /dev/null
+++ b/X11/os.h
@@ -0,0 +1,546 @@
+/* $XFree86: xc/programs/Xserver/include/os.h,v 3.54 2003/10/30 21:21:06 herrb Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+/* $Xorg: os.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+
+#ifndef OS_H
+#define OS_H
+
+#include &quot;misc.h&quot;
+#define ALLOCATE_LOCAL_FALLBACK(_size) Xalloc((unsigned long)(_size))
+#define DEALLOCATE_LOCAL_FALLBACK(_ptr) Xfree((pointer)(_ptr))
+#include &lt;X11/Xalloca.h&gt;
+#ifndef IN_MODULE
+#include &lt;stdarg.h&gt;
+#else
+#include &quot;xf86_ansic.h&quot;
+#endif
+
+#define NullFID ((FID) 0)
+
+#define SCREEN_SAVER_ON   0
+#define SCREEN_SAVER_OFF  1
+#define SCREEN_SAVER_FORCER 2
+#define SCREEN_SAVER_CYCLE  3
+
+#ifndef MAX_REQUEST_SIZE
+#define MAX_REQUEST_SIZE 65535
+#endif
+#ifndef MAX_BIG_REQUEST_SIZE
+#define MAX_BIG_REQUEST_SIZE 4194303
+#endif
+
+typedef pointer	FID;
+typedef struct _FontPathRec *FontPathPtr;
+typedef struct _NewClientRec *NewClientPtr;
+
+#ifndef xalloc
+#define xnfalloc(size) XNFalloc((unsigned long)(size))
+#define xnfcalloc(_num, _size) XNFcalloc((unsigned long)(_num)*(unsigned long)(_size))
+#define xnfrealloc(ptr, size) XNFrealloc((pointer)(ptr), (unsigned long)(size))
+
+#define xalloc(size) Xalloc((unsigned long)(size))
+#define xcalloc(_num, _size) Xcalloc((unsigned long)(_num)*(unsigned long)(_size))
+#define xrealloc(ptr, size) Xrealloc((pointer)(ptr), (unsigned long)(size))
+#define xfree(ptr) Xfree((pointer)(ptr))
+#define xstrdup(s) Xstrdup(s)
+#define xnfstrdup(s) XNFstrdup(s)
+#endif
+
+#ifndef IN_MODULE
+#ifdef __SCO__
+#include &lt;stdio.h&gt;
+#endif
+#include &lt;string.h&gt;
+#endif
+
+/* have to put $(SIGNAL_DEFINES) in DEFINES in Imakefile to get this right */
+#ifdef SIGNALRETURNSINT
+#define SIGVAL int
+#else
+#define SIGVAL void
+#endif
+
+extern Bool OsDelayInitColors;
+extern void (*OsVendorVErrorFProc)(const char *, va_list args);
+
+extern int WaitForSomething(
+    int* /*pClientsReady*/
+);
+
+#ifdef LBX
+#define ReadRequestFromClient(client)   ((client)-&gt;readRequest(client))
+extern int StandardReadRequestFromClient(ClientPtr /*client*/);
+
+extern int ClientConnectionNumber(ClientPtr /*client*/);
+#else
+extern int ReadRequestFromClient(ClientPtr /*client*/);
+#endif /* LBX */
+
+extern Bool InsertFakeRequest(
+    ClientPtr /*client*/, 
+    char* /*data*/, 
+    int /*count*/);
+
+extern void ResetCurrentRequest(ClientPtr /*client*/);
+
+extern void FlushAllOutput(void);
+
+extern void FlushIfCriticalOutputPending(void);
+
+extern void SetCriticalOutputPending(void);
+
+extern int WriteToClient(ClientPtr /*who*/, int /*count*/, char* /*buf*/);
+
+extern void ResetOsBuffers(void);
+
+extern void InitConnectionLimits(void);
+
+extern void CreateWellKnownSockets(void);
+
+extern void ResetWellKnownSockets(void);
+
+extern void CloseWellKnownConnections(void);
+
+extern XID AuthorizationIDOfClient(ClientPtr /*client*/);
+
+extern char *ClientAuthorized(
+    ClientPtr /*client*/,
+    unsigned int /*proto_n*/,
+    char* /*auth_proto*/,
+    unsigned int /*string_n*/,
+    char* /*auth_string*/);
+
+extern Bool EstablishNewConnections(
+    ClientPtr /*clientUnused*/,
+    pointer /*closure*/);
+
+extern void CheckConnections(void);
+
+extern void CloseDownConnection(ClientPtr /*client*/);
+
+extern void AddEnabledDevice(int /*fd*/);
+
+extern void RemoveEnabledDevice(int /*fd*/);
+
+extern void OnlyListenToOneClient(ClientPtr /*client*/);
+
+extern void ListenToAllClients(void);
+
+extern void IgnoreClient(ClientPtr /*client*/);
+
+extern void AttendClient(ClientPtr /*client*/);
+
+extern void MakeClientGrabImpervious(ClientPtr /*client*/);
+
+extern void MakeClientGrabPervious(ClientPtr /*client*/);
+
+#ifdef LBX
+extern void CloseDownFileDescriptor(ClientPtr /* client */);
+#endif
+
+extern void AvailableClientInput(ClientPtr /* client */);
+
+extern CARD32 GetTimeInMillis(void);
+
+extern void AdjustWaitForDelay(
+    pointer /*waitTime*/,
+    unsigned long /*newdelay*/);
+
+typedef	struct _OsTimerRec *OsTimerPtr;
+
+typedef CARD32 (*OsTimerCallback)(
+    OsTimerPtr /* timer */,
+    CARD32 /* time */,
+    pointer /* arg */);
+
+extern void TimerInit(void);
+
+extern Bool TimerForce(OsTimerPtr /* timer */);
+
+#define TimerAbsolute (1&lt;&lt;0)
+#define TimerForceOld (1&lt;&lt;1)
+
+extern OsTimerPtr TimerSet(
+    OsTimerPtr /* timer */,
+    int /* flags */,
+    CARD32 /* millis */,
+    OsTimerCallback /* func */,
+    pointer /* arg */);
+
+extern void TimerCheck(void);
+extern void TimerCancel(OsTimerPtr /* pTimer */);
+extern void TimerFree(OsTimerPtr /* pTimer */);
+
+extern void SetScreenSaverTimer(void);
+extern void FreeScreenSaverTimer(void);
+
+#ifdef DPMSExtension
+extern void SetDPMSTimers(void);
+extern void FreeDPMSTimers(void);
+#endif
+
+extern SIGVAL AutoResetServer(int /*sig*/);
+
+extern SIGVAL GiveUp(int /*sig*/);
+
+extern void UseMsg(void);
+
+extern void InitGlobals(void);
+
+extern void ProcessCommandLine(int /*argc*/, char* /*argv*/[]);
+
+extern int set_font_authorizations(
+    char ** /* authorizations */, 
+    int * /*authlen */, 
+    pointer /* client */);
+
+#ifndef _HAVE_XALLOC_DECLS
+#define _HAVE_XALLOC_DECLS
+extern pointer Xalloc(unsigned long /*amount*/);
+extern pointer Xcalloc(unsigned long /*amount*/);
+extern pointer Xrealloc(pointer /*ptr*/, unsigned long /*amount*/);
+extern void Xfree(pointer /*ptr*/);
+#endif
+
+extern pointer XNFalloc(unsigned long /*amount*/);
+extern pointer XNFcalloc(unsigned long /*amount*/);
+extern pointer XNFrealloc(pointer /*ptr*/, unsigned long /*amount*/);
+
+extern void OsInitAllocator(void);
+
+extern char *Xstrdup(const char *s);
+extern char *XNFstrdup(const char *s);
+extern char *Xprintf(const char *fmt, ...);
+extern char *Xvprintf(const char *fmt, va_list va);
+extern char *XNFprintf(const char *fmt, ...);
+extern char *XNFvprintf(const char *fmt, va_list va);
+
+typedef SIGVAL (*OsSigHandlerPtr)(int /* sig */);
+
+extern OsSigHandlerPtr OsSignal(int /* sig */, OsSigHandlerPtr /* handler */);
+
+extern int auditTrailLevel;
+
+#ifdef SERVER_LOCK
+extern void LockServer(void);
+extern void UnlockServer(void);
+#endif
+
+extern int OsLookupColor(
+    int	/*screen*/,
+    char * /*name*/,
+    unsigned /*len*/,
+    unsigned short * /*pred*/,
+    unsigned short * /*pgreen*/,
+    unsigned short * /*pblue*/);
+
+extern void OsInit(void);
+
+extern void OsCleanup(Bool);
+
+extern void OsVendorFatalError(void);
+
+extern void OsVendorInit(void);
+
+extern int OsInitColors(void);
+
+void OsBlockSignals (void);
+
+void OsReleaseSignals (void);
+
+#if !defined(WIN32) &amp;&amp; !defined(__UNIXOS2__)
+extern int System(char *);
+extern pointer Popen(char *, char *);
+extern int Pclose(pointer);
+extern pointer Fopen(char *, char *);
+extern int Fclose(pointer);
+#else
+#define System(a) system(a)
+#define Popen(a,b) popen(a,b)
+#define Pclose(a) pclose(a)
+#define Fopen(a,b) fopen(a,b)
+#define Fclose(a) fclose(a)
+#endif
+
+extern void CheckUserParameters(int argc, char **argv, char **envp);
+extern void CheckUserAuthorization(void);
+
+extern int AddHost(
+    ClientPtr	/*client*/,
+    int         /*family*/,
+    unsigned    /*length*/,
+    pointer     /*pAddr*/);
+
+extern Bool ForEachHostInFamily (
+    int	    /*family*/,
+    Bool    (* /*func*/ )(
+            unsigned char * /* addr */,
+            short           /* len */,
+            pointer         /* closure */),
+    pointer /*closure*/);
+
+extern int RemoveHost(
+    ClientPtr	/*client*/,
+    int         /*family*/,
+    unsigned    /*length*/,
+    pointer     /*pAddr*/);
+
+extern int GetHosts(
+    pointer * /*data*/,
+    int	    * /*pnHosts*/,
+    int	    * /*pLen*/,
+    BOOL    * /*pEnabled*/);
+
+typedef struct sockaddr * sockaddrPtr;
+
+extern int InvalidHost(sockaddrPtr /*saddr*/, int /*len*/, ClientPtr client);
+
+extern int LocalClient(ClientPtr /* client */);
+
+extern int LocalClientCred(ClientPtr, int *, int *);
+
+extern int ChangeAccessControl(ClientPtr /*client*/, int /*fEnabled*/);
+
+extern int GetAccessControl(void);
+
+
+extern void AddLocalHosts(void);
+
+extern void ResetHosts(char *display);
+
+extern void EnableLocalHost(void);
+
+extern void DisableLocalHost(void);
+
+extern void AccessUsingXdmcp(void);
+
+extern void DefineSelf(int /*fd*/);
+
+extern void AugmentSelf(pointer /*from*/, int /*len*/);
+
+extern void InitAuthorization(char * /*filename*/);
+
+/* extern int LoadAuthorization(void); */
+
+extern void RegisterAuthorizations(void);
+
+extern XID AuthorizationToID (
+	unsigned short	name_length,
+	char		*name,
+	unsigned short	data_length,
+	char		*data);
+
+extern int AuthorizationFromID (
+	XID 		id,
+	unsigned short	*name_lenp,
+	char		**namep,
+	unsigned short	*data_lenp,
+	char		**datap);
+
+extern XID CheckAuthorization(
+    unsigned int /*namelength*/,
+    char * /*name*/,
+    unsigned int /*datalength*/,
+    char * /*data*/,
+    ClientPtr /*client*/,
+    char ** /*reason*/
+);
+
+extern void ResetAuthorization(void);
+
+extern int RemoveAuthorization (
+    unsigned short	name_length,
+    char		*name,
+    unsigned short	data_length,
+    char		*data);
+
+extern int AddAuthorization(
+    unsigned int	/*name_length*/,
+    char *		/*name*/,
+    unsigned int	/*data_length*/,
+    char *		/*data*/);
+
+extern XID GenerateAuthorization(
+    unsigned int   /* name_length */,
+    char	*  /* name */,
+    unsigned int   /* data_length */,
+    char	*  /* data */,
+    unsigned int * /* data_length_return */,
+    char	** /* data_return */);
+
+#ifdef COMMANDLINE_CHALLENGED_OPERATING_SYSTEMS
+extern void ExpandCommandLine(int * /*pargc*/, char *** /*pargv*/);
+#endif
+
+extern void ddxInitGlobals(void);
+
+extern int ddxProcessArgument(int /*argc*/, char * /*argv*/ [], int /*i*/);
+
+extern void ddxUseMsg(void);
+
+/*
+ *  idiom processing stuff
+ */
+
+extern xReqPtr PeekNextRequest(xReqPtr req, ClientPtr client, Bool readmore);
+
+extern void SkipRequests(xReqPtr req, ClientPtr client, int numskipped);
+
+/* int ReqLen(xReq *req, ClientPtr client)
+ * Given a pointer to a *complete* request, return its length in bytes.
+ * Note that if the request is a big request (as defined in the Big
+ * Requests extension), the macro lies by returning 4 less than the
+ * length that it actually occupies in the request buffer.  This is so you
+ * can blindly compare the length with the various sz_&lt;request&gt; constants
+ * in Xproto.h without having to know/care about big requests.
+ */
+#define ReqLen(_pxReq, _client) \
+ ((_pxReq-&gt;length ? \
+     (_client-&gt;swapped ? lswaps(_pxReq-&gt;length) : _pxReq-&gt;length) \
+  : ((_client-&gt;swapped ? \
+	lswapl(((CARD32*)_pxReq)[1]) : ((CARD32*)_pxReq)[1])-1) \
+  ) &lt;&lt; 2)
+
+/* otherReqTypePtr CastxReq(xReq *req, otherReqTypePtr)
+ * Cast the given request to one of type otherReqTypePtr to access
+ * fields beyond the length field.
+ */
+#define CastxReq(_pxReq, otherReqTypePtr) \
+    (_pxReq-&gt;length ? (otherReqTypePtr)_pxReq \
+		    : (otherReqTypePtr)(((CARD32*)_pxReq)+1))
+
+/* stuff for SkippedRequestsCallback */
+extern CallbackListPtr SkippedRequestsCallback;
+typedef struct {
+    xReqPtr req;
+    ClientPtr client;
+    int numskipped;
+} SkippedRequestInfoRec;
+
+/* stuff for ReplyCallback */
+extern CallbackListPtr ReplyCallback;
+typedef struct {
+    ClientPtr client;
+    pointer replyData;
+    unsigned long dataLenBytes;
+    unsigned long bytesRemaining;
+    Bool startOfReply;
+} ReplyInfoRec;
+
+/* stuff for FlushCallback */
+extern CallbackListPtr FlushCallback;
+
+extern void AbortDDX(void);
+extern void ddxGiveUp(void);
+extern int TimeSinceLastInputEvent(void);
+
+/* Logging. */
+typedef enum _LogParameter {
+    XLOG_FLUSH,
+    XLOG_SYNC,
+    XLOG_VERBOSITY,
+    XLOG_FILE_VERBOSITY
+} LogParameter;
+
+/* Flags for log messages. */
+typedef enum {
+    X_PROBED,			/* Value was probed */
+    X_CONFIG,			/* Value was given in the config file */
+    X_DEFAULT,			/* Value is a default */
+    X_CMDLINE,			/* Value was given on the command line */
+    X_NOTICE,			/* Notice */
+    X_ERROR,			/* Error message */
+    X_WARNING,			/* Warning message */
+    X_INFO,			/* Informational message */
+    X_NONE,			/* No prefix */
+    X_NOT_IMPLEMENTED,		/* Not implemented */
+    X_UNKNOWN = -1		/* unknown -- this must always be last */
+} MessageType;
+
+/* XXX Need to check which GCC versions have the format(printf) attribute. */
+#if defined(__GNUC__) &amp;&amp; \
+    ((__GNUC__ &gt; 2) || ((__GNUC__ == 2) &amp;&amp; (__GNUC_MINOR__ &gt; 4)))
+#define _printf_attribute(a,b) __attribute((format(__printf__,a,b)))
+#else
+#define _printf_attribute(a,b) /**/
+#endif
+
+extern const char *LogInit(const char *fname, const char *backup);
+extern void LogClose(void);
+extern Bool LogSetParameter(LogParameter param, int value);
+extern void LogVWrite(int verb, const char *f, va_list args);
+extern void LogWrite(int verb, const char *f, ...) _printf_attribute(2,3);
+extern void LogVMessageVerb(MessageType type, int verb, const char *format,
+			    va_list args);
+extern void LogMessageVerb(MessageType type, int verb, const char *format,
+			   ...) _printf_attribute(3,4);
+extern void LogMessage(MessageType type, const char *format, ...)
+			_printf_attribute(2,3);
+extern void FreeAuditTimer(void);
+extern void AuditF(const char *f, ...) _printf_attribute(1,2);
+extern void VAuditF(const char *f, va_list args);
+extern void FatalError(const char *f, ...) _printf_attribute(1,2)
+#if defined(__GNUC__) &amp;&amp; \
+    ((__GNUC__ &gt; 2) || ((__GNUC__ == 2) &amp;&amp; (__GNUC_MINOR__ &gt; 4)))
+__attribute((noreturn))
+#endif
+;
+
+extern void VErrorF(const char *f, va_list args);
+extern void ErrorF(const char *f, ...) _printf_attribute(1,2);
+extern void Error(char *str);
+extern void LogPrintMarkers(void);
+
+#if defined(NEED_SNPRINTF) &amp;&amp; !defined(IN_MODULE)
+extern int snprintf(char *str, size_t size, const char *format, ...)
+	_printf_attribute(3,4);
+extern int vsnprintf(char *str, size_t size, const char *format, va_list ap);
+#endif
+
+#endif /* OS_H */
diff --git a/X11/Xprotostr.h b/X11/pixmap.h
similarity index 61%
copy from X11/Xprotostr.h
copy to X11/pixmap.h
index f343d98..6cea329 100644
--- a/X11/Xprotostr.h
+++ b/X11/pixmap.h
@@ -1,7 +1,4 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
+/* $Xorg: pixmap.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
@@ -48,31 +45,66 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
+/* $XFree86$ */
+
+#ifndef PIXMAP_H
+#define PIXMAP_H
+
+#include &quot;misc.h&quot;
+#include &quot;screenint.h&quot;
+
+/* types for Drawable */
+#define DRAWABLE_WINDOW 0
+#define DRAWABLE_PIXMAP 1
+#define UNDRAWABLE_WINDOW 2
+#define DRAWABLE_BUFFER 3
+
+/* flags to PaintWindow() */
+#define PW_BACKGROUND 0
+#define PW_BORDER 1
+
+#define NullPixmap ((PixmapPtr)0)
+
+typedef struct _Drawable *DrawablePtr;	
+typedef struct _Pixmap *PixmapPtr;
+
+typedef union _PixUnion {
+    PixmapPtr		pixmap;
+    unsigned long	pixel;
+} PixUnion;
+
+#define SamePixUnion(a,b,isPixel)\
+    ((isPixel) ? (a).pixel == (b).pixel : (a).pixmap == (b).pixmap)
+
+#define EqualPixUnion(as, a, bs, b)				\
+    ((as) == (bs) &amp;&amp; (SamePixUnion (a, b, as)))
 
-/* Used by PolySegment */
+#define OnScreenDrawable(type) \
+	((type == DRAWABLE_WINDOW) || (type == DRAWABLE_BUFFER))
 
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
+#define WindowDrawable(type) \
+	((type == DRAWABLE_WINDOW) || (type == UNDRAWABLE_WINDOW))
 
-/* POINT */
+extern PixmapPtr GetScratchPixmapHeader(
+    ScreenPtr /*pScreen*/,
+    int /*width*/,
+    int /*height*/,
+    int /*depth*/,
+    int /*bitsPerPixel*/,
+    int /*devKind*/,
+    pointer /*pPixData*/);
 
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
+extern void FreeScratchPixmapHeader(
+    PixmapPtr /*pPixmap*/);
 
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
+extern Bool CreateScratchPixmapsForScreen(
+    int /*scrnum*/);
 
-/*  ARC  */
+extern void FreeScratchPixmapsForScreen(
+    int /*scrnum*/);
 
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
+extern PixmapPtr AllocatePixmap(
+    ScreenPtr /*pScreen*/,
+    int /*pixDataSize*/);
 
-#endif /* XPROTOSTRUCTS_H */
+#endif /* PIXMAP_H */
diff --git a/X11/Xprotostr.h b/X11/pixmapstr.h
similarity index 69%
copy from X11/Xprotostr.h
copy to X11/pixmapstr.h
index f343d98..22a1f10 100644
--- a/X11/Xprotostr.h
+++ b/X11/pixmapstr.h
@@ -1,7 +1,4 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
+/* $Xorg: pixmapstr.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
@@ -48,31 +45,44 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
-
-/* Used by PolySegment */
-
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
-
-/* POINT */
-
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
-
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
-
-/*  ARC  */
-
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
-
-#endif /* XPROTOSTRUCTS_H */
+/* $XFree86$ */
+
+#ifndef PIXMAPSTRUCT_H
+#define PIXMAPSTRUCT_H
+#include &quot;pixmap.h&quot;
+#include &quot;screenint.h&quot;
+#include &quot;regionstr.h&quot;
+
+typedef struct _Drawable {
+    unsigned char	type;	/* DRAWABLE_&lt;type&gt; */
+    unsigned char	class;	/* specific to type */
+    unsigned char	depth;
+    unsigned char	bitsPerPixel;
+    unsigned long	id;	/* resource id */
+    short		x;	/* window: screen absolute, pixmap: 0 */
+    short		y;	/* window: screen absolute, pixmap: 0 */
+    unsigned short	width;
+    unsigned short	height;
+    ScreenPtr		pScreen;
+    unsigned long	serialNumber;
+} DrawableRec;
+
+/*
+ * PIXMAP -- device dependent 
+ */
+
+typedef struct _Pixmap {
+    DrawableRec		drawable;
+    int			refcnt;
+    int			devKind;
+    DevUnion		devPrivate;
+#ifdef PIXPRIV
+    DevUnion		*devPrivates; /* real devPrivates like gcs &amp; windows */
+#endif
+#ifdef COMPOSITE
+    short		screen_x;
+    short		screen_y;
+#endif
+} PixmapRec;
+
+#endif /* PIXMAPSTRUCT_H */
diff --git a/X11/Xprotostr.h b/X11/property.h
similarity index 78%
copy from X11/Xprotostr.h
copy to X11/property.h
index f343d98..21a38d5 100644
--- a/X11/Xprotostr.h
+++ b/X11/property.h
@@ -1,7 +1,4 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
+/* $Xorg: property.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
@@ -48,31 +45,30 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
-
-/* Used by PolySegment */
+/* $XFree86: xc/programs/Xserver/include/property.h,v 1.3 2001/12/14 19:59:55 dawes Exp $ */
 
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
+#ifndef PROPERTY_H
+#define PROPERTY_H 
 
-/* POINT */
+#include &quot;window.h&quot;
 
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
+typedef struct _Property *PropertyPtr;
 
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
+extern int ChangeWindowProperty(
+    WindowPtr /*pWin*/,
+    Atom /*property*/,
+    Atom /*type*/,
+    int /*format*/,
+    int /*mode*/,
+    unsigned long /*len*/,
+    pointer /*value*/,
+    Bool /*sendevent*/);
 
-/*  ARC  */
+extern int DeleteProperty(
+    WindowPtr /*pWin*/,
+    Atom /*propName*/);
 
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
+extern void DeleteAllWindowProperties(
+    WindowPtr /*pWin*/);
 
-#endif /* XPROTOSTRUCTS_H */
+#endif  /* PROPERTY_H */
diff --git a/X11/Xprotostr.h b/X11/propertyst.h
similarity index 70%
copy from X11/Xprotostr.h
copy to X11/propertyst.h
index f343d98..177fca1 100644
--- a/X11/Xprotostr.h
+++ b/X11/propertyst.h
@@ -1,7 +1,4 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
+/* $Xorg: propertyst.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
@@ -48,31 +45,32 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
-
-/* Used by PolySegment */
-
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
-
-/* POINT */
-
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
-
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
-
-/*  ARC  */
-
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
+/* $XFree86: xc/programs/Xserver/include/propertyst.h,v 3.2 2001/01/17 22:36:57 dawes Exp $ */
+
+#ifndef PROPERTYSTRUCT_H
+#define PROPERTYSTRUCT_H 
+#include &quot;misc.h&quot;
+#include &quot;property.h&quot;
+/* 
+ *   PROPERTY -- property element
+ */
+
+typedef struct _Property {
+        struct _Property       *next;
+	ATOM 		propertyName;
+	ATOM		type;       /* ignored by server */
+	short		format;     /* format of data for swapping - 8,16,32 */
+	long		size;       /* size of data in (format/8) bytes */
+	pointer         data;       /* private to client */
+#if defined(LBX) || defined(LBX_COMPAT)
+	/*  If space is at a premium and binary compatibility is not
+	 *  an issue, you may want to put the owner_pid next to format
+	 *  so that the two shorts pack together without padding.
+	 */
+  	short		owner_pid;	/* proxy that has the data */
+  	XID		tag_id;
+#endif
+} PropertyRec;
+
+#endif /* PROPERTYSTRUCT_H */
 
-#endif /* XPROTOSTRUCTS_H */
diff --git a/X11/Xprotostr.h b/X11/region.h
similarity index 79%
copy from X11/Xprotostr.h
copy to X11/region.h
index f343d98..0340b0d 100644
--- a/X11/Xprotostr.h
+++ b/X11/region.h
@@ -1,7 +1,4 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
+/* $Xorg: region.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
@@ -48,31 +45,10 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
-
-/* Used by PolySegment */
-
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
-
-/* POINT */
-
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
-
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
 
-/*  ARC  */
+#ifndef REGION_H
+#define REGION_H
 
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
+#include &quot;regionstr.h&quot;
 
-#endif /* XPROTOSTRUCTS_H */
+#endif /* REGION_H */
diff --git a/X11/regionstr.h b/X11/regionstr.h
new file mode 100644
index 0000000..000bf3f
--- /dev/null
+++ b/X11/regionstr.h
@@ -0,0 +1,412 @@
+/* $XdotOrg: xc/programs/Xserver/include/regionstr.h,v 1.7 2005/08/24 11:18:31 daniels Exp $ */
+/* $Xorg: regionstr.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $XFree86: xc/programs/Xserver/include/regionstr.h,v 1.12tsi Exp $ */
+
+#ifndef REGIONSTRUCT_H
+#define REGIONSTRUCT_H
+
+typedef struct _Region RegionRec, *RegionPtr;
+
+#include &quot;miscstruct.h&quot;
+
+/* Return values from RectIn() */
+
+#define rgnOUT 0
+#define rgnIN  1
+#define rgnPART 2
+
+#define NullRegion ((RegionPtr)0)
+
+/*
+ *   clip region
+ */
+
+typedef struct _RegData {
+    long	size;
+    long 	numRects;
+/*  BoxRec	rects[size];   in memory but not explicitly declared */
+} RegDataRec, *RegDataPtr;
+
+struct _Region {
+    BoxRec 	extents;
+    RegDataPtr	data;
+};
+
+extern BoxRec miEmptyBox;
+extern RegDataRec miEmptyData;
+extern RegDataRec miBrokenData;
+
+#define REGION_NIL(reg) ((reg)-&gt;data &amp;&amp; !(reg)-&gt;data-&gt;numRects)
+/* not a region */
+#define REGION_NAR(reg)	((reg)-&gt;data == &amp;miBrokenData)
+#define REGION_NUM_RECTS(reg) ((reg)-&gt;data ? (reg)-&gt;data-&gt;numRects : 1)
+#define REGION_SIZE(reg) ((reg)-&gt;data ? (reg)-&gt;data-&gt;size : 0)
+#define REGION_RECTS(reg) ((reg)-&gt;data ? (BoxPtr)((reg)-&gt;data + 1) \
+			               : &amp;(reg)-&gt;extents)
+#define REGION_BOXPTR(reg) ((BoxPtr)((reg)-&gt;data + 1))
+#define REGION_BOX(reg,i) (&amp;REGION_BOXPTR(reg)[i])
+#define REGION_TOP(reg) REGION_BOX(reg, (reg)-&gt;data-&gt;numRects)
+#define REGION_END(reg) REGION_BOX(reg, (reg)-&gt;data-&gt;numRects - 1)
+#define REGION_SZOF(n) (sizeof(RegDataRec) + ((n) * sizeof(BoxRec)))
+
+/* Keith recommends weaning the region code of pScreen argument */
+#define REG_pScreen	screenInfo.screens[0]
+
+#ifdef NEED_SCREEN_REGIONS
+
+#define REGION_CREATE(_pScreen, _rect, _size) \
+    (*(REG_pScreen)-&gt;RegionCreate)(_rect, _size)
+
+#define REGION_INIT(_pScreen, _pReg, _rect, _size) \
+    (*(REG_pScreen)-&gt;RegionInit)(_pReg, _rect, _size)
+
+#define REGION_COPY(_pScreen, dst, src) \
+    (*(REG_pScreen)-&gt;RegionCopy)(dst, src)
+
+#define REGION_DESTROY(_pScreen, _pReg) \
+    (*(REG_pScreen)-&gt;RegionDestroy)(_pReg)
+
+#define REGION_UNINIT(_pScreen, _pReg) \
+    (*(REG_pScreen)-&gt;RegionUninit)(_pReg)
+
+#define REGION_INTERSECT(_pScreen, newReg, reg1, reg2) \
+    (*(REG_pScreen)-&gt;Intersect)(newReg, reg1, reg2)
+
+#define REGION_UNION(_pScreen, newReg, reg1, reg2) \
+    (*(REG_pScreen)-&gt;Union)(newReg, reg1, reg2)
+
+#define REGION_SUBTRACT(_pScreen, newReg, reg1, reg2) \
+    (*(REG_pScreen)-&gt;Subtract)(newReg, reg1, reg2)
+
+#define REGION_INVERSE(_pScreen, newReg, reg1, invRect) \
+    (*(REG_pScreen)-&gt;Inverse)(newReg, reg1, invRect)
+
+#define REGION_RESET(_pScreen, _pReg, _pBox) \
+    (*(REG_pScreen)-&gt;RegionReset)(_pReg, _pBox)
+
+#define REGION_TRANSLATE(_pScreen, _pReg, _x, _y) \
+    (*(REG_pScreen)-&gt;TranslateRegion)(_pReg, _x, _y)
+
+#define RECT_IN_REGION(_pScreen, _pReg, prect) \
+    (*(REG_pScreen)-&gt;RectIn)(_pReg, prect)
+
+#define POINT_IN_REGION(_pScreen, _pReg, _x, _y, prect) \
+    (*(REG_pScreen)-&gt;PointInRegion)(_pReg, _x, _y, prect)
+
+#define REGION_NOTEMPTY(_pScreen, _pReg) \
+    (*(REG_pScreen)-&gt;RegionNotEmpty)(_pReg)
+
+#define REGION_EQUAL(_pScreen, _pReg1, _pReg2) \
+    (*(REG_pScreen)-&gt;RegionEqual)(_pReg1, _pReg2)
+
+#define REGION_BROKEN(_pScreen, _pReg) \
+    (*(REG_pScreen)-&gt;RegionBroken)(_pReg)
+
+#define REGION_BREAK(_pScreen, _pReg) \
+    (*(REG_pScreen)-&gt;RegionBreak)(_pReg)
+
+#define REGION_EMPTY(_pScreen, _pReg) \
+    (*(REG_pScreen)-&gt;RegionEmpty)(_pReg)
+
+#define REGION_EXTENTS(_pScreen, _pReg) \
+    (*(REG_pScreen)-&gt;RegionExtents)(_pReg)
+
+#define REGION_APPEND(_pScreen, dstrgn, rgn) \
+    (*(REG_pScreen)-&gt;RegionAppend)(dstrgn, rgn)
+
+#define REGION_VALIDATE(_pScreen, badreg, pOverlap) \
+    (*(REG_pScreen)-&gt;RegionValidate)(badreg, pOverlap)
+
+#define BITMAP_TO_REGION(_pScreen, pPix) \
+    (*(REG_pScreen)-&gt;BitmapToRegion)(pPix)
+
+#define RECTS_TO_REGION(_pScreen, nrects, prect, ctype) \
+    (*(REG_pScreen)-&gt;RectsToRegion)(nrects, prect, ctype)
+
+#else /* !NEED_SCREEN_REGIONS */
+
+/* Reference _pScreen macro argument and check its type */
+#define REGION_SCREEN(_pScreen) (void)((REG_pScreen)-&gt;myNum)
+
+#define REGION_CREATE(_pScreen, _rect, _size) \
+    (REGION_SCREEN(_pScreen), miRegionCreate(_rect, _size))
+
+#define REGION_COPY(_pScreen, dst, src) \
+    (REGION_SCREEN(_pScreen), miRegionCopy(dst, src))
+
+#define REGION_DESTROY(_pScreen, _pReg) \
+    (REGION_SCREEN(_pScreen), miRegionDestroy(_pReg))
+
+#define REGION_INTERSECT(_pScreen, newReg, reg1, reg2) \
+    (REGION_SCREEN(_pScreen), miIntersect(newReg, reg1, reg2))
+
+#define REGION_UNION(_pScreen, newReg, reg1, reg2) \
+    (REGION_SCREEN(_pScreen), miUnion(newReg, reg1, reg2))
+
+#define REGION_SUBTRACT(_pScreen, newReg, reg1, reg2) \
+    (REGION_SCREEN(_pScreen), miSubtract(newReg, reg1, reg2))
+
+#define REGION_INVERSE(_pScreen, newReg, reg1, invRect) \
+    (REGION_SCREEN(_pScreen), miInverse(newReg, reg1, invRect))
+
+#define REGION_TRANSLATE(_pScreen, _pReg, _x, _y) \
+    (REGION_SCREEN(_pScreen), miTranslateRegion(_pReg, _x, _y))
+
+#define RECT_IN_REGION(_pScreen, _pReg, prect) \
+    (REGION_SCREEN(_pScreen), miRectIn(_pReg, prect))
+
+#define POINT_IN_REGION(_pScreen, _pReg, _x, _y, prect) \
+    (REGION_SCREEN(_pScreen), miPointInRegion(_pReg, _x, _y, prect))
+
+#define REGION_APPEND(_pScreen, dstrgn, rgn) \
+    (REGION_SCREEN(_pScreen), miRegionAppend(dstrgn, rgn))
+
+#define REGION_VALIDATE(_pScreen, badreg, pOverlap) \
+    (REGION_SCREEN(_pScreen), miRegionValidate(badreg, pOverlap))
+
+#define BITMAP_TO_REGION(_pScreen, pPix) \
+    (*(_pScreen)-&gt;BitmapToRegion)(pPix) /* no mi version?! */
+
+#define RECTS_TO_REGION(_pScreen, nrects, prect, ctype) \
+    (REGION_SCREEN(_pScreen), miRectsToRegion(nrects, prect, ctype))
+
+#define REGION_EQUAL(_pScreen, _pReg1, _pReg2) \
+    (REGION_SCREEN(_pScreen), miRegionEqual(_pReg1, _pReg2))
+
+#define REGION_BREAK(_pScreen, _pReg) \
+    (REGION_SCREEN(_pScreen), miRegionBreak(_pReg))
+
+#ifdef DONT_INLINE_REGION_OPS
+
+#define REGION_INIT(_pScreen, _pReg, _rect, _size) \
+    (REGION_SCREEN(_pScreen), miRegionInit(_pReg, _rect, _size))
+
+#define REGION_UNINIT(_pScreen, _pReg) \
+    (REGION_SCREEN(_pScreen), miRegionUninit(_pReg))
+
+#define REGION_RESET(_pScreen, _pReg, _pBox) \
+    (REGION_SCREEN(_pScreen), miRegionReset(_pReg, _pBox))
+
+#define REGION_NOTEMPTY(_pScreen, _pReg) \
+    (REGION_SCREEN(_pScreen), miRegionNotEmpty(_pReg))
+
+#define REGION_BROKEN(_pScreen, _pReg) \
+    (REGION_SCREEN(_pScreen), miRegionBroken(_pReg))
+
+#define REGION_EMPTY(_pScreen, _pReg) \
+    (REGION_SCREEN(_pScreen), miRegionEmpty(_pReg))
+
+#define REGION_EXTENTS(_pScreen, _pReg) \
+    (REGION_SCREEN(_pScreen), miRegionExtents(_pReg))
+
+#else /* inline certain simple region ops for performance */
+
+#define REGION_INIT(_pScreen, _pReg, _rect, _size) \
+{ \
+    REGION_SCREEN(_pScreen); \
+    if (_rect) \
+    { \
+        (_pReg)-&gt;extents = *(_rect); \
+        (_pReg)-&gt;data = (RegDataPtr)NULL; \
+    } \
+    else \
+    { \
+        (_pReg)-&gt;extents = miEmptyBox; \
+        if (((_size) &gt; 1) &amp;&amp; ((_pReg)-&gt;data = \
+                             (RegDataPtr)xalloc(REGION_SZOF(_size)))) \
+        { \
+            (_pReg)-&gt;data-&gt;size = (_size); \
+            (_pReg)-&gt;data-&gt;numRects = 0; \
+        } \
+        else \
+            (_pReg)-&gt;data = &miEmptyData; \
+    } \
+ }
+
+
+#define REGION_UNINIT(_pScreen, _pReg) \
+{ \
+    REGION_SCREEN(_pScreen); \
+    if ((_pReg)-&gt;data &amp;&amp; (_pReg)-&gt;data-&gt;size) { \
+	xfree((_pReg)-&gt;data); \
+	(_pReg)-&gt;data = NULL; \
+    } \
+}
+
+#define REGION_RESET(_pScreen, _pReg, _pBox) \
+{ \
+    REGION_SCREEN(_pScreen); \
+    (_pReg)-&gt;extents = *(_pBox); \
+    REGION_UNINIT(_pScreen, _pReg); \
+    (_pReg)-&gt;data = (RegDataPtr)NULL; \
+}
+
+#define REGION_NOTEMPTY(_pScreen, _pReg) \
+    (REGION_SCREEN(_pScreen), !REGION_NIL(_pReg))
+
+#define REGION_BROKEN(_pScreen, _pReg) \
+    (REGION_SCREEN(_pScreen), REGION_NAR(_pReg))
+
+#define REGION_EMPTY(_pScreen, _pReg) \
+{ \
+    REGION_UNINIT(_pScreen, _pReg); \
+    (_pReg)-&gt;extents.x2 = (_pReg)-&gt;extents.x1; \
+    (_pReg)-&gt;extents.y2 = (_pReg)-&gt;extents.y1; \
+    (_pReg)-&gt;data = &miEmptyData; \
+}
+
+#define REGION_EXTENTS(_pScreen, _pReg) \
+    (REGION_SCREEN(_pScreen), &amp;(_pReg)-&gt;extents)
+
+#define REGION_NULL(_pScreen, _pReg) \
+{ \
+    REGION_SCREEN(_pScreen); \
+    (_pReg)-&gt;extents = miEmptyBox; \
+    (_pReg)-&gt;data = &miEmptyData; \
+}
+
+#endif /* DONT_INLINE_REGION_OPS */
+
+#endif /* NEED_SCREEN_REGIONS */
+
+#ifndef REGION_NULL
+#define REGION_NULL(_pScreen, _pReg) \
+    REGION_INIT(_pScreen, _pReg, NullBox, 1)
+#endif
+
+/* moved from mi.h */
+
+extern RegionPtr miRegionCreate(
+    BoxPtr /*rect*/,
+    int /*size*/);
+
+extern void miRegionInit(
+    RegionPtr /*pReg*/,
+    BoxPtr /*rect*/,
+    int /*size*/);
+
+extern void miRegionDestroy(
+    RegionPtr /*pReg*/);
+
+extern void miRegionUninit(
+    RegionPtr /*pReg*/);
+
+extern Bool miRegionCopy(
+    RegionPtr /*dst*/,
+    RegionPtr /*src*/);
+
+extern Bool miIntersect(
+    RegionPtr /*newReg*/,
+    RegionPtr /*reg1*/,
+    RegionPtr /*reg2*/);
+
+extern Bool miUnion(
+    RegionPtr /*newReg*/,
+    RegionPtr /*reg1*/,
+    RegionPtr /*reg2*/);
+
+extern Bool miRegionAppend(
+    RegionPtr /*dstrgn*/,
+    RegionPtr /*rgn*/);
+
+extern Bool miRegionValidate(
+    RegionPtr /*badreg*/,
+    Bool * /*pOverlap*/);
+
+extern RegionPtr miRectsToRegion(
+    int /*nrects*/,
+    xRectanglePtr /*prect*/,
+    int /*ctype*/);
+
+extern Bool miSubtract(
+    RegionPtr /*regD*/,
+    RegionPtr /*regM*/,
+    RegionPtr /*regS*/);
+
+extern Bool miInverse(
+    RegionPtr /*newReg*/,
+    RegionPtr /*reg1*/,
+    BoxPtr /*invRect*/);
+
+extern int miRectIn(
+    RegionPtr /*region*/,
+    BoxPtr /*prect*/);
+
+extern void miTranslateRegion(
+    RegionPtr /*pReg*/,
+    int /*x*/,
+    int /*y*/);
+
+extern void miRegionReset(
+    RegionPtr /*pReg*/,
+    BoxPtr /*pBox*/);
+
+extern Bool miRegionBreak(
+    RegionPtr /*pReg*/);
+
+extern Bool miPointInRegion(
+    RegionPtr /*pReg*/,
+    int /*x*/,
+    int /*y*/,
+    BoxPtr /*box*/);
+
+extern Bool miRegionEqual(
+    RegionPtr /*pReg1*/,
+    RegionPtr /*pReg2*/);
+
+extern Bool miRegionNotEmpty(
+    RegionPtr /*pReg*/);
+
+extern void miRegionEmpty(
+    RegionPtr /*pReg*/);
+
+extern BoxPtr miRegionExtents(
+    RegionPtr /*pReg*/);
+
+#endif /* REGIONSTRUCT_H */
diff --git a/X11/resource.h b/X11/resource.h
new file mode 100644
index 0000000..49c1898
--- /dev/null
+++ b/X11/resource.h
@@ -0,0 +1,274 @@
+/* $Xorg: resource.h,v 1.5 2001/02/09 02:05:15 xorgcvs Exp $ */
+/***********************************************************
+
+Copyright 1987, 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987, 1989 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $XFree86: xc/programs/Xserver/include/resource.h,v 1.11 2002/03/06 21:14:04 mvojkovi Exp $ */
+
+#ifndef RESOURCE_H
+#define RESOURCE_H 1
+#include &quot;misc.h&quot;
+
+/*****************************************************************
+ * STUFF FOR RESOURCES 
+ *****************************************************************/
+
+/* classes for Resource routines */
+
+typedef unsigned long RESTYPE;
+
+#define RC_VANILLA	((RESTYPE)0)
+#define RC_CACHED	((RESTYPE)1&lt;&lt;31)
+#define RC_DRAWABLE	((RESTYPE)1&lt;&lt;30)
+/*  Use class RC_NEVERRETAIN for resources that should not be retained
+ *  regardless of the close down mode when the client dies.  (A client's
+ *  event selections on objects that it doesn't own are good candidates.)
+ *  Extensions can use this too!
+ */
+#define RC_NEVERRETAIN	((RESTYPE)1&lt;&lt;29)
+#define RC_LASTPREDEF	RC_NEVERRETAIN
+#define RC_ANY		(~(RESTYPE)0)
+
+/* types for Resource routines */
+
+#define RT_WINDOW	((RESTYPE)1|RC_CACHED|RC_DRAWABLE)
+#define RT_PIXMAP	((RESTYPE)2|RC_CACHED|RC_DRAWABLE)
+#define RT_GC		((RESTYPE)3|RC_CACHED)
+#undef RT_FONT
+#undef RT_CURSOR
+#define RT_FONT		((RESTYPE)4)
+#define RT_CURSOR	((RESTYPE)5)
+#define RT_COLORMAP	((RESTYPE)6)
+#define RT_CMAPENTRY	((RESTYPE)7)
+#define RT_OTHERCLIENT	((RESTYPE)8|RC_NEVERRETAIN)
+#define RT_PASSIVEGRAB	((RESTYPE)9|RC_NEVERRETAIN)
+#define RT_LASTPREDEF	((RESTYPE)9)
+#define RT_NONE		((RESTYPE)0)
+
+/* bits and fields within a resource id */
+#define RESOURCE_AND_CLIENT_COUNT   29			/* 29 bits for XIDs */
+#if MAXCLIENTS == 64
+#define RESOURCE_CLIENT_BITS	6
+#endif
+#if MAXCLIENTS == 128
+#define RESOURCE_CLIENT_BITS	7
+#endif
+#if MAXCLIENTS == 256
+#define RESOURCE_CLIENT_BITS	8
+#endif
+#if MAXCLIENTS == 512
+#define RESOURCE_CLIENT_BITS	9
+#endif
+/* client field offset */
+#define CLIENTOFFSET	    (RESOURCE_AND_CLIENT_COUNT - RESOURCE_CLIENT_BITS)
+/* resource field */
+#define RESOURCE_ID_MASK	((1 &lt;&lt; CLIENTOFFSET) - 1)
+/* client field */
+#define RESOURCE_CLIENT_MASK	(((1 &lt;&lt; RESOURCE_CLIENT_BITS) - 1) &lt;&lt; CLIENTOFFSET)
+/* extract the client mask from an XID */
+#define CLIENT_BITS(id) ((id) &amp; RESOURCE_CLIENT_MASK)
+/* extract the client id from an XID */
+#define CLIENT_ID(id) ((int)(CLIENT_BITS(id) &gt;&gt; CLIENTOFFSET))
+#define SERVER_BIT		(Mask)0x40000000	/* use illegal bit */
+
+#ifdef INVALID
+#undef INVALID	/* needed on HP/UX */
+#endif
+
+/* Invalid resource id */
+#define INVALID	(0)
+
+#define BAD_RESOURCE 0xe0000000
+
+typedef int (*DeleteType)(
+    pointer /*value*/,
+    XID /*id*/);
+
+typedef void (*FindResType)(
+    pointer /*value*/,
+    XID /*id*/,
+    pointer /*cdata*/);
+
+typedef void (*FindAllRes)(
+    pointer /*value*/,
+    XID /*id*/,
+    RESTYPE /*type*/,
+    pointer /*cdata*/);
+
+typedef Bool (*FindComplexResType)(
+    pointer /*value*/,
+    XID /*id*/,
+    pointer /*cdata*/);
+
+extern RESTYPE CreateNewResourceType(
+    DeleteType /*deleteFunc*/);
+
+extern RESTYPE CreateNewResourceClass(void);
+
+extern Bool InitClientResources(
+    ClientPtr /*client*/);
+
+extern XID FakeClientID(
+    int /*client*/);
+
+/* Quartz support on Mac OS X uses the CarbonCore
+   framework whose AddResource function conflicts here. */
+#ifdef __DARWIN__
+#define AddResource Darwin_X_AddResource
+#endif
+extern Bool AddResource(
+    XID /*id*/,
+    RESTYPE /*type*/,
+    pointer /*value*/);
+
+extern void FreeResource(
+    XID /*id*/,
+    RESTYPE /*skipDeleteFuncType*/);
+
+extern void FreeResourceByType(
+    XID /*id*/,
+    RESTYPE /*type*/,
+    Bool /*skipFree*/);
+
+extern Bool ChangeResourceValue(
+    XID /*id*/,
+    RESTYPE /*rtype*/,
+    pointer /*value*/);
+
+extern void FindClientResourcesByType(
+    ClientPtr /*client*/,
+    RESTYPE /*type*/,
+    FindResType /*func*/,
+    pointer /*cdata*/);
+
+extern void FindAllClientResources(
+    ClientPtr /*client*/,
+    FindAllRes /*func*/,
+    pointer /*cdata*/);
+
+extern void FreeClientNeverRetainResources(
+    ClientPtr /*client*/);
+
+extern void FreeClientResources(
+    ClientPtr /*client*/);
+
+extern void FreeAllResources(void);
+
+extern Bool LegalNewID(
+    XID /*id*/,
+    ClientPtr /*client*/);
+
+extern pointer LookupIDByType(
+    XID /*id*/,
+    RESTYPE /*rtype*/);
+
+extern pointer LookupIDByClass(
+    XID /*id*/,
+    RESTYPE /*classes*/);
+
+extern pointer LookupClientResourceComplex(
+    ClientPtr client,
+    RESTYPE type,
+    FindComplexResType func,
+    pointer cdata);
+
+/* These are the access modes that can be passed in the last parameter
+ * to SecurityLookupIDByType/Class.  The Security extension doesn't
+ * currently make much use of these; they're mainly provided as an
+ * example of what you might need for discretionary access control.
+ * You can or these values together to indicate multiple modes
+ * simultaneously.
+ */
+
+#define SecurityUnknownAccess	0	/* don't know intentions */
+#define SecurityReadAccess	(1&lt;&lt;0)	/* inspecting the object */
+#define SecurityWriteAccess	(1&lt;&lt;1)	/* changing the object */
+#define SecurityDestroyAccess	(1&lt;&lt;2)	/* destroying the object */
+
+#ifdef XCSECURITY
+
+extern pointer SecurityLookupIDByType(
+    ClientPtr /*client*/,
+    XID /*id*/,
+    RESTYPE /*rtype*/,
+    Mask /*access_mode*/);
+
+extern pointer SecurityLookupIDByClass(
+    ClientPtr /*client*/,
+    XID /*id*/,
+    RESTYPE /*classes*/,
+    Mask /*access_mode*/);
+
+#else /* not XCSECURITY */
+
+#define SecurityLookupIDByType(client, id, rtype, access_mode) \
+        LookupIDByType(id, rtype)
+
+#define SecurityLookupIDByClass(client, id, classes, access_mode) \
+        LookupIDByClass(id, classes)
+
+#endif /* XCSECURITY */
+
+extern void GetXIDRange(
+    int /*client*/,
+    Bool /*server*/,
+    XID * /*minp*/,
+    XID * /*maxp*/);
+
+extern unsigned int GetXIDList(
+    ClientPtr /*client*/,
+    unsigned int /*count*/,
+    XID * /*pids*/);
+
+extern RESTYPE lastResourceType;
+extern RESTYPE TypeMask;
+
+#ifdef XResExtension
+extern Atom *ResourceNames;
+void RegisterResourceName(RESTYPE type, char* name);
+#endif
+
+#endif /* RESOURCE_H */
+
diff --git a/X11/Xprotostr.h b/X11/rgb.h
similarity index 79%
copy from X11/Xprotostr.h
copy to X11/rgb.h
index f343d98..5741a4e 100644
--- a/X11/Xprotostr.h
+++ b/X11/rgb.h
@@ -1,7 +1,3 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
@@ -48,31 +44,11 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
-
-/* Used by PolySegment */
-
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
-
-/* POINT */
-
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
-
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
-
-/*  ARC  */
-
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
-
-#endif /* XPROTOSTRUCTS_H */
+/* $Xorg: rgb.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+
+#ifndef RGB_H
+#define RGB_H
+typedef struct _RGB {
+	unsigned short red, green, blue;
+	} RGB;
+#endif /* RGB_H */
diff --git a/X11/Xprotostr.h b/X11/screenint.h
similarity index 60%
copy from X11/Xprotostr.h
copy to X11/screenint.h
index f343d98..74d5e14 100644
--- a/X11/Xprotostr.h
+++ b/X11/screenint.h
@@ -1,7 +1,4 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
-
+/* $Xorg: screenint.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
@@ -48,31 +45,69 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
+/* $XFree86: xc/programs/Xserver/include/screenint.h,v 1.5 2001/12/14 19:59:56 dawes Exp $ */
+
+#ifndef SCREENINT_H
+#define SCREENINT_H
+
+#include &quot;misc.h&quot;
+
+typedef struct _PixmapFormat *PixmapFormatPtr;
+typedef struct _Visual *VisualPtr;
+typedef struct _Depth  *DepthPtr;
+typedef struct _Screen *ScreenPtr;
+
+extern void ResetScreenPrivates(void);
+
+extern int AllocateScreenPrivateIndex(void);
+
+extern void ResetWindowPrivates(void);
+
+extern int AllocateWindowPrivateIndex(void);
+
+extern Bool AllocateWindowPrivate(
+    ScreenPtr /* pScreen */,
+    int /* index */,
+    unsigned /* amount */);
+
+extern void ResetGCPrivates(void);
+
+extern int AllocateGCPrivateIndex(void);
+
+extern Bool AllocateGCPrivate(
+    ScreenPtr /* pScreen */,
+    int /* index */,
+    unsigned /* amount */);
+
+extern int AddScreen(
+    Bool (* /*pfnInit*/)(
+	int /*index*/,
+	ScreenPtr /*pScreen*/,
+	int /*argc*/,
+	char ** /*argv*/),
+    int /*argc*/,
+    char** /*argv*/);
+
+#ifdef PIXPRIV
+
+extern void ResetPixmapPrivates(void);
 
-/* Used by PolySegment */
+extern int AllocatePixmapPrivateIndex(void);
 
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
+extern Bool AllocatePixmapPrivate(
+    ScreenPtr /* pScreen */,
+    int /* index */,
+    unsigned /* amount */);
 
-/* POINT */
+#endif /* PIXPRIV */
 
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
+extern void ResetColormapPrivates(void);
 
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
 
-/*  ARC  */
+typedef struct _ColormapRec *ColormapPtr;
+typedef int (*InitCmapPrivFunc)(ColormapPtr, int);
 
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
+extern int AllocateColormapPrivateIndex(
+    InitCmapPrivFunc /* initPrivFunc */);
 
-#endif /* XPROTOSTRUCTS_H */
+#endif /* SCREENINT_H */
diff --git a/X11/scrnintstr.h b/X11/scrnintstr.h
new file mode 100644
index 0000000..ef93586
--- /dev/null
+++ b/X11/scrnintstr.h
@@ -0,0 +1,733 @@
+/* $Xorg: scrnintstr.h,v 1.4 2001/02/09 02:05:15 xorgcvs Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $XFree86: xc/programs/Xserver/include/scrnintstr.h,v 1.12 2003/04/27 21:31:05 herrb Exp $ */
+
+#ifndef SCREENINTSTRUCT_H
+#define SCREENINTSTRUCT_H
+
+#include &quot;screenint.h&quot;
+#include &quot;regionstr.h&quot;
+#include &quot;bstore.h&quot;
+#include &quot;colormap.h&quot;
+#include &quot;cursor.h&quot;
+#include &quot;validate.h&quot;
+#include &lt;X11/Xproto.h&gt;
+#include &quot;dix.h&quot;
+
+typedef struct _PixmapFormat {
+    unsigned char	depth;
+    unsigned char	bitsPerPixel;
+    unsigned char	scanlinePad;
+    } PixmapFormatRec;
+    
+typedef struct _Visual {
+    VisualID		vid;
+    short		class;
+    short		bitsPerRGBValue;
+    short		ColormapEntries;
+    short		nplanes;/* = log2 (ColormapEntries). This does not
+				 * imply that the screen has this many planes.
+				 * it may have more or fewer */
+    unsigned long	redMask, greenMask, blueMask;
+    int			offsetRed, offsetGreen, offsetBlue;
+  } VisualRec;
+
+typedef struct _Depth {
+    unsigned char	depth;
+    short		numVids;
+    VisualID		*vids;    /* block of visual ids for this depth */
+  } DepthRec;
+
+
+/*
+ *  There is a typedef for each screen function pointer so that code that
+ *  needs to declare a screen function pointer (e.g. in a screen private
+ *  or as a local variable) can easily do so and retain full type checking.
+ */
+
+typedef    Bool (* CloseScreenProcPtr)(
+	int /*index*/,
+	ScreenPtr /*pScreen*/);
+
+typedef    void (* QueryBestSizeProcPtr)(
+	int /*class*/,
+	unsigned short * /*pwidth*/,
+	unsigned short * /*pheight*/,
+	ScreenPtr /*pScreen*/);
+
+typedef    Bool (* SaveScreenProcPtr)(
+	 ScreenPtr /*pScreen*/,
+	 int /*on*/);
+
+typedef    void (* GetImageProcPtr)(
+	DrawablePtr /*pDrawable*/,
+	int /*sx*/,
+	int /*sy*/,
+	int /*w*/,
+	int /*h*/,
+	unsigned int /*format*/,
+	unsigned long /*planeMask*/,
+	char * /*pdstLine*/);
+
+typedef    void (* GetSpansProcPtr)(
+	DrawablePtr /*pDrawable*/,
+	int /*wMax*/,
+	DDXPointPtr /*ppt*/,
+	int* /*pwidth*/,
+	int /*nspans*/,
+	char * /*pdstStart*/);
+
+typedef    void (* PointerNonInterestBoxProcPtr)(
+	ScreenPtr /*pScreen*/,
+	BoxPtr /*pBox*/);
+
+typedef    void (* SourceValidateProcPtr)(
+	DrawablePtr /*pDrawable*/,
+	int /*x*/,
+	int /*y*/,
+	int /*width*/,
+	int /*height*/);
+
+typedef    Bool (* CreateWindowProcPtr)(
+	WindowPtr /*pWindow*/);
+
+typedef    Bool (* DestroyWindowProcPtr)(
+	WindowPtr /*pWindow*/);
+
+typedef    Bool (* PositionWindowProcPtr)(
+	WindowPtr /*pWindow*/,
+	int /*x*/,
+	int /*y*/);
+
+typedef    Bool (* ChangeWindowAttributesProcPtr)(
+	WindowPtr /*pWindow*/,
+	unsigned long /*mask*/);
+
+typedef    Bool (* RealizeWindowProcPtr)(
+	WindowPtr /*pWindow*/);
+
+typedef    Bool (* UnrealizeWindowProcPtr)(
+	WindowPtr /*pWindow*/);
+
+typedef    void (* RestackWindowProcPtr)(
+	WindowPtr /*pWindow*/,
+	WindowPtr /*pOldNextSib*/);
+
+typedef    int  (* ValidateTreeProcPtr)(
+	WindowPtr /*pParent*/,
+	WindowPtr /*pChild*/,
+	VTKind /*kind*/);
+
+typedef    void (* PostValidateTreeProcPtr)(
+	WindowPtr /*pParent*/,
+	WindowPtr /*pChild*/,
+	VTKind /*kind*/);
+
+typedef    void (* WindowExposuresProcPtr)(
+	WindowPtr /*pWindow*/,
+	RegionPtr /*prgn*/,
+	RegionPtr /*other_exposed*/);
+
+typedef    void (* PaintWindowProcPtr)(
+	WindowPtr /*pWindow*/,
+	RegionPtr /*pRegion*/,
+	int /*what*/);
+
+typedef PaintWindowProcPtr PaintWindowBackgroundProcPtr;
+typedef PaintWindowProcPtr PaintWindowBorderProcPtr;
+
+typedef    void (* CopyWindowProcPtr)(
+	WindowPtr /*pWindow*/,
+	DDXPointRec /*ptOldOrg*/,
+	RegionPtr /*prgnSrc*/);
+
+typedef    void (* ClearToBackgroundProcPtr)(
+	WindowPtr /*pWindow*/,
+	int /*x*/,
+	int /*y*/,
+	int /*w*/,
+	int /*h*/,
+	Bool /*generateExposures*/);
+
+typedef    void (* ClipNotifyProcPtr)(
+	WindowPtr /*pWindow*/,
+	int /*dx*/,
+	int /*dy*/);
+
+typedef    PixmapPtr (* CreatePixmapProcPtr)(
+	ScreenPtr /*pScreen*/,
+	int /*width*/,
+	int /*height*/,
+	int /*depth*/);
+
+typedef    Bool (* DestroyPixmapProcPtr)(
+	PixmapPtr /*pPixmap*/);
+
+typedef    void (* SaveDoomedAreasProcPtr)(
+	WindowPtr /*pWindow*/,
+	RegionPtr /*prgnSave*/,
+	int /*xorg*/,
+	int /*yorg*/);
+
+typedef    RegionPtr (* RestoreAreasProcPtr)(
+	WindowPtr /*pWindow*/,
+	RegionPtr /*prgnRestore*/);
+
+typedef    void (* ExposeCopyProcPtr)(
+	WindowPtr /*pSrc*/,
+	DrawablePtr /*pDst*/,
+	GCPtr /*pGC*/,
+	RegionPtr /*prgnExposed*/,
+	int /*srcx*/,
+	int /*srcy*/,
+	int /*dstx*/,
+	int /*dsty*/,
+	unsigned long /*plane*/);
+
+typedef    RegionPtr (* TranslateBackingStoreProcPtr)(
+	WindowPtr /*pWindow*/,
+	int /*windx*/,
+	int /*windy*/,
+	RegionPtr /*oldClip*/,
+	int /*oldx*/,
+	int /*oldy*/);
+
+typedef    RegionPtr (* ClearBackingStoreProcPtr)(
+	WindowPtr /*pWindow*/,
+	int /*x*/,
+	int /*y*/,
+	int /*w*/,
+	int /*h*/,
+	Bool /*generateExposures*/);
+
+typedef    void (* DrawGuaranteeProcPtr)(
+	WindowPtr /*pWindow*/,
+	GCPtr /*pGC*/,
+	int /*guarantee*/);
+    
+typedef    Bool (* RealizeFontProcPtr)(
+	ScreenPtr /*pScreen*/,
+	FontPtr /*pFont*/);
+
+typedef    Bool (* UnrealizeFontProcPtr)(
+	ScreenPtr /*pScreen*/,
+	FontPtr /*pFont*/);
+
+typedef    void (* ConstrainCursorProcPtr)(
+	ScreenPtr /*pScreen*/,
+	BoxPtr /*pBox*/);
+
+typedef    void (* CursorLimitsProcPtr)(
+	ScreenPtr /*pScreen*/,
+	CursorPtr /*pCursor*/,
+	BoxPtr /*pHotBox*/,
+	BoxPtr /*pTopLeftBox*/);
+
+typedef    Bool (* DisplayCursorProcPtr)(
+	ScreenPtr /*pScreen*/,
+	CursorPtr /*pCursor*/);
+
+typedef    Bool (* RealizeCursorProcPtr)(
+	ScreenPtr /*pScreen*/,
+	CursorPtr /*pCursor*/);
+
+typedef    Bool (* UnrealizeCursorProcPtr)(
+	ScreenPtr /*pScreen*/,
+	CursorPtr /*pCursor*/);
+
+typedef    void (* RecolorCursorProcPtr)(
+	ScreenPtr /*pScreen*/,
+	CursorPtr /*pCursor*/,
+	Bool /*displayed*/);
+
+typedef    Bool (* SetCursorPositionProcPtr)(
+	ScreenPtr /*pScreen*/,
+	int /*x*/,
+	int /*y*/,
+	Bool /*generateEvent*/);
+
+typedef    Bool (* CreateGCProcPtr)(
+	GCPtr /*pGC*/);
+
+typedef    Bool (* CreateColormapProcPtr)(
+	ColormapPtr /*pColormap*/);
+
+typedef    void (* DestroyColormapProcPtr)(
+	ColormapPtr /*pColormap*/);
+
+typedef    void (* InstallColormapProcPtr)(
+	ColormapPtr /*pColormap*/);
+
+typedef    void (* UninstallColormapProcPtr)(
+	ColormapPtr /*pColormap*/);
+
+typedef    int (* ListInstalledColormapsProcPtr) (
+	ScreenPtr /*pScreen*/,
+	XID* /*pmaps */);
+
+typedef    void (* StoreColorsProcPtr)(
+	ColormapPtr /*pColormap*/,
+	int /*ndef*/,
+	xColorItem * /*pdef*/);
+
+typedef    void (* ResolveColorProcPtr)(
+	unsigned short* /*pred*/,
+	unsigned short* /*pgreen*/,
+	unsigned short* /*pblue*/,
+	VisualPtr /*pVisual*/);
+
+#ifdef NEED_SCREEN_REGIONS
+
+typedef    RegionPtr (* RegionCreateProcPtr)(
+	BoxPtr /*rect*/,
+	int /*size*/);
+
+typedef    void (* RegionInitProcPtr)(
+	RegionPtr /*pReg*/,
+	BoxPtr /*rect*/,
+	int /*size*/);
+
+typedef    Bool (* RegionCopyProcPtr)(
+	RegionPtr /*dst*/,
+	RegionPtr /*src*/);
+
+typedef    void (* RegionDestroyProcPtr)(
+	RegionPtr /*pReg*/);
+
+typedef    void (* RegionUninitProcPtr)(
+	RegionPtr /*pReg*/);
+
+typedef    Bool (* IntersectProcPtr)(
+	RegionPtr /*newReg*/,
+	RegionPtr /*reg1*/,
+	RegionPtr /*reg2*/);
+
+typedef    Bool (* UnionProcPtr)(
+	RegionPtr /*newReg*/,
+	RegionPtr /*reg1*/,
+	RegionPtr /*reg2*/);
+
+typedef    Bool (* SubtractProcPtr)(
+	RegionPtr /*regD*/,
+	RegionPtr /*regM*/,
+	RegionPtr /*regS*/);
+
+typedef    Bool (* InverseProcPtr)(
+	RegionPtr /*newReg*/,
+	RegionPtr /*reg1*/,
+	BoxPtr /*invRect*/);
+
+typedef    void (* RegionResetProcPtr)(
+	RegionPtr /*pReg*/,
+	BoxPtr /*pBox*/);
+
+typedef    void (* TranslateRegionProcPtr)(
+	RegionPtr /*pReg*/,
+	int /*x*/,
+	int /*y*/);
+
+typedef    int (* RectInProcPtr)(
+	RegionPtr /*region*/,
+	BoxPtr /*prect*/);
+
+typedef    Bool (* PointInRegionProcPtr)(
+	RegionPtr /*pReg*/,
+	int /*x*/,
+	int /*y*/,
+	BoxPtr /*box*/);
+
+typedef    Bool (* RegionNotEmptyProcPtr)(
+	RegionPtr /*pReg*/);
+
+typedef    Bool (* RegionEqualProcPtr)(
+	RegionPtr /*pReg1*/,
+	RegionPtr /*pReg2*/);
+
+typedef    Bool (* RegionBrokenProcPtr)(
+	RegionPtr /*pReg*/);
+
+typedef    Bool (* RegionBreakProcPtr)(
+	RegionPtr /*pReg*/);
+
+typedef    void (* RegionEmptyProcPtr)(
+	RegionPtr /*pReg*/);
+
+typedef    BoxPtr (* RegionExtentsProcPtr)(
+	RegionPtr /*pReg*/);
+
+typedef    Bool (* RegionAppendProcPtr)(
+	RegionPtr /*dstrgn*/,
+	RegionPtr /*rgn*/);
+
+typedef    Bool (* RegionValidateProcPtr)(
+	RegionPtr /*badreg*/,
+	Bool* /*pOverlap*/);
+
+#endif /* NEED_SCREEN_REGIONS */
+
+typedef    RegionPtr (* BitmapToRegionProcPtr)(
+	PixmapPtr /*pPix*/);
+
+#ifdef NEED_SCREEN_REGIONS
+
+typedef    RegionPtr (* RectsToRegionProcPtr)(
+	int /*nrects*/,
+	xRectangle* /*prect*/,
+	int /*ctype*/);
+
+#endif /* NEED_SCREEN_REGIONS */
+
+typedef    void (* SendGraphicsExposeProcPtr)(
+	ClientPtr /*client*/,
+	RegionPtr /*pRgn*/,
+	XID /*drawable*/,
+	int /*major*/,
+	int /*minor*/);
+
+typedef    void (* ScreenBlockHandlerProcPtr)(
+	int /*screenNum*/,
+	pointer /*blockData*/,
+	pointer /*pTimeout*/,
+	pointer /*pReadmask*/);
+
+typedef    void (* ScreenWakeupHandlerProcPtr)(
+	 int /*screenNum*/,
+	 pointer /*wakeupData*/,
+	 unsigned long /*result*/,
+	 pointer /*pReadMask*/);
+
+typedef    Bool (* CreateScreenResourcesProcPtr)(
+	ScreenPtr /*pScreen*/);
+
+typedef    Bool (* ModifyPixmapHeaderProcPtr)(
+	PixmapPtr /*pPixmap*/,
+	int /*width*/,
+	int /*height*/,
+	int /*depth*/,
+	int /*bitsPerPixel*/,
+	int /*devKind*/,
+	pointer /*pPixData*/);
+
+typedef    PixmapPtr (* GetWindowPixmapProcPtr)(
+	WindowPtr /*pWin*/);
+
+typedef    void (* SetWindowPixmapProcPtr)(
+	WindowPtr /*pWin*/,
+	PixmapPtr /*pPix*/);
+
+typedef    PixmapPtr (* GetScreenPixmapProcPtr)(
+	ScreenPtr /*pScreen*/);
+
+typedef    void (* SetScreenPixmapProcPtr)(
+	PixmapPtr /*pPix*/);
+
+typedef    void (* MarkWindowProcPtr)(
+	WindowPtr /*pWin*/);
+
+typedef    Bool (* MarkOverlappedWindowsProcPtr)(
+	WindowPtr /*parent*/,
+	WindowPtr /*firstChild*/,
+	WindowPtr * /*pLayerWin*/);
+
+typedef    Bool (* ChangeSaveUnderProcPtr)(
+	WindowPtr /*pLayerWin*/,
+	WindowPtr /*firstChild*/);
+
+typedef    void (* PostChangeSaveUnderProcPtr)(
+	WindowPtr /*pLayerWin*/,
+	WindowPtr /*firstChild*/);
+
+typedef    void (* MoveWindowProcPtr)(
+	WindowPtr /*pWin*/,
+	int /*x*/,
+	int /*y*/,
+	WindowPtr /*pSib*/,
+	VTKind /*kind*/);
+
+typedef    void (* ResizeWindowProcPtr)(
+    WindowPtr /*pWin*/,
+    int /*x*/,
+    int /*y*/, 
+    unsigned int /*w*/,
+    unsigned int /*h*/,
+    WindowPtr /*pSib*/
+);
+
+typedef    WindowPtr (* GetLayerWindowProcPtr)(
+    WindowPtr /*pWin*/
+);
+
+typedef    void (* HandleExposuresProcPtr)(
+    WindowPtr /*pWin*/);
+
+typedef    void (* ReparentWindowProcPtr)(
+    WindowPtr /*pWin*/,
+    WindowPtr /*pPriorParent*/);
+
+#ifdef SHAPE
+typedef    void (* SetShapeProcPtr)(
+	WindowPtr /*pWin*/);
+#endif /* SHAPE */
+
+typedef    void (* ChangeBorderWidthProcPtr)(
+	WindowPtr /*pWin*/,
+	unsigned int /*width*/);
+
+typedef    void (* MarkUnrealizedWindowProcPtr)(
+	WindowPtr /*pChild*/,
+	WindowPtr /*pWin*/,
+	Bool /*fromConfigure*/);
+
+typedef struct _Screen {
+    int			myNum;	/* index of this instance in Screens[] */
+    ATOM		id;
+    short		width, height;
+    short		mmWidth, mmHeight;
+    short		numDepths;
+    unsigned char      	rootDepth;
+    DepthPtr       	allowedDepths;
+    unsigned long      	rootVisual;
+    unsigned long	defColormap;
+    short		minInstalledCmaps, maxInstalledCmaps;
+    char                backingStoreSupport, saveUnderSupport;
+    unsigned long	whitePixel, blackPixel;
+    unsigned long	rgf;	/* array of flags; she's -- HUNGARIAN */
+    GCPtr		GCperDepth[MAXFORMATS+1];
+			/* next field is a stipple to use as default in
+			   a GC.  we don't build default tiles of all depths
+			   because they are likely to be of a color
+			   different from the default fg pixel, so
+			   we don't win anything by building
+			   a standard one.
+			*/
+    PixmapPtr		PixmapPerDepth[1];
+    pointer		devPrivate;
+    short       	numVisuals;
+    VisualPtr		visuals;
+    int			WindowPrivateLen;
+    unsigned		*WindowPrivateSizes;
+    unsigned		totalWindowSize;
+    int			GCPrivateLen;
+    unsigned		*GCPrivateSizes;
+    unsigned		totalGCSize;
+
+    /* Random screen procedures */
+
+    CloseScreenProcPtr		CloseScreen;
+    QueryBestSizeProcPtr	QueryBestSize;
+    SaveScreenProcPtr		SaveScreen;
+    GetImageProcPtr		GetImage;
+    GetSpansProcPtr		GetSpans;
+    PointerNonInterestBoxProcPtr PointerNonInterestBox;
+    SourceValidateProcPtr	SourceValidate;
+
+    /* Window Procedures */
+
+    CreateWindowProcPtr		CreateWindow;
+    DestroyWindowProcPtr	DestroyWindow;
+    PositionWindowProcPtr	PositionWindow;
+    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+    RealizeWindowProcPtr	RealizeWindow;
+    UnrealizeWindowProcPtr	UnrealizeWindow;
+    ValidateTreeProcPtr		ValidateTree;
+    PostValidateTreeProcPtr	PostValidateTree;
+    WindowExposuresProcPtr	WindowExposures;
+    PaintWindowBackgroundProcPtr PaintWindowBackground;
+    PaintWindowBorderProcPtr	PaintWindowBorder;
+    CopyWindowProcPtr		CopyWindow;
+    ClearToBackgroundProcPtr	ClearToBackground;
+    ClipNotifyProcPtr		ClipNotify;
+    RestackWindowProcPtr	RestackWindow;
+
+    /* Pixmap procedures */
+
+    CreatePixmapProcPtr		CreatePixmap;
+    DestroyPixmapProcPtr	DestroyPixmap;
+
+    /* Backing store procedures */
+
+    SaveDoomedAreasProcPtr	SaveDoomedAreas;
+    RestoreAreasProcPtr		RestoreAreas;
+    ExposeCopyProcPtr		ExposeCopy;
+    TranslateBackingStoreProcPtr TranslateBackingStore;
+    ClearBackingStoreProcPtr	ClearBackingStore;
+    DrawGuaranteeProcPtr	DrawGuarantee;
+    /*
+     * A read/write copy of the lower level backing store vector is needed now
+     * that the functions can be wrapped.
+     */
+    BSFuncRec			BackingStoreFuncs;
+    
+    /* Font procedures */
+
+    RealizeFontProcPtr		RealizeFont;
+    UnrealizeFontProcPtr	UnrealizeFont;
+
+    /* Cursor Procedures */
+
+    ConstrainCursorProcPtr	ConstrainCursor;
+    CursorLimitsProcPtr		CursorLimits;
+    DisplayCursorProcPtr	DisplayCursor;
+    RealizeCursorProcPtr	RealizeCursor;
+    UnrealizeCursorProcPtr	UnrealizeCursor;
+    RecolorCursorProcPtr	RecolorCursor;
+    SetCursorPositionProcPtr	SetCursorPosition;
+
+    /* GC procedures */
+
+    CreateGCProcPtr		CreateGC;
+
+    /* Colormap procedures */
+
+    CreateColormapProcPtr	CreateColormap;
+    DestroyColormapProcPtr	DestroyColormap;
+    InstallColormapProcPtr	InstallColormap;
+    UninstallColormapProcPtr	UninstallColormap;
+    ListInstalledColormapsProcPtr ListInstalledColormaps;
+    StoreColorsProcPtr		StoreColors;
+    ResolveColorProcPtr		ResolveColor;
+
+    /* Region procedures */
+
+#ifdef NEED_SCREEN_REGIONS
+    RegionCreateProcPtr		RegionCreate;
+    RegionInitProcPtr		RegionInit;
+    RegionCopyProcPtr		RegionCopy;
+    RegionDestroyProcPtr	RegionDestroy;
+    RegionUninitProcPtr		RegionUninit;
+    IntersectProcPtr		Intersect;
+    UnionProcPtr		Union;
+    SubtractProcPtr		Subtract;
+    InverseProcPtr		Inverse;
+    RegionResetProcPtr		RegionReset;
+    TranslateRegionProcPtr	TranslateRegion;
+    RectInProcPtr		RectIn;
+    PointInRegionProcPtr	PointInRegion;
+    RegionNotEmptyProcPtr	RegionNotEmpty;
+    RegionEqualProcPtr		RegionEqual;
+    RegionBrokenProcPtr		RegionBroken;
+    RegionBreakProcPtr		RegionBreak;
+    RegionEmptyProcPtr		RegionEmpty;
+    RegionExtentsProcPtr	RegionExtents;
+    RegionAppendProcPtr		RegionAppend;
+    RegionValidateProcPtr	RegionValidate;
+#endif /* NEED_SCREEN_REGIONS */
+    BitmapToRegionProcPtr	BitmapToRegion;
+#ifdef NEED_SCREEN_REGIONS
+    RectsToRegionProcPtr	RectsToRegion;
+#endif /* NEED_SCREEN_REGIONS */
+    SendGraphicsExposeProcPtr	SendGraphicsExpose;
+
+    /* os layer procedures */
+
+    ScreenBlockHandlerProcPtr	BlockHandler;
+    ScreenWakeupHandlerProcPtr	WakeupHandler;
+
+    pointer blockData;
+    pointer wakeupData;
+
+    /* anybody can get a piece of this array */
+    DevUnion	*devPrivates;
+
+    CreateScreenResourcesProcPtr CreateScreenResources;
+    ModifyPixmapHeaderProcPtr	ModifyPixmapHeader;
+
+    GetWindowPixmapProcPtr	GetWindowPixmap;
+    SetWindowPixmapProcPtr	SetWindowPixmap;
+    GetScreenPixmapProcPtr	GetScreenPixmap;
+    SetScreenPixmapProcPtr	SetScreenPixmap;
+
+    PixmapPtr pScratchPixmap;		/* scratch pixmap &quot;pool&quot; */
+
+#ifdef PIXPRIV
+    int			PixmapPrivateLen;
+    unsigned int		*PixmapPrivateSizes;
+    unsigned int		totalPixmapSize;
+#endif
+
+    MarkWindowProcPtr		MarkWindow;
+    MarkOverlappedWindowsProcPtr MarkOverlappedWindows;
+    ChangeSaveUnderProcPtr	ChangeSaveUnder;
+    PostChangeSaveUnderProcPtr	PostChangeSaveUnder;
+    MoveWindowProcPtr		MoveWindow;
+    ResizeWindowProcPtr		ResizeWindow;
+    GetLayerWindowProcPtr	GetLayerWindow;
+    HandleExposuresProcPtr	HandleExposures;
+    ReparentWindowProcPtr	ReparentWindow;
+
+#ifdef SHAPE
+    SetShapeProcPtr		SetShape;
+#endif /* SHAPE */
+
+    ChangeBorderWidthProcPtr	ChangeBorderWidth;
+    MarkUnrealizedWindowProcPtr	MarkUnrealizedWindow;
+
+} ScreenRec;
+
+typedef struct _ScreenInfo {
+    int		imageByteOrder;
+    int		bitmapScanlineUnit;
+    int		bitmapScanlinePad;
+    int		bitmapBitOrder;
+    int		numPixmapFormats;
+    PixmapFormatRec
+		formats[MAXFORMATS];
+    int		arraySize;
+    int		numScreens;
+    ScreenPtr	screens[MAXSCREENS];
+    int		numVideoScreens;
+} ScreenInfo;
+
+extern ScreenInfo screenInfo;
+
+extern void InitOutput(
+    ScreenInfo 	* /*pScreenInfo*/,
+    int     	/*argc*/,
+    char    	** /*argv*/);
+
+#endif /* SCREENINTSTRUCT_H */
diff --git a/X11/Xprotostr.h b/X11/selection.h
similarity index 79%
copy from X11/Xprotostr.h
copy to X11/selection.h
index f343d98..9e6edfb 100644
--- a/X11/Xprotostr.h
+++ b/X11/selection.h
@@ -1,6 +1,7 @@
-/* $Xorg: Xprotostr.h,v 1.4 2001/02/09 02:03:23 xorgcvs Exp $ */
-#ifndef XPROTOSTRUCTS_H
-#define XPROTOSTRUCTS_H
+/* $Xorg: selection.h,v 1.4 2001/02/09 02:05:16 xorgcvs Exp $ */
+
+#ifndef SELECTION_H
+#define SELECTION_H 1
 
 /***********************************************************
 
@@ -48,31 +49,21 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 
 ******************************************************************/
-#include &lt;X11/Xmd.h&gt;
-
-/* Used by PolySegment */
-
-typedef struct _xSegment {
-    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
-} xSegment;
-
-/* POINT */
 
-typedef struct _xPoint {
-	INT16		x B16, y B16;
-} xPoint;
+#include &quot;dixstruct.h&quot;
+/*
+ *
+ *  Selection data structures 
+ */
 
-typedef struct _xRectangle {
-    INT16 x B16, y B16;
-    CARD16  width B16, height B16;
-} xRectangle;
+typedef struct _Selection {
+    Atom selection;
+    TimeStamp lastTimeChanged;
+    Window window;
+    WindowPtr pWin;
+    ClientPtr client;
+} Selection;
 
-/*  ARC  */
+#endif /* SELECTION_H */
 
-typedef struct _xArc {
-    INT16 x B16, y B16;
-    CARD16   width B16, height B16;
-    INT16   angle1 B16, angle2 B16;
-} xArc;
 
-#endif /* XPROTOSTRUCTS_H */
diff --git a/X11/servermd.h b/X11/servermd.h
new file mode 100644
index 0000000..cce6b32
--- /dev/null
+++ b/X11/servermd.h
@@ -0,0 +1,583 @@
+/* $XFree86: xc/programs/Xserver/include/servermd.h,v 3.56tsi Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $Xorg: servermd.h,v 1.3 2000/08/17 19:53:31 cpqbld Exp $ */
+/* $XdotOrg: xc/programs/Xserver/include/servermd.h,v 1.9 2005/11/15 00:29:23 ajax Exp $ */
+
+#ifndef SERVERMD_H
+#define SERVERMD_H 1
+
+/*
+ * Machine dependent values:
+ * GLYPHPADBYTES should be chosen with consideration for the space-time
+ * trade-off.  Padding to 0 bytes means that there is no wasted space
+ * in the font bitmaps (both on disk and in memory), but that access of
+ * the bitmaps will cause odd-address memory references.  Padding to
+ * 2 bytes would ensure even address memory references and would
+ * be suitable for a 68010-class machine, but at the expense of wasted
+ * space in the font bitmaps.  Padding to 4 bytes would be good
+ * for real 32 bit machines, etc.  Be sure that you tell the font
+ * compiler what kind of padding you want because its defines are
+ * kept separate from this.  See server/include/font.h for how
+ * GLYPHPADBYTES is used.
+ *
+ * Along with this, you should choose an appropriate value for
+ * GETLEFTBITS_ALIGNMENT, which is used in ddx/mfb/maskbits.h.  This
+ * constant choses what kind of memory references are guarenteed during
+ * font access; either 1, 2 or 4, for byte, word or longword access,
+ * respectively.  For instance, if you have decided to to have
+ * GLYPHPADBYTES == 4, then it is pointless for you to have a
+ * GETLEFTBITS_ALIGNMENT &gt; 1, because the padding of the fonts has already
+ * guarenteed you that your fonts are longword aligned.  On the other
+ * hand, even if you have chosen GLYPHPADBYTES == 1 to save space, you may
+ * also decide that the computing involved in aligning the pointer is more
+ * costly than an odd-address access; you choose GETLEFTBITS_ALIGNMENT == 1.
+ *
+ * Next, choose the tuning parameters which are appropriate for your
+ * hardware; these modify the behaviour of the raw frame buffer code
+ * in ddx/mfb and ddx/cfb.  Defining these incorrectly will not cause
+ * the server to run incorrectly, but defining these correctly will
+ * cause some noticeable speed improvements:
+ *
+ *  AVOID_MEMORY_READ - (8-bit cfb only)
+ *	When stippling pixels on the screen (polytext and pushpixels),
+ *	don't read long words from the display and mask in the
+ *	appropriate values.  Rather, perform multiple byte/short/long
+ *	writes as appropriate.  This option uses many more instructions
+ *	but runs much faster when the destination is much slower than
+ *	the CPU and at least 1 level of write buffer is availible (2
+ *	is much better).  Defined currently for SPARC and MIPS.
+ *
+ *  FAST_CONSTANT_OFFSET_MODE - (cfb and mfb)
+ *	This define is used on machines which have no auto-increment
+ *	addressing mode, but do have an effectively free constant-offset
+ *	addressing mode.  Currently defined for MIPS and SPARC, even though
+ *	I remember the cg6 as performing better without it (cg3 definitely
+ *	performs better with it).
+ *	
+ *  LARGE_INSTRUCTION_CACHE -
+ *	This define increases the number of times some loops are
+ *	unrolled.  On 68020 machines (with 256 bytes of i-cache),
+ *	this define will slow execution down as instructions miss
+ *	the cache frequently.  On machines with real i-caches, this
+ *	reduces loop overhead, causing a slight performance improvement.
+ *	Currently defined for MIPS and SPARC
+ *
+ *  FAST_UNALIGNED_READS -
+ *	For machines with more memory bandwidth than CPU, this
+ *	define uses unaligned reads for 8-bit BitBLT instead of doing
+ *	aligned reads and combining the results with shifts and
+ *	logical-ors.  Currently defined for 68020 and vax.
+ *  PLENTIFUL_REGISTERS -
+ *	For machines with &gt; 20 registers.  Currently used for
+ *	unrolling the text painting code a bit more.  Currently
+ *	defined for MIPS.
+ *  SHARED_IDCACHE -
+ *	For non-Harvard RISC machines, those which share the same
+ *	CPU memory bus for instructions and data.  This unrolls some
+ *	solid fill loops which are otherwise best left rolled up.
+ *	Currently defined for SPARC.
+ */
+
+#ifdef vax
+
+#define IMAGE_BYTE_ORDER	LSBFirst        /* Values for the VAX only */
+#define BITMAP_BIT_ORDER	LSBFirst
+#define	GLYPHPADBYTES		1
+#define GETLEFTBITS_ALIGNMENT	4
+#define FAST_UNALIGNED_READS
+
+#endif /* vax */
+
+#ifdef __arm32__
+
+#define IMAGE_BYTE_ORDER        LSBFirst
+
+# if defined(XF86MONOVGA) || defined(XF86VGA16) || defined(XF86MONO)
+#  define BITMAP_BIT_ORDER      MSBFirst
+# else
+#  define BITMAP_BIT_ORDER      LSBFirst
+# endif
+
+# if defined(XF86MONOVGA) || defined(XF86VGA16)
+#  define BITMAP_SCANLINE_UNIT  8
+# endif
+
+#define GLYPHPADBYTES           4
+#define GETLEFTBITS_ALIGNMENT   1
+#define LARGE_INSTRUCTION_CACHE
+#define AVOID_MEMORY_READ
+
+#endif /* __arm32__ */
+
+#if defined (hpux) || defined __hppa__
+
+#define IMAGE_BYTE_ORDER	MSBFirst
+#define BITMAP_BIT_ORDER	MSBFirst
+#define GLYPHPADBYTES		4	/* to make fb work */
+#define GETLEFTBITS_ALIGNMENT	1	/* PA forces longs to 4 */
+					/* byte boundries */
+#define AVOID_MEMORY_READ
+#define FAST_CONSTANT_OFFSET_MODE
+#define LARGE_INSTRUCTION_CACHE
+#define PLENTIFUL_REGISTERS
+
+#endif /* hpux || __hppa__ */
+
+#if defined(__powerpc__) || defined(__ppc__)
+
+#define IMAGE_BYTE_ORDER        MSBFirst
+#define BITMAP_BIT_ORDER        MSBFirst
+#define GLYPHPADBYTES           4
+#define GETLEFTBITS_ALIGNMENT   1
+
+/* XXX Should this be for Lynx only? */
+#ifdef Lynx
+#define BITMAP_SCANLINE_UNIT	8
+#endif
+
+#define LARGE_INSTRUCTION_CACHE
+#define FAST_CONSTANT_OFFSET_MODE
+#define PLENTIFUL_REGISTERS
+#define AVOID_MEMORY_READ
+
+#define FAST_MEMCPY
+
+#endif /* PowerPC */
+
+#if defined(__sh__)
+
+#if defined(__BIG_ENDIAN__)
+# define IMAGE_BYTE_ORDER	MSBFirst
+# define BITMAP_BIT_ORDER	MSBFirst
+# define GLYPHPADBYTES		4
+# define GETLEFTBITS_ALIGNMENT	1
+#else
+# define IMAGE_BYTE_ORDER	LSBFirst
+# define BITMAP_BIT_ORDER	LSBFirst
+# define GLYPHPADBYTES		4
+# define GETLEFTBITS_ALIGNMENT	1
+#endif
+
+#define AVOID_MEMORY_READ
+#define FAST_CONSTANT_OFFSET_MODE
+#define LARGE_INSTRUCTION_CACHE
+#define PLENTIFUL_REGISTERS
+
+#endif /* SuperH */
+
+
+#if (defined(sun) &amp;&amp; (defined(__sparc) || defined(sparc))) || \
+    (defined(__uxp__) &amp;&amp; (defined(sparc) || defined(mc68000))) || \
+    defined(__sparc__) || defined(__mc68000__)
+
+#if defined(__sparc) || defined(__sparc__)
+# if !defined(sparc)
+#  define sparc 1
+# endif
+#endif
+
+#if defined(sun386) || defined(sun5)
+# define IMAGE_BYTE_ORDER	LSBFirst        /* Values for the SUN only */
+# define BITMAP_BIT_ORDER	LSBFirst
+#else
+# define IMAGE_BYTE_ORDER	MSBFirst        /* Values for the SUN only */
+# define BITMAP_BIT_ORDER	MSBFirst
+#endif
+
+#ifdef sparc
+# define AVOID_MEMORY_READ
+# define LARGE_INSTRUCTION_CACHE
+# define FAST_CONSTANT_OFFSET_MODE
+# define SHARED_IDCACHE
+#endif
+
+#ifdef mc68020
+#define FAST_UNALIGNED_READS
+#endif
+
+#define	GLYPHPADBYTES		4
+#define GETLEFTBITS_ALIGNMENT	1
+
+#endif /* sun &amp;&amp; !(i386 &amp;&amp; SVR4) */
+
+
+#if defined(AIXV3)
+
+#define IMAGE_BYTE_ORDER        MSBFirst        /* Values for the RISC/6000 */
+#define BITMAP_BIT_ORDER        MSBFirst
+#define GLYPHPADBYTES           4
+#define GETLEFTBITS_ALIGNMENT   1
+
+#define LARGE_INSTRUCTION_CACHE
+#define FAST_CONSTANT_OFFSET_MODE
+#define PLENTIFUL_REGISTERS
+#define AVOID_MEMORY_READ
+
+#define FAST_MEMCPY
+#endif /* AIXV3 */
+
+#if defined(ibm032) || defined (ibm)
+
+#ifdef i386
+# define IMAGE_BYTE_ORDER	LSBFirst	/* Value for PS/2 only */
+#else
+# define IMAGE_BYTE_ORDER	MSBFirst        /* Values for the RT only*/
+#endif
+#define BITMAP_BIT_ORDER	MSBFirst
+#define	GLYPHPADBYTES		1
+#define GETLEFTBITS_ALIGNMENT	4
+/* ibm pcc doesn't understand pragmas. */
+
+#ifdef i386
+#define BITMAP_SCANLINE_UNIT	8
+#endif
+
+#endif /* ibm */
+
+#if defined (M4310) || defined(M4315) || defined(M4317) || defined(M4319) || defined(M4330)
+
+#define IMAGE_BYTE_ORDER	MSBFirst        /* Values for Pegasus only */
+#define BITMAP_BIT_ORDER	MSBFirst
+#define GLYPHPADBYTES		4
+#define GETLEFTBITS_ALIGNMENT	1
+
+#define FAST_UNALIGNED_READS
+
+#endif /* tektronix */
+
+#ifdef macII
+
+#define IMAGE_BYTE_ORDER      	MSBFirst        /* Values for the MacII only */
+#define BITMAP_BIT_ORDER      	MSBFirst
+#define GLYPHPADBYTES         	4
+#define GETLEFTBITS_ALIGNMENT 	1
+
+/* might want FAST_UNALIGNED_READS for frame buffers with &lt; 1us latency */
+
+#endif /* macII */
+
+#if (defined(mips) || defined(__mips)) &amp;&amp; !defined(sgi)
+
+#if defined(MIPSEL) || defined(__MIPSEL__)
+# define IMAGE_BYTE_ORDER	LSBFirst        /* Values for the PMAX only */
+# define BITMAP_BIT_ORDER	LSBFirst
+# define GLYPHPADBYTES		4
+# define GETLEFTBITS_ALIGNMENT	1
+#else
+# define IMAGE_BYTE_ORDER	MSBFirst        /* Values for the MIPS only */
+# define BITMAP_BIT_ORDER	MSBFirst
+# define GLYPHPADBYTES		4
+# define GETLEFTBITS_ALIGNMENT	1
+#endif
+
+#define AVOID_MEMORY_READ
+#define FAST_CONSTANT_OFFSET_MODE
+#define LARGE_INSTRUCTION_CACHE
+#define PLENTIFUL_REGISTERS
+
+#endif /* mips */
+
+#if defined(__alpha) || defined(__alpha__) || defined(__alphaCross)
+# define IMAGE_BYTE_ORDER	LSBFirst	/* Values for the Alpha only */
+
+# if defined(XF86MONOVGA) || defined(XF86VGA16) || defined(XF86MONO)
+#  define BITMAP_BIT_ORDER      MSBFirst
+# else
+#  define BITMAP_BIT_ORDER      LSBFirst
+# endif
+
+# if defined(XF86MONOVGA) || defined(XF86VGA16)
+#  define BITMAP_SCANLINE_UNIT  8
+# endif
+
+# define GLYPHPADBYTES		4
+# define GETLEFTBITS_ALIGNMENT	1
+# define FAST_CONSTANT_OFFSET_MODE
+# define LARGE_INSTRUCTION_CACHE
+# define PLENTIFUL_REGISTERS
+
+#endif /* alpha */
+
+#if defined (linux) &amp;&amp; defined (__s390__)
+
+#define IMAGE_BYTE_ORDER      	MSBFirst
+#define BITMAP_BIT_ORDER      	MSBFirst
+#define GLYPHPADBYTES         	4
+#define GETLEFTBITS_ALIGNMENT  1	
+
+#define BITMAP_SCANLINE_UNIT	8
+#define LARGE_INSTRUCTION_CACHE
+#define FAST_CONSTANT_OFFSET_MODE
+#define FAST_UNALIGNED_READ
+
+#define FAST_MEMCPY
+
+#endif /* linux/s390 */
+
+#if defined (linux) &amp;&amp; defined (__s390x__)
+
+#define IMAGE_BYTE_ORDER       MSBFirst
+#define BITMAP_BIT_ORDER       MSBFirst
+#define GLYPHPADBYTES          4
+#define GETLEFTBITS_ALIGNMENT  1
+
+#define BITMAP_SCANLINE_UNIT	8
+#define LARGE_INSTRUCTION_CACHE
+#define FAST_CONSTANT_OFFSET_MODE
+#define FAST_UNALIGNED_READ
+
+#define FAST_MEMCPY
+#endif /* linux/s390x */
+
+
+#if defined(__ia64__) || defined(ia64)
+# define IMAGE_BYTE_ORDER	LSBFirst
+
+# if defined(XF86MONOVGA) || defined(XF86VGA16) || defined(XF86MONO)
+#  define BITMAP_BIT_ORDER      MSBFirst
+# else
+#  define BITMAP_BIT_ORDER      LSBFirst
+# endif
+
+# if defined(XF86MONOVGA) || defined(XF86VGA16)
+#  define BITMAP_SCANLINE_UNIT  8
+# endif
+
+# define GLYPHPADBYTES		4
+# define GETLEFTBITS_ALIGNMENT	1
+# define FAST_CONSTANT_OFFSET_MODE
+# define LARGE_INSTRUCTION_CACHE
+# define PLENTIFUL_REGISTERS
+
+#endif /* ia64 */
+
+#if defined(__amd64__) || defined(amd64) || defined(__amd64)
+# define IMAGE_BYTE_ORDER	LSBFirst
+
+# if defined(XF86MONOVGA) || defined(XF86VGA16) || defined(XF86MONO)
+#  define BITMAP_BIT_ORDER      MSBFirst
+# else
+#  define BITMAP_BIT_ORDER      LSBFirst
+# endif
+
+# if defined(XF86MONOVGA) || defined(XF86VGA16)
+#  define BITMAP_SCANLINE_UNIT  8
+# endif
+
+# define GLYPHPADBYTES		4
+# define GETLEFTBITS_ALIGNMENT	1
+# define LARGE_INSTRUCTION_CACHE
+# define FAST_CONSTANT_OFFSET_MODE
+/* ???? */
+# define FAST_UNALIGNED_READS
+#endif /* AMD64 */
+
+#ifdef stellar
+
+#define IMAGE_BYTE_ORDER	MSBFirst       /* Values for the stellar only*/
+#define BITMAP_BIT_ORDER	MSBFirst
+#define	GLYPHPADBYTES		4
+#define GETLEFTBITS_ALIGNMENT	4
+#define IMAGE_BUFSIZE		(64*1024)
+/*
+ * Use SysV random number generator.
+ */
+#define random rand
+
+#endif /* stellar */
+
+#ifdef luna
+
+#define IMAGE_BYTE_ORDER        MSBFirst   	/* Values for the OMRON only*/
+#define BITMAP_BIT_ORDER	MSBFirst
+#define	GLYPHPADBYTES		4
+#define GETLEFTBITS_ALIGNMENT	1
+
+#ifndef mc68000
+#define FAST_CONSTANT_OFFSET_MODE
+#define AVOID_MEMORY_READ
+#define LARGE_INSTRUCTION_CACHE
+#define PLENTIFUL_REGISTERS
+#endif
+
+#endif /* luna */
+
+#if	(defined(SVR4) &amp;&amp; defined(i386)) || \
+	defined(__alpha__) || defined(__alpha) || \
+	defined(__i386__) || defined(__i386) || \
+	defined(__UNIXOS2__) || \
+	defined(__OS2ELF__) || \
+	defined(__QNX__) || \
+	defined(__s390x__) || defined(__s390__)
+  
+#ifndef IMAGE_BYTE_ORDER
+#define IMAGE_BYTE_ORDER	LSBFirst
+#endif
+
+#ifndef BITMAP_BIT_ORDER
+# if defined(XF86MONOVGA) || defined(XF86VGA16) || defined(XF86MONO)
+#  define BITMAP_BIT_ORDER      MSBFirst
+# else
+#  define BITMAP_BIT_ORDER      LSBFirst
+# endif
+#endif
+
+#ifndef BITMAP_SCANLINE_UNIT
+# if defined(XF86MONOVGA) || defined(XF86VGA16)
+#  define BITMAP_SCANLINE_UNIT  8
+# endif
+#endif
+
+#ifndef GLYPHPADBYTES
+#define GLYPHPADBYTES           4
+#endif
+
+#define GETLEFTBITS_ALIGNMENT	1
+#define AVOID_MEMORY_READ
+#ifdef XSVGA
+#define AVOID_GLYPHBLT
+#define FAST_CONSTANT_OFFSET_MODE
+#define FAST_MEMCPY
+#define NO_ONE_RECT
+#endif
+
+#endif /* SVR4 / BSD / i386 */
+
+#if defined (linux) &amp;&amp; defined (__mc68000__)
+
+#define IMAGE_BYTE_ORDER       MSBFirst
+#define BITMAP_BIT_ORDER       MSBFirst
+#define FAST_UNALIGNED_READS
+#define GLYPHPADBYTES          4
+#define GETLEFTBITS_ALIGNMENT  1
+
+#endif /* linux/m68k */
+
+#ifdef sgi
+
+#define IMAGE_BYTE_ORDER	MSBFirst
+#define BITMAP_BIT_ORDER	MSBFirst
+#define GLYPHPADBYTES		4
+#define GETLEFTBITS_ALIGNMENT	1
+#define AVOID_MEMORY_READ
+#define FAST_CONSTANT_OFFSET_MODE
+#define LARGE_INSTRUCTION_CACHE
+#define PLENTIFUL_REGISTERS
+
+#endif
+
+/* linux on the Compaq Itsy */
+#if defined(linux) &amp;&amp; defined(__arm__)
+#define IMAGE_BYTE_ORDER	LSBFirst
+#define BITMAP_BIT_ORDER	LSBFirst
+#define GLYPHPADBYTES		4
+#define GETLEFTBITS_ALIGNMENT	1
+#endif
+ 
+/* size of buffer to use with GetImage, measured in bytes. There's obviously
+ * a trade-off between the amount of stack (or whatever ALLOCATE_LOCAL gives
+ * you) used and the number of times the ddx routine has to be called.
+ */
+#ifndef IMAGE_BUFSIZE
+#define IMAGE_BUFSIZE		(64*1024)
+#endif
+
+/* pad scanline to a longword */
+#ifndef BITMAP_SCANLINE_UNIT
+#define BITMAP_SCANLINE_UNIT	32
+#endif
+
+#ifndef BITMAP_SCANLINE_PAD
+#define BITMAP_SCANLINE_PAD  32
+#define LOG2_BITMAP_PAD		5
+#define LOG2_BYTES_PER_SCANLINE_PAD	2
+#endif
+
+/* 
+ *   This returns the number of padding units, for depth d and width w.
+ * For bitmaps this can be calculated with the macros above.
+ * Other depths require either grovelling over the formats field of the
+ * screenInfo or hardwired constants.
+ */
+
+typedef struct _PaddingInfo {
+	int     padRoundUp;	/* pixels per pad unit - 1 */
+	int	padPixelsLog2;	/* log 2 (pixels per pad unit) */
+	int     padBytesLog2;	/* log 2 (bytes per pad unit) */
+	int	notPower2;	/* bitsPerPixel not a power of 2 */
+	int	bytesPerPixel;	/* only set when notPower2 is TRUE */
+	int	bitsPerPixel;	/* bits per pixel */
+} PaddingInfo;
+extern PaddingInfo PixmapWidthPaddingInfo[];
+
+/* The only portable way to get the bpp from the depth is to look it up */
+#define BitsPerPixel(d) (PixmapWidthPaddingInfo[d].bitsPerPixel)
+
+#define PixmapWidthInPadUnits(w, d) \
+    (PixmapWidthPaddingInfo[d].notPower2 ? \
+    (((int)(w) * PixmapWidthPaddingInfo[d].bytesPerPixel +  \
+	         PixmapWidthPaddingInfo[d].bytesPerPixel) &gt;&gt; \
+	PixmapWidthPaddingInfo[d].padBytesLog2) : \
+    ((int)((w) + PixmapWidthPaddingInfo[d].padRoundUp) &gt;&gt; \
+	PixmapWidthPaddingInfo[d].padPixelsLog2))
+
+/*
+ *	Return the number of bytes to which a scanline of the given
+ * depth and width will be padded.
+ */
+#define PixmapBytePad(w, d) \
+    (PixmapWidthInPadUnits(w, d) &lt;&lt; PixmapWidthPaddingInfo[d].padBytesLog2)
+
+#define BitmapBytePad(w) \
+    (((int)((w) + BITMAP_SCANLINE_PAD - 1) &gt;&gt; LOG2_BITMAP_PAD) &lt;&lt; LOG2_BYTES_PER_SCANLINE_PAD)
+
+#define PixmapWidthInPadUnitsProto(w, d) PixmapWidthInPadUnits(w, d)
+#define PixmapBytePadProto(w, d) PixmapBytePad(w, d)
+#define BitmapBytePadProto(w) BitmapBytePad(w)
+
+#endif /* SERVERMD_H */
diff --git a/X11/site.h b/X11/site.h
new file mode 100644
index 0000000..be8c003
--- /dev/null
+++ b/X11/site.h
@@ -0,0 +1,139 @@
+/* $Xorg: site.h,v 1.6 2001/02/09 02:05:16 xorgcvs Exp $ */
+/************************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+********************************************************/
+/* $XFree86: xc/programs/Xserver/include/site.h,v 1.8 2001/12/19 21:37:35 dawes Exp $ */
+
+#ifndef SITE_H
+#define SITE_H
+/*
+ * The vendor string identifies the vendor responsible for the
+ * server executable.
+ */
+#ifndef VENDOR_STRING
+#define VENDOR_STRING &quot;The X.Org Group&quot;
+#endif
+
+/*
+ * The vendor release number identifies, for the purpose of submitting
+ * traceable bug reports, the release number of software produced
+ * by the vendor.
+ */
+#ifndef VENDOR_RELEASE
+#define VENDOR_RELEASE	6600
+#endif
+
+/*
+ * The following constants are provided solely as a last line of defense.  The
+ * normal build ALWAYS overrides them using a special rule given in
+ * server/dix/Imakefile.  If you want to change either of these constants, 
+ * you should set the DefaultFontPath or DefaultRGBDatabase configuration 
+ * parameters.
+ * DO NOT CHANGE THESE VALUES OR THE DIX IMAKEFILE!
+ */
+#ifndef COMPILEDDEFAULTFONTPATH
+#define COMPILEDDEFAULTFONTPATH	&quot;/usr/lib/X11/fonts/misc/&quot;
+#endif
+#ifndef RGB_DB
+#define RGB_DB			&quot;/usr/lib/X11/rgb&quot;
+#endif
+
+/*
+ * The following constants contain default values for all of the variables 
+ * that can be initialized on the server command line or in the environment.
+ */
+#define COMPILEDDEFAULTFONT	&quot;fixed&quot;
+#define COMPILEDCURSORFONT	&quot;cursor&quot;
+#ifndef COMPILEDDISPLAYCLASS
+#define COMPILEDDISPLAYCLASS	&quot;MIT-unspecified&quot;
+#endif
+#define DEFAULT_TIMEOUT		60	/* seconds */
+#define DEFAULT_KEYBOARD_CLICK 	0
+#define DEFAULT_BELL		50
+#define DEFAULT_BELL_PITCH	400
+#define DEFAULT_BELL_DURATION	100
+#ifdef XKB
+#define DEFAULT_AUTOREPEAT	TRUE
+#else
+#define DEFAULT_AUTOREPEAT	FALSE
+#endif
+#define DEFAULT_AUTOREPEATS	{\
+        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\
+        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
+
+#define DEFAULT_LEDS		0x0        /* all off */
+#define DEFAULT_LEDS_MASK	0xffffffff /* 32 */
+#define DEFAULT_INT_RESOLUTION		1000
+#define DEFAULT_INT_MIN_VALUE		0
+#define DEFAULT_INT_MAX_VALUE		100
+#define DEFAULT_INT_DISPLAYED		0
+
+#define DEFAULT_PTR_NUMERATOR	2
+#define DEFAULT_PTR_DENOMINATOR	1
+#define DEFAULT_PTR_THRESHOLD	4
+
+#define DEFAULT_SCREEN_SAVER_TIME (10 * (60 * 1000))
+#define DEFAULT_SCREEN_SAVER_INTERVAL (10 * (60 * 1000))
+#define DEFAULT_SCREEN_SAVER_BLANKING PreferBlanking
+#define DEFAULT_SCREEN_SAVER_EXPOSURES AllowExposures
+#ifndef NOLOGOHACK
+#define DEFAULT_LOGO_SCREEN_SAVER 1
+#endif
+#ifndef DEFAULT_ACCESS_CONTROL
+#define DEFAULT_ACCESS_CONTROL TRUE
+#endif
+
+/* Default logging parameters. */
+#ifndef DEFAULT_LOG_VERBOSITY
+#define DEFAULT_LOG_VERBOSITY		0
+#endif
+#ifndef DEFAULT_LOG_FILE_VERBOSITY
+#define DEFAULT_LOG_FILE_VERBOSITY	3
+#endif
+
+#endif /* SITE_H */
diff --git a/X11/swaprep.h b/X11/swaprep.h
new file mode 100644
index 0000000..2c026c6
--- /dev/null
+++ b/X11/swaprep.h
@@ -0,0 +1,322 @@
+/* $XFree86: xc/programs/Xserver/include/swaprep.h,v 3.0 1996/04/15 11:34:34 dawes Exp $ */
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dickey at clark.net</A>&gt;
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef SWAPREP_H
+#define SWAPREP_H 1
+
+extern void Swap32Write(
+    ClientPtr /* pClient */,
+    int /* size */,
+    CARD32 * /* pbuf */);
+
+extern void CopySwap32Write(
+    ClientPtr /* pClient */,
+    int /* size */,
+    CARD32 * /* pbuf */);
+
+extern void CopySwap16Write(
+    ClientPtr /* pClient */,
+    int /* size */,
+    short * /* pbuf */);
+
+extern void SGenericReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGenericReply * /* pRep */);
+
+extern void SGetWindowAttributesReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetWindowAttributesReply * /* pRep */);
+
+extern void SGetGeometryReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetGeometryReply * /* pRep */);
+
+extern void SQueryTreeReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryTreeReply * /* pRep */);
+
+extern void SInternAtomReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xInternAtomReply * /* pRep */);
+
+extern void SGetAtomNameReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetAtomNameReply * /* pRep */);
+
+extern void SGetPropertyReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetPropertyReply * /* pRep */);
+
+extern void SListPropertiesReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListPropertiesReply * /* pRep */);
+
+extern void SGetSelectionOwnerReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetSelectionOwnerReply * /* pRep */);
+
+extern void SQueryPointerReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryPointerReply * /* pRep */);
+
+extern void SwapTimecoord(
+    xTimecoord * /* pCoord */);
+
+extern void SwapTimeCoordWrite(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xTimecoord * /* pRep */);
+
+extern void SGetMotionEventsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetMotionEventsReply * /* pRep */);
+
+extern void STranslateCoordsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xTranslateCoordsReply * /* pRep */);
+
+extern void SGetInputFocusReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetInputFocusReply * /* pRep */);
+
+extern void SQueryKeymapReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryKeymapReply * /* pRep */);
+
+#ifdef LBX
+extern void SwapCharInfo(
+    xCharInfo * /* pInfo */);
+#endif
+
+#ifdef LBX
+extern void SwapFont(
+    xQueryFontReply * /* pr */,
+    Bool /* hasGlyphs */);
+#endif
+
+extern void SQueryFontReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryFontReply * /* pRep */);
+
+extern void SQueryTextExtentsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryTextExtentsReply * /* pRep */);
+
+extern void SListFontsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListFontsReply * /* pRep */);
+
+extern void SListFontsWithInfoReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListFontsWithInfoReply * /* pRep */);
+
+extern void SGetFontPathReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetFontPathReply * /* pRep */);
+
+extern void SGetImageReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetImageReply * /* pRep */);
+
+extern void SListInstalledColormapsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListInstalledColormapsReply * /* pRep */);
+
+extern void SAllocColorReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xAllocColorReply * /* pRep */);
+
+extern void SAllocNamedColorReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xAllocNamedColorReply * /* pRep */);
+
+extern void SAllocColorCellsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xAllocColorCellsReply * /* pRep */);
+
+extern void SAllocColorPlanesReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xAllocColorPlanesReply * /* pRep */);
+
+extern void SwapRGB(
+    xrgb * /* prgb */);
+
+extern void SQColorsExtend(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xrgb * /* prgb */);
+
+extern void SQueryColorsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryColorsReply * /* pRep */);
+
+extern void SLookupColorReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xLookupColorReply * /* pRep */);
+
+extern void SQueryBestSizeReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryBestSizeReply * /* pRep */);
+
+extern void SListExtensionsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListExtensionsReply * /* pRep */);
+
+extern void SGetKeyboardMappingReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetKeyboardMappingReply * /* pRep */);
+
+extern void SGetPointerMappingReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetPointerMappingReply * /* pRep */);
+
+extern void SGetModifierMappingReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetModifierMappingReply * /* pRep */);
+
+extern void SGetKeyboardControlReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetKeyboardControlReply * /* pRep */);
+
+extern void SGetPointerControlReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetPointerControlReply * /* pRep */);
+
+extern void SGetScreenSaverReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetScreenSaverReply * /* pRep */);
+
+extern void SLHostsExtend(
+    ClientPtr /* pClient */,
+    int /* size */,
+    char * /* buf */);
+
+extern void SListHostsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListHostsReply * /* pRep */);
+
+extern void SErrorEvent(
+    xError * /* from */,
+    xError * /* to */);
+
+extern void SwapConnSetupInfo(
+    char * /* pInfo */,
+    char * /* pInfoTBase */);
+
+extern void WriteSConnectionInfo(
+    ClientPtr /* pClient */,
+    unsigned long /* size */,
+    char * /* pInfo */);
+
+extern void SwapConnSetup(
+    xConnSetup * /* pConnSetup */,
+    xConnSetup * /* pConnSetupT */);
+
+extern void SwapWinRoot(
+    xWindowRoot * /* pRoot */,
+    xWindowRoot * /* pRootT */);
+
+extern void SwapVisual(
+    xVisualType * /* pVis */,
+    xVisualType * /* pVisT */);
+
+extern void SwapConnSetupPrefix(
+    xConnSetupPrefix * /* pcspFrom */,
+    xConnSetupPrefix * /* pcspTo */);
+
+extern void WriteSConnSetupPrefix(
+    ClientPtr /* pClient */,
+    xConnSetupPrefix * /* pcsp */);
+
+#undef SWAPREP_PROC
+#define SWAPREP_PROC(func) void func(xEvent * /* from */, xEvent * /* to */)
+
+SWAPREP_PROC(SCirculateEvent);
+SWAPREP_PROC(SClientMessageEvent);
+SWAPREP_PROC(SColormapEvent);
+SWAPREP_PROC(SConfigureNotifyEvent);
+SWAPREP_PROC(SConfigureRequestEvent);
+SWAPREP_PROC(SCreateNotifyEvent);
+SWAPREP_PROC(SDestroyNotifyEvent);
+SWAPREP_PROC(SEnterLeaveEvent);
+SWAPREP_PROC(SExposeEvent);
+SWAPREP_PROC(SFocusEvent);
+SWAPREP_PROC(SGraphicsExposureEvent);
+SWAPREP_PROC(SGravityEvent);
+SWAPREP_PROC(SKeyButtonPtrEvent);
+SWAPREP_PROC(SKeymapNotifyEvent);
+SWAPREP_PROC(SMapNotifyEvent);
+SWAPREP_PROC(SMapRequestEvent);
+SWAPREP_PROC(SMappingEvent);
+SWAPREP_PROC(SNoExposureEvent);
+SWAPREP_PROC(SPropertyEvent);
+SWAPREP_PROC(SReparentEvent);
+SWAPREP_PROC(SResizeRequestEvent);
+SWAPREP_PROC(SSelectionClearEvent);
+SWAPREP_PROC(SSelectionNotifyEvent);
+SWAPREP_PROC(SSelectionRequestEvent);
+SWAPREP_PROC(SUnmapNotifyEvent);
+SWAPREP_PROC(SVisibilityEvent);
+
+#undef SWAPREP_PROC
+
+#endif /* SWAPREP_H */
diff --git a/X11/swapreq.h b/X11/swapreq.h
new file mode 100644
index 0000000..9c59bbf
--- /dev/null
+++ b/X11/swapreq.h
@@ -0,0 +1,120 @@
+/* $XFree86: xc/programs/Xserver/include/swapreq.h,v 1.3 2003/04/27 21:31:05 herrb Exp $ */
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dickey at clark.net</A>&gt;
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef SWAPREQ_H
+#define SWAPREQ_H 1
+
+/* The first two are in misc.h */
+#if 0
+extern void SwapLongs (
+    CARD32 * /* list */,
+    unsigned long /* count */);
+
+extern void SwapShorts (
+    short * /* list */,
+    unsigned long  /* count */);
+#endif
+
+extern void SwapColorItem(
+    xColorItem	* /* pItem */);
+
+extern void SwapConnClientPrefix(
+    xConnClientPrefix * /* pCCP */);
+
+#undef SWAPREQ_PROC
+
+#define SWAPREQ_PROC(func) int func(ClientPtr /* client */)
+
+SWAPREQ_PROC(SProcAllocColor);
+SWAPREQ_PROC(SProcAllocColorCells);
+SWAPREQ_PROC(SProcAllocColorPlanes);
+SWAPREQ_PROC(SProcAllocNamedColor);
+SWAPREQ_PROC(SProcChangeActivePointerGrab);
+SWAPREQ_PROC(SProcChangeGC);
+SWAPREQ_PROC(SProcChangeHosts);
+SWAPREQ_PROC(SProcChangeKeyboardControl);
+SWAPREQ_PROC(SProcChangeKeyboardMapping);
+SWAPREQ_PROC(SProcChangePointerControl);
+SWAPREQ_PROC(SProcChangeProperty);
+SWAPREQ_PROC(SProcChangeWindowAttributes);
+SWAPREQ_PROC(SProcClearToBackground);
+SWAPREQ_PROC(SProcConfigureWindow);
+SWAPREQ_PROC(SProcConvertSelection);
+SWAPREQ_PROC(SProcCopyArea);
+SWAPREQ_PROC(SProcCopyColormapAndFree);
+SWAPREQ_PROC(SProcCopyGC);
+SWAPREQ_PROC(SProcCopyPlane);
+SWAPREQ_PROC(SProcCreateColormap);
+SWAPREQ_PROC(SProcCreateCursor);
+SWAPREQ_PROC(SProcCreateGC);
+SWAPREQ_PROC(SProcCreateGlyphCursor);
+SWAPREQ_PROC(SProcCreatePixmap);
+SWAPREQ_PROC(SProcCreateWindow);
+SWAPREQ_PROC(SProcDeleteProperty);
+SWAPREQ_PROC(SProcFillPoly);
+SWAPREQ_PROC(SProcFreeColors);
+SWAPREQ_PROC(SProcGetImage);
+SWAPREQ_PROC(SProcGetMotionEvents);
+SWAPREQ_PROC(SProcGetProperty);
+SWAPREQ_PROC(SProcGrabButton);
+SWAPREQ_PROC(SProcGrabKey);
+SWAPREQ_PROC(SProcGrabKeyboard);
+SWAPREQ_PROC(SProcGrabPointer);
+SWAPREQ_PROC(SProcImageText);
+SWAPREQ_PROC(SProcInternAtom);
+SWAPREQ_PROC(SProcListFonts);
+SWAPREQ_PROC(SProcListFontsWithInfo);
+SWAPREQ_PROC(SProcLookupColor);
+SWAPREQ_PROC(SProcNoOperation);
+SWAPREQ_PROC(SProcOpenFont);
+SWAPREQ_PROC(SProcPoly);
+SWAPREQ_PROC(SProcPolyText);
+SWAPREQ_PROC(SProcPutImage);
+SWAPREQ_PROC(SProcQueryBestSize);
+SWAPREQ_PROC(SProcQueryColors);
+SWAPREQ_PROC(SProcQueryExtension);
+SWAPREQ_PROC(SProcRecolorCursor);
+SWAPREQ_PROC(SProcReparentWindow);
+SWAPREQ_PROC(SProcResourceReq);
+SWAPREQ_PROC(SProcRotateProperties);
+SWAPREQ_PROC(SProcSendEvent);
+SWAPREQ_PROC(SProcSetClipRectangles);
+SWAPREQ_PROC(SProcSetDashes);
+SWAPREQ_PROC(SProcSetFontPath);
+SWAPREQ_PROC(SProcSetInputFocus);
+SWAPREQ_PROC(SProcSetScreenSaver);
+SWAPREQ_PROC(SProcSetSelectionOwner);
+SWAPREQ_PROC(SProcSimpleReq);
+SWAPREQ_PROC(SProcStoreColors);
+SWAPREQ_PROC(SProcStoreNamedColor);
+SWAPREQ_PROC(SProcTranslateCoords);
+SWAPREQ_PROC(SProcUngrabButton);
+SWAPREQ_PROC(SProcUngrabKey);
+SWAPREQ_PROC(SProcWarpPointer);
+
+#undef SWAPREQ_PROC
+
+#endif /* SWAPREQ_H */
diff --git a/X11/extensions/Xext.h b/X11/validate.h
similarity index 66%
copy from X11/extensions/Xext.h
copy to X11/validate.h
index 5b62c8b..467533d 100644
--- a/X11/extensions/Xext.h
+++ b/X11/validate.h
@@ -1,6 +1,7 @@
+/* $Xorg: validate.h,v 1.4 2001/02/09 02:05:16 xorgcvs Exp $ */
+
 /*
- * $Xorg: Xext.h,v 1.4 2001/02/09 02:03:24 xorgcvs Exp $
- *
+
 Copyright 1989, 1998  The Open Group
 
 Permission to use, copy, modify, distribute, and sell this software and its
@@ -22,36 +23,20 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 Except as contained in this notice, the name of The Open Group shall not be
 used in advertising or otherwise to promote the sale, use or other dealings
 in this Software without prior written authorization from The Open Group.
- */
-/* $XFree86: xc/include/extensions/Xext.h,v 1.4 2001/12/14 19:53:28 dawes Exp $ */
-
-#ifndef _XEXT_H_
-#define _XEXT_H_
-
-#include &lt;X11/Xfuncproto.h&gt;
+*/
+/* $XFree86: xc/programs/Xserver/include/validate.h,v 1.4 2001/01/17 22:36:58 dawes Exp $ */
 
-_XFUNCPROTOBEGIN
+#ifndef VALIDATE_H
+#define VALIDATE_H
 
-extern int (*XSetExtensionErrorHandler(
-    int (*handler)(
-		   Display *,
-		   char *,
-		   char *
-		   )
-))(
-		   Display *,
-		   char *,
-		   char *
-);
+#include &quot;miscstruct.h&quot;
+#include &quot;regionstr.h&quot;
 
-extern int XMissingExtension(
-    Display*		/* dpy */,
-    _Xconst char*	/* ext_name */
-);
+typedef enum { VTOther, VTStack, VTMove, VTUnmap, VTMap, VTBroken } VTKind;
 
-_XFUNCPROTOEND
+/* union _Validate is now device dependent; see mivalidate.h for an example */
+typedef union _Validate *ValidatePtr;
 
-#define X_EXTENSION_UNKNOWN &quot;unknown&quot;
-#define X_EXTENSION_MISSING &quot;missing&quot;
+#define UnmapValData ((ValidatePtr)1)
 
-#endif /* _XEXT_H_ */
+#endif /* VALIDATE_H */
diff --git a/X11/window.h b/X11/window.h
new file mode 100644
index 0000000..7c3fce0
--- /dev/null
+++ b/X11/window.h
@@ -0,0 +1,265 @@
+/* $Xorg: window.h,v 1.4 2001/02/09 02:05:16 xorgcvs Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $XFree86$ */
+
+#ifndef WINDOW_H
+#define WINDOW_H
+
+#include &quot;misc.h&quot;
+#include &quot;region.h&quot;
+#include &quot;screenint.h&quot;
+#include &lt;X11/Xproto.h&gt;
+
+#define TOTALLY_OBSCURED 0
+#define UNOBSCURED 1
+#define OBSCURED 2
+
+#define VisibilityNotViewable	3
+
+/* return values for tree-walking callback procedures */
+#define WT_STOPWALKING		0
+#define WT_WALKCHILDREN		1
+#define WT_DONTWALKCHILDREN	2
+#define WT_NOMATCH 3
+#define NullWindow ((WindowPtr) 0)
+
+typedef struct _BackingStore *BackingStorePtr;
+typedef struct _Window *WindowPtr;
+
+typedef int (*VisitWindowProcPtr)(
+    WindowPtr /*pWin*/,
+    pointer /*data*/);
+
+extern int TraverseTree(
+    WindowPtr /*pWin*/,
+    VisitWindowProcPtr /*func*/,
+    pointer /*data*/);
+
+extern int WalkTree(
+    ScreenPtr /*pScreen*/,
+    VisitWindowProcPtr /*func*/,
+    pointer /*data*/);
+
+extern WindowPtr AllocateWindow(
+    ScreenPtr /*pScreen*/);
+
+extern Bool CreateRootWindow(
+    ScreenPtr /*pScreen*/);
+
+extern void InitRootWindow(
+    WindowPtr /*pWin*/);
+
+extern void ClippedRegionFromBox(
+    WindowPtr /*pWin*/,
+    RegionPtr /*Rgn*/,
+    int /*x*/,
+    int /*y*/,
+    int /*w*/,
+    int /*h*/);
+
+extern WindowPtr RealChildHead(
+    WindowPtr /*pWin*/);
+
+extern WindowPtr CreateWindow(
+    Window /*wid*/,
+    WindowPtr /*pParent*/,
+    int /*x*/,
+    int /*y*/,
+    unsigned int /*w*/,
+    unsigned int /*h*/,
+    unsigned int /*bw*/,
+    unsigned int /*class*/,
+    Mask /*vmask*/,
+    XID* /*vlist*/,
+    int /*depth*/,
+    ClientPtr /*client*/,
+    VisualID /*visual*/,
+    int* /*error*/);
+
+extern int DeleteWindow(
+    pointer /*pWin*/,
+    XID /*wid*/);
+
+extern void DestroySubwindows(
+    WindowPtr /*pWin*/,
+    ClientPtr /*client*/);
+
+/* Quartz support on Mac OS X uses the HIToolbox
+   framework whose ChangeWindowAttributes function conflicts here. */
+#ifdef __DARWIN__
+#define ChangeWindowAttributes Darwin_X_ChangeWindowAttributes
+#endif
+extern int ChangeWindowAttributes(
+    WindowPtr /*pWin*/,
+    Mask /*vmask*/,
+    XID* /*vlist*/,
+    ClientPtr /*client*/);
+
+/* Quartz support on Mac OS X uses the HIToolbox
+   framework whose GetWindowAttributes function conflicts here. */
+#ifdef __DARWIN__
+#define GetWindowAttributes(w,c,x) Darwin_X_GetWindowAttributes(w,c,x)
+extern void Darwin_X_GetWindowAttributes(
+#else
+extern void GetWindowAttributes(
+#endif
+    WindowPtr /*pWin*/,
+    ClientPtr /*client*/,
+    xGetWindowAttributesReply* /* wa */);
+
+extern RegionPtr CreateUnclippedWinSize(
+    WindowPtr /*pWin*/);
+
+extern void GravityTranslate(
+    int /*x*/,
+    int /*y*/,
+    int /*oldx*/,
+    int /*oldy*/,
+    int /*dw*/,
+    int /*dh*/,
+    unsigned /*gravity*/,
+    int* /*destx*/,
+    int* /*desty*/);
+
+extern int ConfigureWindow(
+    WindowPtr /*pWin*/,
+    Mask /*mask*/,
+    XID* /*vlist*/,
+    ClientPtr /*client*/);
+
+extern int CirculateWindow(
+    WindowPtr /*pParent*/,
+    int /*direction*/,
+    ClientPtr /*client*/);
+
+extern int ReparentWindow(
+    WindowPtr /*pWin*/,
+    WindowPtr /*pParent*/,
+    int /*x*/,
+    int /*y*/,
+    ClientPtr /*client*/);
+
+extern int MapWindow(
+    WindowPtr /*pWin*/,
+    ClientPtr /*client*/);
+
+extern void MapSubwindows(
+    WindowPtr /*pParent*/,
+    ClientPtr /*client*/);
+
+extern int UnmapWindow(
+    WindowPtr /*pWin*/,
+    Bool /*fromConfigure*/);
+
+extern void UnmapSubwindows(
+    WindowPtr /*pWin*/);
+
+extern void HandleSaveSet(
+    ClientPtr /*client*/);
+
+extern Bool VisibleBoundingBoxFromPoint(
+    WindowPtr /*pWin*/,
+    int /*x*/,
+    int /*y*/,
+    BoxPtr /*box*/);
+
+extern Bool PointInWindowIsVisible(
+    WindowPtr /*pWin*/,
+    int /*x*/,
+    int /*y*/);
+
+extern RegionPtr NotClippedByChildren(
+    WindowPtr /*pWin*/);
+
+extern void SendVisibilityNotify(
+    WindowPtr /*pWin*/);
+
+extern void SaveScreens(
+    int /*on*/,
+    int /*mode*/);
+
+extern WindowPtr FindWindowWithOptional(
+    WindowPtr /*w*/);
+
+extern void CheckWindowOptionalNeed(
+    WindowPtr /*w*/);
+
+extern Bool MakeWindowOptional(
+    WindowPtr /*pWin*/);
+
+extern void DisposeWindowOptional(
+    WindowPtr /*pWin*/);
+
+extern WindowPtr MoveWindowInStack(
+    WindowPtr /*pWin*/,
+    WindowPtr /*pNextSib*/);
+
+void SetWinSize(
+    WindowPtr /*pWin*/);
+
+void SetBorderSize(
+    WindowPtr /*pWin*/);
+
+void ResizeChildrenWinSize(
+    WindowPtr /*pWin*/,
+    int /*dx*/,
+    int /*dy*/,
+    int /*dw*/,
+    int /*dh*/);
+
+extern void SendShapeNotify(
+    WindowPtr /* pWin */,
+    int /* which */ );
+
+extern RegionPtr CreateBoundingShape(
+    WindowPtr /* pWin */ );
+
+extern RegionPtr CreateClipShape(
+    WindowPtr /* pWin */ );
+
+#endif /* WINDOW_H */
diff --git a/X11/windowstr.h b/X11/windowstr.h
new file mode 100644
index 0000000..89e3ee1
--- /dev/null
+++ b/X11/windowstr.h
@@ -0,0 +1,234 @@
+/* $Xorg: windowstr.h,v 1.4 2001/02/09 02:05:16 xorgcvs Exp $ */
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+/* $XFree86: xc/programs/Xserver/include/windowstr.h,v 1.6 2001/12/14 19:59:57 dawes Exp $ */
+
+#ifndef WINDOWSTRUCT_H
+#define WINDOWSTRUCT_H
+
+#include &quot;window.h&quot;
+#include &quot;pixmapstr.h&quot;
+#include &quot;regionstr.h&quot;
+#include &quot;cursor.h&quot;
+#include &quot;property.h&quot;
+#include &quot;resource.h&quot;	/* for ROOT_WINDOW_ID_BASE */
+#include &quot;dix.h&quot;
+#include &quot;miscstruct.h&quot;
+#include &lt;X11/Xprotostr.h&gt;
+#include &quot;opaque.h&quot;
+
+#define GuaranteeNothing	0
+#define GuaranteeVisBack	1
+
+#define SameBackground(as, a, bs, b)				\
+    ((as) == (bs) &amp;&amp; ((as) == None ||				\
+		      (as) == ParentRelative ||			\
+ 		      SamePixUnion(a,b,as == BackgroundPixel)))
+
+#define SameBorder(as, a, bs, b)				\
+    EqualPixUnion(as, a, bs, b)
+
+typedef struct _WindowOpt {
+    VisualID		visual;		   /* default: same as parent */
+    CursorPtr		cursor;		   /* default: window.cursorNone */
+    Colormap		colormap;	   /* default: same as parent */
+    Mask		dontPropagateMask; /* default: window.dontPropagate */
+    Mask		otherEventMasks;   /* default: 0 */
+    struct _OtherClients *otherClients;	   /* default: NULL */
+    struct _GrabRec	*passiveGrabs;	   /* default: NULL */
+    PropertyPtr		userProps;	   /* default: NULL */
+    unsigned long	backingBitPlanes;  /* default: ~0L */
+    unsigned long	backingPixel;	   /* default: 0 */
+#ifdef SHAPE
+    RegionPtr		boundingShape;	   /* default: NULL */
+    RegionPtr		clipShape;	   /* default: NULL */
+    RegionPtr		inputShape;	   /* default: NULL */
+#endif
+#ifdef XINPUT
+    struct _OtherInputMasks *inputMasks;   /* default: NULL */
+#endif
+} WindowOptRec, *WindowOptPtr;
+
+#define BackgroundPixel	    2L
+#define BackgroundPixmap    3L
+
+typedef struct _Window {
+    DrawableRec		drawable;
+    WindowPtr		parent;		/* ancestor chain */
+    WindowPtr		nextSib;	/* next lower sibling */
+    WindowPtr		prevSib;	/* next higher sibling */
+    WindowPtr		firstChild;	/* top-most child */
+    WindowPtr		lastChild;	/* bottom-most child */
+    RegionRec		clipList;	/* clipping rectangle for output */
+    RegionRec		borderClip;	/* NotClippedByChildren + border */
+    union _Validate	*valdata;
+    RegionRec		winSize;
+    RegionRec		borderSize;
+    DDXPointRec		origin;		/* position relative to parent */
+    unsigned short	borderWidth;
+    unsigned short	deliverableEvents;
+    Mask		eventMask;
+    PixUnion		background;
+    PixUnion		border;
+    pointer		backStorage;	/* null when BS disabled */
+    WindowOptPtr	optional;
+    unsigned		backgroundState:2; /* None, Relative, Pixel, Pixmap */
+    unsigned		borderIsPixel:1;
+    unsigned		cursorIsNone:1;	/* else real cursor (might inherit) */
+    unsigned		backingStore:2;
+    unsigned		saveUnder:1;
+    unsigned		DIXsaveUnder:1;
+    unsigned		bitGravity:4;
+    unsigned		winGravity:4;
+    unsigned		overrideRedirect:1;
+    unsigned		visibility:2;
+    unsigned		mapped:1;
+    unsigned		realized:1;	/* ancestors are all mapped */
+    unsigned		viewable:1;	/* realized &amp;&amp; InputOutput */
+    unsigned		dontPropagate:3;/* index into DontPropagateMasks */
+    unsigned		forcedBS:1;	/* system-supplied backingStore */
+#ifdef NEED_DBE_BUF_BITS
+#define DBE_FRONT_BUFFER 1
+#define DBE_BACK_BUFFER  0
+    unsigned		dstBuffer:1;	/* destination buffer for rendering */
+    unsigned		srcBuffer:1;	/* source buffer for rendering */
+#endif
+#ifdef COMPOSITE
+    unsigned		redirectDraw:1;	/* rendering is redirected from here */
+#endif
+    DevUnion		*devPrivates;
+} WindowRec;
+
+/*
+ * Ok, a bunch of macros for accessing the optional record
+ * fields (or filling the appropriate default value)
+ */
+
+extern Mask	    DontPropagateMasks[];
+
+#define wTrackParent(w,field)	((w)-&gt;optional ? \
+				    (w)-&gt;optional-&gt;field \
+ 				 : FindWindowWithOptional(w)-&gt;optional-&gt;field)
+#define wUseDefault(w,field,def)	((w)-&gt;optional ? \
+				    (w)-&gt;optional-&gt;field \
+				 : def)
+
+#define wVisual(w)		wTrackParent(w, visual)
+#define wCursor(w)		((w)-&gt;cursorIsNone ? None : wTrackParent(w, cursor))
+#define wColormap(w)		((w)-&gt;drawable.class == InputOnly ? None : wTrackParent(w, colormap))
+#define wDontPropagateMask(w)	wUseDefault(w, dontPropagateMask, DontPropagateMasks[(w)-&gt;dontPropagate])
+#define wOtherEventMasks(w)	wUseDefault(w, otherEventMasks, 0)
+#define wOtherClients(w)	wUseDefault(w, otherClients, NULL)
+#ifdef XINPUT
+#define wOtherInputMasks(w)	wUseDefault(w, inputMasks, NULL)
+#else
+#define wOtherInputMasks(w)	NULL
+#endif
+#define wPassiveGrabs(w)	wUseDefault(w, passiveGrabs, NULL)
+#define wUserProps(w)		wUseDefault(w, userProps, NULL)
+#define wBackingBitPlanes(w)	wUseDefault(w, backingBitPlanes, ~0L)
+#define wBackingPixel(w)	wUseDefault(w, backingPixel, 0)
+#ifdef SHAPE
+#define wBoundingShape(w)	wUseDefault(w, boundingShape, NULL)
+#define wClipShape(w)		wUseDefault(w, clipShape, NULL)
+#define wInputShape(w)          wUseDefault(w, inputShape, NULL)
+#endif
+#define wClient(w)		(clients[CLIENT_ID((w)-&gt;drawable.id)])
+#define wBorderWidth(w)		((int) (w)-&gt;borderWidth)
+
+/* true when w needs a border drawn. */
+
+#ifdef SHAPE
+#define HasBorder(w)	((w)-&gt;borderWidth || wClipShape(w))
+#else
+#define HasBorder(w)	((w)-&gt;borderWidth)
+#endif
+
+typedef struct _ScreenSaverStuff {
+    WindowPtr pWindow;
+    XID       wid;
+    char      blanked;
+    Bool      (*ExternalScreenSaver)(
+	ScreenPtr	/*pScreen*/,
+	int		/*xstate*/,
+	Bool		/*force*/);
+} ScreenSaverStuffRec, *ScreenSaverStuffPtr;
+
+#define SCREEN_IS_BLANKED   0
+#define SCREEN_ISNT_SAVED   1
+#define SCREEN_IS_TILED     2
+#define SCREEN_IS_BLACK	    3
+
+#define HasSaverWindow(i)   (savedScreenInfo[i].pWindow != NullWindow)
+
+extern int screenIsSaved;
+extern ScreenSaverStuffRec savedScreenInfo[MAXSCREENS];
+
+/*
+ * this is the configuration parameter &quot;NO_BACK_SAVE&quot;
+ * it means that any existant backing store should not 
+ * be used to implement save unders.
+ */
+
+#ifndef NO_BACK_SAVE
+#define DO_SAVE_UNDERS(pWin)	((pWin)-&gt;drawable.pScreen-&gt;saveUnderSupport ==\
+				 USE_DIX_SAVE_UNDERS)
+/*
+ * saveUnderSupport is set to this magic value when using DIXsaveUnders
+ */
+
+#define USE_DIX_SAVE_UNDERS	0x40
+#endif
+
+extern int numSaveUndersViewable;
+extern int deltaSaveUndersViewable;
+
+#ifdef XEVIE
+extern WindowPtr xeviewin;
+#endif
+
+#endif /* WINDOWSTRUCT_H */
diff --git a/debian/control b/debian/control
index 9acccb8..a2f91fe 100644
--- a/debian/control
+++ b/debian/control
@@ -11,7 +11,12 @@ Build-Depends:
  libjpeg-dev,
  libpng-dev,
  zlib1g-dev
-Build-Conflicts: x11proto-core-dev
+Build-Conflicts:
+ x11proto-core-dev,
+ x11proto-kb-dev,
+ x11proto-randr-dev,
+ x11proto-xinerama-dev,
+ xbitmaps
 Standards-Version: 3.9.2
 Homepage: <A HREF="http://code.x2go.org/releases/source/nxcomp">http://code.x2go.org/releases/source/nxcomp</A>
 Vcs-Git: <A HREF="git://code.x2go.org/nxcomp.git">git://code.x2go.org/nxcomp.git</A>
@@ -56,8 +61,18 @@ Description: NX X compression debug symbols
 
 Package: x11proto-nx-dev
 Architecture: any
-Conflicts: x11proto-core-dev
-Replaces: x11proto-core-dev
+Conflicts:
+ x11proto-core-dev,
+ x11proto-kb-dev,
+ x11proto-randr-dev,
+ x11proto-xinerama-dev,
+ xbitmaps
+Replaces:
+ x11proto-core-dev,
+ x11proto-kb-dev,
+ x11proto-randr-dev,
+ x11proto-xinerama-dev,
+ xbitmaps
 Description: NX X11 replacement library-headers
  NX provides a differential X compression library for X11.
  .


hooks/post-receive
-- 
nxcomp.git (NX comp library)

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;nxcomp.git&quot; (NX comp library).


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001751.html">[X2go-Commits] x2goplasmabindings.git - master (branch) updated:	8570c908d70b578ab4e84bfa508c4c05b9b6837b
</A></li>
	<LI>Next message: <A HREF="001753.html">[X2go-Commits] nxcompext.git - master (branch) updated:	3.5.0-1-2-gfc96513
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1752">[ date ]</a>
              <a href="thread.html#1752">[ thread ]</a>
              <a href="subject.html#1752">[ subject ]</a>
              <a href="author.html#1752">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2go-commits
mailing list</a><br>
</body></html>
