<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2go-Commits] python-x2go.git - build-main (branch) updated:	0.4.0.0
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2013-February/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2go-Commits%5D%20python-x2go.git%20-%20build-main%20%28branch%29%20updated%3A%0A%090.4.0.0&In-Reply-To=%3C20130212074256.351765DB1A%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004138.html">
   <LINK REL="Next"  HREF="004139.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2go-Commits] python-x2go.git - build-main (branch) updated:	0.4.0.0</H1>
    <B>X2Go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2go-Commits%5D%20python-x2go.git%20-%20build-main%20%28branch%29%20updated%3A%0A%090.4.0.0&In-Reply-To=%3C20130212074256.351765DB1A%40ymir%3E"
       TITLE="[X2go-Commits] python-x2go.git - build-main (branch) updated:	0.4.0.0">git-admin at x2go.org
       </A><BR>
    <I>Tue Feb 12 08:42:55 CET 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="004138.html">[X2go-Commits] python-x2go.git - master (branch) updated:	0.2.1.1-46-g720f39f
</A></li>
        <LI>Next message: <A HREF="004139.html">[X2go-Commits] python-x2go.git - build-baikal (branch) created:	0.4.0.0
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4140">[ date ]</a>
              <a href="thread.html#4140">[ thread ]</a>
              <a href="subject.html#4140">[ subject ]</a>
              <a href="author.html#4140">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, build-main has been updated
       via  720f39f4f42896c5633b612e69a01c7add4eaf95 (commit)
       via  1ddcf94e49415941d44f8a142d7863a4d2adcdea (commit)
       via  810c1e98f0e38a4cc5364aac2f2832264bd56e58 (commit)
       via  a93d4f2646aa310295eacaf4f7c6b1bb2566c19e (commit)
       via  79f1296a15b362e57161632519c796ea43994104 (commit)
       via  5e85771f2aeb7d3095a72409b783e96934c788ef (commit)
       via  4793f3a5cadfc7d922403601363b2a1d46ecfc2a (commit)
       via  86055d5fdb0c0c94299946c95ffda6c468a89265 (commit)
       via  e1f9afda375bab994849fc1b3feeded185a926b4 (commit)
       via  2fcc357335868fccc00f0d778c71f9924fa140eb (commit)
       via  eafc5bb4b22a5bee841bfd97313beaa496fac941 (commit)
       via  cb527b4b142bf337d50a026dd2a85eea4ccea923 (commit)
       via  1ddcfcf9bbc3ba029a697b6b7914ccbf67ba71e5 (commit)
       via  01ea13f9b472bf7139c0640fbddb1cf4309c0861 (commit)
       via  3133baf8a3c0e8dc6d80bad8d5aef6b0d0f34862 (commit)
       via  eb0cf279859b9ac49f72cda07b8ca7730dfe7a7e (commit)
       via  5415362f73739312014478cb6b382369dbd3d5c7 (commit)
       via  4557a946e0a316c04d5f0c368c7137c2d15d8056 (commit)
       via  c30e67e43d69963013b04c27f73e641c671996a3 (commit)
       via  7c04590d15e7b41656614a91288d538d28735066 (commit)
       via  9a9712d918b999c87c2ff01b07b0526c3a855835 (commit)
       via  42b3141237a11af183bc4e682292c7b49f408460 (commit)
       via  2e09bcaacd788687daa35ce8379da22bc26bf6b7 (commit)
       via  4b05f61aec2d1e9f8dfde42416be4883782c40b5 (commit)
       via  b014bae497840deba4b094e5fdee4e79478b989b (commit)
       via  1d869290092c02881753955c061fa7f3ef085a62 (commit)
       via  7914c64237973c66222fc35094ccc34b6d921063 (commit)
       via  e1b34e08af86bd3c56119cf467dfae5520c07fac (commit)
       via  cd14d38e23fb6cf8e7860a6f7290669301c874f4 (commit)
       via  4de963ff56562f3fcb967ba2344d122e825aeb14 (commit)
       via  b1c28c749e6d34ae51d5169e360ba4f3409d1d81 (commit)
       via  f787a0620a5fee6cc9df2a53a92abb81d5a99880 (commit)
       via  a986b6081ff2f677036342e210ec9fac3d2f1331 (commit)
       via  60047c179c15e332894d321f323270b0675093ad (commit)
       via  2a9b2742b4f4386750758c6c67f6d003225f168a (commit)
       via  c4a24c0afc5ab8636f069c80c1c70c19df52d5d3 (commit)
       via  61dc41b90989393423cac83e4bc7c4693f37299f (commit)
       via  2dad37975a1de1ddc41c3d460dd7bfc64bd6ec87 (commit)
       via  3710451867d4f079e6324b7e37ad8c2284c5a99d (commit)
       via  cee0cac37466c9ea792588f0a26f6842d104f8e4 (commit)
       via  917cca2a6a1dbd6cf1105cf9b5329d76a7c99758 (commit)
       via  fe173b2649c28ede9348f4ed6bc6a926ffbe303a (commit)
       via  35f6b967ab1eb0e5b6a9fa7bddc984ecbb16cd16 (commit)
       via  2a1d3db9b452102cfa6479dc5b8349b08f82eb67 (commit)
       via  c6f5f43dbb00c79464a1de48fc910f1a6a3f57c5 (commit)
       via  6618320451923230d75f1e9190dbff9502052b6a (commit)
      from  36689cb17e965b1d5437e2235aebe639abe17831 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
-----------------------------------------------------------------------

Summary of changes:
 Makefile.docupload                                 |    4 +-
 README                                             |   30 +-
 README.Trinity-Desktop                             |    2 +-
 TODO                                               |    2 +-
 debian/changelog                                   |   42 +-
 debian/copyright                                   |    8 +-
 debian/rules                                       |    4 +-
 examples/x2go_resume_session.py                    |    4 +-
 examples/x2go_start_session.py                     |    4 +-
 .../x2go_start_session_with_progress_status.py     |    6 +-
 setup.py                                           |    9 +-
 x2go/__init__.py                                   |   92 ++--
 x2go/_paramiko.py                                  |    2 +-
 x2go/backends/__init__.py                          |    2 +-
 x2go/backends/control/__init__.py                  |    6 +-
 x2go/backends/control/_stdout.py                   |  231 ++++++---
 x2go/backends/info/__init__.py                     |   10 +-
 x2go/backends/info/_stdout.py                      |  112 ++++-
 x2go/backends/printing/__init__.py                 |   10 +-
 x2go/backends/printing/_file.py                    |   48 +-
 x2go/backends/printing/_gconf.py                   |   24 +-
 x2go/backends/printing/_winreg.py                  |   24 +-
 x2go/backends/profiles/__init__.py                 |   12 +-
 x2go/backends/profiles/_file.py                    |   92 ++--
 x2go/backends/profiles/_gconf.py                   |   20 +-
 x2go/backends/profiles/_httpsbroker.py             |   20 +-
 x2go/backends/profiles/_winreg.py                  |   20 +-
 x2go/backends/proxy/__init__.py                    |    6 +-
 x2go/backends/proxy/_nx3.py                        |   20 +-
 x2go/backends/proxy/base.py                        |   36 +-
 x2go/backends/settings/__init__.py                 |   10 +-
 x2go/backends/settings/_file.py                    |   20 +-
 x2go/backends/settings/_gconf.py                   |   22 +-
 x2go/backends/settings/_winreg.py                  |   22 +-
 x2go/backends/terminal/__init__.py                 |    6 +-
 x2go/backends/terminal/_stdout.py                  |  221 +++++----
 x2go/cache.py                                      |   66 +--
 x2go/checkhosts.py                                 |  188 ++++---
 x2go/cleanup.py                                    |   14 +-
 x2go/client.py                                     |  518 ++++++++++++--------
 x2go/defaults.py                                   |   85 ++--
 x2go/forward.py                                    |   32 +-
 x2go/gevent_subprocess.py                          |    2 +-
 x2go/guardian.py                                   |   28 +-
 x2go/inifiles.py                                   |   40 +-
 x2go/log.py                                        |   16 +-
 x2go/mimebox.py                                    |   46 +-
 x2go/mimeboxactions.py                             |   66 +--
 x2go/printactions.py                               |   98 ++--
 x2go/printqueue.py                                 |   50 +-
 x2go/pulseaudio.py                                 |   20 +-
 x2go/registry.py                                   |  168 +++----
 x2go/rforward.py                                   |   84 ++--
 x2go/session.py                                    |  365 ++++++++------
 x2go/sftpserver.py                                 |   66 +--
 x2go/sshproxy.py                                   |   77 ++-
 x2go/tests/test_printing.py                        |   24 +-
 x2go/utils.py                                      |   24 +-
 x2go/x2go_exceptions.py                            |   86 ++--
 x2go/xserver.py                                    |   32 +-
 60 files changed, 1989 insertions(+), 1409 deletions(-)

The diff of changes is:
diff --git a/Makefile.docupload b/Makefile.docupload
index aa4869d..a82d7b7 100644
--- a/Makefile.docupload
+++ b/Makefile.docupload
@@ -1,6 +1,6 @@
 #!/usr/bin/make -f
 # Makefile.docupload file - for python-x2go
-# Copyright 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;, GPLv3+ applies to this file
+# Copyright 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;, GPLv3+ applies to this file
 
 VERSION=`head -n1 debian/changelog | sed 's,.*(\(.*\)).*,\1,' | cut -d&quot;-&quot; -f1`
 DOC_HOST=code.x2go.org
@@ -16,7 +16,7 @@ docbuild:
 	rm -Rf .epydoc/html/*
 	epydoc --debug -n &quot;Python X2Go&quot; -u <A HREF="http://www.x2go.org">http://www.x2go.org</A> -v --html --no-private -o .epydoc/html x2go/
 	#epydoc --debug --pdf --no-private -o .epydoc/pdf.tmp x2go/
-	#mv .epydoc/pdf.tmp/api.pdf .epydoc/pdf/Python-X2go_API.pdf
+	#mv .epydoc/pdf.tmp/api.pdf .epydoc/pdf/Python-X2Go_API.pdf
 	#rm -Rf .epydoc/pdf.tmp
 
 
diff --git a/README b/README
index da4bc54..c1535ea 100644
--- a/README
+++ b/README
@@ -1,16 +1,16 @@
-python-x2go - Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+python-x2go - Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 
 Published under the terms of the GNU Affero General Public License.
 See <A HREF="http://www.gnu.org/licenses/agpl.html">http://www.gnu.org/licenses/agpl.html</A> for a recent copy.
 
 
-=== What is Python X2go? ===
+=== What is Python X2Go? ===
 
 The Python X2Go module integrates X2Go client support into your python programmes.
 Python X2Go is used in the headless X2Go client &#187;pyhoca-cli&#171; and by the tiny systray GUI
 application &#187;pyhoca-gui&#171;
 
-Python X2Go takes advantages of the NX Proxy by NoMachine published under GPL. 
+Python X2Go takes advantages of the NX Proxy by NoMachine published under GPL.
 On Windows and MacOS X systems you have to make sure that you have installed a current
 NX Proxy executable somewhere on your system. It probably will be sufficient to have
 the X2Go project's x2goclient package installed on your client machine.
@@ -18,22 +18,22 @@ the X2Go project's x2goclient package installed on your client machine.
 On Debian / Ubuntu systems there is a nxproxy package available within the distribution.
 Python X2Go defaults to using the distro nxproxy binary.
 
-Python X2Go was originally inspired by work of J&#246;rg Sawatzki &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">joerg.sawatzki at web.de</A>&gt;. 
-Unfortunately, J&#246;rg had to give up work on his ideas due to licensing issues with his 
-contractor. To make his ideas furthermore available to the OSS community this complete 
+Python X2Go was originally inspired by work of J&#246;rg Sawatzki &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">joerg.sawatzki at web.de</A>&gt;.
+Unfortunately, J&#246;rg had to give up work on his ideas due to licensing issues with his
+contractor. To make his ideas furthermore available to the OSS community this complete
 rewrite of J&#246;rgs ideas has been called into life.
 
-In case you have the opinion that parts of the presented code are not as much a rewrite 
+In case you have the opinion that parts of the presented code are not as much a rewrite
 as they should be, may I ask you to contact me directly and in person. I am sure, things can
-be sorted out in a non-complicated and heartful fashion. Thanks in advance for your directness 
+be sorted out in a non-complicated and heartful fashion. Thanks in advance for your directness
 and wholeheartedness concerning this inner process.
 
 
 === Requirements ===
 
-* X2Go Server 
-    - you need a working X2Go server to connect to. In order to use shadowing make sure 
-      you have at least X2Go Baikal (3.1.x) installed
+* X2Go Server
+    - you need a working X2Go server to connect to. In order to use shadowing make sure
+      you have at least X2Go Server (&gt;= 4.1.0.0) installed
 * on the client system you will need
     - the python-gevent library (for details refer to: <A HREF="http://www.gevent.org/">http://www.gevent.org/</A>)
     - the python-paramiko library (SSH implementation in Python, <A HREF="http://www.lag.net/paramiko/">http://www.lag.net/paramiko/</A>)
@@ -44,7 +44,7 @@ and wholeheartedness concerning this inner process.
     - also working: if no Ghostscript/GSView is installed the win32api ,,print'' command will
       be executed on incoming PDF print spool files. Win32api will try launch the print function
       of the default PDF viewer application (mostly Adobe Acrobat Reader)
-    - if you have a choice: install Ghostscript/GSview on the system that uses Python X2Go 
+    - if you have a choice: install Ghostscript/GSview on the system that uses Python X2Go
       applications... it's highly recommended
 
 
@@ -59,7 +59,7 @@ and wholeheartedness concerning this inner process.
 * use Pulse Audio sound
 * X2Go printing
 * reading/writing session profiles from file
-* sharing of local (client-side) folders (SFTP server is integrated in Python X2go)
+* sharing of local (client-side) folders (SFTP server is integrated in Python X2Go)
 * connect via proxy SSH server
 * X2Go MIME box support
 * color depth auto-recognition
@@ -77,7 +77,7 @@ We use Launchpad for Ubuntu packaging:
   $ apt-get update
   $ apt-get install python-x2go
 
-From Ubuntu oneiric on python-x2go is also available as a part of the 
+From Ubuntu oneiric on python-x2go is also available as a part of the
 Ubuntu GNU/Linux distribution.
 
 
@@ -107,7 +107,7 @@ Testing and writing a short howto for this section is very welcome.
 === How to use it from the command line? ===
 
 A good example for the usage of Python X2Go is the pyhoca-cli programme, a headless
-X2Go client that aims at 100% compatibility with X2goClient applications released in 
+X2Go client that aims at 100% compatibility with X2Go Client applications released in
 the X2Go project.
 
 On Debian/Ubuntu you can easily install the X2Go Client by running APT again:
diff --git a/README.Trinity-Desktop b/README.Trinity-Desktop
index 90ffa21..2bab505 100644
--- a/README.Trinity-Desktop
+++ b/README.Trinity-Desktop
@@ -1,4 +1,4 @@
-Trinity Deskop (KDE3.5 fork) and (Python) X2go
+Trinity Deskop (KDE3.5 fork) and (Python) X2Go
 ==============================================
 
 Python X2Go brings support to start Trinity Desktops on remote 
diff --git a/TODO b/TODO
index d6cf347..ee8039c 100644
--- a/TODO
+++ b/TODO
@@ -1,4 +1,4 @@
-python-x2go - Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+python-x2go - Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 
 Published under the terms of the GNU Affero General Public License.
 See <A HREF="http://www.gnu.org/licenses/agpl.html">http://www.gnu.org/licenses/agpl.html</A> for a recent copy.
diff --git a/debian/changelog b/debian/changelog
index 4e01b79..65b9050 100644
--- a/debian/changelog
+++ b/debian/changelog
@@ -1,3 +1,43 @@
+python-x2go (0.4.0.0-0~x2go1) unstable; urgency=low
+
+  [ Orion Poplawski ]
+  * New upstream version (0.4.0.0):
+    - Importing all of x2go in setup.py causes rpmbuild problems due to
+      DISPLAY not being set.  It is overkill as well, causing extra dependencies
+      to be installed at build time. (Fixes: #91).
+
+  [ Mike Gabriel ]
+  * Bump version to 0.4.0.0.
+  * WARNING: starting with version 0.4.0.0 of PyHoca-GUI, PyHoca-CLI and Python
+    X2Go, all class identifiers are now X2Go..., not X2go... anymore.
+  * New upstream version (0.4.0.0):
+    - Add session profile option ,,display'' to default session profile options.
+    - Catch any kind of exception when writing session profile files and return
+      True or False in cases where I/O errors occur.
+    - Avoid the known_hosts file being flushed with localhost:[&lt;someport&gt;]
+      entries. Store host keys of SSH-proxied hosts under the [&lt;address&gt;]:&lt;port&gt;
+      the system has _behind_ the SSH proxy gateway. (Hopefully fixes: #18,
+      partially fixes: #53).
+    - Add session profile option: uniquehostkeyaliases. Allow the
+      (by-design-unique) X2Go session profile ID to be a representative for
+      &lt;hostname&gt;:&lt;port&gt;. Update session profile IDs on hostname changes.
+      Re-arrange class structure for MissingHostKey policies, also provide an
+      X2goAutoAddPolicy class.
+    - Fix auto-starting and auto-resuming of sessions.
+    - Avoid false-positive notifications of dead control session directly after
+      a disconnect request from the user.
+    - Improve desktop sharing code. Add code to obtain version information of
+      server-side X2Go components.
+    - Add session type filter for list of sharable desktops.
+    - Sort X2Go feature list, add force option for X2GoClient queries of server
+      features and server components. Add alias get_server_components (for 
+      get_server_versions).
+    - Add low latency support for link types 'modem' and 'isdn'. Selecting
+      either link quality will double nearly all connection timeout values.
+      (Fixes: #53).
+
+ -- Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;  Tue, 12 Feb 2013 08:41:52 +0100
+
 python-x2go (0.2.1.1-0~x2go1) unstable; urgency=low
 
   * New upstream version (0.2.1.1):
@@ -12,7 +52,7 @@ python-x2go (0.2.1.1-0~x2go1) unstable; urgency=low
       under the same user ID, we have to strictly differentiate between
       running/suspend sessions associated to the several connected session
       profiles.
-    - Make connection disruptures more robust.
+    - Make connection disruptures more robust. (Fixes: #23).
 
  -- Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;  Tue, 18 Dec 2012 12:36:34 +0100
 
diff --git a/debian/copyright b/debian/copyright
index 8a3752a..f1d6bb8 100644
--- a/debian/copyright
+++ b/debian/copyright
@@ -4,12 +4,12 @@ Upstream-Contact: Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 Source: <A HREF="http://code.x2go.org/releases/source/python-x2go">http://code.x2go.org/releases/source/python-x2go</A> 
 
 Files: *
-Copyright: 2010-2012, Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+Copyright: 2010-2013, Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 License: AGPL-3+
 
 Files: x2go/gevent_subprocess.py
 Copyright:  2010, Mark Visser &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mjmvisser at gmail.com</A>&gt;
-            2010-2012, Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+            2010-2013, Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 License: AGPL-3+
 Comment: The file was placed in the ,,public domain'' by Mark Visser and
  in context of the X2Go project it is published as GPL-3. The file was
@@ -17,7 +17,7 @@ Comment: The file was placed in the ,,public domain'' by Mark Visser and
  <A HREF="http://groups.google.com/group/gevent/browse_thread/thread/dba1a5d29e0a60ff">http://groups.google.com/group/gevent/browse_thread/thread/dba1a5d29e0a60ff</A>
 
 Files: Makefile.docupload
-Copyright: 2010-2012, Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+Copyright: 2010-2013, Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 License: GPL-3+
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
@@ -39,7 +39,7 @@ License: GPL-3+
  `/usr/share/common-licenses/GPL-3'.
 
 Files: debian/*
-Copyright: 2010-2012, Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+Copyright: 2010-2013, Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 License: GPL-2+
  Python X2Go is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
diff --git a/debian/rules b/debian/rules
index 214d87b..4f67782 100755
--- a/debian/rules
+++ b/debian/rules
@@ -1,7 +1,7 @@
 #!/usr/bin/make -f
 # debian/rules file - for python-x2go
 # Based on sample debian/rules file - for GNU Hello (1.3).
-# Copyright 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 
 WITH_PYTHON2 = $(shell test -f /usr/bin/dh_python2 &amp;&amp; echo &quot;--with python2&quot;)
 
@@ -11,7 +11,7 @@ WITH_PYTHON2 = $(shell test -f /usr/bin/dh_python2 &amp;&amp; echo &quot;--with python2&quot;)
 override_dh_auto_build:
 	mkdir -p .epydoc/html
 	rm -Rf .epydoc/html/*
-	epydoc --debug -n &quot;Python X2go&quot; -u <A HREF="http://www.x2go.org">http://www.x2go.org</A> -v --html --no-private -o .epydoc/html x2go/
+	epydoc --debug -n &quot;Python X2Go&quot; -u <A HREF="http://www.x2go.org">http://www.x2go.org</A> -v --html --no-private -o .epydoc/html x2go/
 	dh_auto_build
 
 # tests from upstream are currently broken...
diff --git a/examples/x2go_resume_session.py b/examples/x2go_resume_session.py
index 2afc739..26c151c 100644
--- a/examples/x2go_resume_session.py
+++ b/examples/x2go_resume_session.py
@@ -1,7 +1,7 @@
 #!/usr/bin/python
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -37,7 +37,7 @@ username = &quot;foo&quot;
 
 password = getpass.getpass()
 
-cli = x2go.X2goClient(use_cache=False, loglevel=x2go.log.loglevel_DEBUG)
+cli = x2go.X2GoClient(use_cache=False, loglevel=x2go.log.loglevel_DEBUG)
 s_uuid = cli.register_session(server, port=port, username=username, geometry=&quot;800x600&quot;, add_to_known_hosts=True)
 cli.connect_session(s_uuid, password=password)
 
diff --git a/examples/x2go_start_session.py b/examples/x2go_start_session.py
index d260f64..fbea4c4 100644
--- a/examples/x2go_start_session.py
+++ b/examples/x2go_start_session.py
@@ -1,7 +1,7 @@
 #!/usr/bin/python
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -37,7 +37,7 @@ command  = &quot;GNOME&quot;
 
 password = getpass.getpass()
 
-cli = x2go.X2goClient(use_cache=False, loglevel=x2go.log.loglevel_DEBUG)
+cli = x2go.X2GoClient(use_cache=False, loglevel=x2go.log.loglevel_DEBUG)
 s_uuid = cli.register_session(server, port=port,
                               username=username,
                               cmd=command,
diff --git a/examples/x2go_start_session_with_progress_status.py b/examples/x2go_start_session_with_progress_status.py
index 8e7b0e6..8a4ec5f 100644
--- a/examples/x2go_start_session_with_progress_status.py
+++ b/examples/x2go_start_session_with_progress_status.py
@@ -1,7 +1,7 @@
 #!/usr/bin/python
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -32,7 +32,7 @@ import threading
 
 # modify to your needs...
 server   = &quot;server.mydomain.tld&quot;
-port     = 222
+port     = 22
 username = &quot;foo&quot;
 command  = &quot;GNOME&quot;
 
@@ -45,7 +45,7 @@ def my_progress_bar(ps):
 
 password = getpass.getpass()
 
-cli = x2go.X2goClient(use_cache=False, loglevel=x2go.log.loglevel_DEBUG)
+cli = x2go.X2GoClient(use_cache=False, loglevel=x2go.log.loglevel_DEBUG)
 s_uuid = cli.register_session(server, port=port,
                               username=username,
                               cmd=command,
diff --git a/setup.py b/setup.py
index 396dd13..890ebef 100755
--- a/setup.py
+++ b/setup.py
@@ -18,12 +18,17 @@
 # Free Software Foundation, Inc.,
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
+import os
+
 from setuptools import setup, find_packages
-import x2go 
+for line in file(os.path.join('x2go', '__init__.py')).readlines():
+    if (line.startswith('__VERSION__')):
+        exec(line.strip())
+MODULE_VERSION = __VERSION__
 
 setup(
     name = &quot;x2go&quot;,
-    version = x2go.__VERSION__,
+    version = MODULE_VERSION,
     description = &quot;Python X2Go implements an X2Go client/session library in Python based on the Python Paramiko SSH module.&quot;,
     license = 'AGPLv3+',
     author = 'Mike Gabriel',
diff --git a/x2go/__init__.py b/x2go/__init__.py
index e8470ef..340f24f 100644
--- a/x2go/__init__.py
+++ b/x2go/__init__.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -26,6 +26,11 @@ Introduction
     With Python X2Go you can write your own X2Go clients or embed X2Go client
     features into already existing application environments.
 
+    NOTE: Beginning with v0.4.0.0 of Python X2Go all class names start with
+    X2Go***. Earlier versions used X2go***. As X2Go is the official name of the
+    project (i.e. with a capital X and a capital G) we have adapted the class
+    names to this circumstance.
+
 API Concept
 ===========
 
@@ -38,25 +43,25 @@ API Concept
 
     Python X2Go only offers five public API classes. With the release of
     version 0.1.0.0, we will try to keep these five public API classes
-    of future releases as compatible as possible with versions of Python X2go
+    of future releases as compatible as possible with versions of Python X2Go
     greater/equal than v0.1.0.0.
 
     The five public API classes are:
 
-        - L{X2goClient} --- a whole X2Go client API
-        - L{X2goSession} --- management of an individual X2Go 
-        session--either started standalone or from within an L{X2goClient} instance
-        - L{X2goClientSettings} --- provide access to X2Go (global and 
+        - L{X2GoClient} --- a whole X2Go client API
+        - L{X2GoSession} --- management of an individual X2Go 
+        session--either started standalone or from within an L{X2GoClient} instance
+        - L{X2GoClientSettings} --- provide access to X2Go (global and 
         user) configuration node &#187;settings&#171;
-        - L{X2goClientPrinting} --- provide access to X2Go (global and 
+        - L{X2GoClientPrinting} --- provide access to X2Go (global and 
         user) configuration node &#187;printing&#171;
-        - L{X2goSessionProfiles} --- provide access to X2Go (global and 
+        - L{X2GoSessionProfiles} --- provide access to X2Go (global and 
         user) configuration node &#187;sessions&#171;
 
     Plus two extra classes on MS Windows platforms:
 
-       - L{X2goClientXConfig} and L{X2goXServer} --- these classes will be initialized 
-       during L{X2goClient} instantiation on MS Windows platforms and start an installed XServer
+       - L{X2GoClientXConfig} and L{X2GoXServer} --- these classes will be initialized 
+       during L{X2GoClient} instantiation on MS Windows platforms and start an installed XServer
 
     Any other of the Python X2Go classes may be subject to internal changes
     and the way of addressing these classes in code may vary between different
@@ -68,40 +73,40 @@ API Structure
 =============
 
     When using Python X2Go in your applications, the basic idea is that you
-    create your own class and inherit the X2goClient class in that::
+    create your own class and inherit the X2GoClient class in that::
 
         import x2go
-        class MyX2goClient(x2go.X2goClient):
+        class MyX2GoClient(x2go.X2GoClient):
 
             ...
 
     Python X2Go is capable of handling multiple running/suspended sessions within the
     same client instance, so for your application, there should not be any need of
-    instantiating more than one L{X2goClient} object in parallel. 
+    instantiating more than one L{X2GoClient} object in parallel. 
 
     NOTE: Doing so is--herewith--fully disrecommended.
 
-    The L{X2goClient} class flattens the complex structure of Python X2Go into
-    many L{X2goClient} methods that you can use in your own C{MyX2goClient} instance.
+    The L{X2GoClient} class flattens the complex structure of Python X2Go into
+    many L{X2GoClient} methods that you can use in your own C{MyX2GoClient} instance.
 
     However, it might be handy to retrieve a whole X2Go session instance 
-    from the L{X2goClient} instance. This can be achieved by the 
-    L{X2goClient.register_session()} method::
+    from the L{X2GoClient} instance. This can be achieved by the 
+    L{X2GoClient.register_session()} method::
 
         import x2go
-        my_x2gocli = MyX2goClient()
+        my_x2gocli = MyX2GoClient()
         reg_session_instance = my_x2gocli.register_session(&lt;options&gt;, return_object=True)
 
     Whereas &lt;options&gt; can be as simple as::
 
          &#187;profile_name=&lt;PROFILE_NAME_IN_SESSIONS_FILE&gt;&#171;
 
-    or contain a whole set of L{X2goSession} parameters that can be used to start a 
+    or contain a whole set of L{X2GoSession} parameters that can be used to start a 
     session manually (i.e. a session that is based on a pre-configured session profile 
     in either of the &#187;sessions&#171; config files).
 
-    The L{X2goClient.register_session()} method---in object-retrieval-mode---returns
-    an L{X2goSession} instance. With this instance you can then manage
+    The L{X2GoClient.register_session()} method---in object-retrieval-mode---returns
+    an L{X2GoSession} instance. With this instance you can then manage
     your X2Go session::
 
         import gevent, getpass
@@ -126,8 +131,8 @@ API Structure
     How to access---especially how to modify---the X2Go client configuration
     files &#187;settings&#171;, &#187;printing&#171;, &#187;sessions&#171; and &#187;xconfig&#171; (Windows only)
     is explained in detail with each class declaration in this API documentation. 
-    Please refer to the class docs of L{X2goClientSettings}, L{X2goClientPrinting},
-    L{X2goSessionProfiles} and L{X2goXServer}.
+    Please refer to the class docs of L{X2GoClientSettings}, L{X2GoClientPrinting},
+    L{X2GoSessionProfiles} and L{X2GoXServer}.
 
 
 Configuration and Session Management
@@ -142,22 +147,22 @@ Configuration and Session Management
     section, a section in the Windows registry, etc.
 
     NOTE: Each configuration node will be re-read whenever it is needed 
-    by an X2Go sesion or the X2goClient class itself.
+    by an X2Go sesion or the X2GoClient class itself.
 
     Conclusively, any change to either of the configuration nodes
     will be reflected as a change in your X2Go client behaviour:
 
-      - L{X2goSessionProfiles}: changes to a session profile in
+      - L{X2GoSessionProfiles}: changes to a session profile in
       the &#187;sessions&#171; node will be available for the next registered
-      L{X2goSession} instance
-      - L{X2goClientPrinting}: on each incoming X2Go print job the
+      L{X2GoSession} instance
+      - L{X2GoClientPrinting}: on each incoming X2Go print job the
       &#187;printing&#171; configuration node will be re-read, thus you can 
       change your X2Go client's print setup during a running session
-      - L{X2goClientSettings}: also the configuration node &#187;settings&#171; 
+      - L{X2GoClientSettings}: also the configuration node &#187;settings&#171; 
       is re-read whenever needed in the course of X2Go session management
-      - L{X2goClientXConfig} and L{X2goXServer} (Windows only): these classes will only be initialized 
+      - L{X2GoClientXConfig} and L{X2GoXServer} (Windows only): these classes will only be initialized 
       once (starting the XServer on Windows platforms) on construction
-      of an L{X2goClient} instance
+      of an L{X2GoClient} instance
 
 Dependencies
 ============
@@ -178,19 +183,19 @@ Contact
 &quot;&quot;&quot;
 
 __NAME__    = 'python-x2go'
-__VERSION__ = '0.2.1.1'
+__VERSION__ = '0.4.0.0'
 
 from gevent import monkey
 monkey.patch_all()
 
 import utils
 
-from client import X2goClient
-from backends.profiles import X2goSessionProfiles
-from backends.printing import X2goClientPrinting
-from backends.settings import X2goClientSettings
-from session import X2goSession
-from sshproxy import X2goSSHProxy
+from client import X2GoClient
+from backends.profiles import X2GoSessionProfiles
+from backends.printing import X2GoClientPrinting
+from backends.settings import X2GoClientSettings
+from session import X2GoSession
+from sshproxy import X2GoSSHProxy
 from x2go_exceptions import *
 from log import *
 
@@ -204,5 +209,16 @@ from defaults import X2GO_SESSIONS_ROOTDIR
 from defaults import X2GO_SSH_ROOTDIR
 
 if X2GOCLIENT_OS == 'Windows':
-    from xserver import X2goClientXConfig, X2goXServer
+    from xserver import X2GoClientXConfig, X2GoXServer
+
+# compat section
+X2goClient = X2GoClient
+X2goSessionProfiles = X2GoSessionProfiles
+X2goClientPrinting = X2GoClientPrinting
+X2goClientSettings = X2GoClientSettings
+X2goSession = X2GoSession
+X2goSSHProxy = X2GoSSHProxy
 
+if X2GOCLIENT_OS == 'Windows':
+    X2goClientXConfig = X2GoClientXconfig
+    X2goXServer = X2GoXServer
diff --git a/x2go/_paramiko.py b/x2go/_paramiko.py
index b1e57c5..3b93d14 100644
--- a/x2go/_paramiko.py
+++ b/x2go/_paramiko.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
diff --git a/x2go/backends/__init__.py b/x2go/backends/__init__.py
index de9a5a7..21601b4 100644
--- a/x2go/backends/__init__.py
+++ b/x2go/backends/__init__.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
diff --git a/x2go/backends/control/__init__.py b/x2go/backends/control/__init__.py
index 81de8bb..890975f 100644
--- a/x2go/backends/control/__init__.py
+++ b/x2go/backends/control/__init__.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -19,6 +19,6 @@
 
 from x2go.defaults import BACKEND_CONTROLSESSION_DEFAULT
 
-from _stdout import X2goControlSessionSTDOUT
+from _stdout import X2GoControlSessionSTDOUT
 
-X2goControlSession = eval(BACKEND_CONTROLSESSION_DEFAULT)
+X2GoControlSession = eval(BACKEND_CONTROLSESSION_DEFAULT)
diff --git a/x2go/backends/control/_stdout.py b/x2go/backends/control/_stdout.py
index fdb80d4..0050147 100644
--- a/x2go/backends/control/_stdout.py
+++ b/x2go/backends/control/_stdout.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,7 +18,7 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goControlSessionSTDOUT class - core functions for handling your individual X2Go sessions.
+X2GoControlSessionSTDOUT class - core functions for handling your individual X2Go sessions.
 
 This backend handles X2Go server implementations that respond via server-side STDOUT.
 
@@ -48,10 +48,10 @@ import x2go.x2go_exceptions as x2go_exceptions
 import x2go.defaults as defaults
 import x2go.checkhosts as checkhosts
 
-from x2go.backends.terminal import X2goTerminalSession as _X2goTerminalSession
-from x2go.backends.info import X2goServerSessionInfo as _X2goServerSessionInfo
-from x2go.backends.info import X2goServerSessionList as _X2goServerSessionList
-from x2go.backends.proxy import X2goProxy as _X2goProxy
+from x2go.backends.terminal import X2GoTerminalSession as _X2GoTerminalSession
+from x2go.backends.info import X2GoServerSessionInfo as _X2GoServerSessionInfo
+from x2go.backends.info import X2GoServerSessionList as _X2GoServerSessionList
+from x2go.backends.proxy import X2GoProxy as _X2GoProxy
 
 import x2go._paramiko
 x2go._paramiko.monkey_patch_paramiko()
@@ -103,7 +103,7 @@ def _rewrite_password(cmd, user=None, password=None):
     return cmd
 
 
-class X2goControlSessionSTDOUT(paramiko.SSHClient):
+class X2GoControlSessionSTDOUT(paramiko.SSHClient):
     &quot;&quot;&quot;\
     In the Python X2Go concept, X2Go sessions fall into two parts: a control session and one to many terminal sessions.
 
@@ -118,22 +118,24 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                  add_to_known_hosts=False,
                  known_hosts=None,
                  forward_sshagent=False,
-                 terminal_backend=_X2goTerminalSession,
-                 info_backend=_X2goServerSessionInfo,
-                 list_backend=_X2goServerSessionList,
-                 proxy_backend=_X2goProxy,
+                 unique_hostkey_aliases=False,
+                 terminal_backend=_X2GoTerminalSession,
+                 info_backend=_X2GoServerSessionInfo,
+                 list_backend=_X2GoServerSessionList,
+                 proxy_backend=_X2GoProxy,
                  client_rootdir=os.path.join(defaults.LOCAL_HOME, defaults.X2GO_CLIENT_ROOTDIR),
                  sessions_rootdir=os.path.join(defaults.LOCAL_HOME, defaults.X2GO_SESSIONS_ROOTDIR),
                  ssh_rootdir=os.path.join(defaults.LOCAL_HOME, defaults.X2GO_SSH_ROOTDIR),
                  logger=None, loglevel=log.loglevel_DEFAULT,
                  published_applications_no_submenus=0,
+                 low_latency=False,
                  **kwargs):
         &quot;&quot;&quot;\
         Initialize an X2Go control session. For each connected session profile there will be one SSH-based
         control session and one to many terminal sessions that all server-client-communicate via this one common control
         session.
 
-        A control session normally gets set up by an L{X2goSession} instance. Do not use it directly!!!
+        A control session normally gets set up by an L{X2GoSession} instance. Do not use it directly!!!
 
         @param profile_name: the profile name of the session profile this control session works for
         @type profile_name: C{str}
@@ -143,14 +145,17 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @type known_hosts: C{str}
         @param forward_sshagent: forward SSH agent authentication requests to the X2Go client-side
         @type forward_sshagent: C{bool}
+        @param unique_hostkey_aliases: instead of storing [&lt;hostname&gt;]:&lt;port&gt; in known_hosts file, use the
+            (unique-by-design) profile ID
+        @type unique_hostkey_aliases: C{bool}
         @param terminal_backend: X2Go terminal session backend to use
         @type terminal_backend: C{class}
         @param info_backend: backend for handling storage of server session information
-        @type info_backend: C{X2goServerSessionInfo*} instance
+        @type info_backend: C{X2GoServerSessionInfo*} instance
         @param list_backend: backend for handling storage of session list information
-        @type list_backend: C{X2goServerSessionList*} instance
+        @type list_backend: C{X2GoServerSessionList*} instance
         @param proxy_backend: backend for handling the X-proxy connections
-        @type proxy_backend: C{X2goProxy*} instance
+        @type proxy_backend: C{X2GoProxy*} instance
         @param client_rootdir: client base dir (default: ~/.x2goclient)
         @type client_rootdir: C{str}
         @param sessions_rootdir: sessions base dir (default: ~/.x2go)
@@ -160,12 +165,14 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @param published_applications_no_submenus: published applications menus with less items than C{published_applications_no_submenus}
             are rendered without submenus
         @type published_applications_no_submenus: C{int}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goControlSessionSTDOUT} constructor
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoControlSessionSTDOUT} constructor
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
+        @param low_latency: set this boolean switch for weak connections, it will double all timeout values.
+        @type low_latency: C{bool}
         @param kwargs: catch any non-defined parameters in C{kwargs}
         @type kwargs: C{dict}
 
@@ -177,6 +184,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         self.add_to_known_hosts = add_to_known_hosts
         self.known_hosts = known_hosts
         self.forward_sshagent = forward_sshagent
+        self.unique_hostkey_aliases = unique_hostkey_aliases
 
         self.hostname = None
         self.port = None
@@ -189,10 +197,11 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         self._remote_username = None
         self._remote_peername = None
 
+        self._server_versions = None
         self._server_features = None
 
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -217,6 +226,8 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
 
         self.session_died = False
 
+        self.low_latency = low_latency
+
         self.published_applications_no_submenus = published_applications_no_submenus
         self._already_querying_published_applications = threading.Lock()
 
@@ -271,7 +282,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @param remote_path: full remote path name of the server-side target location, path names have to be Unix-compliant
         @type remote_path: C{str}
 
-        @raise X2goControlSessionException: if the SSH connection dropped out
+        @raise X2GoControlSessionException: if the SSH connection dropped out
 
         &quot;&quot;&quot;
         ssh_transport = self.get_transport()
@@ -285,7 +296,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                 # react to connection dropped error for SSH connections
                 self.session_died = True
                 self._transport_lock.release()
-                raise x2go_exceptions.X2goControlSessionException('The SSH connection was dropped during an sFTP put action.')
+                raise x2go_exceptions.X2GoControlSessionException('The SSH connection was dropped during an sFTP put action.')
             self.sftp_client = None
         self._transport_lock.release()
 
@@ -300,7 +311,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @param content: a text file, multi-line files use Unix-link EOL style
         @type content: C{str}
 
-        @raise X2goControlSessionException: if the SSH connection dropped out
+        @raise X2GoControlSessionException: if the SSH connection dropped out
 
         &quot;&quot;&quot;
         ssh_transport = self.get_transport()
@@ -317,7 +328,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                 self.session_died = True
                 self._transport_lock.release()
                 self.logger('sFTP-write: opening remote file %s on host %s failed' % (remote_path, self.remote_peername()), loglevel=log.loglevel_WARN)
-                raise x2go_exceptions.X2goControlSessionException('The SSH connection was dropped during an sFTP write action.')
+                raise x2go_exceptions.X2GoControlSessionException('The SSH connection was dropped during an sFTP write action.')
             self.sftp_client = None
         self._transport_lock.release()
 
@@ -330,7 +341,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @param remote_path: full remote path name of the server-side file to be removed, path names have to be Unix-compliant
         @type remote_path: C{str}
 
-        @raise X2goControlSessionException: if the SSH connection dropped out
+        @raise X2GoControlSessionException: if the SSH connection dropped out
 
         &quot;&quot;&quot;
         ssh_transport = self.get_transport()
@@ -344,7 +355,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                 self.session_died = True
                 self._transport_lock.release()
                 self.logger('sFTP-write: removing remote file %s on host %s failed' % (remote_path, self.remote_peername()), loglevel=log.loglevel_WARN)
-                raise x2go_exceptions.X2goControlSessionException('The SSH connection was dropped during an sFTP remove action.')
+                raise x2go_exceptions.X2GoControlSessionException('The SSH connection was dropped during an sFTP remove action.')
             self.sftp_client = None
             self._transport_lock.release()
 
@@ -367,7 +378,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @return: C{True} if the command could be successfully executed on the remote X2Go server
         @rtype: C{bool}
 
-        @raise X2goControlSessionException: if the command execution failed (due to a lost connection)
+        @raise X2GoControlSessionException: if the command execution failed (due to a lost connection)
 
         &quot;&quot;&quot;
         if type(cmd_line) == types.ListType:
@@ -388,6 +399,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         ssh_transport = self.get_transport()
         if ssh_transport and ssh_transport.is_authenticated():
 
+            if self.low_latency: timeout = timeout * 2
             timer = gevent.Timeout(timeout)
             timer.start()
             try:
@@ -398,54 +410,89 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                 self._transport_lock.release()
                 if self.sshproxy_session:
                     self.sshproxy_session.stop_thread()
-                raise x2go_exceptions.X2goControlSessionException('the X2Go control session has died unexpectedly')
+                raise x2go_exceptions.X2GoControlSessionException('the X2Go control session has died unexpectedly')
             except EOFError:
                 self.session_died = True
                 self._transport_lock.release()
                 if self.sshproxy_session:
                     self.sshproxy_session.stop_thread()
-                raise x2go_exceptions.X2goControlSessionException('the X2Go control session has died unexpectedly')
+                raise x2go_exceptions.X2GoControlSessionException('the X2Go control session has died unexpectedly')
             except x2go_exceptions.SSHException:
                 self.session_died = True
                 self._transport_lock.release()
                 if self.sshproxy_session:
                     self.sshproxy_session.stop_thread()
-                raise x2go_exceptions.X2goControlSessionException('the X2Go control session has died unexpectedly')
+                raise x2go_exceptions.X2GoControlSessionException('the X2Go control session has died unexpectedly')
             except gevent.timeout.Timeout:
                 self.session_died = True
                 self._transport_lock.release()
                 if self.sshproxy_session:
                     self.sshproxy_session.stop_thread()
-                raise x2go_exceptions.X2goControlSessionException('the X2Go control session command timed out')
+                raise x2go_exceptions.X2GoControlSessionException('the X2Go control session command timed out')
             except socket.error:
                 self.session_died = True
                 self._transport_lock.release()
                 if self.sshproxy_session:
                     self.sshproxy_session.stop_thread()
-                raise x2go_exceptions.X2goControlSessionException('the X2Go control session has died unexpectedly')
+                raise x2go_exceptions.X2GoControlSessionException('the X2Go control session has died unexpectedly')
             finally:
                 timer.cancel()
 
         else:
             self._transport_lock.release()
-            raise x2go_exceptions.X2goControlSessionException('the X2Go control session is not connected')
+            raise x2go_exceptions.X2GoControlSessionException('the X2Go control session is not connected')
 
         self._transport_lock.release()
         return _retval
 
     @property
+    def _x2go_server_versions(self):
+        &quot;&quot;&quot;\
+        Render a dictionary of server-side X2Go components and their versions. Results get cached
+        once there has been one successful query.
+
+        &quot;&quot;&quot;
+        if self._server_versions is None:
+            self._server_versions = {}
+            (stdin, stdout, stderr) = self._x2go_exec_command('which x2goversion &gt;/dev/null &amp;&amp; x2goversion')
+            _lines = stdout.read().split('\n')
+            for _line in _lines:
+                if ':' not in _line: continue
+                comp = _line.split(':')[0].strip()
+                version = _line.split(':')[1].strip()
+                self._server_versions.update({comp: version})
+            self.logger('server-side X2Go components and their versions are: %s' % self._server_versions, loglevel=log.loglevel_DEBUG)
+        return self._server_versions
+
+    def query_server_versions(self, force=False):
+        &quot;&quot;&quot;\
+        Do a query for the server-side list of X2Go components and their versions.
+
+        @param force: do not use the cached component list, really ask the server (again)
+        @type force: C{bool}
+
+        @return: dictionary of X2Go components (as keys) and their versions (as values)
+        @rtype: C{list}
+
+        &quot;&quot;&quot;
+        if force:
+            self._server_versions = None
+        return self._x2go_server_versions
+    get_server_versions = query_server_versions
+
+    @property
     def _x2go_server_features(self):
         &quot;&quot;&quot;\
-        Render a list of server-side X2Go features. Results get cached once there has been one successfull query.
+        Render a list of server-side X2Go features. Results get cached once there has been one successful query.
 
         &quot;&quot;&quot;
         if self._server_features is None:
             (stdin, stdout, stderr) = self._x2go_exec_command('which x2gofeaturelist &gt;/dev/null &amp;&amp; x2gofeaturelist')
             self._server_features = stdout.read().split('\n')
+            self._server_features = [ f for f in self._server_features if f ]
+            self._server_features.sort()
             self.logger('server-side X2Go features are: %s' % self._server_features, loglevel=log.loglevel_DEBUG)
-            return self._server_features
-        else:
-            return self._server_features
+        return self._server_features
 
     def query_server_features(self, force=False):
         &quot;&quot;&quot;\
@@ -538,7 +585,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @return: SSH transport's user name
         @rtype: C{str}
 
-        @raise X2goControlSessionException: on SSH connection loss
+        @raise X2GoControlSessionException: on SSH connection loss
 
         &quot;&quot;&quot;
         if self._remote_username is None:
@@ -547,7 +594,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                     self._remote_username = self.get_transport().get_username()
                 except:
                     self.session_died = True
-                    raise x2go_exceptions.X2goControlSessionException('Lost connection to X2Go server')
+                    raise x2go_exceptions.X2GoControlSessionException('Lost connection to X2Go server')
         return self._remote_username
 
     def remote_peername(self):
@@ -557,7 +604,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @return: SSH transport's peer name
         @rtype: C{tuple}
 
-        @raise X2goControlSessionException: on SSH connection loss
+        @raise X2GoControlSessionException: on SSH connection loss
 
         &quot;&quot;&quot;
         if self._remote_peername is None:
@@ -566,7 +613,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                     self._remote_peername = self.get_transport().getpeername()
                 except:
                     self.session_died = True
-                    raise x2go_exceptions.X2goControlSessionException('Lost connection to X2Go server')
+                    raise x2go_exceptions.X2GoControlSessionException('Lost connection to X2Go server')
         return self._remote_peername
 
     @property
@@ -617,6 +664,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                 sshproxy_key_filename='', sshproxy_pkey=None, sshproxy_look_for_keys=False, sshproxy_allow_agent=False,
                 sshproxy_tunnel='',
                 forward_sshagent=None,
+                unique_hostkey_aliases=None,
                 session_instance=None,
                 add_to_known_hosts=False, force_password_auth=False):
         &quot;&quot;&quot;\
@@ -660,6 +708,8 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @param forward_sshagent: forward SSH agent authentication requests to the X2Go client-side
             (will update the class property of the same name)
         @type forward_sshagent: C{bool}
+        @param unique_hostkey_aliases: update the unique_hostkey_aliases class property
+        @type unique_hostkey_aliases: C{bool}
         @param timeout: an optional timeout (in seconds) for the TCP connect
         @type timeout: float
         @param look_for_keys: set to C{True} to enable searching for discoverable
@@ -675,7 +725,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @param force_password_auth: non-paramiko option, disable pub/priv key authentication 
             completely, even if the C{pkey} or the C{key_filename} parameter is given
         @type force_password_auth: C{bool}
-        @param session_instance: an instance L{X2goSession} using this L{X2goControlSessionSTDOUT}
+        @param session_instance: an instance L{X2GoSession} using this L{X2GoControlSessionSTDOUT}
             instance.
         @type session_instance: C{obj}
         @param use_sshproxy: connect through an SSH proxy
@@ -713,14 +763,26 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @raise SSHException: if there was any other error connecting or
             establishing an SSH session
         @raise socket.error: if a socket error occurred while connecting
-        @raise X2goSSHProxyException: any SSH proxy exception is passed through while establishing the SSH proxy connection and tunneling setup
-        @raise X2goSSHAuthenticationException: any SSH proxy authentication exception is passed through while establishing the SSH proxy connection and tunneling setup
-        @raise X2goRemoteHomeException: if the remote home directory does not exist or is not accessible
+        @raise X2GoSSHProxyException: any SSH proxy exception is passed through while establishing the SSH proxy connection and tunneling setup
+        @raise X2GoSSHAuthenticationException: any SSH proxy authentication exception is passed through while establishing the SSH proxy connection and tunneling setup
+        @raise X2GoRemoteHomeException: if the remote home directory does not exist or is not accessible
 
         &quot;&quot;&quot;
+        _fake_hostname = None
+
+        if unique_hostkey_aliases is not None:
+            self.unique_hostkey_aliases = unique_hostkey_aliases
+            # prep the fake hostname with the real hostname, so we trigger the corresponding code path in 
+            # x2go.checkhosts and either of its missing host key policies
+            if self.unique_hostkey_aliases:
+                _fake_hostname = &quot;[%s]:%s&quot; % (hostname, port)
+
         if use_sshproxy and sshproxy_host and sshproxy_user:
             try:
-                self.sshproxy_session = sshproxy.X2goSSHProxy(known_hosts=self.known_hosts,
+
+                if not sshproxy_tunnel:
+                    sshproxy_tunnel = &quot;localhost:44444:%s:%s&quot; % (hostname, port)
+                self.sshproxy_session = sshproxy.X2GoSSHProxy(known_hosts=self.known_hosts,
                                                               sshproxy_host=sshproxy_host,
                                                               sshproxy_port=sshproxy_port,
                                                               sshproxy_user=sshproxy_user,
@@ -734,6 +796,11 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                                                               session_instance=session_instance,
                                                               logger=self.logger,
                                                              )
+                hostname = self.sshproxy_session.get_local_proxy_host()
+                port = self.sshproxy_session.get_local_proxy_port()
+                _fake_hostname = self.sshproxy_session.get_remote_host()
+                _fake_port = self.sshproxy_session.get_remote_port()
+                _fake_hostname = &quot;[%s]:%s&quot; % (_fake_hostname, _fake_port)
 
             except:
                 if self.sshproxy_session:
@@ -750,10 +817,10 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                 port = self.sshproxy_session.get_local_proxy_port()
 
         if not add_to_known_hosts and session_instance:
-            self.set_missing_host_key_policy(checkhosts.X2goInteractiveAddPolicy(caller=self, session_instance=session_instance))
+            self.set_missing_host_key_policy(checkhosts.X2GoInteractiveAddPolicy(caller=self, session_instance=session_instance, fake_hostname=_fake_hostname))
 
         if add_to_known_hosts:
-            self.set_missing_host_key_policy(paramiko.AutoAddPolicy())
+            self.set_missing_host_key_policy(checkhosts.X2GoAutoAddPolicy(caller=self, session_instance=session_instance, fake_hostname=_fake_hostname))
 
         # disable pub/priv key authentication if forced
         if force_password_auth:
@@ -776,6 +843,9 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         if forward_sshagent is not None:
             self.forward_sshagent = forward_sshagent
 
+        if timeout and self.low_latency:
+            timeout = timeout * 2
+
         if key_filename or pkey or look_for_keys or allow_agent or (password and force_password_auth):
             try:
                 if password and force_password_auth:
@@ -861,7 +931,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         ssh_transport = self.get_transport()
         ssh_transport.reverse_tunnels = {}
 
-        # mark Paramiko/SSH transport as X2goControlSession
+        # mark Paramiko/SSH transport as X2GoControlSession
         ssh_transport._x2go_session_marker = True
         self._session_password = password
 
@@ -885,7 +955,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
             self.close()
             if self.sshproxy_session:
                 self.sshproxy_session.stop_thread()
-            raise x2go_exceptions.X2goRemoteHomeException('remote home directory does not exist')
+            raise x2go_exceptions.X2GoRemoteHomeException('remote home directory does not exist')
 
         return (self.get_transport() is not None)
 
@@ -894,7 +964,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         Drop an associated terminal session.
 
         @param terminal_session: the terminal session object to remove from the list of associated terminals
-        @type terminal_session: C{X2goTerminalSession*}
+        @type terminal_session: C{X2GoTerminalSession*}
 
         &quot;&quot;&quot;
         for t_name in self.associated_terminals.keys():
@@ -917,9 +987,9 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                 try:
                     if not self.session_died:
                         t_obj.suspend()
-                except x2go_exceptions.X2goTerminalSessionException:
+                except x2go_exceptions.X2GoTerminalSessionException:
                     pass
-                except x2go_exceptions.X2goControlSessionException:
+                except x2go_exceptions.X2GoControlSessionException:
                     self.session_died
                 t_obj.__del__()
             for t_name in t_names:
@@ -987,7 +1057,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         try:
             if self._x2go_exec_command('echo', loglevel=log.loglevel_DEBUG):
                 return True
-        except x2go_exceptions.X2goControlSessionException:
+        except x2go_exceptions.X2GoControlSessionException:
             self.session_died = True
             self.disconnect()
         return False
@@ -1202,8 +1272,8 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         &quot;&quot;&quot;\
         Start a new X2Go session.
 
-        The L{X2goControlSessionSTDOUT.start()} method accepts any parameter
-        that can be passed to any of the C{X2goTerminalSession} backend class
+        The L{X2GoControlSessionSTDOUT.start()} method accepts any parameter
+        that can be passed to any of the C{X2GoTerminalSession} backend class
         constructors.
 
         @param kwargs: parameters that get passed through to the control session's
@@ -1224,26 +1294,25 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         &quot;&quot;&quot;\
         Resume a running/suspended X2Go session. 
 
-        The L{X2goControlSessionSTDOUT.resume()} method accepts any parameter
-        that can be passed to any of the C{X2goTerminalSession*} backend class constructors.
+        The L{X2GoControlSessionSTDOUT.resume()} method accepts any parameter
+        that can be passed to any of the C{X2GoTerminalSession*} backend class constructors.
 
         @return: True if the session could be successfully resumed
         @rtype: C{bool}
 
-        @raise X2goUserException: if the remote user is not allowed to launch/resume X2Go sessions.
+        @raise X2GoUserException: if the remote user is not allowed to launch/resume X2Go sessions.
 
         &quot;&quot;&quot;
         if not self.is_x2gouser(self.get_transport().get_username()):
-            raise x2go_exceptions.X2goUserException('remote user %s is not allowed to run X2Go commands' % self.get_transport().get_username())
+            raise x2go_exceptions.X2GoUserException('remote user %s is not allowed to run X2Go commands' % self.get_transport().get_username())
 
+        session_info = None
         try:
             if session_name is not None:
                 if session_list:
                     session_info = session_list[session_name]
                 else:
                     session_info = self.list_sessions()[session_name]
-            else:
-                session_info = None
         except KeyError:
             _success = False
 
@@ -1264,7 +1333,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                 _success = _terminal.resume()
             else:
                 _success = _terminal.start()
-        except x2go_exceptions.X2goTerminalSessionException:
+        except x2go_exceptions.X2GoTerminalSessionException:
             _success = False
 
         if _success:
@@ -1301,7 +1370,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @return: True if the session could be successfully shared
         @rtype: C{bool}
 
-        @raise X2goDesktopSharingException: if C{username} and C{dislpay} do not relate to a
+        @raise X2GoDesktopSharingException: if C{username} and C{dislpay} do not relate to a
             sharable desktop session
 
         &quot;&quot;&quot;
@@ -1309,7 +1378,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
             user = desktop.split('@')[0]
             display = desktop.split('@')[1]
         if not (user and display):
-            raise x2go_exceptions.X2goDesktopSharingException('Need user name and display number of sharable desktop.')
+            raise x2go_exceptions.X2GoDesktopSharingException('Need user name and display number of shared desktop.')
 
         cmd = '%sXSHAD%sXSHAD%s' % (share_mode, user, display)
 
@@ -1330,7 +1399,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @return: a list of X2Go desktops available for sharing
         @rtype: C{list}
 
-        @raise X2goTimeOutException: on command execution timeouts, with the server-side C{x2golistdesktops}
+        @raise X2GoTimeOutException: on command execution timeouts, with the server-side C{x2golistdesktops}
             command this can sometimes happen. Make sure you ignore these time-outs and to try again
 
         &quot;&quot;&quot;
@@ -1343,6 +1412,9 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
             # this _success loop will catch errors in case the x2golistsessions output is corrupt
             # this should not be needed and is a workaround for the current X2Go server implementation
 
+            if self.low_latency:
+                maxwait = maxwait * 2
+
             timeout = gevent.Timeout(maxwait)
             timeout.start()
             try:
@@ -1353,7 +1425,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
                 # if we do not get a reply here after &lt;maxwait&gt; seconds we will raise a time out, we have to
                 # make sure that we catch this at places where we want to ignore timeouts (e.g. in the 
                 # desktop list cache)
-                raise x2go_exceptions.X2goTimeOutException('x2golistdesktop command timed out')
+                raise x2go_exceptions.X2GoTimeOutException('x2golistdesktop command timed out')
             finally:
                 timeout.cancel()
 
@@ -1374,7 +1446,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         @return: a list of client-side mounts for X2Go session C{&lt;session_name&gt;} on the server
         @rtype: C{list}
 
-        @raise X2goTimeOutException: on command execution timeouts, queries with the server-side
+        @raise X2GoTimeOutException: on command execution timeouts, queries with the server-side
             C{x2golistmounts} query should normally be processed quickly, a time-out may hint that the
             control session has lost its connection to the X2Go server
 
@@ -1385,6 +1457,9 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
 
         else:
 
+            if self.low_latency:
+                maxwait = maxwait * 2
+
             # this _success loop will catch errors in case the x2golistmounts output is corrupt
 
             timeout = gevent.Timeout(maxwait)
@@ -1396,7 +1471,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
             except gevent.timeout.Timeout:
                 # if we do not get a reply here after &lt;maxwait&gt; seconds we will raise a time out, we have to
                 # make sure that we catch this at places where we want to ignore timeouts
-                raise x2go_exceptions.X2goTimeOutException('x2golistmounts command timed out')
+                raise x2go_exceptions.X2GoTimeOutException('x2golistmounts command timed out')
             finally:
                 timeout.cancel()
 
@@ -1410,16 +1485,19 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
             C{x2golistsessions} is returned.
         @type raw: C{bool}
 
-        @return: normally an instance of a C{X2goServerSessionList*} backend is returned. However,
+        @return: normally an instance of a C{X2GoServerSessionList*} backend is returned. However,
             if the raw argument is set, the plain text output of the server-side C{x2golistsessions}
             command is returned
-        @rtype: C{X2goServerSessionList} instance or str
+        @rtype: C{X2GoServerSessionList} instance or str
 
-        @raise X2goControlSessionException: on command execution timeouts, if this happens the control session will
+        @raise X2GoControlSessionException: on command execution timeouts, if this happens the control session will
             be interpreted as disconnected due to connection loss
         &quot;&quot;&quot;
         if raw:
-            (stdin, stdout, stderr) = self._x2go_exec_command(&quot;export HOSTNAME &amp;&amp; x2golistsessions&quot;)
+            if 'X2GO_LIST_SHADOWSESSIONS' in self._x2go_server_features:
+                (stdin, stdout, stderr) = self._x2go_exec_command(&quot;export HOSTNAME &amp;&amp; { x2golistsessions; x2golistshadowsessions; }&quot;)
+            else:
+                (stdin, stdout, stderr) = self._x2go_exec_command(&quot;export HOSTNAME &amp;&amp; x2golistsessions&quot;)
             return stdout.read(), stderr.read()
 
         else:
@@ -1436,7 +1514,10 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
             while not _success and _count &lt; _maxwait:
                 _count += 1
                 try:
-                    (stdin, stdout, stderr) = self._x2go_exec_command(&quot;export HOSTNAME &amp;&amp; x2golistsessions&quot;)
+                    if 'X2GO_LIST_SHADOWSESSIONS' in self._x2go_server_features:
+                        (stdin, stdout, stderr) = self._x2go_exec_command(&quot;export HOSTNAME &amp;&amp; { x2golistsessions; x2golistshadowsessions; }&quot;)
+                    else:
+                        (stdin, stdout, stderr) = self._x2go_exec_command(&quot;export HOSTNAME &amp;&amp; x2golistsessions&quot;)
                     _stdout_read = stdout.read()
                     _listsessions = self._list_backend(_stdout_read, info_backend=self._info_backend).sessions
                     _success = True
@@ -1450,7 +1531,7 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
             if _count &gt;= _maxwait:
                 self.session_died = True
                 self.disconnect()
-                raise x2go_exceptions.X2goControlSessionException('x2golistsessions command failed after we have tried 20 times')
+                raise x2go_exceptions.X2GoControlSessionException('x2golistsessions command failed after we have tried 20 times')
 
             # update internal variables when list_sessions() is called
             for _session_name, _terminal in self.associated_terminals.items():
diff --git a/x2go/backends/info/__init__.py b/x2go/backends/info/__init__.py
index 4183215..6cf39f7 100644
--- a/x2go/backends/info/__init__.py
+++ b/x2go/backends/info/__init__.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -20,8 +20,8 @@
 from x2go.defaults import BACKEND_SERVERSESSIONINFO_DEFAULT
 from x2go.defaults import BACKEND_SERVERSESSIONLIST_DEFAULT
 
-from _stdout import X2goServerSessionInfoSTDOUT
-from _stdout import X2goServerSessionListSTDOUT
+from _stdout import X2GoServerSessionInfoSTDOUT
+from _stdout import X2GoServerSessionListSTDOUT
 
-X2goServerSessionInfo = eval(BACKEND_SERVERSESSIONINFO_DEFAULT)
-X2goServerSessionList = eval(BACKEND_SERVERSESSIONLIST_DEFAULT)
+X2GoServerSessionInfo = eval(BACKEND_SERVERSESSIONINFO_DEFAULT)
+X2GoServerSessionList = eval(BACKEND_SERVERSESSIONLIST_DEFAULT)
diff --git a/x2go/backends/info/_stdout.py b/x2go/backends/info/_stdout.py
index 7182a95..2273eb3 100644
--- a/x2go/backends/info/_stdout.py
+++ b/x2go/backends/info/_stdout.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,7 +18,7 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goServerSessionList and X2goServerSessionInfo classes - data handling for 
+X2GoServerSessionList and X2GoServerSessionInfo classes - data handling for 
 X2Go server sessions.
 
 This backend handles X2Go server implementations that respond with session infos 
@@ -34,17 +34,17 @@ import re
 
 import x2go.defaults as defaults
 
-class X2goServerSessionInfoSTDOUT(object):
+class X2GoServerSessionInfoSTDOUT(object):
     &quot;&quot;&quot;\
-    L{X2goServerSessionInfo} is used to store all information
+    L{X2GoServerSessionInfo} is used to store all information
     that is retrieved from the connected X2Go server on 
-    C{X2goTerminalSessionBACKEND.start()} resp. C{X2goTerminalSessionBACKEND.resume()}.
+    C{X2GoTerminalSessionBACKEND.start()} resp. C{X2GoTerminalSessionBACKEND.resume()}.
 
     &quot;&quot;&quot;
     def __str__(self):
         return self.name
     def __repr__(self):
-        result = 'X2goServerSessionInfoSTDOUT('
+        result = 'X2GoServerSessionInfoSTDOUT('
         for p in dir(self):
             if '__' in p or not p in self.__dict__ or type(p) is types.InstanceType: continue
             result += p + '=' + str(self.__dict__[p]) +','
@@ -52,7 +52,7 @@ class X2goServerSessionInfoSTDOUT(object):
 
     def _parse_x2golistsessions_line(self, x2go_output):
         &quot;&quot;&quot;\
-        Parse a single line of X2go's listsessions output.
+        Parse a single line of X2Go's listsessions output.
 
         @param x2go_output: output from ,,x2golistsessions'' command (as list of strings/lines)
         @type x2go_output: C{list}
@@ -90,7 +90,7 @@ class X2goServerSessionInfoSTDOUT(object):
         @rtype: C{bool}
 
         &quot;&quot;&quot;
-        return re.match('.*_stRPUBLISHED_.*', self.name)
+        return bool(re.match('.*_stRPUBLISHED_.*', self.name))
 
     def is_running(self):
         &quot;&quot;&quot;\
@@ -102,6 +102,34 @@ class X2goServerSessionInfoSTDOUT(object):
         &quot;&quot;&quot;
         return self.status == 'R'
 
+    def get_session_type(self):
+        &quot;&quot;&quot;\
+        Get the session type (i.e. 'D', 'R', 'S' or 'P').
+
+        @return: session type
+        @rtype: C{str}
+        &quot;&quot;&quot;
+        cmd = self.name.split('_')[1]
+        session_type = cmd[2]
+        if session_type == 'R' and self.is_published_applications_provider():
+            session_type = 'P'
+        return session_type
+
+    def get_share_mode(self):
+        &quot;&quot;&quot;\
+        Get the share mode of a shadow session.
+
+        @return: share mode (0: view-only, 1: full access), C{None} when used for non-desktop-sharing sessions
+        @rtype: C{str}
+
+        &quot;&quot;&quot;
+        share_mode = None
+        cmd = self.name.split('_')[1]
+        session_type = cmd[2]
+        if session_type == 'S':
+            share_mode = cmd[3]
+        return share_mode
+
     def is_suspended(self):
         &quot;&quot;&quot;\
         Is this session suspended?
@@ -120,9 +148,7 @@ class X2goServerSessionInfoSTDOUT(object):
         @rtype: C{bool}
 
         &quot;&quot;&quot;
-        _desktop_sessions = defaults.X2GO_DESKTOPSESSIONS.keys()
-        _regexp_desktop_sessions = '(%s)' % &quot;|&quot;.join(_desktop_sessions)
-        return re.match('.*_stD%s_.*' % _regexp_desktop_sessions, self.name)
+        return self.get_session_type() == 'D'
 
     def _parse_x2gostartagent_output(self, x2go_output):
         &quot;&quot;&quot;\
@@ -214,7 +240,7 @@ class X2goServerSessionInfoSTDOUT(object):
 
     def clear(self):
         &quot;&quot;&quot;\
-        Clear all properties of a L{X2goServerSessionInfo} object.
+        Clear all properties of a L{X2GoServerSessionInfo} object.
 
         &quot;&quot;&quot;
         self.name = ''
@@ -235,10 +261,10 @@ class X2goServerSessionInfoSTDOUT(object):
 
     def update(self, session_info):
         &quot;&quot;&quot;\
-        Update all properties of a L{X2goServerSessionInfo} object.
+        Update all properties of a L{X2GoServerSessionInfo} object.
 
         @param session_info: a provided session info data structure
-        @type session_info: C{X2goServerSessionInfo*}
+        @type session_info: C{X2GoServerSessionInfo*}
 
         &quot;&quot;&quot;
         if type(session_info) == type(self):
@@ -253,35 +279,43 @@ class X2goServerSessionInfoSTDOUT(object):
     &quot;&quot;&quot; Class constructor, identical to L{clear()} method. &quot;&quot;&quot;
 
 
-class X2goServerSessionListSTDOUT(object):
+class X2GoServerSessionListSTDOUT(object):
     &quot;&quot;&quot;\
-    L{X2goServerSessionListSTDOUT} is used to store all information
+    L{X2GoServerSessionListSTDOUT} is used to store all information
     that is retrieved from a connected X2Go server on a
-    C{X2goControlSessionBACKEND.list_sessions()} call.
+    C{X2GoControlSessionBACKEND.list_sessions()} call.
 
     &quot;&quot;&quot;
-    def __init__(self, x2go_output, info_backend=X2goServerSessionInfoSTDOUT):
+    def __init__(self, x2go_output=None, info_backend=X2GoServerSessionInfoSTDOUT):
         &quot;&quot;&quot;\
         @param x2go_output: X2Go server's C{x2golistsessions} command output, each 
             session separated by a newline character. Session values are separated 
             by Unix Pipe Symbols ('|')
         @type x2go_output: str
         @param info_backend: the session info backend to use
-        @type info_backend: C{X2goServerSessionInfo*}
+        @type info_backend: C{X2GoServerSessionInfo*}
 
         &quot;&quot;&quot;
         self.sessions = {}
-        lines = x2go_output.split(&quot;\n&quot;)
-        for line in lines:
-            if not line:
-                continue
-            s_info = info_backend()
-            s_info._parse_x2golistsessions_line(line)
-            self.sessions[s_info.name] = s_info
+        if x2go_output is not None:
+            lines = x2go_output.split(&quot;\n&quot;)
+            for line in lines:
+                if not line:
+                    continue
+                s_info = info_backend()
+                s_info._parse_x2golistsessions_line(line)
+                self.sessions[s_info.name] = s_info
 
     def __call__(self):
         return self.sessions
 
+    def set_sessions(self, sessions):
+        &quot;&quot;&quot;\
+        Set the sessions property directly by parsing a complete data structure.
+
+        &quot;&quot;&quot;
+        self.sessions = sessions
+
     def get_session_info(self, session_name):
         &quot;&quot;&quot;\
         Retrieve the session information for C{&lt;session_name&gt;}.
@@ -290,10 +324,34 @@ class X2goServerSessionListSTDOUT(object):
         @type session_name: C{str}
 
         @return: the session info of C{&lt;session_name&gt;}
-        @rtype: C{X2goServerSessionInfo*} or C{None}
+        @rtype: C{X2GoServerSessionInfo*} or C{None}
 
         &quot;&quot;&quot;
         try:
             return self.sessions[session_name]
         except KeyError:
             return None
+
+    def get_session_with(self, property_name, value, hostname=None):
+        &quot;&quot;&quot;\
+        Find session with a given display number on a given host.
+
+        @param property_name: match a session based on this property name
+        @type property_name: C{str}
+        @param value: the resulting session has to match this value for C{&lt;property_name&gt;}
+        @type value: C{str}
+        @param hostname: the result has to match this hostname
+        @type hostname: C{str}
+
+        &quot;&quot;&quot;
+        if property_name == 'display':
+            value = value.lstrip(':')
+            if '.' in value: value = value.split('.')[0]
+
+        for session in self.sessions.values():
+            try:
+                if str(getattr(session, property_name)) == str(value):
+                    if hostname is None or session.hostname == hostname:
+                        return session
+            except AttributeError:
+                pass
diff --git a/x2go/backends/printing/__init__.py b/x2go/backends/printing/__init__.py
index 94cbd97..0fda59e 100644
--- a/x2go/backends/printing/__init__.py
+++ b/x2go/backends/printing/__init__.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -19,9 +19,9 @@
 
 from x2go.defaults import BACKEND_CLIENTPRINTING_DEFAULT
 
-from _file import X2goClientPrintingFILE
-from _winreg import X2goClientPrintingWINREG
-from _gconf import X2goClientPrintingGCONF
+from _file import X2GoClientPrintingFILE
+from _winreg import X2GoClientPrintingWINREG
+from _gconf import X2GoClientPrintingGCONF
 
-X2goClientPrinting = eval(BACKEND_CLIENTPRINTING_DEFAULT)
+X2GoClientPrinting = eval(BACKEND_CLIENTPRINTING_DEFAULT)
 
diff --git a/x2go/backends/printing/_file.py b/x2go/backends/printing/_file.py
index ba136da..3f606f0 100644
--- a/x2go/backends/printing/_file.py
+++ b/x2go/backends/printing/_file.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,9 +18,9 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-L{X2goClientPrintingFILE} class is one of Python X2go's public API classes. 
+L{X2GoClientPrintingFILE} class is one of Python X2Go's public API classes. 
 
-Retrieve an instance of this class from your L{X2goClient} instance.
+Retrieve an instance of this class from your L{X2GoClient} instance.
 Use this class in your Python X2Go based applications to access the &#187;printing&#171; 
 configuration of your X2Go client application.
 
@@ -41,15 +41,15 @@ import x2go.x2go_exceptions as x2go_exceptions
 
 _print_property_map = {
         'pdfview_cmd': {
-            'ini_section': 'view', 
+            'ini_section': 'view',
             'ini_option': 'command',
         },
         'save_to_folder': {
-            'ini_section': 'save', 
+            'ini_section': 'save',
             'ini_option': 'folder',
         },
         'printer': {
-            'ini_section': 'CUPS', 
+            'ini_section': 'CUPS',
             'ini_option': 'defaultprinter',
         },
         'print_cmd': {
@@ -58,13 +58,13 @@ _print_property_map = {
         },
 }
 
-class X2goClientPrintingFILE(inifiles.X2goIniFile):
+class X2GoClientPrintingFILE(inifiles.X2GoIniFile):
     &quot;&quot;&quot;\
-    L{X2goClientPrintingFILE} provides access to the X2Go ini-like file
+    L{X2GoClientPrintingFILE} provides access to the X2Go ini-like file
     &#187;printing&#171; as stored in C{~/.x2goclient/printing} resp. globally
     C{/etc/x2goclient/printing}.
 
-    An instance of L{X2goClientPrintingFILE} is created on each incoming
+    An instance of L{X2GoClientPrintingFILE} is created on each incoming
     print job. This facilitates that on every print job the print action
     for this job is derived from the &#187;printing&#171; configuration file.
 
@@ -81,18 +81,18 @@ class X2goClientPrintingFILE(inifiles.X2goIniFile):
             directory filename)
         @type config_files: C{list}
         @param defaults: a cascaded Python dicitionary structure with ini file defaults (to override 
-            Python X2go's hard coded defaults in L{defaults}
+            Python X2Go's hard coded defaults in L{defaults}
         @type defaults: C{dict}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goPrintAction} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoPrintAction} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         self.client_instance = client_instance
-        inifiles.X2goIniFile.__init__(self, config_files, defaults=defaults, logger=logger, loglevel=loglevel)
+        inifiles.X2GoIniFile.__init__(self, config_files, defaults=defaults, logger=logger, loglevel=loglevel)
 
         self._detect_print_action()
 
@@ -108,23 +108,23 @@ class X2goClientPrintingFILE(inifiles.X2goIniFile):
         _show_dialog = self.get('General', 'showdialog', key_type=types.BooleanType)
 
         if _show_dialog and self.client_instance is not None:
-            self._print_action = printactions.X2goPrintActionDIALOG(client_instance=self.client_instance, logger=self.logger)
+            self._print_action = printactions.X2GoPrintActionDIALOG(client_instance=self.client_instance, logger=self.logger)
 
         elif _general_pdfview and _view_open:
             _view_command = self.get('view', 'command')
-            self._print_action = printactions.X2goPrintActionPDFVIEW(client_instance=self.client_instance, pdfview_cmd=_view_command, logger=self.logger)
+            self._print_action = printactions.X2GoPrintActionPDFVIEW(client_instance=self.client_instance, pdfview_cmd=_view_command, logger=self.logger)
 
         elif _general_pdfview and not _view_open:
             _safe_folder = self.get('save', 'folder')
-            self._print_action = printactions.X2goPrintActionPDFSAVE(client_instance=self.client_instance, save_to_folder=_safe_folder, logger=self.logger)
+            self._print_action = printactions.X2GoPrintActionPDFSAVE(client_instance=self.client_instance, save_to_folder=_safe_folder, logger=self.logger)
 
         elif not _general_pdfview and not _print_startcmd:
             _cups_defaultprinter = self.get('CUPS', 'defaultprinter')
-            self._print_action = printactions.X2goPrintActionPRINT(client_instance=self.client_instance, printer=_cups_defaultprinter, logger=self.logger)
+            self._print_action = printactions.X2GoPrintActionPRINT(client_instance=self.client_instance, printer=_cups_defaultprinter, logger=self.logger)
 
         elif not _general_pdfview and _print_startcmd:
             _print_command = self.get('print', 'command')
-            self._print_action = printactions.X2goPrintActionPRINTCMD(client_instance=self.client_instance, print_cmd=_print_command, logger=self.logger)
+            self._print_action = printactions.X2GoPrintActionPRINTCMD(client_instance=self.client_instance, print_cmd=_print_command, logger=self.logger)
 
     @property
     def print_action(self):
@@ -173,7 +173,7 @@ class X2goClientPrintingFILE(inifiles.X2goIniFile):
         @return: the stored value for C{&lt;print_property&gt;}
         @rtype: C{str}
 
-        @raise X2goClientPrintingException: if the printing property does not exist
+        @raise X2GoClientPrintingException: if the printing property does not exist
 
         &quot;&quot;&quot;
         if print_property in _print_property_map.keys():
@@ -181,7 +181,7 @@ class X2goClientPrintingFILE(inifiles.X2goIniFile):
             _ini_option = _print_property_map[print_property]['ini_option']
             return self.get_value(_ini_section, _ini_option)
         else:
-            raise x2go_exceptions.X2goClientPrintingException('No such X2Go client printing property ,,%s\'\'' % print_property)
+            raise x2go_exceptions.X2GoClientPrintingException('No such X2Go client printing property ,,%s\'\'' % print_property)
 
     def set_property(self, print_property, value):
         &quot;&quot;&quot;\
@@ -192,7 +192,7 @@ class X2goClientPrintingFILE(inifiles.X2goIniFile):
         @param value: the value to be stored as C{&lt;print_property&gt;}
         @rtype: C{str}
 
-        @raise X2goClientPrintingException: if the printing property does not exist or if there is a type mismatch
+        @raise X2GoClientPrintingException: if the printing property does not exist or if there is a type mismatch
 
         &quot;&quot;&quot;
         if print_property in _print_property_map.keys():
@@ -202,10 +202,10 @@ class X2goClientPrintingFILE(inifiles.X2goIniFile):
             if type(value) is types.UnicodeType:
                 value = value.encode('utf-8')
             if  _default_type != type(value):
-                raise x2go_exceptions.X2goClientPrintingException('Type mismatch error for property ,,%s\'\' - is: %s, should be: %s' % (print_property, str(type(value)), str(_default_type)))
+                raise x2go_exceptions.X2GoClientPrintingException('Type mismatch error for property ,,%s\'\' - is: %s, should be: %s' % (print_property, str(type(value)), str(_default_type)))
             self.update_value(_ini_section, _ini_option, value)
         else:
-            raise x2go_exceptions.X2goClientPrintingException('No such X2Go client printing property ,,%s\'\'' % print_property)
+            raise x2go_exceptions.X2GoClientPrintingException('No such X2Go client printing property ,,%s\'\'' % print_property)
 
     def store_print_action(self, print_action, **print_properties):
         &quot;&quot;&quot;\
diff --git a/x2go/backends/printing/_gconf.py b/x2go/backends/printing/_gconf.py
index 11bc718..84f3a2b 100644
--- a/x2go/backends/printing/_gconf.py
+++ b/x2go/backends/printing/_gconf.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,9 +18,9 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-L{X2goClientPrintingGCONF} class is one of Python X2go's public API classes. 
+L{X2GoClientPrintingGCONF} class is one of Python X2Go's public API classes. 
 
-Retrieve an instance of this class from your L{X2goClient} instance.
+Retrieve an instance of this class from your L{X2GoClient} instance.
 Use this class in your Python X2Go based applications to access the &#187;printing&#171; 
 configuration of your X2Go client application.
 
@@ -36,14 +36,14 @@ from x2go.defaults import X2GO_CLIENTPRINTING_DEFAULTS as _X2GO_CLIENTPRINTING_D
 from x2go.defaults import X2GO_PRINTING_CONFIGFILES as _X2GO_PRINTING_CONFIGFILES
 import x2go.inifiles as inifiles
 
-from x2go.x2go_exceptions import X2goNotImplementedYetException
+from x2go.x2go_exceptions import X2GoNotImplementedYetException
 
-class X2goClientPrintingGCONF(inifiles.X2goIniFile):
+class X2GoClientPrintingGCONF(inifiles.X2GoIniFile):
     &quot;&quot;&quot;\
-    L{X2goClientPrintingGCONF} provides access to the GCONF based configuration
+    L{X2GoClientPrintingGCONF} provides access to the GCONF based configuration
     of the X2Go client printing setup.
 
-    An instance of L{X2goClientPrintingGCONF} is created on each incoming
+    An instance of L{X2GoClientPrintingGCONF} is created on each incoming
     print job. This facilitates that on every print job the print action
     for this job is derived from the &#187;printing&#171; configuration file.
 
@@ -56,16 +56,16 @@ class X2goClientPrintingGCONF(inifiles.X2goIniFile):
     def __init__(self, defaults=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
         @param defaults: a cascaded Python dicitionary structure with ini file defaults (to override 
-            Python X2go's hard coded defaults in L{defaults}
+            Python X2Go's hard coded defaults in L{defaults}
         @type defaults: C{dict}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goPrintAction} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoPrintAction} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
-        raise X2goNotImplementedYetException('GCONF backend support is not implemented yet')
+        raise X2GoNotImplementedYetException('GCONF backend support is not implemented yet')
 
 
diff --git a/x2go/backends/printing/_winreg.py b/x2go/backends/printing/_winreg.py
index 839be52..b5e65e7 100644
--- a/x2go/backends/printing/_winreg.py
+++ b/x2go/backends/printing/_winreg.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,9 +18,9 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-L{X2goClientPrintingWINREG} class is one of Python X2go's public API classes. 
+L{X2GoClientPrintingWINREG} class is one of Python X2Go's public API classes. 
 
-Retrieve an instance of this class from your L{X2goClient} instance.
+Retrieve an instance of this class from your L{X2GoClient} instance.
 Use this class in your Python X2Go based applications to access the &#187;printing&#171; 
 configuration of your X2Go client application.
 
@@ -36,14 +36,14 @@ from x2go.defaults import X2GO_CLIENTPRINTING_DEFAULTS as _X2GO_CLIENTPRINTING_D
 from x2go.defaults import X2GO_PRINTING_CONFIGFILES as _X2GO_PRINTING_CONFIGFILES
 import x2go.inifiles as inifiles
 
-from x2go.x2go_exceptions import X2goNotImplementedYetException
+from x2go.x2go_exceptions import X2GoNotImplementedYetException
 
-class X2goClientPrintingWINREG(inifiles.X2goIniFile):
+class X2GoClientPrintingWINREG(inifiles.X2GoIniFile):
     &quot;&quot;&quot;\
-    L{X2goClientPrintingWINREG} provides access to the Windows registry based configuration
+    L{X2GoClientPrintingWINREG} provides access to the Windows registry based configuration
     of the X2Go client printing setup.
 
-    An instance of L{X2goClientPrintingWINREG} is created on each incoming
+    An instance of L{X2GoClientPrintingWINREG} is created on each incoming
     print job. This facilitates that on every print job the print action
     for this job is derived from the &#187;printing&#171; configuration file.
 
@@ -56,14 +56,14 @@ class X2goClientPrintingWINREG(inifiles.X2goIniFile):
     def __init__(self, defaults=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
         @param defaults: a cascaded Python dicitionary structure with ini file defaults (to override 
-            Python X2go's hard coded defaults in L{defaults}
+            Python X2Go's hard coded defaults in L{defaults}
         @type defaults: C{dict}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goPrintAction} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoPrintAction} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
-        raise X2goNotImplementedYetException('WINREG backend support is not implemented yet')
+        raise X2GoNotImplementedYetException('WINREG backend support is not implemented yet')
diff --git a/x2go/backends/profiles/__init__.py b/x2go/backends/profiles/__init__.py
index 796245b..9766fc5 100644
--- a/x2go/backends/profiles/__init__.py
+++ b/x2go/backends/profiles/__init__.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -19,10 +19,10 @@
 
 from x2go.defaults import BACKEND_SESSIONPROFILES_DEFAULT
 
-from _file import X2goSessionProfilesFILE
-from _winreg import X2goSessionProfilesWINREG
-from _httpsbroker import X2goSessionProfilesHTTPSBROKER
-from _gconf import X2goSessionProfilesGCONF
+from _file import X2GoSessionProfilesFILE
+from _winreg import X2GoSessionProfilesWINREG
+from _httpsbroker import X2GoSessionProfilesHTTPSBROKER
+from _gconf import X2GoSessionProfilesGCONF
 
-X2goSessionProfiles = eval(BACKEND_SESSIONPROFILES_DEFAULT)
+X2GoSessionProfiles = eval(BACKEND_SESSIONPROFILES_DEFAULT)
 
diff --git a/x2go/backends/profiles/_file.py b/x2go/backends/profiles/_file.py
index eb21f61..64b5f15 100644
--- a/x2go/backends/profiles/_file.py
+++ b/x2go/backends/profiles/_file.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,9 +18,9 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-L{X2goSessionProfiles} class - managing x2goclient session profiles.
+L{X2GoSessionProfiles} class - managing x2goclient session profiles.
 
-L{X2goSessionProfiles} is a public API class. Use this class in your Python X2Go based 
+L{X2GoSessionProfiles} is a public API class. Use this class in your Python X2Go based 
 applications.
 
 &quot;&quot;&quot;
@@ -37,10 +37,10 @@ from x2go.defaults import X2GO_DESKTOPSESSIONS as _X2GO_DESKTOPSESSIONS
 import x2go.inifiles as inifiles
 import x2go.log as log
 import x2go.utils as utils
-from x2go.x2go_exceptions import X2goProfileException
+from x2go.x2go_exceptions import X2GoProfileException
 
 
-class X2goSessionProfilesFILE(inifiles.X2goIniFile):
+class X2GoSessionProfilesFILE(inifiles.X2GoIniFile):
 
     defaultSessionProfile = _X2GO_SESSIONPROFILE_DEFAULTS
     _non_profile_sections = ('embedded')
@@ -55,10 +55,10 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
         @type defaults: C{dict}
         @param session_profile_defaults: a default session profile
         @type session_profile_defaults: C{dict}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goSessionProfilesFILE} constructor
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoSessionProfilesFILE} constructor
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
@@ -67,16 +67,17 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
         self._profile_metatypes = {}
         self._cached_profile_ids = []
         self._cached_profile_names = []
+        self._profiles_need_profile_id_renewal = []
 
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
 
-        # providing defaults for an X2goSessionProfiles instance will---in the worst case---override your
+        # providing defaults for an X2GoSessionProfiles instance will---in the worst case---override your
         # existing sessions file in your home directory once you write the sessions back to file...
-        inifiles.X2goIniFile.__init__(self, config_files, defaults=defaults, logger=logger, loglevel=loglevel)
+        inifiles.X2GoIniFile.__init__(self, config_files, defaults=defaults, logger=logger, loglevel=loglevel)
 
         if utils._checkSessionProfileDefaults(session_profile_defaults):
             self.defaultSessionProfile = session_profile_defaults
@@ -115,7 +116,6 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
         @rtype: C{str}
 
         &quot;&quot;&quot;
-
         _profile_id = self.check_profile_id_or_name(profile_id_or_name)
         if not self._profile_metatypes.has_key(_profile_id) or force:
             _config = self.get_profile_config(_profile_id)
@@ -146,6 +146,22 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
         else:
             return self._profile_metatypes[_profile_id]
 
+    def write(self):
+
+        # then update profile IDs for profiles that have a renamed host attribute...
+        for profile_id in self._profiles_need_profile_id_renewal:
+            _config = self.get_profile_config(profile_id=profile_id)
+            self.iniConfig.remove_section(profile_id)
+            try: self._cached_profile_ids.remove(profile_id)
+            except ValueError: pass
+            self.add_profile(profile_id=None, **_config)
+            self._cached_profile_names = []
+        self._profiles_need_profile_id_renewal = []
+
+        # at last write the profile config as is...
+        return inifiles.X2GoIniFile.write(self)
+
+
     def get_profile_option_type(self, option):
         &quot;&quot;&quot;\
         Get the data type for a specific session profile option.
@@ -186,7 +202,7 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
         @type profile_id_or_name: C{str}
         @param parameter: if specified, only the value for the given parameter is returned
         @type parameter: C{str}
-        @param profile_id: profile ID (fast than specifying C{profile_id_or_name})
+        @param profile_id: profile ID (faster than specifying C{profile_id_or_name})
         @type profile_id: C{str}
 
         @return: the session profile configuration for the given profile ID (or name)
@@ -217,7 +233,7 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
                 return value
 
             else:
-                raise X2goProfileException('no such session profile parameter: %s' % parameter)
+                raise X2GoProfileException('no such session profile parameter: %s' % parameter)
         return _profile_config
 
     def default_profile_config(self):
@@ -244,7 +260,7 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
         try:
             self.check_profile_id_or_name(profile_id_or_name)
             return True
-        except X2goProfileException:
+        except X2GoProfileException:
             return False
 
     @property
@@ -310,7 +326,7 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
         elif len(_profile_ids) == 0:
             return None
         else:
-            raise X2goProfileException('The sessions config file contains multiple session profiles with name: %s' % profile_name)
+            raise X2GoProfileException('The sessions config file contains multiple session profiles with name: %s' % profile_name)
 
     def to_profile_name(self, profile_id):
         &quot;&quot;&quot;\
@@ -344,18 +360,13 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
         &quot;&quot;&quot;
         if profile_id is None:
             profile_id = utils._genSessionProfileId()
+
         for key, value in kwargs.items():
-            if key in self.defaultSessionProfile:
-                self.update_value(profile_id, key, value)
-            else:
-                raise X2goProfileException('keyword ,,%s\'\' not supported in X2Go session profile' % key)
+            self.update_value(None, key, value, profile_id=profile_id)
 
         for key, value in self.defaultSessionProfile.items():
             if key in kwargs: continue
-            self.update_value(profile_id, key, value)
-
-        self._cached_profile_ids = []
-        self._cached_profile_names = []
+            self.update_value(None, key, value, profile_id=profile_id)
 
         return profile_id
 
@@ -374,7 +385,7 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
         self._cached_profile_ids = []
         self._cached_profile_names = []
 
-    def update_value(self, section, key, value):
+    def update_value(self, section, key, value, profile_id=None):
         &quot;&quot;&quot;\
         Update a value in a session profile.
 
@@ -387,21 +398,23 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
 
         &quot;&quot;&quot;
         try:
-            profile_id = self.check_profile_id_or_name(section)
-        except X2goProfileException:
+            profile_id = profile_id or self.check_profile_id_or_name(section)
+        except X2GoProfileException:
             profile_id = section
+
+        inifiles.X2GoIniFile.update_value(self, profile_id, key, value)
+
         if key == 'name':
             profile_name = value
             current_profile_name = self.get_value(profile_id, key)
             if not profile_name:
-                raise X2goProfileException('profile name for profile id %s may not be empty' % profile_id)
+                raise X2GoProfileException('profile name for profile id %s may not be empty' % profile_id)
             else:
                 if profile_name != current_profile_name and profile_name in self.profile_names:
-                    raise X2goProfileException('a profile of name ,,%s'' already exists' % profile_name)
+                    raise X2GoProfileException('a profile of name ,,%s\'\' already exists' % profile_name)
             self._cached_profile_names = []
 
         if key == 'export' and type(value) == types.DictType:
-
             _strvalue = '&quot;'
             for folder in value.keys():
                 _strvalue += &quot;%s:%s;&quot; % (folder, int(value[folder]))
@@ -409,7 +422,10 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
             _strvalue = _strvalue.replace('&quot;&quot;', '')
             value = _strvalue
 
-        inifiles.X2goIniFile.update_value(self, profile_id, key, value)
+        if key == 'host':
+            _config = self.get_profile_config(profile_id=profile_id)
+            if _config.has_key('host') and _config['host'] != value:
+                self._profiles_need_profile_id_renewal.append(profile_id)
 
     def check_profile_id_or_name(self, profile_id_or_name):
         &quot;&quot;&quot;\
@@ -421,7 +437,7 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
         @return: profile ID
         @rtype: C{str}
 
-        @raise X2goProfileException: if no such session profile exists
+        @raise X2GoProfileException: if no such session profile exists
 
         &quot;&quot;&quot;
         _profile_id = None
@@ -432,19 +448,19 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
             # we were given a session profile id...
             _profile_id = profile_id_or_name
         else:
-            raise X2goProfileException('No session profile with id or name ,,%s\'\' exists.' % profile_id_or_name)
+            raise X2GoProfileException('No session profile with id or name ,,%s\'\' exists.' % profile_id_or_name)
         return _profile_id
 
     def to_session_params(self, profile_id_or_name=None, profile_id=None):
         &quot;&quot;&quot;\
-        Convert session profile options to L{X2goSession} constructor method parameters.
+        Convert session profile options to L{X2GoSession} constructor method parameters.
 
         @param profile_id_or_name: either profile ID or profile name is accepted
         @type profile_id_or_name: C{str}
         @param profile_id: profile ID (fast than specifying C{profile_id_or_name})
         @type profile_id: C{str}
 
-        @return: a dictionary of L{X2goSession} constructor method parameters
+        @return: a dictionary of L{X2GoSession} constructor method parameters
         @rtype: C{dict}
 
         &quot;&quot;&quot;
@@ -453,11 +469,11 @@ class X2goSessionProfilesFILE(inifiles.X2goIniFile):
 
     def get_session_param(self, profile_id_or_name, param):
         &quot;&quot;&quot;\
-        Get a single L{X2goSession} parameter from a specific session profile.
+        Get a single L{X2GoSession} parameter from a specific session profile.
 
         @param profile_id_or_name: either profile ID or profile name is accepted
         @type profile_id_or_name: C{str}
-        @param param: the parameter name in the L{X2goSession} constructor method
+        @param param: the parameter name in the L{X2GoSession} constructor method
         @type param: C{str}
 
         @return: the value of the session profile option represented by C{param}
diff --git a/x2go/backends/profiles/_gconf.py b/x2go/backends/profiles/_gconf.py
index 1926e44..645a213 100644
--- a/x2go/backends/profiles/_gconf.py
+++ b/x2go/backends/profiles/_gconf.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,9 +18,9 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-L{X2goSessionProfiles} class - managing x2goclient session profiles.
+L{X2GoSessionProfiles} class - managing x2goclient session profiles.
 
-L{X2goSessionProfiles} is a public API class. Use this class in your Python X2Go based 
+L{X2GoSessionProfiles} is a public API class. Use this class in your Python X2Go based 
 applications.
 
 &quot;&quot;&quot;
@@ -32,9 +32,9 @@ from x2go.defaults import X2GO_SESSIONPROFILE_DEFAULTS
 import x2go.inifiles as inifiles
 import x2go.log as log
 
-from x2go.x2go_exceptions import X2goNotImplementedYetException
+from x2go.x2go_exceptions import X2GoNotImplementedYetException
 
-class X2goSessionProfilesGCONF(inifiles.X2goIniFile):
+class X2GoSessionProfilesGCONF(inifiles.X2GoIniFile):
 
     defaultSessionProfile = X2GO_SESSIONPROFILE_DEFAULTS
     _non_profile_sections = ('embedded')
@@ -45,12 +45,12 @@ class X2goSessionProfilesGCONF(inifiles.X2goIniFile):
 
         @param session_profile_defaults: a default session profile
         @type session_profile_defaults: C{dict}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goSessionProfilesGCONF} constructor
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoSessionProfilesGCONF} constructor
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
-        raise X2goNotImplementedYetException('GCONF backend support is not implemented yet')
+        raise X2GoNotImplementedYetException('GCONF backend support is not implemented yet')
diff --git a/x2go/backends/profiles/_httpsbroker.py b/x2go/backends/profiles/_httpsbroker.py
index b56b237..852630d 100644
--- a/x2go/backends/profiles/_httpsbroker.py
+++ b/x2go/backends/profiles/_httpsbroker.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,9 +18,9 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-L{X2goSessionProfiles} class - managing x2goclient session profiles.
+L{X2GoSessionProfiles} class - managing x2goclient session profiles.
 
-L{X2goSessionProfiles} is a public API class. Use this class in your Python X2Go based 
+L{X2GoSessionProfiles} is a public API class. Use this class in your Python X2Go based 
 applications.
 
 &quot;&quot;&quot;
@@ -32,9 +32,9 @@ from x2go.defaults import X2GO_SESSIONPROFILE_DEFAULTS
 import x2go.inifiles as inifiles
 import x2go.log as log
 
-from x2go.x2go_exceptions import X2goNotImplementedYetException
+from x2go.x2go_exceptions import X2GoNotImplementedYetException
 
-class X2goSessionProfilesHTTPSBROKER(inifiles.X2goIniFile):
+class X2GoSessionProfilesHTTPSBROKER(inifiles.X2GoIniFile):
 
     defaultSessionProfile = X2GO_SESSIONPROFILE_DEFAULTS
     _non_profile_sections = ('embedded')
@@ -45,12 +45,12 @@ class X2goSessionProfilesHTTPSBROKER(inifiles.X2goIniFile):
 
         @param session_profile_defaults: a default session profile
         @type session_profile_defaults: C{dict}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goSessionProfilesHTTPSBROKER} constructor
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoSessionProfilesHTTPSBROKER} constructor
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
-        raise X2goNotImplementedYetException('HTTPSBROKER backend support is not implemented yet')
+        raise X2GoNotImplementedYetException('HTTPSBROKER backend support is not implemented yet')
diff --git a/x2go/backends/profiles/_winreg.py b/x2go/backends/profiles/_winreg.py
index 7fb1319..07f8e95 100644
--- a/x2go/backends/profiles/_winreg.py
+++ b/x2go/backends/profiles/_winreg.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,9 +18,9 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-L{X2goSessionProfiles} class - managing x2goclient session profiles.
+L{X2GoSessionProfiles} class - managing x2goclient session profiles.
 
-L{X2goSessionProfiles} is a public API class. Use this class in your Python X2Go based 
+L{X2GoSessionProfiles} is a public API class. Use this class in your Python X2Go based 
 applications.
 
 &quot;&quot;&quot;
@@ -32,9 +32,9 @@ from x2go.defaults import X2GO_SESSIONPROFILE_DEFAULTS
 import x2go.inifiles as inifiles
 import x2go.log as log
 
-from x2go.x2go_exceptions import X2goNotImplementedYetException
+from x2go.x2go_exceptions import X2GoNotImplementedYetException
 
-class X2goSessionProfilesWINREG(inifiles.X2goIniFile):
+class X2GoSessionProfilesWINREG(inifiles.X2GoIniFile):
 
     defaultSessionProfile = X2GO_SESSIONPROFILE_DEFAULTS
     _non_profile_sections = ('embedded')
@@ -45,13 +45,13 @@ class X2goSessionProfilesWINREG(inifiles.X2goIniFile):
 
         @param session_profile_defaults: a default session profile
         @type session_profile_defaults: C{dict}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goSessionProfilesWINREG} constructor
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoSessionProfilesWINREG} constructor
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
-        raise X2goNotImplementedYetException('WINREG backend support is not implemented yet')
+        raise X2GoNotImplementedYetException('WINREG backend support is not implemented yet')
 
diff --git a/x2go/backends/proxy/__init__.py b/x2go/backends/proxy/__init__.py
index 4b15847..83d6aff 100644
--- a/x2go/backends/proxy/__init__.py
+++ b/x2go/backends/proxy/__init__.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -19,6 +19,6 @@
 
 from x2go.defaults import BACKEND_PROXY_DEFAULT
 
-from _nx3 import X2goProxyNX3
+from _nx3 import X2GoProxyNX3
 
-X2goProxy = eval(BACKEND_PROXY_DEFAULT)
+X2GoProxy = eval(BACKEND_PROXY_DEFAULT)
diff --git a/x2go/backends/proxy/_nx3.py b/x2go/backends/proxy/_nx3.py
index 22ba3ef..3fb1c7c 100644
--- a/x2go/backends/proxy/_nx3.py
+++ b/x2go/backends/proxy/_nx3.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,7 +18,7 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goProxy classes - proxying your connection through NX3 and others.
+X2GoProxy classes - proxying your connection through NX3 and others.
 
 &quot;&quot;&quot;
 __NAME__ = 'x2goproxynx3-pylib'
@@ -32,20 +32,20 @@ import base
 
 from x2go.defaults import X2GOCLIENT_OS as _X2GOCLIENT_OS
 
-class X2goProxyNX3(base.X2goProxyBASE):
+class X2GoProxyNX3(base.X2GoProxyBASE):
     &quot;&quot;&quot;\
-    X2goNX3Proxy is a NX version 3 based X2Go proxy connection class.
+    X2GoNX3Proxy is a NX version 3 based X2Go proxy connection class.
 
-    It basically fills L{X2goProxyBASE} variables with sensible content. Its 
+    It basically fills L{X2GoProxyBASE} variables with sensible content. Its 
     methods mostly wrap around the corresponding methods of the parent class.
 
     &quot;&quot;&quot;
     def __init__(self, *args, **kwargs):
         &quot;&quot;&quot;\
-        For available parameters refer to L{X2goProxyBASE} class documentation.
+        For available parameters refer to L{X2GoProxyBASE} class documentation.
 
         &quot;&quot;&quot;
-        base.X2goProxyBASE.__init__(self, *args, **kwargs)
+        base.X2GoProxyBASE.__init__(self, *args, **kwargs)
 
         # setting some default environment variables, nxproxy paths etc.
         if _X2GOCLIENT_OS == &quot;Windows&quot;:
@@ -76,7 +76,7 @@ class X2goProxyNX3(base.X2goProxyBASE):
                 &quot;connect=127.0.0.1&quot;,
                 &quot;clipboard=1&quot;,
                 &quot;cookie=%s&quot; % self.session_info.cookie,
-                &quot;port=%d&quot; % self.session_info.graphics_port,
+                &quot;port=%s&quot; % self.session_info.graphics_port,
                 &quot;errors=%s&quot; % os.path.join(&quot;.&quot;, &quot;..&quot;, &quot;S-%s&quot; % self.session_info.name, self.session_log, ),
             ]
         else:
@@ -87,7 +87,7 @@ class X2goProxyNX3(base.X2goProxyBASE):
                 &quot;connect=127.0.0.1&quot;,
                 &quot;clipboard=1&quot;,
                 &quot;cookie=%s&quot; % self.session_info.cookie,
-                &quot;port=%d&quot; % self.session_info.graphics_port,
+                &quot;port=%s&quot; % self.session_info.graphics_port,
                 &quot;errors=%s&quot; % os.path.join(self.session_info.local_container, self.session_log, ),
             ]
 
@@ -136,7 +136,7 @@ class X2goProxyNX3(base.X2goProxyBASE):
         self.logger('NX3 Proxy mode is server, cookie=%s, host=127.0.0.1, port=%s.' % (self.session_info.cookie, self.session_info.graphics_port,), loglevel=log.loglevel_DEBUG)
         self.logger('NX3 proxy writes session log to %s.' % os.path.join(self.session_info.local_container, 'session.log'), loglevel=log.loglevel_DEBUG)
 
-        p, p_ok = base.X2goProxyBASE.start_proxy(self)
+        p, p_ok = base.X2GoProxyBASE.start_proxy(self)
 
         if self.ok():
             self.logger('NX3 proxy is up and running.', loglevel=log.loglevel_INFO)
diff --git a/x2go/backends/proxy/base.py b/x2go/backends/proxy/base.py
index 38e80da..3e9d11e 100644
--- a/x2go/backends/proxy/base.py
+++ b/x2go/backends/proxy/base.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,7 +18,7 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goProxyBASE class - proxying your connection through NX3 and others.
+X2GoProxyBASE class - proxying your connection through NX3 and others.
 
 &quot;&quot;&quot;
 __NAME__ = 'x2goproxy-pylib'
@@ -47,12 +47,12 @@ from x2go.defaults import LOCAL_HOME as _LOCAL_HOME
 from x2go.defaults import X2GO_SESSIONS_ROOTDIR as _X2GO_SESSIONS_ROOTDIR
 
 
-class X2goProxyBASE(threading.Thread):
+class X2GoProxyBASE(threading.Thread):
     &quot;&quot;&quot;\
-    X2goProxy is an abstract class for X2Go proxy connections.
+    X2GoProxy is an abstract class for X2Go proxy connections.
 
     This class needs to be inherited from a concrete proxy class. Only 
-    currently available proxy class is: L{X2goProxyNX3}.
+    currently available proxy class is: L{X2GoProxyNX3}.
 
     &quot;&quot;&quot;
     PROXY_CMD = ''
@@ -75,30 +75,30 @@ class X2goProxyBASE(threading.Thread):
                  session_instance=None,
                  logger=None, loglevel=log.loglevel_DEFAULT, ):
         &quot;&quot;&quot;\
-        @param session_info: session information provided as an C{X2goServerSessionInfo*} backend
+        @param session_info: session information provided as an C{X2GoServerSessionInfo*} backend
             instance
-        @type session_info: C{X2goServerSessionInfo*} instance
+        @type session_info: C{X2GoServerSessionInfo*} instance
         @param ssh_transport: SSH transport object from C{paramiko.SSHClient}
         @type ssh_transport: C{paramiko.Transport} instance
         @param session_log: name of the proxy's session logfile
         @type session_log: C{str}
         @param sessions_rootdir: base dir where X2Go session files are stored (by default: ~/.x2go)
         @type sessions_rootdir: C{str}
-        @param proxy_options: a set of very C{X2goProxy*} backend specific options; any option that is not known
-            to the C{X2goProxy*} backend will simply be ignored
+        @param proxy_options: a set of very C{X2GoProxy*} backend specific options; any option that is not known
+            to the C{X2GoProxy*} backend will simply be ignored
         @type proxy_options: C{dict}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goProxy} constructor
-        @param session_instance: the L{X2goSession} instance this C{X2goProxy*} instance belongs to
-        @type session_instance: L{X2goSession} instance
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoProxy} constructor
+        @param session_instance: the L{X2GoSession} instance this C{X2GoProxy*} instance belongs to
+        @type session_instance: L{X2GoSession} instance
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: int
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -180,7 +180,7 @@ class X2goProxyBASE(threading.Thread):
             if self.ssh_transport.getpeername() in ('::1', '127.0.0.1', 'localhost', 'localhost.localdomain'):
                 local_graphics_port += 10000
         except socket.error:
-            raise x2go_exceptions.X2goControlSessionException('The control session has died unexpectedly.')
+            raise x2go_exceptions.X2GoControlSessionException('The control session has died unexpectedly.')
         local_graphics_port = utils.detect_unused_port(preferred_port=local_graphics_port)
 
         self.fw_tunnel = forward.start_forward_tunnel(local_port=local_graphics_port, 
@@ -244,7 +244,7 @@ class X2goProxyBASE(threading.Thread):
 
             1. remove processed proxy_options from self.proxy_options
             2. once you have finished processing the proxy_options call
-            the parent class method X2goProxyBASE.process_proxy_options()
+            the parent class method X2GoProxyBASE.process_proxy_options()
 
         &quot;&quot;&quot;
         # do the logging of remaining options
diff --git a/x2go/backends/settings/__init__.py b/x2go/backends/settings/__init__.py
index a1cb355..a08b32a 100644
--- a/x2go/backends/settings/__init__.py
+++ b/x2go/backends/settings/__init__.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -19,9 +19,9 @@
 
 from x2go.defaults import BACKEND_CLIENTSETTINGS_DEFAULT
 
-from _file import X2goClientSettingsFILE
-from _gconf import X2goClientSettingsGCONF
-from _winreg import X2goClientSettingsWINREG
+from _file import X2GoClientSettingsFILE
+from _gconf import X2GoClientSettingsGCONF
+from _winreg import X2GoClientSettingsWINREG
 
-X2goClientSettings = eval(BACKEND_CLIENTSETTINGS_DEFAULT)
+X2GoClientSettings = eval(BACKEND_CLIENTSETTINGS_DEFAULT)
 
diff --git a/x2go/backends/settings/_file.py b/x2go/backends/settings/_file.py
index 14b5c56..a31cb2a 100644
--- a/x2go/backends/settings/_file.py
+++ b/x2go/backends/settings/_file.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,10 +18,10 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goClientSettings class - managing x2goclient settings file (incl. LDAP-Support).
+X2GoClientSettings class - managing x2goclient settings file (incl. LDAP-Support).
 
-The L{X2goClientSettings} class one of Python X2go's a public API classes.
-Use this class (indirectly by retrieving it from an L{X2goClient} instance)
+The L{X2GoClientSettings} class one of Python X2Go's a public API classes.
+Use this class (indirectly by retrieving it from an L{X2GoClient} instance)
 in your Python X2Go based applications to access the
 &#187;settings&#171; configuration file of your X2Go client application.
 
@@ -35,20 +35,20 @@ from x2go.defaults import X2GO_CLIENTSETTINGS_DEFAULTS as _X2GO_CLIENTSETTINGS_D
 import x2go.inifiles as inifiles
 
 
-class X2goClientSettingsFILE(inifiles.X2goIniFile):
+class X2GoClientSettingsFILE(inifiles.X2GoIniFile):
     &quot;&quot;&quot;\
-    Configuration file based settings for L{X2goClient} instances.
+    Configuration file based settings for L{X2GoClient} instances.
 
     &quot;&quot;&quot;
     defaultValues = _X2GO_CLIENTSETTINGS_DEFAULTS
 
     def __init__(self, config_files=_X2GO_SETTINGS_CONFIGFILES, defaults=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        Constructs an L{X2goClientSettingsFILE} instance. This is normally done from within an L{X2goClient} instance.
-        You can retrieve this L{X2goClientSettingsFILE} instance with the L{X2goClient.get_client_settings()} 
+        Constructs an L{X2GoClientSettingsFILE} instance. This is normally done from within an L{X2GoClient} instance.
+        You can retrieve this L{X2GoClientSettingsFILE} instance with the L{X2GoClient.get_client_settings()} 
         method.
 
-        On construction the L{X2goClientSettingsFILE} object is filled with values from the configuration files::
+        On construction the L{X2GoClientSettingsFILE} object is filled with values from the configuration files::
 
             /etc/x2goclient/settings
             ~/.x2goclient/settings
@@ -58,4 +58,4 @@ class X2goClientSettingsFILE(inifiles.X2goIniFile):
         C{/etc/x2goclient/settings}.
 
         &quot;&quot;&quot;
-        inifiles.X2goIniFile.__init__(self, config_files, defaults=defaults, logger=logger, loglevel=loglevel)
+        inifiles.X2GoIniFile.__init__(self, config_files, defaults=defaults, logger=logger, loglevel=loglevel)
diff --git a/x2go/backends/settings/_gconf.py b/x2go/backends/settings/_gconf.py
index a20bcbb..3d2f349 100644
--- a/x2go/backends/settings/_gconf.py
+++ b/x2go/backends/settings/_gconf.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,10 +18,10 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goClientSettings class - managing x2goclient settings file (incl. LDAP-Support).
+X2GoClientSettings class - managing x2goclient settings file (incl. LDAP-Support).
 
-The L{X2goClientSettings} class one of Python X2go's a public API classes.
-Use this class (indirectly by retrieving it from an L{X2goClient} instance)
+The L{X2GoClientSettings} class one of Python X2Go's a public API classes.
+Use this class (indirectly by retrieving it from an L{X2GoClient} instance)
 in your Python X2Go based applications to access the
 &#187;settings&#171; configuration file of your X2Go client application.
 
@@ -34,25 +34,25 @@ from x2go.defaults import X2GO_SETTINGS_CONFIGFILES as _X2GO_SETTINGS_CONFIGFILE
 from x2go.defaults import X2GO_CLIENTSETTINGS_DEFAULTS as _X2GO_CLIENTSETTINGS_DEFAULTS
 import x2go.inifiles as inifiles
 
-from x2go.x2go_exceptions import X2goNotImplementedYetException
+from x2go.x2go_exceptions import X2GoNotImplementedYetException
 
-class X2goClientSettingsGCONF(inifiles.X2goIniFile):
+class X2GoClientSettingsGCONF(inifiles.X2GoIniFile):
     &quot;&quot;&quot;\
-    Configure settings for L{X2goClient} instances with the GConf daemon.
+    Configure settings for L{X2GoClient} instances with the GConf daemon.
 
     &quot;&quot;&quot;
     defaultValues = _X2GO_CLIENTSETTINGS_DEFAULTS
 
     def __init__(self, config_files=_X2GO_SETTINGS_CONFIGFILES, defaults=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        Constructs an L{X2goClientSettingsGCONF} instance. This is normally done from within an L{X2goClient} instance.
-        You can retrieve this L{X2goClientSettingsGCONF} instance with the L{X2goClient.get_client_settings()} 
+        Constructs an L{X2GoClientSettingsGCONF} instance. This is normally done from within an L{X2GoClient} instance.
+        You can retrieve this L{X2GoClientSettingsGCONF} instance with the L{X2GoClient.get_client_settings()} 
         method.
 
-        On construction the L{X2goClientSettingsGCONF} object is filled with values as found in GConf::
+        On construction the L{X2GoClientSettingsGCONF} object is filled with values as found in GConf::
 
             &lt;GConf paths, FIXME: give proper locations here&gt;
 
         &quot;&quot;&quot;
-        raise X2goNotImplementedYetException('GCONF backend support is not implemented yet')
+        raise X2GoNotImplementedYetException('GCONF backend support is not implemented yet')
 
diff --git a/x2go/backends/settings/_winreg.py b/x2go/backends/settings/_winreg.py
index c5f6f31..50ffc40 100644
--- a/x2go/backends/settings/_winreg.py
+++ b/x2go/backends/settings/_winreg.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,10 +18,10 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goClientSettings class - managing x2goclient settings file (incl. LDAP-Support).
+X2GoClientSettings class - managing x2goclient settings file (incl. LDAP-Support).
 
-The L{X2goClientSettings} class one of Python X2go's a public API classes.
-Use this class (indirectly by retrieving it from an L{X2goClient} instance)
+The L{X2GoClientSettings} class one of Python X2Go's a public API classes.
+Use this class (indirectly by retrieving it from an L{X2GoClient} instance)
 in your Python X2Go based applications to access the
 &#187;settings&#171; configuration file of your X2Go client application.
 
@@ -34,25 +34,25 @@ from x2go.defaults import X2GO_SETTINGS_CONFIGFILES as _X2GO_SETTINGS_CONFIGFILE
 from x2go.defaults import X2GO_CLIENTSETTINGS_DEFAULTS as _X2GO_CLIENTSETTINGS_DEFAULTS
 import x2go.inifiles as inifiles
 
-from x2go.x2go_exceptions import X2goNotImplementedYetException
+from x2go.x2go_exceptions import X2GoNotImplementedYetException
 
-class X2goClientSettingsWINREG(inifiles.X2goIniFile):
+class X2GoClientSettingsWINREG(inifiles.X2GoIniFile):
     &quot;&quot;&quot;\
-    Windows registry based settings for L{X2goClient} instances.
+    Windows registry based settings for L{X2GoClient} instances.
 
     &quot;&quot;&quot;
     defaultValues = _X2GO_CLIENTSETTINGS_DEFAULTS
 
     def __init__(self, config_files=_X2GO_SETTINGS_CONFIGFILES, defaults=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        Constructs an L{X2goClientSettingsWINREG} instance. This is normally done from within an L{X2goClient} instance.
-        You can retrieve this L{X2goClientSettingsWINREG} instance with the L{X2goClient.get_client_settings()} 
+        Constructs an L{X2GoClientSettingsWINREG} instance. This is normally done from within an L{X2GoClient} instance.
+        You can retrieve this L{X2GoClientSettingsWINREG} instance with the L{X2GoClient.get_client_settings()} 
         method.
 
-        On construction the L{X2goClientSettings} object is filled with values from the Windows registry::
+        On construction the L{X2GoClientSettings} object is filled with values from the Windows registry::
 
             &lt;HKLM path, FIXME: give proper locations here&gt;
             &lt;HKCU path, FIXME: give proper locations here&gt;
 
         &quot;&quot;&quot;
-        raise X2goNotImplementedYetException('WINREG backend support is not implemented yet')
+        raise X2GoNotImplementedYetException('WINREG backend support is not implemented yet')
diff --git a/x2go/backends/terminal/__init__.py b/x2go/backends/terminal/__init__.py
index 315441e..c168066 100644
--- a/x2go/backends/terminal/__init__.py
+++ b/x2go/backends/terminal/__init__.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -19,6 +19,6 @@
 
 from x2go.defaults import BACKEND_TERMINALSESSION_DEFAULT
 
-from _stdout import X2goTerminalSessionSTDOUT
+from _stdout import X2GoTerminalSessionSTDOUT
 
-X2goTerminalSession = eval(BACKEND_TERMINALSESSION_DEFAULT)
+X2GoTerminalSession = eval(BACKEND_TERMINALSESSION_DEFAULT)
diff --git a/x2go/backends/terminal/_stdout.py b/x2go/backends/terminal/_stdout.py
index 6f474c0..aeead53 100644
--- a/x2go/backends/terminal/_stdout.py
+++ b/x2go/backends/terminal/_stdout.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,7 +18,7 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goTerminalSession class - core functions for handling your individual X2Go sessions.
+X2GoTerminalSession class - core functions for handling your individual X2Go sessions.
 
 This backend handles X2Go server implementations that respond with session infos 
 via server-side STDOUT and use NX3 as graphical proxy.
@@ -54,10 +54,10 @@ from x2go.defaults import X2GO_SESSIONS_ROOTDIR as _X2GO_SESSIONS_ROOTDIR
 from x2go.defaults import X2GO_GENERIC_APPLICATIONS as _X2GO_GENERIC_APPLICATIONS
 from x2go.defaults import X2GO_DESKTOPSESSIONS as _X2GO_DESKTOPSESSIONS
 
-from x2go.backends.info import X2goServerSessionInfo as _X2goServerSessionInfo
-from x2go.backends.info import X2goServerSessionList as _X2goServerSessionList
-from x2go.backends.proxy import X2goProxy as _X2goProxy
-from x2go.backends.printing import X2goClientPrinting as _X2goClientPrinting
+from x2go.backends.info import X2GoServerSessionInfo as _X2GoServerSessionInfo
+from x2go.backends.info import X2GoServerSessionList as _X2GoServerSessionList
+from x2go.backends.proxy import X2GoProxy as _X2GoProxy
+from x2go.backends.printing import X2GoClientPrinting as _X2GoClientPrinting
 
 _local_color_depth = utils.local_color_depth()
 
@@ -69,7 +69,7 @@ def _rewrite_cmd(cmd, params=None):
     @param cmd: the current command for execution (as found in the session profile parameter C{cmd})
     @type cmd: C{str}
     @param params: an session paramter object
-    @type params: L{X2goSessionParams}
+    @type params: L{X2GoSessionParams}
 
     @return: the rewritten command for server-side execution
     @rtype: C{str}
@@ -82,7 +82,7 @@ def _rewrite_cmd(cmd, params=None):
     if cmd in _X2GO_DESKTOPSESSIONS.keys():
         cmd = _X2GO_DESKTOPSESSIONS[cmd]
 
-    if (cmd == 'RDP') and (type(params) == X2goSessionParams):
+    if (cmd == 'RDP') and (type(params) == X2GoSessionParams):
         _depth = params.depth
         if int(_depth) == 17:
             _depth = 16
@@ -95,7 +95,7 @@ def _rewrite_cmd(cmd, params=None):
     if cmd:
         cmd = '&quot;%s&quot;' % cmd
 
-    if ((type(params) == X2goSessionParams) and params.published_applications and cmd == ''):
+    if ((type(params) == X2GoSessionParams) and params.published_applications and cmd == ''):
         cmd = 'PUBLISHED'
 
     return cmd
@@ -118,10 +118,10 @@ def _rewrite_blanks(cmd):
     return cmd
 
 
-class X2goSessionParams(object):
+class X2GoSessionParams(object):
     &quot;&quot;&quot;\
-    The L{X2goSessionParams} class is used to store all parameters that
-    C{X2goTerminalSession} backend objects are constructed with.
+    The L{X2GoSessionParams} class is used to store all parameters that
+    C{X2GoTerminalSession} backend objects are constructed with.
 
     &quot;&quot;&quot;
     def rewrite_session_type(self):
@@ -169,12 +169,12 @@ class X2goSessionParams(object):
 
     def update(self, **properties_to_be_updated):
         &quot;&quot;&quot;\
-        Update all properties in the object L{X2goSessionParams} object from
+        Update all properties in the object L{X2GoSessionParams} object from
         the passed on dictionary.
 
-        @param properties_to_be_updated: a dictionary with L{X2goSessionParams}
+        @param properties_to_be_updated: a dictionary with L{X2GoSessionParams}
             property names as keys und their values to be update in 
-            L{X2goSessionParams} object.
+            L{X2GoSessionParams} object.
         @type properties_to_be_updated: C{dict}
 
         &quot;&quot;&quot;
@@ -183,25 +183,25 @@ class X2goSessionParams(object):
         self.rewrite_session_type()
 
 
-class X2goTerminalSessionSTDOUT(object):
+class X2GoTerminalSessionSTDOUT(object):
     &quot;&quot;&quot;\
     Class for managing X2Go terminal sessions on a remote X2Go server via Paramiko/SSH.
 
-    With the L{X2goTerminalSessionSTDOUT} class you can start new X2Go sessions, resume suspended 
+    With the L{X2GoTerminalSessionSTDOUT} class you can start new X2Go sessions, resume suspended 
     sessions or suspend resp. terminate currently running sessions on a 
     connected X2Go server.
 
-    An L{X2goTerminalSessionSTDOUT} object uses two main data structure classes:
+    An L{X2GoTerminalSessionSTDOUT} object uses two main data structure classes:
 
-        - L{X2goSessionParams}: stores all parameters that have been passed to the 
+        - L{X2GoSessionParams}: stores all parameters that have been passed to the 
         constructor method.
 
-        - C{X2goServerSessionInfo*} backend class: when starting or resuming a session, an object of this class 
+        - C{X2GoServerSessionInfo*} backend class: when starting or resuming a session, an object of this class 
         will be used to store all information retrieved from the X2Go server.
 
     The terminal session instance works closely together (i.e. depends on) a connected control
-    session instance (e.g. L{X2goControlSessionSTDOUT}). You never should use either of them as a standalone
-    instance. Both, control session and terminal session(s) get managed/controlled via L{X2goSession} instances.
+    session instance (e.g. L{X2GoControlSessionSTDOUT}). You never should use either of them as a standalone
+    instance. Both, control session and terminal session(s) get managed/controlled via L{X2GoSession} instances.
 
     &quot;&quot;&quot;
     def __init__(self, control_session, session_info=None,
@@ -217,16 +217,16 @@ class X2goTerminalSessionSTDOUT(object):
                  rootdir=None,
                  profile_name='UNKNOWN', profile_id=utils._genSessionProfileId(),
                  print_action=None, print_action_args={},
-                 info_backend=_X2goServerSessionInfo,
-                 list_backend=_X2goServerSessionList,
-                 proxy_backend=_X2goProxy, proxy_options={},
-                 printing_backend=_X2goClientPrinting,
+                 info_backend=_X2GoServerSessionInfo,
+                 list_backend=_X2GoServerSessionList,
+                 proxy_backend=_X2GoProxy, proxy_options={},
+                 printing_backend=_X2GoClientPrinting,
                  client_rootdir=os.path.join(_LOCAL_HOME, _X2GO_CLIENT_ROOTDIR),
                  sessions_rootdir=os.path.join(_LOCAL_HOME, _X2GO_SESSIONS_ROOTDIR),
                  session_instance=None,
                  logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        Initialize an X2Go session. With the L{X2goTerminalSessionSTDOUT} class you can start
+        Initialize an X2Go session. With the L{X2GoTerminalSessionSTDOUT} class you can start
         new X2Go sessions, resume suspended sessions or suspend resp. terminate
         currently running sessions on a connected X2Go server.
 
@@ -241,8 +241,8 @@ class X2goTerminalSessionSTDOUT(object):
         @type pack: C{str}
         @param dpi: dots-per-inch value for the session screen (has an impact on the font size on screen)
         @type dpi: C{str}
-        @param cache_type: a dummy parameter that is passed to the L{X2goProxyBASE}. In NX Proxy 
-            (class C{X2goProxyNX3}) this originally is the session name. With X2Go it 
+        @param cache_type: a dummy parameter that is passed to the L{X2GoProxyBASE}. In NX Proxy 
+            (class C{X2GoProxyNX3}) this originally is the session name. With X2Go it 
             defines the name of the NX cache directory. Best is to leave it untouched.
         @type cache_type: C{str}
         @param kbtype: keyboard type, e.g. C{pc105/us} (default), C{pc105/de}, ...
@@ -259,7 +259,7 @@ class X2goTerminalSessionSTDOUT(object):
         @param snd_port: local sound port for network capable audio system
         @type snd_port: C{int}
         @param cmd: command to be run on X2Go server after session start (only used
-            when L{X2goTerminalSessionSTDOUT.start()} is called, ignored on resume, suspend etc.
+            when L{X2GoTerminalSessionSTDOUT.start()} is called, ignored on resume, suspend etc.
         @type cmd: C{str}
         @param published_applications: session is published applications provider
         @type published_applications: C{bool}
@@ -288,30 +288,30 @@ class X2goTerminalSessionSTDOUT(object):
         @param profile_id: the session profile ID for this terminal session
         @type profile_id: C{str}
         @param print_action: either a print action short name (PDFVIEW, PDFSAVE, PRINT, PRINTCMD) or the
-            resp. C{X2goPrintActionXXX} class (where XXX equals one of the given short names)
+            resp. C{X2GoPrintActionXXX} class (where XXX equals one of the given short names)
         @type print_action: C{str} or C{class}
         @param print_action_args: optional arguments for a given print_action (for further info refer to
-            L{X2goPrintActionPDFVIEW}, L{X2goPrintActionPDFSAVE}, L{X2goPrintActionPRINT} and L{X2goPrintActionPRINTCMD})
+            L{X2GoPrintActionPDFVIEW}, L{X2GoPrintActionPDFSAVE}, L{X2GoPrintActionPRINT} and L{X2GoPrintActionPRINTCMD})
         @type print_action_args: dict
         @param info_backend: backend for handling storage of server session information
-        @type info_backend: C{X2goServerSessionInfo*} instance
+        @type info_backend: C{X2GoServerSessionInfo*} instance
         @param list_backend: backend for handling storage of session list information
-        @type list_backend: C{X2goServerSessionList*} instance
+        @type list_backend: C{X2GoServerSessionList*} instance
         @param proxy_backend: backend for handling the X-proxy connections
-        @type proxy_backend: C{X2goProxy*} instance
-        @param proxy_options: a set of very C{X2goProxy*} backend specific options; any option that is not known
-            to the C{X2goProxy*} backend will simply be ignored
+        @type proxy_backend: C{X2GoProxy*} instance
+        @param proxy_options: a set of very C{X2GoProxy*} backend specific options; any option that is not known
+            to the C{X2GoProxy*} backend will simply be ignored
         @type proxy_options: C{dict}
         @param client_rootdir: client base dir (default: ~/.x2goclient)
         @type client_rootdir: C{str}
         @param sessions_rootdir: sessions base dir (default: ~/.x2go)
         @type sessions_rootdir: C{str}
-        @param session_instance: the L{X2goSession} instance that is parent to this terminal session
+        @param session_instance: the L{X2GoSession} instance that is parent to this terminal session
         @type session_instance: C{obj}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goTerminalSessionSTDOUT} constructor
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoTerminalSessionSTDOUT} constructor
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
@@ -327,7 +327,7 @@ class X2goTerminalSessionSTDOUT(object):
         self.mimebox_queue = None
 
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -338,7 +338,7 @@ class X2goTerminalSessionSTDOUT(object):
         self.client_rootdir = client_rootdir
         self.sessions_rootdir = sessions_rootdir
 
-        self.params = X2goSessionParams()
+        self.params = X2GoSessionParams()
 
         self.params.geometry = str(geometry)
         self.params.link = str(link)
@@ -391,7 +391,7 @@ class X2goTerminalSessionSTDOUT(object):
             if self.session_info.name:
                 self.session_info.local_container = os.path.join(self.params.rootdir, 'S-%s' % self.session_info.name)
             else:
-                raise x2go_exceptions.X2goTerminalSessionException('no valid session info availble')
+                raise x2go_exceptions.X2GoTerminalSessionException('no valid session info availble')
         else:
             self.session_info = info_backend()
 
@@ -485,7 +485,7 @@ class X2goTerminalSessionSTDOUT(object):
         Retrieve the X2Go session's session info object.
 
         @return: the session info object
-        @rtype: C{X2goServerSessionInfo*}
+        @rtype: C{X2GoServerSessionInfo*}
 
         &quot;&quot;&quot;
         return self.session_info
@@ -519,7 +519,7 @@ class X2goTerminalSessionSTDOUT(object):
             - PulseAudio
             - Esound (not tested very much)
 
-        @raise X2goControlSessionException: if the control session of this terminal session is not connected
+        @raise X2GoControlSessionException: if the control session of this terminal session is not connected
 
         &quot;&quot;&quot;
         _tunnel = None
@@ -538,7 +538,7 @@ class X2goTerminalSessionSTDOUT(object):
                     self.control_session._x2go_sftp_put(local_path='%s/.pulse-cookie' % _LOCAL_HOME, remote_path='%s/.pulse-cookie' % self.session_info.remote_container)
 
                     # start reverse SSH tunnel for pulse stream
-                    _tunnel = rforward.X2goRevFwTunnel(server_port=self.session_info.snd_port, 
+                    _tunnel = rforward.X2GoRevFwTunnel(server_port=self.session_info.snd_port, 
                                                        remote_host='127.0.0.1', 
                                                        remote_port=self.snd_port, 
                                                        ssh_transport=self.control_session.get_transport(),
@@ -563,7 +563,7 @@ class X2goTerminalSessionSTDOUT(object):
                 self.control_session._x2go_sftp_put(local_path='%s/.esd_auth' % _LOCAL_HOME, remote_path='%s/.esd_auth' % self.control_session._x2go_remote_home)
 
                 # start reverse SSH tunnel for pulse stream
-                _tunnel = rforward.X2goRevFwTunnel(server_port=self.session_info.snd_port, 
+                _tunnel = rforward.X2GoRevFwTunnel(server_port=self.session_info.snd_port, 
                                                    remote_host='127.0.0.1', 
                                                    remote_port=self.snd_port, 
                                                    ssh_transport=self.control_session.get_transport(),
@@ -587,13 +587,13 @@ class X2goTerminalSessionSTDOUT(object):
 
         &quot;&quot;&quot;
         if not self.control_session.is_sshfs_available():
-            raise x2go_exceptions.X2goUserException('Remote user %s is not allowed to share SSHFS resources with the server.' % self.session_info.username)
+            raise x2go_exceptions.X2GoUserException('Remote user %s is not allowed to share SSHFS resources with the server.' % self.session_info.username)
 
         # start reverse SSH tunnel for sshfs (folder sharing, printing)
         ssh_transport = self.control_session.get_transport()
         if self.reverse_tunnels[self.session_info.name]['sshfs'][1] is None:
 
-            _tunnel = sftpserver.X2goRevFwTunnelToSFTP(server_port=self.session_info.sshfs_port,
+            _tunnel = sftpserver.X2GoRevFwTunnelToSFTP(server_port=self.session_info.sshfs_port,
                                                        ssh_transport=ssh_transport,
                                                        auth_key=self.control_session._x2go_session_auth_rsakey,
                                                        session_instance=self.session_instance,
@@ -641,17 +641,17 @@ class X2goTerminalSessionSTDOUT(object):
         &quot;&quot;&quot;\
         Initialize X2Go print spooling.
 
-        @raise X2goUserException: if the X2Go printing feature is not available to this user
+        @raise X2GoUserException: if the X2Go printing feature is not available to this user
 
         &quot;&quot;&quot;
         if not self.control_session.is_sshfs_available():
-            raise x2go_exceptions.X2goUserException('Remote user %s is not allowed to use client-side printing.' % self.session_info.username)
+            raise x2go_exceptions.X2GoUserException('Remote user %s is not allowed to use client-side printing.' % self.session_info.username)
 
         spool_dir = os.path.join(self.session_info.local_container, 'spool')
         if not os.path.exists(spool_dir):
             os.makedirs(spool_dir)
         self.share_local_folder(local_path=spool_dir, folder_type='spool')
-        self.print_queue = printqueue.X2goPrintQueue(profile_name=self.profile_name,
+        self.print_queue = printqueue.X2GoPrintQueue(profile_name=self.profile_name,
                                                      session_name=self.session_info.name,
                                                      spool_dir=spool_dir,
                                                      print_action=self.print_action, 
@@ -667,10 +667,10 @@ class X2goTerminalSessionSTDOUT(object):
         &quot;&quot;&quot;\
         Set a print action for the next incoming print jobs.
 
-        This method is a wrapper for L{X2goPrintQueue}C{.set_print_action()}.
+        This method is a wrapper for L{X2GoPrintQueue}C{.set_print_action()}.
 
-        @param print_action: print action name or object (i.e. an instance of C{X2goPrintAction*} classes)
-        @type print_action: C{str} or C{X2goPrintAction*}
+        @param print_action: print action name or object (i.e. an instance of C{X2GoPrintAction*} classes)
+        @type print_action: C{str} or C{X2GoPrintAction*}
         @param kwargs: print action specific parameters
         @type kwargs: dict
 
@@ -701,20 +701,20 @@ class X2goTerminalSessionSTDOUT(object):
 
         @param mimebox_extensions: file name extensions that are allowed for local opening/processing
         @type mimebox_extensions: C{list}
-        @param mimebox_action: MIME box action given as name or object (i.e. an instance of C{X2goMIMEboxAction*} classes).
+        @param mimebox_action: MIME box action given as name or object (i.e. an instance of C{X2GoMIMEboxAction*} classes).
         @type mimebox_action: C{str} or C{obj}
 
-        @raise X2goUserException: if the X2Go MIME box feature is not available to this user
+        @raise X2GoUserException: if the X2Go MIME box feature is not available to this user
 
         &quot;&quot;&quot;
         if not self.control_session.is_sshfs_available():
-            raise x2go_exceptions.X2goUserException('Remote user %s is not allowed to use the MIME box.' % self.session_info.username)
+            raise x2go_exceptions.X2GoUserException('Remote user %s is not allowed to use the MIME box.' % self.session_info.username)
 
         mimebox_dir = os.path.join(self.session_info.local_container, 'mimebox')
         if not os.path.exists(mimebox_dir):
             os.makedirs(mimebox_dir)
         self.share_local_folder(local_path=mimebox_dir, folder_type='mimebox')
-        self.mimebox_queue = mimebox.X2goMIMEboxQueue(profile_name=self.profile_name,
+        self.mimebox_queue = mimebox.X2GoMIMEboxQueue(profile_name=self.profile_name,
                                                       session_name=self.session_info.name,
                                                       mimebox_dir=mimebox_dir,
                                                       mimebox_extensions=mimebox_extensions,
@@ -729,10 +729,10 @@ class X2goTerminalSessionSTDOUT(object):
         &quot;&quot;&quot;\
         Set a MIME box action for the next incoming MIME jobs.
 
-        This method is a wrapper for L{X2goMIMEboxQueue}C{set_mimebox_action()}.
+        This method is a wrapper for L{X2GoMIMEboxQueue}C{set_mimebox_action()}.
 
-        @param mimebox_action: MIME box action name or object (i.e. an instance of C{X2goMIMEboxAction*} classes)
-        @type mimebox_action: C{str} or C{X2goMIMEboxAction*}
+        @param mimebox_action: MIME box action name or object (i.e. an instance of C{X2GoMIMEboxAction*} classes)
+        @type mimebox_action: C{str} or C{X2GoMIMEboxAction*}
         @param kwargs: MIME box action specific parameters
         @type kwargs: dict
 
@@ -795,12 +795,12 @@ class X2goTerminalSessionSTDOUT(object):
         @return: returns C{True} if the local folder has been successfully mounted within the X2Go server session
         @rtype: C{bool}
 
-        @raise X2goUserException: if local folder sharing is not available to this user
+        @raise X2GoUserException: if local folder sharing is not available to this user
         @raise Exception: any other exception occuring on the way is passed through by this method
 
         &quot;&quot;&quot;
         if not self.control_session.is_sshfs_available():
-            raise x2go_exceptions.X2goUserException('Remote user %s is not allowed to share local folders with the server.' % self.session_info.username)
+            raise x2go_exceptions.X2GoUserException('Remote user %s is not allowed to share local folders with the server.' % self.session_info.username)
 
         if local_path is None:
             self.logger('no folder name given...', log.loglevel_WARN)
@@ -983,6 +983,18 @@ class X2goTerminalSessionSTDOUT(object):
                 # session title fallback... (like X2Go server does it...)
                 self.session_title = _generic_title
 
+        elif self.params.session_type == 'S':
+            if self.set_session_title:
+
+                shared_user = _generic_title.split('XSHAD')[1]
+                shared_display = _generic_title.split('XSHAD')[2].replace('PP', ':').split(&quot;_&quot;)[0]
+
+                self.session_title = 'Desktop %s@%s shared with %s@%s' % (shared_user, shared_display, self.control_session.remote_username(), self.control_session.get_hostname())
+
+            else:
+                # session title fallback... (like X2Go server does it...)
+                self.session_title = _generic_title
+
         else:
             # do nothing for rootless sessions
             self.session_title = _generic_title
@@ -1148,8 +1160,8 @@ class X2goTerminalSessionSTDOUT(object):
         &quot;&quot;&quot;\
         Run a command in this session.
 
-        After L{X2goTerminalSessionSTDOUT.start()} has been called 
-        one or more commands can be executed with L{X2goTerminalSessionSTDOUT.run_command()}
+        After L{X2GoTerminalSessionSTDOUT.start()} has been called 
+        one or more commands can be executed with L{X2GoTerminalSessionSTDOUT.run_command()}
         within the current X2Go session.
 
         @param cmd: Command to be run
@@ -1358,7 +1370,7 @@ class X2goTerminalSessionSTDOUT(object):
         @return: C{True} if session startup has been successful and the X2Go proxy is up-and-running
         @rtype: C{bool}
 
-        @raise X2goTerminalSessionException: if the session startup failed
+        @raise X2GoTerminalSessionException: if the session startup failed
 
         &quot;&quot;&quot;
         self.params.rewrite_session_type()
@@ -1413,7 +1425,7 @@ class X2goTerminalSessionSTDOUT(object):
         # if the first line of stdout is a &quot;DEN(Y)&quot; string then we will presume that
         # we tried to use X2Go desktop sharing and the sharing was rejected
         if &quot;ACCESS DENIED&quot; in _stderr and &quot;XSHAD&quot; in _stderr:
-            raise x2go_exceptions.X2goDesktopSharingException('X2Go desktop sharing has been denied by the remote user')
+            raise x2go_exceptions.X2GoDesktopSharingException('X2Go desktop sharing has been denied by the remote user')
 
         try:
             self.session_info.initialize(_stdout,
@@ -1421,9 +1433,9 @@ class X2goTerminalSessionSTDOUT(object):
                                          hostname=self.control_session.remote_peername(),
                                         )
         except ValueError:
-            raise x2go_exceptions.X2goTerminalSessionException(&quot;failed to start X2Go session&quot;)
+            raise x2go_exceptions.X2GoTerminalSessionException(&quot;failed to start X2Go session&quot;)
         except IndexError:
-            raise x2go_exceptions.X2goTerminalSessionException(&quot;failed to start X2Go session&quot;)
+            raise x2go_exceptions.X2GoTerminalSessionException(&quot;failed to start X2Go session&quot;)
 
         # local path may be a Windows path, so we use the path separator of the local system
         self.session_info.local_container = os.path.join(self.params.rootdir, 'S-%s' % self.session_info.name)
@@ -1453,7 +1465,7 @@ class X2goTerminalSessionSTDOUT(object):
                 self.control_session.get_published_applications()
 
         else:
-            raise x2go_exceptions.X2goTerminalSessionException(&quot;failed to start X2Go session&quot;)
+            raise x2go_exceptions.X2GoTerminalSessionException(&quot;failed to start X2Go session&quot;)
 
         return proxy_ok
 
@@ -1464,7 +1476,7 @@ class X2goTerminalSessionSTDOUT(object):
         @return: C{True} if the session could successfully be resumed
         @rtype: C{bool}
 
-        @raise X2goTerminalSessionException: if the terminal session failed to update server-side reported port changes
+        @raise X2GoTerminalSessionException: if the terminal session failed to update server-side reported port changes
 
         &quot;&quot;&quot;
         setkbd = &quot;0&quot;
@@ -1502,7 +1514,7 @@ class X2goTerminalSessionSTDOUT(object):
                         self.logger('re-allocating graphics port for session %s, old server-side port is in use; new graphics port is %s' % (self.session_info, self.session_info.graphics_port), loglevel=log.loglevel_NOTICE)
                     except TypeError:
                         # if the re-allocation fails, this is fatal!!!
-                        raise x2go_exceptions.X2goTerminalSessionException('Failed to retrieve new graphics port from server. X2Go Session cannot be resumed.')
+                        raise x2go_exceptions.X2GoTerminalSessionException('Failed to retrieve new graphics port from server. X2Go Session cannot be resumed.')
                 elif 'sound_port=' in stdout_line and _new_value != str(self.session_info.snd_port):
                     try:
                         self.session_info.snd_port = int(_new_value)
@@ -1518,6 +1530,12 @@ class X2goTerminalSessionSTDOUT(object):
             except IndexError:
                 continue
 
+        # local path may be a Windows path, so we use the path separator of the local system
+        self.session_info.local_container = os.path.join(self.params.rootdir, 'S-%s' % self.session_info.name)
+        # remote path is always a UniX path...
+        self.session_info.remote_container = '%s/.x2go/C-%s' % (self.control_session._x2go_remote_home, 
+                                                                self.session_info.name,
+                                                               )
         self.proxy = self.proxy_backend(session_info=self.session_info, 
                                         ssh_transport=self.control_session.get_transport(), 
                                         sessions_rootdir=self.sessions_rootdir,
@@ -1527,12 +1545,6 @@ class X2goTerminalSessionSTDOUT(object):
         self.proxy_subprocess, proxy_ok = self.proxy.start_proxy()
 
         if proxy_ok:
-            # local path may be a Windows path, so we use the path separator of the local system
-            self.session_info.local_container = os.path.join(self.params.rootdir, 'S-%s' % self.session_info.name)
-            # remote path is always a UniX path...
-            self.session_info.remote_container = '%s/.x2go/C-%s' % (self.control_session._x2go_remote_home, 
-                                                                    self.session_info.name,
-                                                                   )
             self.params.depth = self.session_info.name.split('_')[2][2:]
 
             # on a session resume the user name comes in as a user ID. We have to translate this...
@@ -1550,7 +1562,7 @@ class X2goTerminalSessionSTDOUT(object):
                 self.control_session.get_published_applications()
                 self.published_applications = True
         else:
-            raise x2go_exceptions.X2goTerminalSessionException(&quot;failed to start X2Go session&quot;)
+            raise x2go_exceptions.X2GoTerminalSessionException(&quot;failed to start X2Go session&quot;)
 
         return proxy_ok
 
@@ -1616,3 +1628,48 @@ class X2goTerminalSessionSTDOUT(object):
                 self._rm_desktop_dirtree()
 
             self._cleaned_up = True
+
+    def is_desktop_session(self):
+        &quot;&quot;&quot;\
+        Test if this terminal session is a desktop session.
+
+        @return: C{True} if this session is of session type desktop ('D').
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        self.params.rewrite_session_type()
+        return self.params.session_type == 'D'
+
+    def is_rootless_session(self):
+        &quot;&quot;&quot;\
+        Test if this terminal session is a rootless session.
+
+        @return: C{True} if this session is of session type rootless ('R').
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        self.params.rewrite_session_type()
+        return self.params.session_type == 'R'
+
+    def is_shadow_session(self):
+        &quot;&quot;&quot;\
+        Test if this terminal session is a desktop sharing (aka shadow) session.
+
+        @return: C{True} if this session is of session type shadow ('S').
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        self.params.rewrite_session_type()
+        return self.params.session_type == 'S'
+
+    def is_pubapp_session(self):
+        &quot;&quot;&quot;\
+        Test if this terminal session is a published applications session.
+
+        @return: C{True} if this session is of session type published applications ('P').
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        self.params.rewrite_session_type()
+        return self.params.session_type == 'P'
+
diff --git a/x2go/cache.py b/x2go/cache.py
index 1654e08..389d71a 100644
--- a/x2go/cache.py
+++ b/x2go/cache.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,7 +18,7 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goListSessionCache class - caching X2Go session information.
+X2GoListSessionCache class - caching X2Go session information.
 
 &quot;&quot;&quot;
 __NAME__ = 'x2gocache-pylib'
@@ -31,14 +31,14 @@ import gevent
 import log
 import x2go_exceptions
 
-class X2goListSessionsCache(object):
+class X2GoListSessionsCache(object):
     &quot;&quot;&quot;\
     For non-blocking operations in client applications using Python X2Go, it is
-    recommended to enable the L{X2goListSessionsCache}. This can be done by calling
-    the constructor of the L{X2goClient} class.
+    recommended to enable the L{X2GoListSessionsCache}. This can be done by calling
+    the constructor of the L{X2GoClient} class.
 
     The session list and desktop cache gets updated in regular intervals by a threaded
-    L{X2goSessionGuardian} instance. For the session list and desktop list update, the
+    L{X2GoSessionGuardian} instance. For the session list and desktop list update, the
     X2Go server commands C{x2golistsessions} and C{x2godesktopsessions} are called and
     the command's stdout is cached in the session list cache.
 
@@ -52,11 +52,11 @@ class X2goListSessionsCache(object):
 
     def __init__(self, client_instance, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        @param client_instance: the L{X2goClient} instance that uses this L{X2goListSessionsCache}
+        @param client_instance: the L{X2GoClient} instance that uses this L{X2GoListSessionsCache}
         @type client_instance: C{obj}
-        @param logger: you can pass an L{X2goLogger} object to the L{X2goListSessionsCache} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the L{X2GoListSessionsCache} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
@@ -66,7 +66,7 @@ class X2goListSessionsCache(object):
         self.protected = False
 
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -99,7 +99,7 @@ class X2goListSessionsCache(object):
 
     def update_all(self, update_sessions=True, update_desktops=False):
         &quot;&quot;&quot;\
-        Update L{X2goListSessionsCache} for all connected session profiles.
+        Update L{X2GoListSessionsCache} for all connected session profiles.
 
         @param update_sessions: cache recent session lists from all connected servers
         @type update_sessions: C{bool}
@@ -114,7 +114,7 @@ class X2goListSessionsCache(object):
 
     def update(self, profile_name, update_sessions=True, update_desktops=False, update_mounts=False):
         &quot;&quot;&quot;\
-        Update L{X2goListSessionsCache} (i.e. session/desktops) for session profile C{profile_name}.
+        Update L{X2GoListSessionsCache} (i.e. session/desktops) for session profile C{profile_name}.
 
         @param profile_name: name of profile to update
         @type profile_name: C{str}
@@ -141,12 +141,12 @@ class X2goListSessionsCache(object):
 
     def _update_mounts(self, profile_name, control_session):
         &quot;&quot;&quot;\
-        Update mounts list of L{X2goListSessionsCache} for session profile C{profile_name}.
+        Update mounts list of L{X2GoListSessionsCache} for session profile C{profile_name}.
 
         @param profile_name: name of profile to update
         @type profile_name: C{str}
 
-        @raise X2goControlSessionException: if the control session's C{list_mounts} method fails
+        @raise X2GoControlSessionException: if the control session's C{list_mounts} method fails
         &quot;&quot;&quot;
         try:
             self.x2go_listsessions_cache[profile_name]['mounts'] = {}
@@ -154,64 +154,64 @@ class X2goListSessionsCache(object):
                 for session_name in self.x2go_listsessions_cache[profile_name]['sessions']:
                     if control_session is not None and not control_session.has_session_died():
                         self.x2go_listsessions_cache[profile_name]['mounts'].update(control_session.list_mounts(session_name))
-        except (x2go_exceptions.X2goControlSessionException, AttributeError), e:
+        except (x2go_exceptions.X2GoControlSessionException, AttributeError), e:
             if profile_name in self.x2go_listsessions_cache.keys():
                 del self.x2go_listsessions_cache[profile_name]
             self.protected = False
-            raise x2go_exceptions.X2goControlSessionException
-        except x2go_exceptions.X2goTimeOutException:
+            raise x2go_exceptions.X2GoControlSessionException
+        except x2go_exceptions.X2GoTimeOutException:
             pass
 
     def _update_desktops(self, profile_name, control_session):
         &quot;&quot;&quot;\
-        Update session lists of L{X2goListSessionsCache} for session profile C{profile_name}.
+        Update session lists of L{X2GoListSessionsCache} for session profile C{profile_name}.
 
         @param profile_name: name of profile to update
         @type profile_name: C{str}
         @param control_session: X2Go control session instance
         @type control_session: C{obj}
 
-        @raise X2goControlSessionException: if the control session's C{list_desktop} method fails
+        @raise X2GoControlSessionException: if the control session's C{list_desktop} method fails
         &quot;&quot;&quot;
         try:
             if control_session is not None and not control_session.has_session_died():
                 self.x2go_listsessions_cache[profile_name]['desktops'] = control_session.list_desktops()
-        except (x2go_exceptions.X2goControlSessionException, AttributeError), e:
+        except (x2go_exceptions.X2GoControlSessionException, AttributeError), e:
             if profile_name in self.x2go_listsessions_cache.keys():
                 del self.x2go_listsessions_cache[profile_name]
             self.protected = False
-            raise x2go_exceptions.X2goControlSessionException
-        except x2go_exceptions.X2goTimeOutException:
+            raise x2go_exceptions.X2GoControlSessionException
+        except x2go_exceptions.X2GoTimeOutException:
             pass
 
     def _update_sessions(self, profile_name, control_session):
         &quot;&quot;&quot;\
-        Update desktop list of L{X2goListSessionsCache} for session profile C{profile_name}.
+        Update desktop list of L{X2GoListSessionsCache} for session profile C{profile_name}.
 
         @param profile_name: name of profile to update
         @type profile_name: C{str}
 
-        @raise X2goControlSessionException: if the control session's C{list_sessions} method fails
+        @raise X2GoControlSessionException: if the control session's C{list_sessions} method fails
         &quot;&quot;&quot;
         try:
             if control_session is not None and not control_session.has_session_died():
                 self.x2go_listsessions_cache[profile_name]['sessions'] = control_session.list_sessions()
-        except (x2go_exceptions.X2goControlSessionException, AttributeError), e:
+        except (x2go_exceptions.X2GoControlSessionException, AttributeError), e:
             if profile_name in self.x2go_listsessions_cache.keys():
                 del self.x2go_listsessions_cache[profile_name]
             self.protected = False
-            raise x2go_exceptions.X2goControlSessionException
+            raise x2go_exceptions.X2GoControlSessionException
 
     def list_sessions(self, session_uuid):
         &quot;&quot;&quot;\
-        Retrieve a session list from the current cache content of L{X2goListSessionsCache}
-        for a given L{X2goSession} instance (specified by its unique session UUID).
+        Retrieve a session list from the current cache content of L{X2GoListSessionsCache}
+        for a given L{X2GoSession} instance (specified by its unique session UUID).
 
         @param session_uuid: unique identifier of session to query cache for
         @type session_uuid: C{str}
 
         @return: a data object containing available session information
-        @rtype: C{X2goServerSessionList*} instance (or C{None})
+        @rtype: C{X2GoServerSessionList*} instance (or C{None})
 
         &quot;&quot;&quot;
         profile_name = self.client_instance.get_session_profile_name(session_uuid)
@@ -223,7 +223,7 @@ class X2goListSessionsCache(object):
     def list_desktops(self, session_uuid):
         &quot;&quot;&quot;\
         Retrieve a list of available desktop sessions from the current cache content of
-        L{X2goListSessionsCache} for a given L{X2goSession} instance (specified by its 
+        L{X2GoListSessionsCache} for a given L{X2GoSession} instance (specified by its 
         unique session UUID).
 
         @param session_uuid: unique identifier of session to query cache for
@@ -242,7 +242,7 @@ class X2goListSessionsCache(object):
     def list_mounts(self, session_uuid):
         &quot;&quot;&quot;\
         Retrieve a list of mounted client shares from the current cache content of
-        L{X2goListSessionsCache} for a given L{X2goSession} instance (specified by its 
+        L{X2GoListSessionsCache} for a given L{X2GoSession} instance (specified by its 
         unique session UUID).
 
         @param session_uuid: unique identifier of session to query cache for
@@ -274,8 +274,8 @@ class X2goListSessionsCache(object):
         if profile_name is None and session_uuid and self.client_instance:
             try:
                 profile_name = self.client_instance.get_session_profile_name(session_uuid)
-            except x2go_exceptions.X2goSessionRegistryException:
-                raise x2go_exceptions.X2goSessionCacheException(&quot;requested session UUID is not valid anymore&quot;)
+            except x2go_exceptions.X2GoSessionRegistryException:
+                raise x2go_exceptions.X2GoSessionCacheException(&quot;requested session UUID is not valid anymore&quot;)
         _is_profile_cached = self.x2go_listsessions_cache.has_key(profile_name)
         _is_cache_type_cached = _is_profile_cached and self.x2go_listsessions_cache[profile_name].has_key(cache_type)
         if cache_type is None:
diff --git a/x2go/checkhosts.py b/x2go/checkhosts.py
index 98badbb..192850a 100644
--- a/x2go/checkhosts.py
+++ b/x2go/checkhosts.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,7 +18,7 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-Providing mechanisms to C{X2goControlSession*} backends for checking host validity.
+Providing mechanisms to C{X2GoControlSession*} backends for checking host validity.
 
 &quot;&quot;&quot;
 __NAME__ = 'x2gocheckhosts-pylib'
@@ -34,89 +34,29 @@ import x2go_exceptions
 import random
 import string
 
-class X2goInteractiveAddPolicy(paramiko.MissingHostKeyPolicy):
+class X2GoMissingHostKeyPolicy(paramiko.MissingHostKeyPolicy):
     &quot;&quot;&quot;\
-    Policy for making host key information available to Python X2Go after a
-    Paramiko/SSH connect has been attempted. This class needs information
-    about the associated L{X2goSession} instance.
-
-    Once called, the L{missing_host_key} method of this class will try to call
-    L{X2goSession.HOOK_check_host_dialog()}. This hook method---if not re-defined
-    in your application---will then try to call the L{X2goClient.HOOK_check_host_dialog()},
-    which then will return C{True} by default if not customized in your application.
-
-    To accept host key checks, make sure to either customize the 
-    L{X2goClient.HOOK_check_host_dialog()} method or the L{X2goSession.HOOK_check_host_dialog()}
-    method and hook some interactive user dialog to either of them.
+    Skeleton class for Python X2Go's missing host key policies.
 
     &quot;&quot;&quot;
-    def __init__(self, caller=None, session_instance=None):
+    def __init__(self, caller=None, session_instance=None, fake_hostname=None):
         &quot;&quot;&quot;\
         @param caller: calling instance
         @type caller: C{class}
         @param session_instance: an X2Go session instance
-        @type session_instance: L{X2goSession} instance
+        @type session_instance: L{X2GoSession} instance
 
         &quot;&quot;&quot;
         self.caller = caller
         self.session_instance = session_instance
-
-    def missing_host_key(self, client, hostname, key):
-        &quot;&quot;&quot;\
-        Handle a missing host key situation. This method calls
-
-        Once called, the L{missing_host_key} method will try to call
-        L{X2goSession.HOOK_check_host_dialog()}. This hook method---if not re-defined
-        in your application---will then try to call the L{X2goClient.HOOK_check_host_dialog()},
-        which then will return C{True} by default if not customized in your application.
-
-        To accept host key checks, make sure to either customize the 
-        L{X2goClient.HOOK_check_host_dialog()} method or the L{X2goSession.HOOK_check_host_dialog()}
-        method and hook some interactive user dialog to either of them.
-
-        @param client: SSH client (C{X2goControlSession*}) instance
-        @type client: C{X2goControlSession*} instance
-        @param hostname: remote hostname
-        @type hostname: C{str}
-        @param key: host key to validate
-        @type key: Paramiko/SSH key instance
-
-        @raise X2goHostKeyException: if the X2Go server host key is not in the C{known_hosts} file
-        @raise X2goSSHProxyHostKeyException: if the SSH proxy host key is not in the C{known_hosts} file
-        @raise SSHException: if this instance does not know its {self.session_instance}
-
-        &quot;&quot;&quot;
-        self.client = client
-        self.hostname = hostname
-        if (self.hostname.find(']') == -1) and (self.hostname.find(':') == -1):
-            # if hostname is an IPv4 quadruple with standard SSH port...
-            self.hostname = '[%s]:22' % self.hostname
-        self.key = key
-        client._log(paramiko.common.DEBUG, 'Interactively Checking %s host key for %s: %s' %
-                   (self.key.get_name(), self.hostname, binascii.hexlify(self.key.get_fingerprint())))
-        if self.session_instance:
-            self.session_instance.logger('SSH host key verification for host %s with %s fingerprint ,,%s\'\' initiated. We are seeing this X2Go server for the first time.' % (self.get_hostname(), self.get_key_name(), self.get_key_fingerprint_with_colons()), loglevel=log.loglevel_NOTICE)
-            _valid = self.session_instance.HOOK_check_host_dialog(self.get_hostname_name(),
-                                                                  port=self.get_hostname_port(),
-                                                                  fingerprint=self.get_key_fingerprint_with_colons(),
-                                                                  fingerprint_type=self.get_key_name(),
-                                                                 )
-            if _valid:
-                paramiko.AutoAddPolicy().missing_host_key(client, self.hostname, key)
-            else:
-                if type(self.caller) in (sshproxy.X2goSSHProxy, ):
-                    raise x2go_exceptions.X2goSSHProxyHostKeyException('Invalid host %s is not authorized for access. Add the host to Paramiko/SSH\'s known_hosts file.' % hostname)
-                else:
-                    raise x2go_exceptions.X2goHostKeyException('Invalid host %s is not authorized for access. Add the host to Paramiko/SSH\'s known_hosts file.' % hostname)
-        else:
-            raise x2go_exceptions.SSHException('Policy has collected host key information on %s for further introspection' % hostname)
+        self.fake_hostname = fake_hostname
 
     def get_client(self):
         &quot;&quot;&quot;\
         Retrieve the Paramiko SSH/Client.
 
         @return: the associated X2Go control session instance.
-        @rtype: C{X2goControlSession*} instance
+        @rtype: C{X2GoControlSession*} instance
 
         &quot;&quot;&quot;
         return self.client
@@ -129,7 +69,7 @@ class X2goInteractiveAddPolicy(paramiko.MissingHostKeyPolicy):
         @rtype: C{str}
 
         &quot;&quot;&quot;
-        return self.hostname
+        return self.fake_hostname or self.hostname
 
     def get_hostname_name(self):
         &quot;&quot;&quot;\
@@ -201,6 +141,110 @@ class X2goInteractiveAddPolicy(paramiko.MissingHostKeyPolicy):
         return _colon_fingerprint.rstrip(':')
 
 
+class X2GoAutoAddPolicy(X2GoMissingHostKeyPolicy):
+
+    def missing_host_key(self, client, hostname, key):
+        self.client = client
+        self.hostname = hostname
+        self.key = key
+        if self.session_instance and self.session_instance.control_session.unique_hostkey_aliases:
+            self.client._host_keys.add(self.session_instance.get_profile_id(), self.key.get_name(), self.key)
+        else:
+            self.client._host_keys.add(self.get_hostname(), self.key.get_name(), self.key)
+        if self.client._host_keys_filename is not None:
+            self.client.save_host_keys(self.client._host_keys_filename)
+        self.client._log(paramiko.common.DEBUG, 'Adding %s host key for %s: %s' %
+                         (self.key.get_name(), self.get_hostname(), binascii.hexlify(self.key.get_fingerprint())))
+
+
+class X2GoInteractiveAddPolicy(X2GoMissingHostKeyPolicy):
+    &quot;&quot;&quot;\
+    Policy for making host key information available to Python X2Go after a
+    Paramiko/SSH connect has been attempted. This class needs information
+    about the associated L{X2GoSession} instance.
+
+    Once called, the L{missing_host_key} method of this class will try to call
+    L{X2GoSession.HOOK_check_host_dialog()}. This hook method---if not re-defined
+    in your application---will then try to call the L{X2GoClient.HOOK_check_host_dialog()},
+    which then will return C{True} by default if not customized in your application.
+
+    To accept host key checks, make sure to either customize the 
+    L{X2GoClient.HOOK_check_host_dialog()} method or the L{X2GoSession.HOOK_check_host_dialog()}
+    method and hook some interactive user dialog to either of them.
+
+    &quot;&quot;&quot;
+    def missing_host_key(self, client, hostname, key):
+        &quot;&quot;&quot;\
+        Handle a missing host key situation. This method calls
+
+        Once called, the L{missing_host_key} method will try to call
+        L{X2GoSession.HOOK_check_host_dialog()}. This hook method---if not re-defined
+        in your application---will then try to call the L{X2GoClient.HOOK_check_host_dialog()},
+        which then will return C{True} by default if not customized in your application.
+
+        To accept host key checks, make sure to either customize the 
+        L{X2GoClient.HOOK_check_host_dialog()} method or the L{X2GoSession.HOOK_check_host_dialog()}
+        method and hook some interactive user dialog to either of them.
+
+        @param client: SSH client (C{X2GoControlSession*}) instance
+        @type client: C{X2GoControlSession*} instance
+        @param hostname: remote hostname
+        @type hostname: C{str}
+        @param key: host key to validate
+        @type key: Paramiko/SSH key instance
+
+        @raise X2GoHostKeyException: if the X2Go server host key is not in the C{known_hosts} file
+        @raise X2GoSSHProxyHostKeyException: if the SSH proxy host key is not in the C{known_hosts} file
+        @raise SSHException: if this instance does not know its {self.session_instance}
+
+        &quot;&quot;&quot;
+        self.client = client
+        self.hostname = hostname
+        if (self.hostname.find(']') == -1) and (self.hostname.find(':') == -1):
+            # if hostname is an IPv4 quadruple with standard SSH port...
+            self.hostname = '[%s]:22' % self.hostname
+        self.key = key
+        self.client._log(paramiko.common.DEBUG, 'Interactively Checking %s host key for %s: %s' %
+                         (self.key.get_name(), self.get_hostname(), binascii.hexlify(self.key.get_fingerprint())))
+        if self.session_instance:
+
+            if self.fake_hostname is not None:
+                server_key = client.get_transport().get_remote_server_key()
+                keytype = server_key.get_name()
+                our_server_key = client._system_host_keys.get(self.fake_hostname, {}).get(keytype, None)
+                if our_server_key is None:
+                    if self.session_instance.control_session.unique_hostkey_aliases:
+                        our_server_key = client._host_keys.get(self.session_instance.get_profile_id(), {}).get(keytype, None)
+                        if our_server_key is not None:
+                            self.session_instance.logger('SSH host key verification for SSH-proxied host %s with %s fingerprint ,,%s\'\' succeeded. This host is known by the X2Go session profile ID of profile &#187;%s&#171;.' % (self.fake_hostname, self.get_key_name(), self.get_key_fingerprint_with_colons(), self.session_instance.profile_name), loglevel=log.loglevel_NOTICE)
+                            return
+                    else:
+                        our_server_key = client._host_keys.get(self.fake_hostname, {}).get(keytype, None)
+                        if our_server_key is not None:
+                            self.session_instance.logger('SSH host key verification for SSH-proxied host %s with %s fingerprint ,,%s\'\' succeeded. This host is known by the address it has behind the SSH proxy host.' % (self.fake_hostname, self.get_key_name(), self.get_key_fingerprint_with_colons()), loglevel=log.loglevel_NOTICE)
+                            return
+
+            self.session_instance.logger('SSH host key verification for host %s with %s fingerprint ,,%s\'\' initiated. We are seeing this X2Go server for the first time.' % (self.get_hostname(), self.get_key_name(), self.get_key_fingerprint_with_colons()), loglevel=log.loglevel_NOTICE)
+            _valid = self.session_instance.HOOK_check_host_dialog(self.get_hostname_name(),
+                                                                  port=self.get_hostname_port(),
+                                                                  fingerprint=self.get_key_fingerprint_with_colons(),
+                                                                  fingerprint_type=self.get_key_name(),
+                                                                 )
+            if _valid:
+                if self.session_instance.control_session.unique_hostkey_aliases and type(self.caller) not in (sshproxy.X2GoSSHProxy, ):
+                    paramiko.AutoAddPolicy().missing_host_key(client, self.session_instance.get_profile_id(), key)
+                else:
+                    paramiko.AutoAddPolicy().missing_host_key(client, self.get_hostname(), key)
+
+            else:
+                if type(self.caller) in (sshproxy.X2GoSSHProxy, ):
+                    raise x2go_exceptions.X2GoSSHProxyHostKeyException('Invalid host %s is not authorized for access. Add the host to Paramiko/SSH\'s known_hosts file.' % self.get_hostname())
+                else:
+                    raise x2go_exceptions.X2GoHostKeyException('Invalid host %s is not authorized for access. Add the host to Paramiko/SSH\'s known_hosts file.' % self.get_hostname())
+        else:
+            raise x2go_exceptions.SSHException('Policy has collected host key information on %s for further introspection' % self.get_hostname())
+
+
 def check_ssh_host_key(x2go_sshclient_instance, hostname, port=22):
     &quot;&quot;&quot;\
     Perform a Paramiko/SSH host key check by connecting to the host and
@@ -208,7 +252,7 @@ def check_ssh_host_key(x2go_sshclient_instance, hostname, port=22):
     connect process).
 
     @param x2go_sshclient_instance: a Paramiko/SSH client instance to be used for testing host key validity.
-    @type x2go_sshclient_instance: C{X2goControlSession*} instance
+    @type x2go_sshclient_instance: C{X2GoControlSession*} instance
     @param hostname: hostname of server to validate
     @type hostname: C{str}
     @param port: port of server to validate
@@ -217,7 +261,7 @@ def check_ssh_host_key(x2go_sshclient_instance, hostname, port=22):
     @return: returns a tuple with the following components (&lt;host_ok&gt;, &lt;hostname&gt;, &lt;port&gt;, &lt;fingerprint&gt;, &lt;fingerprint_type&gt;)
     @rtype: C{tuple}
 
-    @raise SSHException: if an SSH exception occurred, that we did not provocate in L{X2goInteractiveAddPolicy.missing_host_key()}
+    @raise SSHException: if an SSH exception occurred, that we did not provocate in L{X2GoInteractiveAddPolicy.missing_host_key()}
 
     &quot;&quot;&quot;
     _hostname = hostname
@@ -225,7 +269,7 @@ def check_ssh_host_key(x2go_sshclient_instance, hostname, port=22):
     _fingerprint = 'NO-FINGERPRINT'
     _fingerprint_type = 'SOME-KEY-TYPE'
 
-    _check_policy = X2goInteractiveAddPolicy()
+    _check_policy = X2GoInteractiveAddPolicy()
     x2go_sshclient_instance.set_missing_host_key_policy(_check_policy)
 
     host_ok = False
diff --git a/x2go/cleanup.py b/x2go/cleanup.py
index 399dfa4..1cc040e 100644
--- a/x2go/cleanup.py
+++ b/x2go/cleanup.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -46,7 +46,7 @@ def x2go_cleanup(e=None, threads=None):
         import x2go
 
         try:
-            my_x2goclient = x2go.X2goClient(...)
+            my_x2goclient = x2go.X2GoClient(...)
 
             [... your code ...]
 
@@ -70,11 +70,11 @@ def x2go_cleanup(e=None, threads=None):
 
         # stop X2Go reverse forwarding tunnels
         for t in threads:
-            if type(t) == rforward.X2goRevFwTunnel:
+            if type(t) == rforward.X2GoRevFwTunnel:
                 t.stop_thread()
                 del t
 
-        # stop X2Go paramiko transports used by X2goTerminalSession objects
+        # stop X2Go paramiko transports used by X2GoTerminalSession objects
         for t in threads:
             if type(t) == paramiko.Transport:
                 if hasattr(t, '_x2go_session_marker'):
@@ -84,19 +84,19 @@ def x2go_cleanup(e=None, threads=None):
         # on Windows: stop the XServer that we evoked
         if _X2GOCLIENT_OS == 'Windows':
             for t in threads:
-                if type(t) == xserver.X2goXServer:
+                if type(t) == xserver.X2GoXServer:
                     t.stop_thread()
                     del t
 
         # on Windows: stop the PulseAudio daemon that we evoked
         if _X2GOCLIENT_OS == 'Windows':
             for t in threads:
-                if type(t) == pulseaudio.X2goPulseAudio:
+                if type(t) == pulseaudio.X2GoPulseAudio:
                     t.stop_thread()
                     del t
 
         for t in threads:
-            if type(t) == guardian.X2goSessionGuardian:
+            if type(t) == guardian.X2GoSessionGuardian:
                 t.stop_thread()
                 del t
 
diff --git a/x2go/client.py b/x2go/client.py
index d160e74..c850e40 100644
--- a/x2go/client.py
+++ b/x2go/client.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 
 #
 # Python X2Go is free software; you can redistribute it and/or modify
@@ -19,8 +19,8 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-L{X2goClient} is a public API class. Use this class in your Python X2Go based 
-applications.  Use it as a parent class for your own object oriented L{X2goClient}'ish
+L{X2GoClient} is a public API class. Use this class in your Python X2Go based 
+applications.  Use it as a parent class for your own object oriented L{X2GoClient}'ish
 class implementation.
 
 Supported Features
@@ -38,19 +38,20 @@ Supported Features
         - enabling and mangaging X2Go printing (real printing, viewing as PDF, saving
           to a local folder or executing a custom &#187;print&#171; command
         - transparent tunneling of audio (Pulseaudio, ESD)
+        - sharing of other desktops
         - LDAP support for X2Go server clusters (NOT IMPLEMENTED YET)
 
 Non-Profile Sessions
 ====================
-    A new non-profile based X2Go session within an L{X2goClient} instance is setup in the 
+    A new non-profile based X2Go session within an L{X2GoClient} instance is setup in the 
     following way:
 
         - import the Python X2Go module and call the session constructor::
 
             import x2go
-            x2go_client = x2go.X2goClient()
+            x2go_client = x2go.X2GoClient()
 
-        - register a new L{X2goClient} session; this creates an L{X2goSession} instance
+        - register a new L{X2GoClient} session; this creates an L{X2GoSession} instance
           and calls its constructor method::
 
             x2go_sess_uuid = x2go_client.register_session(&lt;many-options&gt;)
@@ -76,14 +77,14 @@ Non-Profile Sessions
 Profiled Sessions
 =================
     A new profile based X2Go session (i.e. using pre-defined session profiles) within an 
-    L{X2goClient} instance is setup in a much easier way:
+    L{X2GoClient} instance is setup in a much easier way:
 
         - import the Python X2Go module and call the session constructor::
 
             import x2go
-            x2go_client = x2go.X2goClient()
+            x2go_client = x2go.X2GoClient()
 
-        - register an X2goClient session based on a pre-configured session profile::
+        - register an X2GoClient session based on a pre-configured session profile::
 
             x2go_sess_uuid = x2go_client.register_session(profile_name=&lt;session_profile_name&gt;)
 
@@ -123,9 +124,9 @@ import types
 import os
 
 # Python X2Go modules
-from registry import X2goSessionRegistry
-from guardian import X2goSessionGuardian
-from cache import X2goListSessionsCache
+from registry import X2GoSessionRegistry
+from guardian import X2GoSessionGuardian
+from cache import X2GoListSessionsCache
 import x2go_exceptions
 import log
 import utils
@@ -161,33 +162,33 @@ import x2go.backends.settings as settings
 import x2go.backends.printing as printing
 
 if _X2GOCLIENT_OS == 'Windows':
-    from xserver import X2goClientXConfig, X2goXServer
-    from pulseaudio import X2goPulseAudio
+    from xserver import X2GoClientXConfig, X2GoXServer
+    from pulseaudio import X2GoPulseAudio
 
 
-class X2goClient(object):
+class X2GoClient(object):
     &quot;&quot;&quot;\
-    The X2goClient implements _THE_ public Python X2Go API. With it you can
+    The X2GoClient implements _THE_ public Python X2Go API. With it you can
     construct your own X2Go client application in Python.
 
     Most methods in this class require that you have registered a session
     with a remote X2Go server (passing of session options, initialization of the
     session object etc.) and connected to it (authentication). For these two steps
-    use these methods: L{X2goClient.register_session()} and L{X2goClient.connect_session()}.
+    use these methods: L{X2GoClient.register_session()} and L{X2GoClient.connect_session()}.
 
     &quot;&quot;&quot;
 
     lang = 'en'
 
     def __init__(self,
-                 control_backend=control.X2goControlSession,
-                 terminal_backend=terminal.X2goTerminalSession,
-                 info_backend=info.X2goServerSessionInfo,
-                 list_backend=info.X2goServerSessionList,
-                 proxy_backend=proxy.X2goProxy,
-                 profiles_backend=profiles.X2goSessionProfiles,
-                 settings_backend=settings.X2goClientSettings,
-                 printing_backend=printing.X2goClientPrinting,
+                 control_backend=control.X2GoControlSession,
+                 terminal_backend=terminal.X2GoTerminalSession,
+                 info_backend=info.X2GoServerSessionInfo,
+                 list_backend=info.X2GoServerSessionList,
+                 proxy_backend=proxy.X2GoProxy,
+                 profiles_backend=profiles.X2GoSessionProfiles,
+                 settings_backend=settings.X2GoClientSettings,
+                 printing_backend=printing.X2GoClientPrinting,
                  client_rootdir=None,
                  sessions_rootdir=None,
                  ssh_rootdir=None,
@@ -227,19 +228,19 @@ class X2goClient(object):
         @type sessions_rootdir: C{str}
         @param ssh_rootdir: ssh base dir (default: ~/.ssh)
         @type ssh_rootdir: C{str}
-        @param start_xserver: start XServer when registering an L{X2goClient} instance
+        @param start_xserver: start XServer when registering an L{X2GoClient} instance
         @type start_xserver: C{bool}
-        @param start_pulseaudio: start Pulseaudio daemon when registering an L{X2goClient} instance
+        @param start_pulseaudio: start Pulseaudio daemon when registering an L{X2GoClient} instance
         @type start_pulseaudio: C{bool}
         @param use_cache: alias for C{use_listsessions_cache}
         @type use_cache: C{bool}
-        @param use_listsessions_cache: activate the X2Go session list cache in (L{X2goListSessionsCache})
+        @param use_listsessions_cache: activate the X2Go session list cache in (L{X2GoListSessionsCache})
         @type use_listsessions_cache: C{bool}
-        @param auto_update_listsessions_cache: activate automatic updates of the X2Go session list cache (L{X2goListSessionsCache})
+        @param auto_update_listsessions_cache: activate automatic updates of the X2Go session list cache (L{X2GoListSessionsCache})
         @type auto_update_listsessions_cache: C{bool}
-        @param auto_update_listdesktops_cache: activate automatic updates of desktop lists in (L{X2goListSessionsCache})
+        @param auto_update_listdesktops_cache: activate automatic updates of desktop lists in (L{X2GoListSessionsCache})
         @type auto_update_listdesktops_cache: C{bool}
-        @param auto_update_listmounts_cache: activate automatic updates of mount lists in (L{X2goListSessionsCache})
+        @param auto_update_listmounts_cache: activate automatic updates of mount lists in (L{X2GoListSessionsCache})
         @type auto_update_listmounts_cache: C{bool}
         @param auto_update_sessionregistry: activate automatic updates of the X2Go session registry
         @type auto_update_sessionregistry: C{bool}
@@ -251,10 +252,10 @@ class X2goClient(object):
         @type refresh_interval: C{int}
         @param pulseaudio_installdir: install path of Pulseaudio binary
         @type pulseaudio_installdir: C{str}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goClient} constructor
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no X2goLogger object has been supplied a new one will be
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoClient} constructor
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no X2GoLogger object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
@@ -262,7 +263,7 @@ class X2goClient(object):
         self.listsessions_cache = None
 
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self._logger_tag = __NAME__
@@ -307,9 +308,9 @@ class X2goClient(object):
         if _X2GOCLIENT_OS == 'Windows' and start_xserver:
 
             if self.client_rootdir:
-                self.client_xconfig = X2goClientXConfig(config_files=[_xconfig_config_file], logger=self.logger)
+                self.client_xconfig = X2GoClientXConfig(config_files=[_xconfig_config_file], logger=self.logger)
             else:
-                self.client_xconfig = X2goClientXConfig(logger=self.logger)
+                self.client_xconfig = X2GoClientXConfig(logger=self.logger)
 
             if not self.client_xconfig.known_xservers:
                 self.HOOK_no_known_xserver_found()
@@ -329,7 +330,7 @@ class X2goClient(object):
                 if not self.client_xconfig.running_xservers:
 
                     if p_xs is not None:
-                        self.xserver = X2goXServer(p_xs[0], p_xs[1], logger=self.logger)
+                        self.xserver = X2GoXServer(p_xs[0], p_xs[1], logger=self.logger)
 
                 else:
 
@@ -346,12 +347,12 @@ class X2goClient(object):
                         os.environ.update({'DISPLAY': 'localhost:0'})
 
         if _X2GOCLIENT_OS == 'Windows' and start_pulseaudio:
-            self.pulseaudio = X2goPulseAudio(path=self.pulseaudio_installdir, client_instance=self, logger=self.logger)
+            self.pulseaudio = X2GoPulseAudio(path=self.pulseaudio_installdir, client_instance=self, logger=self.logger)
 
         self.auto_register_sessions = auto_register_sessions
         self.no_auto_reg_pubapp_sessions = no_auto_reg_pubapp_sessions
-        self.session_registry = X2goSessionRegistry(self, logger=self.logger)
-        self.session_guardian = X2goSessionGuardian(self, auto_update_listsessions_cache=auto_update_listsessions_cache &amp; (use_listsessions_cache|use_cache),
+        self.session_registry = X2GoSessionRegistry(self, logger=self.logger)
+        self.session_guardian = X2GoSessionGuardian(self, auto_update_listsessions_cache=auto_update_listsessions_cache &amp; (use_listsessions_cache|use_cache),
                                                     auto_update_listdesktops_cache=auto_update_listdesktops_cache &amp; use_listsessions_cache,
                                                     auto_update_listmounts_cache=auto_update_listmounts_cache &amp; use_listsessions_cache,
                                                     auto_update_sessionregistry=auto_update_sessionregistry,
@@ -363,7 +364,7 @@ class X2goClient(object):
         self.auto_update_sessionregistry = auto_update_sessionregistry
 
         if use_listsessions_cache:
-            self.listsessions_cache = X2goListSessionsCache(self, logger=self.logger)
+            self.listsessions_cache = X2GoListSessionsCache(self, logger=self.logger)
 
         self.use_listsessions_cache = use_listsessions_cache | use_cache
         self.auto_update_listsessions_cache = auto_update_listsessions_cache
@@ -384,6 +385,20 @@ class X2goClient(object):
         &quot;&quot;&quot;
         self.logger('HOOK_session_startup_failed: session startup for session profile ,,%s'' failed.' % profile_name, loglevel=log.loglevel_WARN)
 
+    def HOOK_list_desktops_timeout(self, profile_name='UNKNOWN'):
+        &quot;&quot;&quot;\
+        HOOK method: called if the x2golistdesktops command generates a timeout due to long execution time.
+
+        &quot;&quot;&quot;
+        self.logger('HOOK_list_desktops_timeout: the server-side x2golistdesktops command for session profile %s took too long to return results. This can happen from time to time, please try again.' % profile_name, loglevel=log.loglevel_WARN)
+
+    def HOOK_no_such_desktop(self, profile_name='UNKNOWN', desktop='UNKNOWN'):
+        &quot;&quot;&quot;\
+        HOOK method: called if it is tried to connect to a (seen before) sharable desktop that's not available (anymore).
+
+        &quot;&quot;&quot;
+        self.logger('HOOK_no_such_desktop: the desktop %s (via session profile %s) is not available for sharing (anymore).' % (desktop, profile_name), loglevel=log.loglevel_WARN)
+
     def HOOK_no_known_xserver_found(self):
         &quot;&quot;&quot;\
         HOOK method: called if the Python X2Go module could not find any usable XServer
@@ -394,7 +409,7 @@ class X2goClient(object):
 
     def HOOK_open_print_dialog(self, profile_name='UNKNOWN', session_name='UNKNOWN'):
         &quot;&quot;&quot;\
-        HOOK method: called if an incoming print job has been detected by L{X2goPrintQueue} and a print dialog box is
+        HOOK method: called if an incoming print job has been detected by L{X2GoPrintQueue} and a print dialog box is
         requested.
 
         @param profile_name: profile name of session that called this hook method
@@ -403,7 +418,7 @@ class X2goClient(object):
         @type session_name: C{str}
 
         &quot;&quot;&quot;
-        self.logger('HOOK_open_print_dialog: incoming print job detected by X2goClient hook method', loglevel=log.loglevel_WARN)
+        self.logger('HOOK_open_print_dialog: incoming print job detected by X2GoClient hook method', loglevel=log.loglevel_WARN)
 
     def HOOK_no_such_command(self, cmd, profile_name='UNKNOWN', session_name='UNKNOWN'):
         &quot;&quot;&quot;\
@@ -431,7 +446,7 @@ class X2goClient(object):
         @type session_name: C{str}
 
         &quot;&quot;&quot;
-        self.logger('HOOK_open_mimebox_saveas_dialog: incoming MIME box job ,, %s'' detected by X2goClient hook method' % filename, loglevel=log.loglevel_WARN)
+        self.logger('HOOK_open_mimebox_saveas_dialog: incoming MIME box job ,, %s'' detected by X2GoClient hook method' % filename, loglevel=log.loglevel_WARN)
 
     def HOOK_printaction_error(self, filename, profile_name='UNKNOWN', session_name='UNKNOWN', err_msg='GENERIC_ERROR', printer=None):
         &quot;&quot;&quot;\
@@ -454,7 +469,7 @@ class X2goClient(object):
         else:
             self.logger('HOOK_printaction_error: incoming print job ,, %s'' caused error: %s' % (filename, err_msg), loglevel=log.loglevel_ERROR)
 
-    def HOOK_check_host_dialog(self, profile_name='UNKNOWN', host='UNKNOWN', port=22, fingerprint='no fingerprint', fingerprint_type='RSA'):
+    def HOOK_check_host_dialog(self, profile_name='UNKNOWN', host='UNKNOWN', port=22, fingerprint='no fingerprint', fingerprint_type='UNKNOWN'):
         &quot;&quot;&quot;\
         HOOK method: called if a host check is requested. This hook has to either return C{True} (default) or C{False}.
 
@@ -477,7 +492,6 @@ class X2goClient(object):
         # this HOOK has to return either True (accept host connection) or False (deny host conection)
         return True
 
-
     def HOOK_on_control_session_death(self, profile_name):
         &quot;&quot;&quot;\
         HOOK method: called if a control session (server connection) has unexpectedly encountered a failure.
@@ -540,11 +554,11 @@ class X2goClient(object):
         @type chain_port: C{str}
 
         &quot;&quot;&quot;
-        self.logger('Forwarding tunnel request to [%s]:%s for session %s (%s) was denied by remote X2go/SSH server. Session startup failed.' % (chain_host, chain_port, session_name, profile_name), loglevel=log.loglevel_ERROR)
+        self.logger('Forwarding tunnel request to [%s]:%s for session %s (%s) was denied by remote X2Go/SSH server. Session startup failed.' % (chain_host, chain_port, session_name, profile_name), loglevel=log.loglevel_ERROR)
 
     def HOOK_on_session_has_started_by_me(self, session_uuid='UNKNOWN', profile_name='UNKNOWN', session_name='UNKNOWN'):
         &quot;&quot;&quot;\
-        HOOK method: called if a session has been started by this instance of L{X2goClient}.
+        HOOK method: called if a session has been started by this instance of L{X2GoClient}.
 
         @param session_uuid: unique session identifier of the calling session
         @type session_uuid: C{str}
@@ -572,7 +586,7 @@ class X2goClient(object):
 
     def HOOK_on_session_has_resumed_by_me(self, session_uuid='UNKNOWN', profile_name='UNKNOWN', session_name='UNKNOWN'):
         &quot;&quot;&quot;\
-        HOOK method: called if a session has been resumed by this instance of L{X2goClient}.
+        HOOK method: called if a session has been resumed by this instance of L{X2GoClient}.
 
         @param session_uuid: unique session identifier of the calling session
         @type session_uuid: C{str}
@@ -614,7 +628,7 @@ class X2goClient(object):
 
     def HOOK_on_session_has_been_suspended(self, session_uuid='UNKNOWN', profile_name='UNKNOWN', session_name='UNKNOWN'):
         &quot;&quot;&quot;\
-        HOOK method: called if a session has been suspended by this instance of L{X2goClient}.
+        HOOK method: called if a session has been suspended by this instance of L{X2GoClient}.
 
         @param session_uuid: unique session identifier of the calling session
         @type session_uuid: C{str}
@@ -692,7 +706,7 @@ class X2goClient(object):
         &quot;&quot;&quot;\
         Detect backend classes from the command line
 
-        @raise X2goBackendException: if a given backend name is unknown.&quot;
+        @raise X2GoBackendException: if a given backend name is unknown.&quot;
 
         &quot;&quot;&quot;
         # CONTROL session backend
@@ -703,7 +717,7 @@ class X2goClient(object):
                 if self.control_backend in _BACKENDS_CONTROLSESSION.values():
                    _classname = self.control_backend
                 else:
-                    raise x2go_exceptions.X2goBackendException('unknown control session backend name %s' % self.control_backend)
+                    raise x2go_exceptions.X2GoBackendException('unknown control session backend name %s' % self.control_backend)
             self.control_backend = eval('control.%s' % _classname)
 
         # TERMINAL session backend
@@ -714,7 +728,7 @@ class X2goClient(object):
                 if self.terminal_backend in _BACKENDS_TERMINALSESSION.values():
                    _classname = self.terminal_backend
                 else:
-                    raise x2go_exceptions.X2goBackendException('unknown terminal session backend name %s' % self.terminal_backend)
+                    raise x2go_exceptions.X2GoBackendException('unknown terminal session backend name %s' % self.terminal_backend)
             self.terminal_backend = eval('terminal.%s' % _classname)
 
         # PROXY session backend
@@ -725,7 +739,7 @@ class X2goClient(object):
                 if self.proxy_backend in _BACKENDS_PROXY.values():
                    _classname = self.proxy_backend
                 else:
-                    raise x2go_exceptions.X2goBackendException('unknown proxy backend name %s' % self.proxy_backend)
+                    raise x2go_exceptions.X2GoBackendException('unknown proxy backend name %s' % self.proxy_backend)
             self.proxy_backend = eval('proxy.%s' % _classname)
 
         # server session info backend
@@ -736,7 +750,7 @@ class X2goClient(object):
                 if self.info_backend in _BACKENDS_SERVERSESSIONINFO.values():
                    _classname = self.info_backend
                 else:
-                    raise x2go_exceptions.X2goBackendException('unknown server session info backend name %s' % self.info_backend)
+                    raise x2go_exceptions.X2GoBackendException('unknown server session info backend name %s' % self.info_backend)
             self.info_backend = eval('info.%s' % _classname)
 
         # server session list backend
@@ -747,7 +761,7 @@ class X2goClient(object):
                 if self.list_backend in _BACKENDS_SERVERSESSIONLIST.values():
                    _classname = self.list_backend
                 else:
-                    raise x2go_exceptions.X2goBackendException('unknown server session info backend name %s' % self.list_backend)
+                    raise x2go_exceptions.X2GoBackendException('unknown server session info backend name %s' % self.list_backend)
             self.list_backend = eval('info.%s' % _classname)
 
         # session profiles backend
@@ -758,7 +772,7 @@ class X2goClient(object):
                 if self.profiles_backend in _BACKENDS_SESSIONPROFILES.values():
                    _classname = self.profiles_backend
                 else:
-                    raise x2go_exceptions.X2goBackendException('unknown session profiles backend name %s' % self.profiles_backend)
+                    raise x2go_exceptions.X2GoBackendException('unknown session profiles backend name %s' % self.profiles_backend)
             self.profiles_backend = eval('profiles.%s' % _classname)
 
         # client settings backend
@@ -769,7 +783,7 @@ class X2goClient(object):
                 if self.settings_backend in _BACKENDS_CLIENTSETTINGS.values():
                    _classname = self.settings_backend
                 else:
-                    raise x2go_exceptions.X2goBackendException('unknown client settings backend name %s' % self.settings_backend)
+                    raise x2go_exceptions.X2GoBackendException('unknown client settings backend name %s' % self.settings_backend)
             self.settings_backend = eval('settings.%s' % _classname)
 
         # client printing backend
@@ -780,12 +794,12 @@ class X2goClient(object):
                 if self.printing_backend in _BACKENDS_CLIENTPRINTING.values():
                    _classname = self.printing_backend
                 else:
-                    raise x2go_exceptions.X2goBackendException('unknown client printing backend name %s' % self.printing_backend)
+                    raise x2go_exceptions.X2GoBackendException('unknown client printing backend name %s' % self.printing_backend)
             self.printing_backend = eval('printing.%s' % _classname)
 
     def get_client_rootdir(self):
         &quot;&quot;&quot;\
-        Retrieve the settings root directory of this L{X2goClient} instance.
+        Retrieve the settings root directory of this L{X2GoClient} instance.
 
         @return: X2Go client root directory
         @rtype: C{str}
@@ -796,7 +810,7 @@ class X2goClient(object):
     @property
     def has_custom_client_rootdir(self):
         &quot;&quot;&quot;\
-        Does this L{X2goClient} instance have a customized root dir path?
+        Does this L{X2GoClient} instance have a customized root dir path?
         Equals C{True} in case it has.
 
         &quot;&quot;&quot;
@@ -805,7 +819,7 @@ class X2goClient(object):
 
     def get_sessions_rootdir(self):
         &quot;&quot;&quot;\
-        Retrieve the sessions root directory of this L{X2goClient} instance.
+        Retrieve the sessions root directory of this L{X2GoClient} instance.
 
         @return: X2Go sessions root directory
         @rtype: C{str}
@@ -815,7 +829,7 @@ class X2goClient(object):
 
     def get_ssh_rootdir(self):
         &quot;&quot;&quot;\
-        Retrieve the SSH client root dir used with this L{X2goClient} instance.
+        Retrieve the SSH client root dir used with this L{X2GoClient} instance.
 
         @return: SSH client root directory
         @rtype: C{str}
@@ -827,7 +841,7 @@ class X2goClient(object):
         &quot;&quot;&quot;\
         Query the local user's username (i.e. the user running the X2Go client).
 
-        @return: the local username this L{X2goClient} instance runs as
+        @return: the local username this L{X2GoClient} instance runs as
         @rtype: C{str}
 
         &quot;&quot;&quot;
@@ -839,20 +853,20 @@ class X2goClient(object):
         Register all session profiles found in the C{sessions} configuration node 
         as potential X2Go sessions.
 
-        @param return_objects: if set to C{True} this methods returns a list of L{X2goSession}
+        @param return_objects: if set to C{True} this methods returns a list of L{X2GoSession}
             instances, otherwise a list of session UUIDs representing the corresponding 
             registered sessions is returned
         @type return_objects: C{bool}
 
         @return: a Python dictionary containing one registered session for each available session profile 
-            configuration, whereas the profile names are used as dictionary keys and L{X2goSession} 
+            configuration, whereas the profile names are used as dictionary keys and L{X2GoSession} 
             instances as their values
         @rtype: C{list}
 
         &quot;&quot;&quot;
         sessions = {}
         for profile_name in self.session_profiles.profile_names:
-            _obj = self._X2goClient__register_session(profile_name=profile_name, return_object=True)
+            _obj = self._X2GoClient__register_session(profile_name=profile_name, return_object=True)
             sessions[_obj.get_profile_name()] = _obj
         return sessions
     __register_all_session_profiles = register_all_session_profiles
@@ -865,13 +879,13 @@ class X2goClient(object):
                          proxy_options={},
                          return_object=False, **kwargs):
         &quot;&quot;&quot;\
-        Register a new L{X2goSession}. Within one L{X2goClient}
-        instance you can manage several L{X2goSession} instances on serveral
+        Register a new L{X2GoSession}. Within one L{X2GoClient}
+        instance you can manage several L{X2GoSession} instances on serveral
         remote X2Go servers under different user names.
 
-        These sessions can be instantiated by passing direct L{X2goSession}
+        These sessions can be instantiated by passing direct L{X2GoSession}
         parameters to this method or by specifying the name of an existing session profile
-        (as found in the L{X2goClient}'s C{sessions} configuration node.
+        (as found in the L{X2GoClient}'s C{sessions} configuration node.
 
         A session profile is a pre-defined set of session options stored in a sessions
         profile node (e.g. a configuration file). With the FILE backend such session
@@ -881,14 +895,14 @@ class X2goClient(object):
         Python X2Go also supports starting multiple X2Go sessions for the same
         session profile simultaneously.
 
-        This method (L{X2goClient.register_session()}) accepts a similar set of parameters
-        as the L{X2goSession} constructor itself. For a complete set of session options refer
+        This method (L{X2GoClient.register_session()}) accepts a similar set of parameters
+        as the L{X2GoSession} constructor itself. For a complete set of session options refer
         there.
 
         Alternatively, you can also pass a profile name or a profile id 
         to this method. If you do this, Python X2Go tries to find the specified session
         in the C{sessions} configuration node and then derives the necessary session parameters
-        from the session profile configuration. Additional L{X2goSession} parameters can
+        from the session profile configuration. Additional L{X2GoSession} parameters can
         also be passed to this method---they will override the option values retrieved from
         the session profile.
 
@@ -920,18 +934,18 @@ class X2goClient(object):
         @type known_hosts: C{str}
         @param forward_sshagent: forward SSH agent authentication requests to the X2Go client-side
         @type forward_sshagent: C{bool}
-        @param proxy_options: a set of very C{X2goProxy*} backend specific options; any option that is not known
-            to the C{X2goProxy*} backend will simply be ignored
+        @param proxy_options: a set of very C{X2GoProxy*} backend specific options; any option that is not known
+            to the C{X2GoProxy*} backend will simply be ignored
         @type proxy_options: C{dict}
         @param return_object: normally this method returns a unique session UUID. If 
-            C{return_object} is set to C{True} an X2goSession object will be returned 
+            C{return_object} is set to C{True} an X2GoSession object will be returned 
             instead
         @type return_object: C{bool}
-        @param kwargs: any option that is also valid for the L{X2goSession} constructor
+        @param kwargs: any option that is also valid for the L{X2GoSession} constructor
         @type kwargs: C{dict}
 
         @return: a unique identifier (UUID) for the newly registered X2Go session (or an
-            X2goSession object if C{return_object} is set to True
+            X2GoSession object if C{return_object} is set to True
         @rtype: C{str}
 
         &quot;&quot;&quot;
@@ -1014,7 +1028,7 @@ class X2goClient(object):
     __register_session = register_session
 
     ###
-    ### WRAPPER METHODS FOR X2goSessionRegistry objects
+    ### WRAPPER METHODS FOR X2GoSessionRegistry objects
     ###
 
     def get_session_summary(self, session_uuid):
@@ -1029,12 +1043,12 @@ class X2goClient(object):
     __get_session_summary = get_session_summary
 
     ###
-    ### WRAPPER METHODS FOR X2goSession objects
+    ### WRAPPER METHODS FOR X2GoSession objects
     ###
 
     def get_session_username(self, session_uuid):
         &quot;&quot;&quot;\
-        After an L{X2goSession} has been set up you can query the
+        After an L{X2GoSession} has been set up you can query the
         username that the remote sessions runs as.
 
         @param session_uuid: the X2Go session's UUID registry hash
@@ -1083,13 +1097,13 @@ class X2goClient(object):
 
     def get_session(self, session_uuid):
         &quot;&quot;&quot;\
-        Retrieve the complete L{X2goSession} object that has been
+        Retrieve the complete L{X2GoSession} object that has been
         registered under the given session registry hash.
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
 
-        @return: the L{X2goSession} instance
+        @return: the L{X2GoSession} instance
         @rtype: obj
 
         &quot;&quot;&quot;
@@ -1100,23 +1114,23 @@ class X2goClient(object):
 
     def get_session_of_session_name(self, session_name, return_object=False, match_profile_name=None):
         &quot;&quot;&quot;\
-        Retrieve session UUID or L{X2goSession} for session name
+        Retrieve session UUID or L{X2GoSession} for session name
         &lt;session_name&gt; from the session registry.
 
         @param session_name: the X2Go session's UUID registry hash
         @type session_name: C{str}
-        @param return_object: session UUID hash or L{X2goSession} instance wanted?
+        @param return_object: session UUID hash or L{X2GoSession} instance wanted?
         @type return_object: C{bool}
         @param match_profile_name: only return sessions that match this profile name
         @type match_profile_name: C{str}
 
-        @return: the X2Go session's UUID registry hash or L{X2goSession} instance
-        @rtype: C{str} or L{X2goSession} instance
+        @return: the X2Go session's UUID registry hash or L{X2GoSession} instance
+        @rtype: C{str} or L{X2GoSession} instance
 
         &quot;&quot;&quot;
         try:
             return self.session_registry.get_session_of_session_name(session_name=session_name, return_object=return_object, match_profile_name=match_profile_name)
-        except x2go_exceptions.X2goSessionRegistryException:
+        except x2go_exceptions.X2GoSessionRegistryException:
             return None
     __get_session_of_session_name = get_session_of_session_name
 
@@ -1165,13 +1179,13 @@ class X2goClient(object):
 
         &quot;&quot;&quot;
         if session_uuid is None and profile_name:
-            _session_uuids = self._X2goClient__client_pubapp_sessions_of_profile_name(profile_name, return_objects=False)
+            _session_uuids = self._X2GoClient__client_pubapp_sessions_of_profile_name(profile_name, return_objects=False)
             if len(_session_uuids): session_uuid = _session_uuids[0]
         if session_uuid:
             try:
                 if self.session_registry(session_uuid).is_published_applications_provider():
                     return self.session_registry(session_uuid).get_published_applications(lang=lang, refresh=refresh, raw=raw, very_raw=False, max_no_submenus=max_no_submenus)
-            except x2go_exceptions.X2goSessionRegistryException:
+            except x2go_exceptions.X2GoSessionRegistryException:
                 pass
         else:
             self.logger('Cannot find a terminal session for profile ,,%s\'\' that can be used to query a published applications menu tree' % profile_name, loglevel=log.loglevel_INFO)
@@ -1182,7 +1196,7 @@ class X2goClient(object):
 
     def set_session_username(self, session_uuid, username):
         &quot;&quot;&quot;\
-        Set the session username for the L{X2goSession} that has been registered under C{session_uuid}.
+        Set the session username for the L{X2GoSession} that has been registered under C{session_uuid}.
         This can be helpful for modifying user credentials during an authentication phase.
 
         @param session_uuid: the X2Go session's UUID registry hash
@@ -1309,7 +1323,7 @@ class X2goClient(object):
         @param sshproxy_password: the SSH proxy user's password
         @type sshproxy_password: C{str}
         @param add_to_known_hosts: non-Paramiko option, if C{True} paramiko.AutoAddPolicy() 
-            is used as missing-host-key-policy. If set to C{False} checkhosts.X2goInteractiveAddPolicy() 
+            is used as missing-host-key-policy. If set to C{False} L{checkhosts.X2GoInteractiveAddPolicy()} 
             is used
         @type add_to_known_hosts: C{bool}
         @param force_password_auth: disable SSH pub/priv key authentication mechanisms
@@ -1338,7 +1352,7 @@ class X2goClient(object):
 
     def disconnect_session(self, session_uuid):
         &quot;&quot;&quot;\
-        Disconnect an L{X2goSession} by closing down its Paramiko/SSH Transport thread.
+        Disconnect an L{X2GoSession} by closing down its Paramiko/SSH Transport thread.
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
@@ -1356,16 +1370,16 @@ class X2goClient(object):
         Currently, there are five different print actions available, each defined as an individual
         print action class:
 
-            - B{PDFVIEW} (L{X2goPrintActionPDFVIEW}): view an incoming spool job (a PDF file) 
+            - B{PDFVIEW} (L{X2GoPrintActionPDFVIEW}): view an incoming spool job (a PDF file) 
               locally in a PDF viewer
-            - B{PDFSAVE} (L{X2goPrintActionPDFSAVE}): save an incoming spool job (a PDF file) 
+            - B{PDFSAVE} (L{X2GoPrintActionPDFSAVE}): save an incoming spool job (a PDF file) 
               under a nice name in a designated folder
-            - B{PRINT} (L{X2goPrintActionPRINT}): really print the incoming spool job on a real printing device
-            - B{PRINTCMD} L{X2goPrintActionPRINTCMD}: on each incoming spool job execute an 
+            - B{PRINT} (L{X2GoPrintActionPRINT}): really print the incoming spool job on a real printing device
+            - B{PRINTCMD} L{X2GoPrintActionPRINTCMD}: on each incoming spool job execute an 
               external command that lets the client user handle the further processing of the 
               print job (PDF) file
-            - B{DIALOG} (L{X2goPrintActionDIALOG}): on each incoming spool job this print action 
-              will call L{X2goClient.HOOK_open_print_dialog()}
+            - B{DIALOG} (L{X2GoPrintActionDIALOG}): on each incoming spool job this print action 
+              will call L{X2GoClient.HOOK_open_print_dialog()}
 
         Each of the print action classes accepts different print action arguments. For detail
         information on these print action arguments please refer to the constructor methods of 
@@ -1444,7 +1458,7 @@ class X2goClient(object):
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
-        @param sessionopts: pass-through of options directly to the session instance's L{X2goSession.start()} method
+        @param sessionopts: pass-through of options directly to the session instance's L{X2GoSession.start()} method
         @type sessionopts: C{dict}
 
         @return: returns True if this method has been successful
@@ -1465,11 +1479,11 @@ class X2goClient(object):
         return _retval
     __start_session = start_session
 
-    def share_desktop_session(self, session_uuid, desktop=None, user=None, display=None, share_mode=0, **sessionopts):
+    def share_desktop_session(self, session_uuid, desktop=None, user=None, display=None, share_mode=0, check_desktop_list=False, **sessionopts):
         &quot;&quot;&quot;\
         Share another already running desktop session. Desktop sharing can be run
         in two different modes: view-only and full-access mode. Like new sessions
-        a to-be-shared session has be registered first with the L{X2goClient}
+        a to-be-shared session has be registered first with the L{X2GoClient}
         instance.
 
         @param desktop: desktop ID of a sharable desktop in format &lt;user&gt;@&lt;display&gt;
@@ -1482,17 +1496,17 @@ class X2goClient(object):
         @type display: C{str}
         @param share_mode: desktop sharing mode, 0 is VIEW-ONLY, 1 is FULL-ACCESS.
         @type share_mode: C{int}
-        @param sessionopts: pass-through of options directly to the session instance's L{X2goSession.share_desktop()} method
+        @param sessionopts: pass-through of options directly to the session instance's L{X2GoSession.share_desktop()} method
         @type sessionopts: C{dict}
 
         @return: True if the session could be successfully shared.
         @rtype: C{bool}
 
-        @raise X2goDesktopSharingException: if a given desktop ID does not specify an available desktop session
+        @raise X2GoDesktopSharingException: if a given desktop ID does not specify an available desktop session
 
         &quot;&quot;&quot;
 
-        # X2goClient.list_desktops() uses caching (if enabled, so we prefer lookups here...
+        # X2GoClient.list_desktops() uses caching (if enabled, so we prefer lookups here...)
         if desktop:
             _desktop = desktop
             user = None
@@ -1500,13 +1514,11 @@ class X2goClient(object):
         else:
             _desktop = '%s@%s' % (user, display)
 
-        if not _desktop in self._X2goClient__list_desktops(session_uuid):
+        if not _desktop in self._X2GoClient__list_desktops(session_uuid):
             _orig_desktop = _desktop
             _desktop = '%s.0' % _desktop
-            if not _desktop in self._X2goClient__list_desktops(session_uuid):
-                raise x2go_exceptions.X2goDesktopSharingException('No such desktop ID: %s' % _orig_desktop)
 
-        return self.session_registry(session_uuid).share_desktop(desktop=_desktop, share_mode=share_mode, check_desktop_list=False, **sessionopts)
+        return self.session_registry(session_uuid).share_desktop(desktop=_desktop, share_mode=share_mode, check_desktop_list=check_desktop_list, **sessionopts)
     __share_desktop_session = share_desktop_session
 
     def resume_session(self, session_uuid=None, session_name=None, match_profile_name=None, **sessionopts):
@@ -1521,28 +1533,28 @@ class X2goClient(object):
         @type session_name: C{str}
         @param match_profile_name: only resume a session if this profile name matches
         @type match_profile_name: C{str}
-        @param sessionopts: pass-through of options directly to the session instance's L{X2goSession.resume()} method
+        @param sessionopts: pass-through of options directly to the session instance's L{X2GoSession.resume()} method
         @type sessionopts: C{dict}
 
         @return: returns True if this method has been successful
         @rtype: C{bool}
 
-        @raise X2goClientException: if the method does not know what session to resume
+        @raise X2GoClientException: if the method does not know what session to resume
 
         &quot;&quot;&quot;
         try:
             if session_uuid is None and session_name is None:
-                raise x2go_exceptions.X2goClientException('can\'t resume a session without either session_uuid or session_name')
+                raise x2go_exceptions.X2GoClientException('can\'t resume a session without either session_uuid or session_name')
             if session_name is None and self.session_registry(session_uuid).session_name is None:
-                raise x2go_exceptions.X2goClientException('don\'t know which session to resume')
+                raise x2go_exceptions.X2GoClientException('don\'t know which session to resume')
             if session_uuid is None:
                 session_uuid = self.session_registry.get_session_of_session_name(session_name=session_name, return_object=False, match_profile_name=match_profile_name)
-                return self.session_registry(session_uuid).resume(session_list=self._X2goClient__list_sessions(session_uuid=session_uuid), **sessionopts)
+                return self.session_registry(session_uuid).resume(session_list=self._X2GoClient__list_sessions(session_uuid=session_uuid), **sessionopts)
             else:
-                return self.session_registry(session_uuid).resume(session_name=session_name, session_list=self._X2goClient__list_sessions(session_uuid=session_uuid), **sessionopts)
-        except x2go_exceptions.X2goControlSessionException:
+                return self.session_registry(session_uuid).resume(session_name=session_name, session_list=self._X2GoClient__list_sessions(session_uuid=session_uuid), **sessionopts)
+        except x2go_exceptions.X2GoControlSessionException:
             profile_name = self.get_session_profile_name(session_uuid)
-            self.HOOK_on_control_session_death(profile_name)
+            if self.session_registry(session_uuid).connected: self.HOOK_on_control_session_death(profile_name)
             self.disconnect_profile(profile_name)
     __resume_session = resume_session
 
@@ -1552,7 +1564,7 @@ class X2goClient(object):
 
         Normally, you will use this method to suspend a registered session that you
         have formerly started/resumed from within your recent
-        L{X2goClient} instance. For this you simply call this method
+        L{X2GoClient} instance. For this you simply call this method
         using the session's C{session_uuid}, leave the C{session_name}
         empty.
 
@@ -1570,7 +1582,7 @@ class X2goClient(object):
         @type session_name: C{str}
         @param match_profile_name: only suspend a session if this profile name matches
         @type match_profile_name: C{str}
-        @param sessionopts: pass-through of options directly to the session instance's L{X2goSession.suspend()} method
+        @param sessionopts: pass-through of options directly to the session instance's L{X2GoSession.suspend()} method
         @type sessionopts: C{dict}
 
         @return: returns True if this method has been successful
@@ -1593,9 +1605,9 @@ class X2goClient(object):
                     if session_name == session.get_session_name():
                         return session.suspend()
             return self.session_registry(session_uuid).control_session.suspend(session_name=session_name, **sessionopts)
-        except x2go_exceptions.X2goControlSessionException:
+        except x2go_exceptions.X2GoControlSessionException:
             profile_name = self.get_session_profile_name(session_uuid)
-            self.HOOK_on_control_session_death(profile_name)
+            if self.session_registry(session_uuid).conntected: self.HOOK_on_control_session_death(profile_name)
             self.disconnect_profile(profile_name)
     __suspend_session = suspend_session
 
@@ -1605,7 +1617,7 @@ class X2goClient(object):
 
         Normally you will use this method to terminate a registered session that you 
         have formerly started/resumed from within your recent
-        L{X2goClient} instance. For this you simply call this method
+        L{X2GoClient} instance. For this you simply call this method
         using the session's C{session_uuid}, leave the C{session_name}
         empty.
 
@@ -1622,7 +1634,7 @@ class X2goClient(object):
         @type session_name: C{str}
         @param match_profile_name: only terminate a session if this profile name matches
         @type match_profile_name: C{str}
-        @param sessionopts: pass-through of options directly to the session instance's L{X2goSession.terminate()} method
+        @param sessionopts: pass-through of options directly to the session instance's L{X2GoSession.terminate()} method
         @type sessionopts: C{dict}
 
         @return: returns True if this method has been successful
@@ -1645,9 +1657,9 @@ class X2goClient(object):
                     if session_name == session.get_session_name():
                         return session.terminate()
             return self.session_registry(session_uuid).control_session.terminate(session_name=session_name, **sessionopts)
-        except x2go_exceptions.X2goControlSessionException:
+        except x2go_exceptions.X2GoControlSessionException:
             profile_name = self.get_session_profile_name(session_uuid)
-            self.HOOK_on_control_session_death(profile_name)
+            if self.session_registry(session_uuid).conntected: self.HOOK_on_control_session_death(profile_name)
             self.disconnect_profile(profile_name)
     __terminate_session = terminate_session
 
@@ -1661,7 +1673,7 @@ class X2goClient(object):
 
         For non-profile based session this will either be a C{profile_name} that 
         was passed to L{register_session} or it will be the application that
-        instantiated this L{X2goClient} instance.
+        instantiated this L{X2GoClient} instance.
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
@@ -1830,11 +1842,11 @@ class X2goClient(object):
 
         &quot;&quot;&quot;
         if session_uuid is None and profile_name:
-            session_uuid = self._X2goClient__get_master_session(profile_name, return_object=False)
+            session_uuid = self._X2GoClient__get_master_session(profile_name, return_object=False)
         if session_uuid:
             try:
                 return self.session_registry(session_uuid).is_folder_sharing_available()
-            except x2go_exceptions.X2goSessionRegistryException:
+            except x2go_exceptions.X2GoSessionRegistryException:
                 return False
         else:
             self.logger('Cannot find a terminal session for profile ,,%s\'\' that can be used to query folder sharing capabilities' % profile_name, loglevel=log.loglevel_INFO)
@@ -1869,11 +1881,11 @@ class X2goClient(object):
         if folder_name: local_path = folder_name
 
         if session_uuid is None and profile_name:
-            session_uuid = self._X2goClient__get_master_session(profile_name, return_object=False)
+            session_uuid = self._X2GoClient__get_master_session(profile_name, return_object=False)
         if session_uuid:
             try:
                 return self.session_registry(session_uuid).share_local_folder(local_path=local_path)
-            except x2go_exceptions.X2goSessionException:
+            except x2go_exceptions.X2GoSessionException:
                 return False
         else:
             self.logger('Cannot find a terminal session for profile ,,%s\'\' to share a local folder with' % profile_name, loglevel=log.loglevel_WARN)
@@ -1902,7 +1914,7 @@ class X2goClient(object):
 
         &quot;&quot;&quot;
         if session_uuid is None and profile_name:
-            session_uuid = self._X2goClient__get_master_session(profile_name, return_object=False)
+            session_uuid = self._X2GoClient__get_master_session(profile_name, return_object=False)
         if session_uuid:
             return self.session_registry(session_uuid).unshare_all_local_folders()
         else:
@@ -1927,7 +1939,7 @@ class X2goClient(object):
         @param profile_name: alternatively, the profile name can be used to unshare
             mounted folders
         @type profile_name: C{str}
-        @param local_path: the full path of a local folder that is mounted within X2go
+        @param local_path: the full path of a local folder that is mounted within X2Go
             session with session ID &lt;session_uuid&gt; (or recognized via profile name) and that
             shall be unmounted from that session.
         @type local_path: C{str}
@@ -1937,7 +1949,7 @@ class X2goClient(object):
 
         &quot;&quot;&quot;
         if session_uuid is None and profile_name:
-            session_uuid = self._X2goClient__get_master_session(profile_name, return_object=False)
+            session_uuid = self._X2GoClient__get_master_session(profile_name, return_object=False)
         if session_uuid:
             return self.session_registry(session_uuid).unshare_local_folder(local_path=local_path)
         else:
@@ -1965,7 +1977,7 @@ class X2goClient(object):
 
         &quot;&quot;&quot;
         if session_uuid is None and profile_name:
-            session_uuid = self._X2goClient__get_master_session(profile_name, return_object=False)
+            session_uuid = self._X2GoClient__get_master_session(profile_name, return_object=False)
 
         if session_uuid and profile_name is None:
             profile_name = self.session_registry(session_uuid).get_profile_name()
@@ -1992,7 +2004,7 @@ class X2goClient(object):
 
         @param profile_name: the profile name that we query the master session of
         @type profile_name: C{str}
-        @param return_object: return L{X2goSession} instance
+        @param return_object: return L{X2GoSession} instance
         @type return_object: C{bool}
         @param return_session_name: return X2Go session name
         @type return_session_name: C{bool}
@@ -2007,12 +2019,12 @@ class X2goClient(object):
     __profile_master_session = profile_master_session
 
     ###
-    ### Provide access to the X2goClient's session registry
+    ### Provide access to the X2GoClient's session registry
     ### 
 
     def client_connected_sessions(self, return_objects=False, return_profile_names=False, return_profile_ids=False, return_session_names=False):
         &quot;&quot;&quot;\
-        Retrieve a list of X2Go sessions that this L{X2goClient} instance is connected to.
+        Retrieve a list of X2Go sessions that this L{X2GoClient} instance is connected to.
 
         @param return_objects: return as list of X2Go session objects
         @type return_objects: C{bool}
@@ -2022,6 +2034,7 @@ class X2goClient(object):
         @type return_profile_ids: C{bool}
         @param return_session_names: return as list of session names
         @type return_session_names: C{bool}
+
         @return: list of connected sessions
         @rtype: C{list}
 
@@ -2032,7 +2045,7 @@ class X2goClient(object):
     @property
     def client_has_connected_sessions(self):
         &quot;&quot;&quot;\
-        Equals C{True} if there are any connected sessions with this L{X2goClient} instance.
+        Equals C{True} if there are any connected sessions with this L{X2GoClient} instance.
 
         &quot;&quot;&quot;
         return self.session_registry.has_connected_sessions
@@ -2040,7 +2053,7 @@ class X2goClient(object):
 
     def client_associated_sessions(self, return_objects=False, return_profile_names=False, return_profile_ids=False, return_session_names=False):
         &quot;&quot;&quot;\
-        Retrieve a list of X2Go sessions associated to this L{X2goClient} instance.
+        Retrieve a list of X2Go sessions associated to this L{X2GoClient} instance.
 
         @param return_objects: return as list of X2Go session objects
         @type return_objects: C{bool}
@@ -2050,6 +2063,7 @@ class X2goClient(object):
         @type return_profile_ids: C{bool}
         @param return_session_names: return as list of session names
         @type return_session_names: C{bool}
+
         @return: list of associated sessions
         @rtype: C{list}
 
@@ -2060,7 +2074,7 @@ class X2goClient(object):
     @property
     def client_has_associated_sessions(self):
         &quot;&quot;&quot;\
-        Equals C{True} if there are any associated sessions with this L{X2goClient} instance.
+        Equals C{True} if there are any associated sessions with this L{X2GoClient} instance.
 
         &quot;&quot;&quot;
         return self.session_registry.has_associated_sessions
@@ -2078,6 +2092,7 @@ class X2goClient(object):
         @type return_profile_ids: C{bool}
         @param return_session_names: return as list of session names
         @type return_session_names: C{bool}
+
         @return: list of running sessions
         @rtype: C{list}
 
@@ -2088,7 +2103,7 @@ class X2goClient(object):
     @property
     def client_has_running_sessions(self):
         &quot;&quot;&quot;\
-        Equals C{True} if there are any running sessions with this L{X2goClient} instance.
+        Equals C{True} if there are any running sessions with this L{X2GoClient} instance.
 
         &quot;&quot;&quot;
         return self.session_registry.has_running_sessions
@@ -2106,6 +2121,7 @@ class X2goClient(object):
         @type return_profile_ids: C{bool}
         @param return_session_names: return as list of session names
         @type return_session_names: C{bool}
+
         @return: list of suspended sessions
         @rtype: C{list}
 
@@ -2116,7 +2132,7 @@ class X2goClient(object):
     @property
     def client_has_suspended_sessions(self):
         &quot;&quot;&quot;\
-        Equals C{True} if there are any suspended sessions with this L{X2goClient} instance.
+        Equals C{True} if there are any suspended sessions with this L{X2GoClient} instance.
 
         &quot;&quot;&quot;
         return self.session_registry.has_suspended_sessions
@@ -2134,6 +2150,7 @@ class X2goClient(object):
         @type return_profile_ids: C{bool}
         @param return_session_names: return as list of session names
         @type return_session_names: C{bool}
+
         @return: list of registered sessions
         @rtype: C{list}
 
@@ -2158,12 +2175,78 @@ class X2goClient(object):
         @type profile_name: C{str}
 
         @return: control session instance
-        @rtype: C{X2goControlSession} instance
+        @rtype: C{X2GoControlSession} instance
 
         &quot;&quot;&quot;
         return self.session_registry.control_session_of_profile_name(profile_name)
     __client_control_session_of_profile_name = client_control_session_of_profile_name
 
+    def get_server_versions(self, profile_name, component=None, force=False):
+        &quot;&quot;&quot;\
+        Query the server configured in session profile &lt;profile_name&gt; for the list of install X2Go components
+        and its versions.
+
+        @param profile_name: use the control session of this profile to query the X2Go server for its component list
+        @type profile_name: C{str}
+        @param component: only return the version of a specific component
+        @type component: C{str}
+        @param force: refresh component/version data by a query to the server
+        @type force: C{bool}
+
+        @return: dictionary of server components (as keys) and their versions (as values) or the version of the given &lt;component&gt;
+        @rtype: C{dict} or C{str}
+
+        @raise X2GoClientException: if component is not available on the X2Go Server.
+
+        &quot;&quot;&quot;
+        control_session = self.client_control_session_of_profile_name(profile_name)
+        if component is None:
+            return control_session.get_server_versions(force=force)
+        else:
+            try:
+                return control_session.get_server_versions(force=force)[component]
+            except KeyError:
+                raise x2go_exceptions.X2GoClientException('No such component on X2Go Server')
+    __get_server_versions = get_server_versions
+    get_server_components = get_server_versions
+    __get_server_components = get_server_components
+
+    def get_server_features(self, profile_name, force=False):
+        &quot;&quot;&quot;\
+        Query the server configured in session profile &lt;profile_name&gt; for the list of server-side
+        X2Go features.
+
+        @param profile_name: use the control session of this profile to query the X2Go server for its feature list
+        @type profile_name: C{str}
+        @param force: refresh feature list by a query to the server
+        @type force: C{bool}
+
+        @return: list of server feature names (as returned by server-side command ,,x2gofeaturelist''
+        @rtype: C{list}
+
+        &quot;&quot;&quot;
+        control_session = self.client_control_session_of_profile_name(profile_name)
+        return control_session.get_server_features(force=force)
+    __get_server_features = get_server_features
+
+    def has_server_feature(self, profile_name, feature):
+        &quot;&quot;&quot;\
+        Query the server configured in session profile &lt;profile_name&gt; for the availability
+        of a certain server feature.
+
+        @param profile_name: use the control session of this profile to query the X2Go server for its feature
+        @type profile_name: C{str}
+        @param feature: test the availability of this feature on the X2Go server
+        @type feature: C{str}
+
+        @return: C{True} if the feature is available on the queried server
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        control_session = self.client_control_session_of_profile_name(profile_name)
+        return feature in control_session.get_server_features()
+    __has_server_feature = has_server_feature
+
     def client_registered_session_of_name(self, session_name, return_object=False):
         &quot;&quot;&quot;\
         Retrieve X2Go session of a given session name.
@@ -2172,7 +2255,7 @@ class X2goClient(object):
         @type session_name: C{str}
 
         @return: session instance of the given name
-        @rtype: C{X2goSession} or C{str}
+        @rtype: C{X2GoSession} or C{str}
 
         &quot;&quot;&quot;
         return self.session_registry.get_session_of_session_name(session_name, return_object=return_object)
@@ -2309,22 +2392,22 @@ class X2goClient(object):
         &quot;&quot;&quot;\
         Test if server that corresponds to the terminal session C{session_uuid} is alive.
 
-        If the session is not connected anymore the L{X2goClient.HOOK_on_control_session_death()} gets called.
+        If the session is not connected anymore the L{X2GoClient.HOOK_on_control_session_death()} gets called.
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
 
-        @return: C{True} if X2Go server connection for L{X2goSession} instance with &lt;session_uuid&gt; is alive.
+        @return: C{True} if X2Go server connection for L{X2GoSession} instance with &lt;session_uuid&gt; is alive.
         @rtype: C{bool}
 
-        @raise X2goControlSessionException: if the session is not connected anymore; in that case the L{HOOK_on_control_session_death} gets called.
+        @raise X2GoControlSessionException: if the session is not connected anymore; in that case the L{HOOK_on_control_session_death} gets called.
 
         &quot;&quot;&quot;
         try:
             return self.session_registry(session_uuid).is_alive()
-        except x2go_exceptions.X2goControlSessionException:
+        except x2go_exceptions.X2GoControlSessionException:
             profile_name = self.get_session_profile_name(session_uuid)
-            self.HOOK_on_control_session_death(profile_name)
+            if self.session_registry(session_uuid).conntected: self.HOOK_on_control_session_death(profile_name)
             self.disconnect_profile(profile_name)
             return False
     __server_is_alive = server_is_alive
@@ -2362,7 +2445,7 @@ class X2goClient(object):
     def server_running_sessions(self, session_uuid):
         &quot;&quot;&quot;\
         Retrieve a list of session names of all server-side running sessions (including those not
-        instantiated by our L{X2goClient} instance).
+        instantiated by our L{X2GoClient} instance).
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
@@ -2370,14 +2453,14 @@ class X2goClient(object):
         @return: list of session names
         @rtype: C{list}
 
-        @raise X2goClientException: if the session with UUID C{session_uuid} is not connected
+        @raise X2GoClientException: if the session with UUID C{session_uuid} is not connected
 
         &quot;&quot;&quot;
-        if self._X2goClient__is_session_connected(session_uuid):
-            session_list = self._X2goClient__list_sessions(session_uuid)
+        if self._X2GoClient__is_session_connected(session_uuid):
+            session_list = self._X2GoClient__list_sessions(session_uuid)
             return [ key for key in session_list.keys() if session_list[key].status == 'R' ]
         else:
-            raise x2go_exceptions.X2goClientException('X2Go session with UUID %s is not connected' % session_uuid)
+            raise x2go_exceptions.X2GoClientException('X2Go session with UUID %s is not connected' % session_uuid)
     __server_running_sessions = server_running_sessions
 
     def server_has_running_sessions(self, session_uuid):
@@ -2390,7 +2473,7 @@ class X2goClient(object):
         @rtype: C{bool}
 
         &quot;&quot;&quot;
-        return len(self._X2goClient__server_running_sessions(session_uuid)) &gt; 0
+        return len(self._X2GoClient__server_running_sessions(session_uuid)) &gt; 0
     __server_has_running_sessions = server_has_running_sessions
 
     def server_has_running_session_of_name(self, session_uuid, session_name):
@@ -2403,13 +2486,13 @@ class X2goClient(object):
         @type session_name: C{str}
 
         &quot;&quot;&quot;
-        return session_name in self._X2goClient__server_running_sessions(session_uuid)
+        return session_name in self._X2GoClient__server_running_sessions(session_uuid)
     __server_has_running_session_of_name = server_has_running_session_of_name
 
     def server_suspended_sessions(self, session_uuid):
         &quot;&quot;&quot;\
         Retrieve a list of session names of all server-side suspended sessions (including those not
-        instantiated by our L{X2goClient} instance).
+        instantiated by our L{X2GoClient} instance).
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
@@ -2417,14 +2500,14 @@ class X2goClient(object):
         @return: list of session names
         @rtype: C{list}
 
-        @raise X2goClientException: if the session with UUID C{session_uuid} is not connected
+        @raise X2GoClientException: if the session with UUID C{session_uuid} is not connected
 
         &quot;&quot;&quot;
-        if self._X2goClient__is_session_connected(session_uuid):
-            session_list = self._X2goClient__list_sessions(session_uuid)
+        if self._X2GoClient__is_session_connected(session_uuid):
+            session_list = self._X2GoClient__list_sessions(session_uuid)
             return [ key for key in session_list.keys() if session_list[key].status == 'S' ]
         else:
-            raise x2go_exceptions.X2goClientException('X2Go session with UUID %s is not connected' % session_uuid)
+            raise x2go_exceptions.X2GoClientException('X2Go session with UUID %s is not connected' % session_uuid)
     __server_suspended_sessions = server_suspended_sessions
 
     def server_has_suspended_sessions(self, session_uuid):
@@ -2435,7 +2518,7 @@ class X2goClient(object):
         @type session_uuid: C{str}
 
         &quot;&quot;&quot;
-        return len(self._X2goClient__server_suspended_sessions(session_uuid)) &gt; 0
+        return len(self._X2GoClient__server_suspended_sessions(session_uuid)) &gt; 0
     __server_has_suspended_sessions = server_has_suspended_sessions
 
     def server_has_suspended_session_of_name(self, session_uuid, session_name):
@@ -2450,7 +2533,7 @@ class X2goClient(object):
         @rtype: C{bool}
 
         &quot;&quot;&quot;
-        return session_name in self._X2goClient__server_suspended_sessions(session_uuid)
+        return session_name in self._X2GoClient__server_suspended_sessions(session_uuid)
     __server_has_suspended_session_of_name = server_has_suspended_session_of_name
 
     ###
@@ -2463,9 +2546,9 @@ class X2goClient(object):
         connected user on the remote X2Go server and terminate them.
 
         Before calling this method you have to setup a pro forma remote X2Go session 
-        with L{X2goClient.register_session()} (even if you do not intend to open 
+        with L{X2GoClient.register_session()} (even if you do not intend to open 
         a real X2Go session window on the remote server) and connect to this session (with
-        L{X2goClient.connect_session()}.
+        L{X2GoClient.connect_session()}.
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
@@ -2491,9 +2574,9 @@ class X2goClient(object):
         connected X2Go server (for the authenticated user).
 
         Before calling this method you have to setup a pro forma remote X2Go session 
-        with L{X2goClient.register_session()} (even if you do not intend to open 
+        with L{X2GoClient.register_session()} (even if you do not intend to open 
         a real X2Go session window on the remote server) and connect to this session (with
-        L{X2goClient.connect_session()}.
+        L{X2GoClient.connect_session()}.
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
@@ -2510,12 +2593,12 @@ class X2goClient(object):
             session registry according to the obtained information
         @type update_sessionregistry: C{bool}
         @param register_sessions: query the X2Go server directly and register newly found X2Go session
-            as L{X2goSession} instances associated to this L{X2goClient} instance
+            as L{X2GoSession} instances associated to this L{X2GoClient} instance
         @type register_sessions: C{bool}
-        @param raw: output the session list in X2go's raw C{x2golistsessions} format
+        @param raw: output the session list in X2Go's raw C{x2golistsessions} format
         @type raw: C{bool}
 
-        @raise X2goClientException: if the session profile specified by C{session_uuid}, C{profile_name} or C{profile_id} is not connected
+        @raise X2GoClientException: if the session profile specified by C{session_uuid}, C{profile_name} or C{profile_id} is not connected
             or if none of the named parameters has been specified
 
         &quot;&quot;&quot;
@@ -2530,12 +2613,12 @@ class X2goClient(object):
                 # thus, we simply grab the first that comes in...
                 session_uuid = _connected_sessions[0].get_uuid()
             else:
-                raise x2go_exceptions.X2goClientException('profile ,,%s\'\' is not connected' % profile_name)
+                raise x2go_exceptions.X2GoClientException('profile ,,%s\'\' is not connected' % profile_name)
 
         elif session_uuid is not None:
             pass
         else:
-            raise x2go_exceptions.X2goClientException('must either specify session UUID or profile name')
+            raise x2go_exceptions.X2GoClientException('must either specify session UUID or profile name')
 
         if raw:
             return self.session_registry(session_uuid).list_sessions(raw=raw)
@@ -2565,6 +2648,7 @@ class X2goClient(object):
     def list_desktops(self, session_uuid=None, 
                       profile_name=None, profile_id=None,
                       no_cache=False, refresh_cache=False,
+                      exclude_session_types=[],
                       raw=False):
         &quot;&quot;&quot;\
         Use the X2Go session registered under C{session_uuid} to
@@ -2572,9 +2656,9 @@ class X2goClient(object):
         for desktop sharing.
 
         Before calling this method you have to setup a pro forma remote X2Go session
-        with L{X2goClient.register_session()} (even if you do not intend to open
+        with L{X2GoClient.register_session()} (even if you do not intend to open
         a real X2Go session window on the remote server) and connect to this session (with
-        L{X2goClient.connect_session()}.
+        L{X2GoClient.connect_session()}.
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
@@ -2582,15 +2666,22 @@ class X2goClient(object):
         @type profile_name: C{str}
         @param profile_id: use profile id instead of &lt;profile_name&gt; or &lt;session_uuid&gt;
         @type profile_id: C{str}
-        @param no_cache: do not get the session list from cache, query the X2Go server directly
+        @param no_cache: do not get the desktop list from cache, query the X2Go server directly
         @type no_cache: C{bool}
-        @param raw: output the session list in X2go's raw C{x2golistdesktops} format
+        @param refresh_cache: query the X2Go server directly and update the desktop list cache
+            with the new information
+        @type refresh_cache: C{bool}
+        @param excluded_session_types: session types (e.g. &quot;D&quot;, &quot;R&quot;, &quot;S&quot; or &quot;P&quot;) to be excluded from the
+            returned list of sharable desktops (this only works for sharing someone's own sessions, for
+            sharing other users' sessions, the X2Go Desktop Sharing decides on what is sharable and what not).
+        @type excluded_session_types: C{list}
+        @param raw: output the session list in X2Go's raw C{x2golistdesktops} format
         @type raw: C{bool}
 
         @return: a list of available desktops to be shared
         @rtype: C{list}
 
-        @raise X2goClientException: if the session profile specified by C{session_uuid}, C{profile_name} or C{profile_id} is not connected
+        @raise X2GoClientException: if the session profile specified by C{session_uuid}, C{profile_name} or C{profile_id} is not connected
             or if none of the named parameters has been specified
 
         &quot;&quot;&quot;
@@ -2605,12 +2696,12 @@ class X2goClient(object):
                 # thus, we simply grab the first that comes in...
                 session_uuid = _connected_sessions[0].get_uuid()
             else:
-                raise x2go_exceptions.X2goClientException('profile ,,%s\'\' is not connected' % profile_name)
+                raise x2go_exceptions.X2GoClientException('profile ,,%s\'\' is not connected' % profile_name)
 
         elif session_uuid is not None:
             pass
         else:
-            raise x2go_exceptions.X2goClientException('must either specify session UUID or profile name')
+            raise x2go_exceptions.X2GoClientException('must either specify session UUID or profile name')
 
         if raw:
             return self.session_registry(session_uuid).list_desktops(raw=raw)
@@ -2622,6 +2713,23 @@ class X2goClient(object):
                 self.__update_cache_by_session_uuid(session_uuid, update_sessions=False, update_desktops=True)
             _desktop_list = self.listsessions_cache.list_desktops(session_uuid)
 
+        # attempt to exclude session types that are requested to be excluded
+        if exclude_session_types:
+
+            # create an X2GoServerSessionList* instance and operate on that
+            session_list = self.list_backend()
+            session_list.set_sessions(self._X2GoClient__list_sessions(session_uuid))
+
+            # search for a match among the listed sessions
+            for desktop in copy.deepcopy(_desktop_list):
+                user = desktop.split('@')[0]
+                if user == self.get_session_username(session_uuid):
+                    display = desktop.split('@')[1]
+                    session = session_list.get_session_with('display', display, hostname=self.get_session_server_hostname(session_uuid))
+                    if session is None: continue
+                    if session.get_session_type() in exclude_session_types:
+                        _desktop_list.remove(desktop)
+
         return _desktop_list
     __list_desktops = list_desktops
 
@@ -2636,7 +2744,7 @@ class X2goClient(object):
         @type profile_name: C{str}
         @param no_cache: do not get the session list from cache, query the X2Go server directly
         @type no_cache: C{bool}
-        @param raw: output the session list in X2go's raw C{x2golistmounts} format
+        @param raw: output the session list in X2Go's raw C{x2golistmounts} format
         @type raw: C{bool}
 
         @return: list of server-side mounted shares for a given profile name
@@ -2667,7 +2775,7 @@ class X2goClient(object):
         @type session_uuid: C{str}
         @param no_cache: do not get the session list from cache, query the X2Go server directly
         @type no_cache: C{bool}
-        @param raw: output the session list in X2go's raw C{x2golistmounts} format
+        @param raw: output the session list in X2Go's raw C{x2golistmounts} format
         @type raw: C{bool}
 
         @return: list of server-side mounted shares for a given session UUID
@@ -2693,14 +2801,14 @@ class X2goClient(object):
 
     def get_profiles(self):
         &quot;&quot;&quot;\
-        Returns the L{X2goClient} instance's C{X2goSessionProfiles*} object.
+        Returns the L{X2GoClient} instance's C{X2GoSessionProfiles*} object.
 
         Use this method for object retrieval if you want to modify the &#187;sessions&#171;
         configuration node (e.g. in ~/.x2goclient with the FILE backend) from within your
         Python X2Go based application.
 
         return: returns the client's session profiles instance
-        rtype: C{X2goSessionProfiles*} instance
+        rtype: C{X2GoSessionProfiles*} instance
 
         &quot;&quot;&quot;
         return self.session_profiles
@@ -2711,7 +2819,7 @@ class X2goClient(object):
     @property
     def profile_names(self):
         &quot;&quot;&quot;\
-        Equals a list of all profile names that are known to this L{X2goClient} instance.
+        Equals a list of all profile names that are known to this L{X2GoClient} instance.
 
         &quot;&quot;&quot;
         return self.session_profiles.profile_names
@@ -2719,7 +2827,7 @@ class X2goClient(object):
 
     def get_client_settings(self):
         &quot;&quot;&quot;\
-        Returns the L{X2goClient} instance's C{X2goClientSettings*} object.
+        Returns the L{X2GoClient} instance's C{X2GoClientSettings*} object.
 
         Use this method for object retrieval if you want to modify the &#187;settings&#171;
         configuration node (e.g. in ~/.x2goclient with the FILE backend) from within your
@@ -2734,7 +2842,7 @@ class X2goClient(object):
 
     def get_client_printing(self):
         &quot;&quot;&quot;\
-        Returns the L{X2goClient} instance's C{X2goClientPrinting*} object.
+        Returns the L{X2GoClient} instance's C{X2GoClientPrinting*} object.
 
         Use this method for object retrieval if you want to modify the printing
         configuration node (e.g. in ~/.x2goclient with the FILE backend) from within your
@@ -2854,7 +2962,7 @@ class X2goClient(object):
 
     def disconnect_profile(self, profile_name):
         &quot;&quot;&quot;\
-        Disconnect all L{X2goSession} instances that relate to C{profile_name} by closing down their
+        Disconnect all L{X2GoSession} instances that relate to C{profile_name} by closing down their
         Paramiko/SSH Transport thread.
 
         @param profile_name: the X2Go session profile name
@@ -2887,33 +2995,33 @@ class X2goClient(object):
         @param profile_name: the X2Go session profile name
         @type profile_name: C{str}
         @param session_list: a manually passed on list of X2Go sessions
-        @type session_list: C{X2goServerList*} instances
+        @type session_list: C{X2GoServerList*} instances
 
         &quot;&quot;&quot;
         session_uuids = self.client_registered_sessions_of_profile_name(profile_name, return_objects=False)
         if session_uuids:
             if session_list is None:
-                session_list = self._X2goClient__list_sessions(session_uuids[0],
+                session_list = self._X2GoClient__list_sessions(session_uuids[0],
                                                                update_sessionregistry=False,
                                                                register_sessions=False,
                                                               )
             try:
                 self.session_registry.update_status(profile_name=profile_name, session_list=session_list)
-            except x2go_exceptions.X2goControlSessionException:
-                self.HOOK_on_control_session_death(profile_name)
+            except x2go_exceptions.X2GoControlSessionException:
+                if self.session_registry(session_uuids[0]).connected: self.HOOK_on_control_session_death(profile_name)
                 self.disconnect_profile(profile_name)
     __update_sessionregistry_status_by_profile_name = update_sessionregistry_status_by_profile_name
 
     def update_sessionregistry_status_by_session_uuid(self, session_uuid):
         &quot;&quot;&quot;\
-        Update the session registry status of a specific L{X2goSession} instance with
+        Update the session registry status of a specific L{X2GoSession} instance with
         session identifier &lt;session_uuid&gt;.
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
 
         &quot;&quot;&quot;
-        session_list = self._X2goClient__list_sessions(session_uuid, update_sessionregistry=False, register_sessions=False)
+        session_list = self._X2GoClient__list_sessions(session_uuid, update_sessionregistry=False, register_sessions=False)
         if session_list:
             self.session_registry.update_status(session_uuid=session_uuid, session_list=session_list)
     __update_sessionregistry_status_by_session_uuid = update_sessionregistry_status_by_session_uuid
@@ -2953,14 +3061,15 @@ class X2goClient(object):
             _update_mounts = ('mounts' in cache_types) or update_mounts
             try:
                 self.listsessions_cache.update(profile_name, update_sessions=_update_sessions, update_desktops=_update_desktops, update_mounts=_update_mounts, )
-            except x2go_exceptions.X2goControlSessionException:
-                self.HOOK_on_control_session_death(profile_name)
+            except x2go_exceptions.X2GoControlSessionException:
+                c_sessions = self.client_connected_sessions_of_profile_name(profile_name, return_objects=True)
+                if len(c_sessions) and c_sessions[0].connected: self.HOOK_on_control_session_death(profile_name)
                 self.disconnect_profile(profile_name)
     __update_cache_by_profile_name = update_cache_by_profile_name
 
     def update_cache_by_session_uuid(self, session_uuid, cache_types=('sessions'), update_sessions=None, update_desktops=None, update_mounts=None):
         &quot;&quot;&quot;\
-        Update the session list cache of a specific L{X2goSession} instance with
+        Update the session list cache of a specific L{X2GoSession} instance with
         session identifier &lt;session_uuid&gt;.
 
         @param session_uuid: the X2Go session's UUID registry hash
@@ -3033,21 +3142,22 @@ class X2goClient(object):
         &quot;&quot;&quot;
         if profile_name not in self.client_connected_profiles(return_profile_names=True):
             return
-        session_list = self._X2goClient__list_sessions(profile_name=profile_name,
+        session_list = self._X2GoClient__list_sessions(profile_name=profile_name,
                                                        update_sessionregistry=False,
                                                        register_sessions=False,
                                                       )
         try:
             self.session_registry.register_available_server_sessions(profile_name, session_list=session_list, re_register=re_register, skip_pubapp_sessions=skip_pubapp_sessions)
-        except x2go_exceptions.X2goControlSessionException, e:
-            self.HOOK_on_control_session_death(profile_name)
+        except x2go_exceptions.X2GoControlSessionException, e:
+            c_sessions = self.client_connected_sessions_of_profile_name(profile_name, return_objects=True)
+            if len(c_sessions) and c_sessions[0].connected: self.HOOK_on_control_session_death(profile_name)
             self.disconnect_profile(profile_name)
             raise e
     __register_available_server_sessions_by_profile_name = register_available_server_sessions_by_profile_name
 
     def register_available_server_sessions_by_session_uuid(self, session_uuid, skip_pubapp_sessions=False):
         &quot;&quot;&quot;\
-        Register available sessions that are found on the X2Go server that the L{X2goSession} instance 
+        Register available sessions that are found on the X2Go server that the L{X2GoSession} instance 
         with session identifier &lt;session_uuid&gt; is connected to.
 
         @param session_uuid: the X2Go session's UUID registry hash
@@ -3071,6 +3181,6 @@ class X2goClient(object):
         for profile_name in self.client_connected_profiles(return_profile_names=True):
             try:
                 self.__register_available_server_sessions_by_profile_name(profile_name, skip_pubapp_sessions=skip_pubapp_sessions)
-            except x2go_exceptions.X2goSessionRegistryException:
+            except x2go_exceptions.X2GoSessionRegistryException:
                 pass
     __register_available_server_sessions_all_profiles = register_available_server_sessions_all_profiles
diff --git a/x2go/defaults.py b/x2go/defaults.py
index 15ea901..d6d0473 100644
--- a/x2go/defaults.py
+++ b/x2go/defaults.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -96,56 +96,56 @@ else:
 ##
 
 BACKENDS_CONTROLSESSION = {
-    'STDOUT': 'X2goControlSessionSTDOUT',
+    'STDOUT': 'X2GoControlSessionSTDOUT',
 }
 BACKENDS_TERMINALSESSION = {
-    'STDOUT': 'X2goTerminalSessionSTDOUT',
+    'STDOUT': 'X2GoTerminalSessionSTDOUT',
 }
 BACKENDS_SERVERSESSIONINFO = {
-    'STDOUT': 'X2goServerSessionInfoSTDOUT',
+    'STDOUT': 'X2GoServerSessionInfoSTDOUT',
 }
 BACKENDS_SERVERSESSIONLIST = {
-    'STDOUT': 'X2goServerSessionListSTDOUT',
+    'STDOUT': 'X2GoServerSessionListSTDOUT',
 }
 BACKENDS_PROXY = {
-    'NX3': 'X2goProxyNX3',
+    'NX3': 'X2GoProxyNX3',
 }
 
-BACKEND_CONTROLSESSION_DEFAULT =  'X2goControlSessionSTDOUT'
-BACKEND_TERMINALSESSION_DEFAULT = 'X2goTerminalSessionSTDOUT'
-BACKEND_SERVERSESSIONINFO_DEFAULT = 'X2goServerSessionInfoSTDOUT'
-BACKEND_SERVERSESSIONLIST_DEFAULT = 'X2goServerSessionListSTDOUT'
-BACKEND_PROXY_DEFAULT = 'X2goProxyNX3'
+BACKEND_CONTROLSESSION_DEFAULT =  'X2GoControlSessionSTDOUT'
+BACKEND_TERMINALSESSION_DEFAULT = 'X2GoTerminalSessionSTDOUT'
+BACKEND_SERVERSESSIONINFO_DEFAULT = 'X2GoServerSessionInfoSTDOUT'
+BACKEND_SERVERSESSIONLIST_DEFAULT = 'X2GoServerSessionListSTDOUT'
+BACKEND_PROXY_DEFAULT = 'X2GoProxyNX3'
 
 ##
 ## profile backend defaults
 ##
 
 BACKENDS_SESSIONPROFILES = {
-    'FILE': 'X2goSessionProfilesFILE',
-    'GCONF': 'X2goSessionProfilesGCONF',
-    'HTTPSBROKER': 'X2goSessionProfilesHTTPSBROKER',
-    'WINREG': 'X2goSessionProfilesWINREG',
+    'FILE': 'X2GoSessionProfilesFILE',
+    'GCONF': 'X2GoSessionProfilesGCONF',
+    'HTTPSBROKER': 'X2GoSessionProfilesHTTPSBROKER',
+    'WINREG': 'X2GoSessionProfilesWINREG',
 }
 &quot;&quot;&quot;Python X2Go backends for storing session profiles.&quot;&quot;&quot;
 BACKENDS_CLIENTSETTINGS = {
-    'FILE': 'X2goClientSettingsFILE',
-    'GCONF': 'X2goClientSettingsGCONF',
-    'HTTPSBROKER': 'X2goClientSettingsHTTPSBROKER',
-    'WINREG': 'X2goClientSettingsWINREG',
+    'FILE': 'X2GoClientSettingsFILE',
+    'GCONF': 'X2GoClientSettingsGCONF',
+    'HTTPSBROKER': 'X2GoClientSettingsHTTPSBROKER',
+    'WINREG': 'X2GoClientSettingsWINREG',
 }
 &quot;&quot;&quot;Python X2Go backends for storing client settings.&quot;&quot;&quot;
 BACKENDS_CLIENTPRINTING = {
-    'FILE': 'X2goClientPrintingFILE',
-    'GCONF': 'X2goClientPrintingGCONF',
-    'HTTPSBROKER': 'X2goClientPrintingHTTPSBROKER',
-    'WINREG': 'X2goClientPrintingWINREG',
+    'FILE': 'X2GoClientPrintingFILE',
+    'GCONF': 'X2GoClientPrintingGCONF',
+    'HTTPSBROKER': 'X2GoClientPrintingHTTPSBROKER',
+    'WINREG': 'X2GoClientPrintingWINREG',
 }
 &quot;&quot;&quot;Python X2Go backends for storing print settings.&quot;&quot;&quot;
 
-BACKEND_SESSIONPROFILES_DEFAULT = 'X2goSessionProfilesFILE'
-BACKEND_CLIENTSETTINGS_DEFAULT = 'X2goClientSettingsFILE'
-BACKEND_CLIENTPRINTING_DEFAULT = 'X2goClientPrintingFILE'
+BACKEND_SESSIONPROFILES_DEFAULT = 'X2GoSessionProfilesFILE'
+BACKEND_CLIENTSETTINGS_DEFAULT = 'X2GoClientSettingsFILE'
+BACKEND_CLIENTPRINTING_DEFAULT = 'X2GoClientPrintingFILE'
 
 ##
 ## X2Go Printing
@@ -181,7 +181,7 @@ X2GO_CLIENTSETTINGS_DEFAULTS = {
         'port2': 0,
     },
     'General': {
-        # clientport is not needed for Python X2go
+        # clientport is not needed for Python X2Go
         'clientport': 22, 
         'autoresume': True,
     },
@@ -211,9 +211,9 @@ X2GO_CLIENTPRINTING_DEFAULTS = {
         'startcmd': False,
         # print command for non-CUPS printing
         'command': 'lpr',
-        # ignored in Python X2go
+        # ignored in Python X2Go
         'stdin': False,
-        # ignored in Python X2go
+        # ignored in Python X2Go
         'ps': False,
     },
     'save': {
@@ -289,18 +289,19 @@ else:
     X2GO_CLIENTXCONFIG_DEFAULTS = {}
 
 X2GO_GENERIC_APPLICATIONS = [ 'WWWBROWSER', 'MAILCLIENT', 'OFFICE', 'TERMINAL', ]
-&quot;&quot;&quot;X2go's generic applications.&quot;&quot;&quot;
+&quot;&quot;&quot;X2Go's generic applications.&quot;&quot;&quot;
 
 X2GO_SESSIONPROFILE_DEFAULTS = {
     'autologin': True, 'autoconnect': False, 'autostart': False, 'setsessiontitle': False, 'sessiontitle': &quot;&quot;,
     'speed': 2, 'pack': '16m-jpeg', 'quality': 9,
     'iconvto': 'UTF-8', 'iconvfrom': 'UTF-8', 'useiconv': False,
-    'usesshproxy': False, 'sshproxyhost': 'proxyhost.mydomain', 'sshproxyport': 22, 'sshproxyuser': '', 'sshproxytunnel': 'localhost:44444:server.mydomain.private:22', 'sshproxykeyfile': '',
+    'usesshproxy': False, 'sshproxyhost': 'proxyhost.mydomain', 'sshproxyport': 22, 'sshproxyuser': '', 'sshproxykeyfile': '',
     'sshproxytype': 'SSH', 'sshproxysameuser': False, 'sshproxysamepass': False, 'sshproxyautologin': True,
+    'uniquehostkeyaliases': False,
     'useexports': True, 'restoreexports': False, 'fstunnel': True, 'export': '',
     'usemimebox': False, 'mimeboxextensions': '', 'mimeboxaction': 'OPEN',
     'fullscreen': False,
-    'width': 800,'height': 600, 'maxdim': False, 'dpi': 96, 'setdpi': False, 'xinerama': False, 'multidisp': False,
+    'width': 800,'height': 600, 'maxdim': False, 'dpi': 96, 'setdpi': False, 'xinerama': False, 'multidisp': False, 'display': 1,
     'usekbd': True, 'layout': 'us', 'type': 'pc105/us', 'variant': '',
     'sound': False, 'soundsystem': 'pulse', 'startsoundsystem': False, 'soundtunnel':True, 'defsndport':True, 'sndport':4713,
     'name': 'NEW_PROFILE', 'icon': ':icons/128x128/x2gosession.png',
@@ -311,7 +312,7 @@ X2GO_SESSIONPROFILE_DEFAULTS = {
     'print': False,
     'xdmcpserver': 'localhost',
 }
-&quot;&quot;&quot;L{X2goSessionProfiles} default values to fill a new session profile with.&quot;&quot;&quot;
+&quot;&quot;&quot;L{X2GoSessionProfiles} default values to fill a new session profile with.&quot;&quot;&quot;
 ##
 ## X2Go Proxy defaults
 ##
@@ -381,7 +382,7 @@ X2GO_DESKTOPSESSIONS={
     'TRINITY': 'starttrinity',
     'UNITY': 'unity',
 }
-&quot;&quot;&quot;A dictionary with meta-commands for X2go's window manager sessions.&quot;&quot;&quot;
+&quot;&quot;&quot;A dictionary with meta-commands for X2Go's window manager sessions.&quot;&quot;&quot;
 
 ##
 ## X2Go SFTP server defaults
@@ -397,11 +398,11 @@ application instance.
 &quot;&quot;&quot;
 
 X2GO_PRINT_ACTIONS = {
-    'PDFVIEW': 'X2goPrintActionPDFVIEW',
-    'PDFSAVE': 'X2goPrintActionPDFSAVE',
-    'PRINT': 'X2goPrintActionPRINT',
-    'PRINTCMD': 'X2goPrintActionPRINTCMD',
-    'DIALOG': 'X2goPrintActionDIALOG',
+    'PDFVIEW': 'X2GoPrintActionPDFVIEW',
+    'PDFSAVE': 'X2GoPrintActionPDFSAVE',
+    'PRINT': 'X2GoPrintActionPRINT',
+    'PRINTCMD': 'X2GoPrintActionPRINTCMD',
+    'DIALOG': 'X2GoPrintActionDIALOG',
 }
 &quot;&quot;&quot;Relating print action names and classes.&quot;&quot;&quot;
 
@@ -413,9 +414,9 @@ DEFAULT_PRINTCMD_CMD = 'lpr'
 &quot;&quot;&quot;Default command for the PRINTCMD print action.&quot;&quot;&quot;
 
 X2GO_MIMEBOX_ACTIONS = {
-    'OPEN': 'X2goMIMEboxActionOPEN',
-    'OPENWITH': 'X2goMIMEboxActionOPENWITH',
-    'SAVEAS': 'X2goMIMEboxActionSAVEAS',
+    'OPEN': 'X2GoMIMEboxActionOPEN',
+    'OPENWITH': 'X2GoMIMEboxActionOPENWITH',
+    'SAVEAS': 'X2GoMIMEboxActionSAVEAS',
 }
 &quot;&quot;&quot;Relating MIME box action names and classes.&quot;&quot;&quot;
 
diff --git a/x2go/forward.py b/x2go/forward.py
index f626efc..e9e776a 100644
--- a/x2go/forward.py
+++ b/x2go/forward.py
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -36,13 +36,13 @@ from gevent.server import StreamServer
 import log
 from defaults import X2GOCLIENT_OS as _X2GOCLIENT_OS
 
-class X2goFwServer(StreamServer):
+class X2GoFwServer(StreamServer):
     &quot;&quot;&quot;\
-    L{X2goFwServer} implements a gevent's StreamServer based Paramiko/SSH port
+    L{X2GoFwServer} implements a gevent's StreamServer based Paramiko/SSH port
     forwarding server.
 
-    An L{X2goFwServer} class object is used to tunnel graphical trafic
-    through an external proxy command launched by a C{X2goProxy*} backend.
+    An L{X2GoFwServer} class object is used to tunnel graphical trafic
+    through an external proxy command launched by a C{X2GoProxy*} backend.
 
     &quot;&quot;&quot;
     def __init__ (self, listener, remote_host, remote_port, ssh_transport, session_instance=None, session_name=None, logger=None, loglevel=log.loglevel_DEFAULT,):
@@ -55,21 +55,21 @@ class X2goFwServer(StreamServer):
         @type remote_port: C{int}
         @param ssh_transport: a valid Paramiko/SSH transport object
         @type ssh_transport: C{obj}
-        @param session_instance: the complete L{X2goSession} instance of the X2Go session this port forwarding server belongs to.
-            Note: for new L{X2goSession} instances the object has the session name not yet set(!!!)
+        @param session_instance: the complete L{X2GoSession} instance of the X2Go session this port forwarding server belongs to.
+            Note: for new L{X2GoSession} instances the object has the session name not yet set(!!!)
         @type session_instance: C{obj}
         @param session_name: the session name of the X2Go session this port forwarding server belongs to
         @type session_name: C{str}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goFwServer} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoFwServer} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -240,18 +240,18 @@ def start_forward_tunnel(local_host='127.0.0.1', local_port=22022,
     @type remote_port: C{int}
     @param ssh_transport: the Paramiko/SSH transport (i.e. the X2Go session's Paramiko/SSH transport object)
     @type ssh_transport: C{obj}
-    @param session_instance: the L{X2goSession} instance that initiates this tunnel
+    @param session_instance: the L{X2GoSession} instance that initiates this tunnel
     @type session_instance: C{obj}
     @param session_name: the session name of the X2Go session this port forwarding server belongs to
     @type session_name: C{str}
-    @param logger: an X2goLogger object
+    @param logger: an X2GoLogger object
     @type logger: C{obj}
 
-    @return: returns an L{X2goFwServer} instance
+    @return: returns an L{X2GoFwServer} instance
     @rtype: C{obj}
 
     &quot;&quot;&quot;
-    fw_server = X2goFwServer(listener=(local_host, local_port),
+    fw_server = X2GoFwServer(listener=(local_host, local_port),
                              remote_host=remote_host, remote_port=remote_port,
                              ssh_transport=ssh_transport,
                              session_instance=session_instance, session_name=session_name,
@@ -270,7 +270,7 @@ def stop_forward_tunnel(fw_server):
     &quot;&quot;&quot;\
     Tear down a given Paramiko/SSH port forwarding tunnel.
 
-    @param fw_server: an L{X2goFwServer} instance as returned by the L{start_forward_tunnel()} function
+    @param fw_server: an L{X2GoFwServer} instance as returned by the L{start_forward_tunnel()} function
     @type fw_server: C{obj}
 
     &quot;&quot;&quot;
diff --git a/x2go/gevent_subprocess.py b/x2go/gevent_subprocess.py
index 6bd6294..cdc3879 100644
--- a/x2go/gevent_subprocess.py
+++ b/x2go/gevent_subprocess.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
diff --git a/x2go/guardian.py b/x2go/guardian.py
index 5e035ff..7ccf0a5 100644
--- a/x2go/guardian.py
+++ b/x2go/guardian.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,7 +18,7 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goSessionGuardian class - a guardian thread that controls X2Go session threads
+X2GoSessionGuardian class - a guardian thread that controls X2Go session threads
 and their sub-threads (like reverse forwarding tunnels, Paramiko transport threads,
 etc.).
 
@@ -34,14 +34,14 @@ import copy
 from cleanup import x2go_cleanup
 import log
 
-class X2goSessionGuardian(threading.Thread):
+class X2GoSessionGuardian(threading.Thread):
     &quot;&quot;&quot;\
-    L{X2goSessionGuardian} thread controls X2Go session threads and their sub-threads (like 
+    L{X2GoSessionGuardian} thread controls X2Go session threads and their sub-threads (like 
     reverse forwarding tunnels, Paramiko transport threads, etc.). Its main function is
     to tidy up once a session gets interrupted (SIGTERM, SIGINT). 
 
-    There is one L{X2goSessionGuardian} for each L{X2goClient} instance (thus: for normal
-    setups there should be _one_ L{X2goClient} and _one_ L{X2goSessionGuardian} in use).
+    There is one L{X2GoSessionGuardian} for each L{X2GoClient} instance (thus: for normal
+    setups there should be _one_ L{X2GoClient} and _one_ L{X2GoSessionGuardian} in use).
 
     &quot;&quot;&quot;
     def __init__(self, client_instance, 
@@ -54,11 +54,11 @@ class X2goSessionGuardian(threading.Thread):
                  refresh_interval=5,
                  logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        @param auto_update_listsessions_cache: let L{X2goSessionGuardian} refresh the session list cache for all L{X2goSession} objects
+        @param auto_update_listsessions_cache: let L{X2GoSessionGuardian} refresh the session list cache for all L{X2GoSession} objects
         @type auto_update_listsessions_cache: C{bool}
-        @param auto_update_listdesktops_cache: let L{X2goSessionGuardian} refresh desktop lists in the session list cache for all L{X2goSession} objects
+        @param auto_update_listdesktops_cache: let L{X2GoSessionGuardian} refresh desktop lists in the session list cache for all L{X2GoSession} objects
         @type auto_update_listdesktops_cache: C{bool}
-        @param auto_update_listmounts_cache: let L{X2goSessionGuardian} refresh mount lists in the session list cache for all L{X2goSession} objects
+        @param auto_update_listmounts_cache: let L{X2GoSessionGuardian} refresh mount lists in the session list cache for all L{X2GoSession} objects
         @type auto_update_listmounts_cache: C{bool}
         @param auto_update_sessionregistry: if set to C{True} the session status will be updated in regular intervals
         @type auto_update_sessionregistry: C{bool}
@@ -69,15 +69,15 @@ class X2goSessionGuardian(threading.Thread):
         @type no_auto_reg_pubapp_sessions: C{bool}
         @param refresh_interval: refresh cache and session registry every &lt;refresh_interval&gt; seconds
         @type refresh_interval: C{int}
-        @param logger: you can pass an L{X2goLogger} object to the L{X2goSessionGuardian} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the L{X2GoSessionGuardian} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -97,7 +97,7 @@ class X2goSessionGuardian(threading.Thread):
 
     def guardian(self):
         &quot;&quot;&quot;\
-        The handler of this L{X2goSessionGuardian} thread.
+        The handler of this L{X2GoSessionGuardian} thread.
 
         &quot;&quot;&quot;
         seconds = 0
@@ -132,7 +132,7 @@ class X2goSessionGuardian(threading.Thread):
 
     def stop_thread(self):
         &quot;&quot;&quot;\
-        Stop this L{X2goSessionGuardian} thread.
+        Stop this L{X2GoSessionGuardian} thread.
 
         &quot;&quot;&quot;
         self._keepalive = False
diff --git a/x2go/inifiles.py b/x2go/inifiles.py
index 996cf83..7650d9e 100644
--- a/x2go/inifiles.py
+++ b/x2go/inifiles.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -24,7 +24,7 @@
 #       none so far
 
 &quot;&quot;&quot;\
-X2goProcessIniFile - helper class for parsing .ini files
+X2GoProcessIniFile - helper class for parsing .ini files
 
 &quot;&quot;&quot;
 __NAME__ = 'x2goinifiles-pylib'
@@ -41,14 +41,14 @@ from defaults import LOCAL_HOME as _current_home
 import log
 import utils
 
-class X2goIniFile(object):
+class X2GoIniFile(object):
     &quot;&quot;&quot;
-    Base class for processing the different ini files used by X2go
+    Base class for processing the different ini files used by X2Go
     clients. Primarily used to standardize the content of the different
     X2Go client ini file (settings, printing, sessions, xconfig).
 
     If entries are omitted in an ini file, they are filled with
-    default values (as hard coded in Python X2go), so the resulting objects 
+    default values (as hard coded in Python X2Go), so the resulting objects 
     always contain the same fields.
 
     &quot;&quot;&quot;
@@ -66,12 +66,12 @@ class X2goIniFile(object):
             directory filename)
         @type config_files: C{list}
         @param defaults: a cascaded Python dicitionary structure with ini file defaults (to override
-            Python X2go's hard coded defaults in L{defaults}
+            Python X2Go's hard coded defaults in L{defaults}
         @type defaults: C{dict}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goIniFile} constructor
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoIniFile} constructor
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
@@ -81,7 +81,7 @@ class X2goIniFile(object):
             config_files = []
 
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -131,7 +131,7 @@ class X2goIniFile(object):
         self._fill_defaults()
 
     def __repr__(self):
-        result = 'X2goIniFile('
+        result = 'X2GoIniFile('
         for p in dir(self):
             if '__' in p or not p in self.__dict__ or type(p) is types.InstanceType: continue
             result += p + '=' + str(self.__dict__[p]) + ','
@@ -204,12 +204,20 @@ class X2goIniFile(object):
         For writing the first of the C{config_files} specified on instance construction
         that is writable will be used.
 
+        @return: C{True} if the user config file has been successfully writte, C{False} otherwise.
+        @rtype: C{bool}
+
         &quot;&quot;&quot;
         if self.user_config_file and self.write_user_config:
-            fd = open(self.user_config_file, 'wb')
-            self.iniConfig.write(fd)
-            fd.close()
-            self.write_user_config = False
+            try:
+                fd = open(self.user_config_file, 'wb')
+                self.iniConfig.write(fd)
+                fd.close()
+                self.write_user_config = False
+                return True
+            except Exception, e:
+                print e
+        return False
 
     def get_type(self, section, key):
         &quot;&quot;&quot;\
diff --git a/x2go/log.py b/x2go/log.py
index 7454f8b..c1d538d 100644
--- a/x2go/log.py
+++ b/x2go/log.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,7 +18,7 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goLogger class - flexible handling of log and debug output.
+X2GoLogger class - flexible handling of log and debug output.
 
 &quot;&quot;&quot;
 __NAME__ = 'x2gologger-pylib'
@@ -38,13 +38,13 @@ loglevel_DEBUG_SFTPXFER = 1024
 
 loglevel_DEFAULT = loglevel_ERROR | loglevel_WARN | loglevel_NOTICE
 &quot;&quot;&quot;\
-Default loglevel of X2goLogger objects is: NOTICE &amp; WARN &amp; ERROR
+Default loglevel of X2GoLogger objects is: NOTICE &amp; WARN &amp; ERROR
 &quot;&quot;&quot;
 
 # Python X2Go modules
 import utils
 
-class X2goLogger(object):
+class X2GoLogger(object):
     &quot;&quot;&quot;\
     A simple logger class, that is used by all Python X2Go classes.
 
@@ -65,9 +65,9 @@ class X2goLogger(object):
 
     def __init__(self, name=sys.argv[0], loglevel=loglevel_DEFAULT, tag=None):
         &quot;&quot;&quot;\
-        @param name: name of the programme that uses Python X2go
+        @param name: name of the programme that uses Python X2Go
         @type name: C{str}
-        @param loglevel: log level for Python X2go
+        @param loglevel: log level for Python X2Go
         @type loglevel: C{int}
         @param tag: additional tag for all log entries
         @type tag: C{str}
@@ -184,3 +184,7 @@ class X2goLogger(object):
 
         &quot;&quot;&quot;
         self.loglevel = self.loglevel ^ loglevel_DEBUG_SFTPXFER
+
+# compat section
+X2goLogger = X2GoLogger
+
diff --git a/x2go/mimebox.py b/x2go/mimebox.py
index c424047..dcf6d32 100644
--- a/x2go/mimebox.py
+++ b/x2go/mimebox.py
@@ -1,7 +1,7 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -19,11 +19,11 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-L{X2goMIMEboxQueue} sets up a thread that listens for incoming files that
+L{X2GoMIMEboxQueue} sets up a thread that listens for incoming files that
 shall be opened locally on the client.
 
 For each file that gets dropped in the MIME box an individual 
-thread is started (L{X2goMIMEboxJob}) that handles the processing 
+thread is started (L{X2GoMIMEboxJob}) that handles the processing 
 of the incoming file.
 
 &quot;&quot;&quot;
@@ -43,12 +43,12 @@ import log
 import mimeboxactions
 
 
-class X2goMIMEboxQueue(threading.Thread):
+class X2GoMIMEboxQueue(threading.Thread):
     &quot;&quot;&quot;\
-    If the X2Go MIME box is supported in a particaluar L{X2goSession} instance
+    If the X2Go MIME box is supported in a particaluar L{X2GoSession} instance
     this class provides a sub-thread for handling incoming files in the MIME box
     directory. The actual handling of a dropped file is handled by the classes
-    L{X2goMIMEboxActionOPEN}, L{X2goMIMEboxActionOPENWITH} and L{X2goMIMEboxActionSAVEAS}.
+    L{X2GoMIMEboxActionOPEN}, L{X2GoMIMEboxActionOPENWITH} and L{X2GoMIMEboxActionSAVEAS}.
 
     &quot;&quot;&quot;
     mimebox_action = None
@@ -67,18 +67,18 @@ class X2goMIMEboxQueue(threading.Thread):
         @type mimebox_dir: C{str}
         @param mimebox_action: name or instance of either of the possible X2Go print action classes
         @type mimebox_action: C{str} or instance
-        @param client_instance: the underlying L{X2goClient} instance
+        @param client_instance: the underlying L{X2GoClient} instance
         @type client_instance: C{obj}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goPrintQueue} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoPrintQueue} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -95,7 +95,7 @@ class X2goMIMEboxQueue(threading.Thread):
         self._accept_jobs = False
 
         if mimebox_action is None:
-            mimebox_action = mimeboxactions.X2goMIMEboxActionOPEN(client_instance=self.client_instance, logger=self.logger)
+            mimebox_action = mimeboxactions.X2GoMIMEboxActionOPEN(client_instance=self.client_instance, logger=self.logger)
         elif type(mimebox_action) in (types.StringType, types.UnicodeType):
             mimebox_action = self.set_mimebox_action(mimebox_action, client_instance=self.client_instance, logger=self.logger)
         else:
@@ -136,7 +136,7 @@ class X2goMIMEboxQueue(threading.Thread):
 
     def stop_thread(self):
         &quot;&quot;&quot;\
-        Stops this L{X2goMIMEboxQueue} thread completely.
+        Stops this L{X2GoMIMEboxQueue} thread completely.
 
         &quot;&quot;&quot;
         self.pause()
@@ -158,7 +158,7 @@ class X2goMIMEboxQueue(threading.Thread):
 
     def set_mimebox_action(self, mimebox_action, **kwargs):
         &quot;&quot;&quot;\
-        Modify the MIME box action of this L{X2goMIMEboxQueue} thread during runtime. The 
+        Modify the MIME box action of this L{X2GoMIMEboxQueue} thread during runtime. The 
         change of the MIME box action will be valid for the next incoming file in the MIME box
         directory.
 
@@ -176,7 +176,7 @@ class X2goMIMEboxQueue(threading.Thread):
 
     def run(self):
         &quot;&quot;&quot;\
-        This method gets called once the L{X2goMIMEboxQueue} thread is started by the C{X2goMIMEboxQueue.start()} method.
+        This method gets called once the L{X2GoMIMEboxQueue} thread is started by the C{X2GoMIMEboxQueue.start()} method.
 
         &quot;&quot;&quot;
         self.logger('starting MIME box queue thread: %s' % repr(self), loglevel=log.loglevel_DEBUG)
@@ -190,7 +190,7 @@ class X2goMIMEboxQueue(threading.Thread):
 
                     for _job in self._incoming_mimebox_jobs:
                         self.logger('processing incoming X2Go MIME box job: %s' % _job, loglevel=log.loglevel_NOTICE)
-                        _new_mimeboxjob_thread = X2goMIMEboxJob(target=x2go_mimeboxjob_handler,
+                        _new_mimeboxjob_thread = X2GoMIMEboxJob(target=x2go_mimeboxjob_handler,
                                                                 kwargs={ 
                                                                   'mimebox_file': _job,
                                                                   'mimebox_extensions': self.mimebox_extensions,
@@ -213,15 +213,15 @@ def x2go_mimeboxjob_handler(mimebox_file=None,
                             parent_thread=None, logger=None, ):
     &quot;&quot;&quot;\
     This function is called as a handler function for each incoming X2Go MIME box file
-    represented by the class L{X2goMIMEboxJob}.
+    represented by the class L{X2GoMIMEboxJob}.
 
     @param mimebox_file: MIME box file name as placed in to the X2Go MIME box spool directory
     @type mimebox_file: C{str}
-    @param mimebox_action: an instance of either of the possible C{X2goMIMEboxActionXXX} classes
-    @type mimebox_action: C{X2goMIMEboxActionXXX} nstance
-    @param parent_thread: the L{X2goMIMEboxQueue} thread that actually created this handler's L{X2goMIMEboxJob} instance
+    @param mimebox_action: an instance of either of the possible C{X2GoMIMEboxActionXXX} classes
+    @type mimebox_action: C{X2GoMIMEboxActionXXX} nstance
+    @param parent_thread: the L{X2GoMIMEboxQueue} thread that actually created this handler's L{X2GoMIMEboxJob} instance
     @type parent_thread: C{obj}
-    @param logger: the L{X2goMIMEboxQueue}'s logging instance
+    @param logger: the L{X2GoMIMEboxQueue}'s logging instance
     @type logger: C{obj}
 
     &quot;&quot;&quot;
@@ -242,7 +242,7 @@ def x2go_mimeboxjob_handler(mimebox_file=None,
     elif _dotfile:
         logger('placing files starting with a dot (.&lt;file&gt;) into the X2Go MIME box is prohibited, ignoring the file ,,%s\'\'' % mimebox_file, loglevel=log.loglevel_WARN)
     else:
-        logger('file extension of MIME box file %s has been found in Python X2go\' hardcoded MIME box extenstions blacklist' % mimebox_file, loglevel=log.loglevel_WARN)
+        logger('file extension of MIME box file %s has been found in Python X2Go\' hardcoded MIME box extenstions blacklist' % mimebox_file, loglevel=log.loglevel_WARN)
 
     logger('removing MIME box file %s' % mimebox_file, loglevel=log.loglevel_DEBUG)
 
@@ -257,7 +257,7 @@ def x2go_mimeboxjob_handler(mimebox_file=None,
         parent_thread.mimebox_history = parent_thread.mimebox_history[-100:]
 
 
-class X2goMIMEboxJob(threading.Thread):
+class X2GoMIMEboxJob(threading.Thread):
     &quot;&quot;&quot;\
     For each X2Go MIME box job we create a sub-thread that let's 
     the MIME box job be processed in the background.
diff --git a/x2go/mimeboxactions.py b/x2go/mimeboxactions.py
index a2749f4..10ca5e0 100644
--- a/x2go/mimeboxactions.py
+++ b/x2go/mimeboxactions.py
@@ -1,7 +1,7 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -20,7 +20,7 @@
 
 &quot;&quot;&quot;\
 For MIME box jobs there are currently three handling actions available:
-L{X2goMIMEboxActionOPEN}, L{X2goMIMEboxActionOPENWITH} and L{X2goMIMEboxActionSAVEAS}.
+L{X2GoMIMEboxActionOPEN}, L{X2GoMIMEboxActionOPENWITH} and L{X2GoMIMEboxActionSAVEAS}.
 
 &quot;&quot;&quot;
 __NAME__ = 'x2gomimeboxactions-pylib'
@@ -46,7 +46,7 @@ import x2go_exceptions
 _MIMEBOX_ENV = os.environ.copy()
 
 
-class X2goMIMEboxAction(object):
+class X2GoMIMEboxAction(object):
 
     __name__ = 'NAME'
     __description__ = 'DESCRIPTION'
@@ -56,23 +56,23 @@ class X2goMIMEboxAction(object):
         This is a meta class and has no functionality as such. It is used as parent
         class by &#187;real&#171; X2Go MIME box actions.
 
-        @param client_instance: the underlying L{X2goClient} instance
+        @param client_instance: the underlying L{X2GoClient} instance
         @type client_instance: C{obj}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goMIMEboxAction} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoMIMEboxAction} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
 
-        # these get set from within the X2goMIMEboxQueue class
+        # these get set from within the X2GoMIMEboxQueue class
         self.profile_name = 'UNKNOWN'
         self.session_name = 'UNKNOWN'
 
@@ -96,7 +96,7 @@ class X2goMIMEboxAction(object):
 
     def _do_process(self, mimebox_file, mimebox_dir, ):
         &quot;&quot;&quot;\
-        Perform the defined MIME box action (doing nothing in L{X2goMIMEboxAction} parent class).
+        Perform the defined MIME box action (doing nothing in L{X2GoMIMEboxAction} parent class).
 
         @param mimebox_file: file name as placed in to the X2Go MIME box directory
         @type mimebox_file: C{str}
@@ -123,7 +123,7 @@ class X2goMIMEboxAction(object):
         self._do_process(mimebox_file, mimebox_dir)
 
 
-class X2goMIMEboxActionOPEN(X2goMIMEboxAction):
+class X2GoMIMEboxActionOPEN(X2GoMIMEboxAction):
     &quot;&quot;&quot;\
     MIME box action that opens incoming files in the system's default application.
 
@@ -133,18 +133,18 @@ class X2goMIMEboxActionOPEN(X2goMIMEboxAction):
 
     def __init__(self, client_instance=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        @param client_instance: the underlying L{X2goClient} instance
+        @param client_instance: the underlying L{X2GoClient} instance
         @type client_instance: C{obj}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goMIMEboxActionOPEN} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoMIMEboxActionOPEN} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         self.client_instance = client_instance
-        X2goMIMEboxAction.__init__(self, logger=logger, loglevel=loglevel)
+        X2GoMIMEboxAction.__init__(self, logger=logger, loglevel=loglevel)
 
     def _do_process(self, mimebox_file, mimebox_dir, ):
         &quot;&quot;&quot;\
@@ -180,7 +180,7 @@ class X2goMIMEboxActionOPEN(X2goMIMEboxAction):
             time.sleep(20)
 
 
-class X2goMIMEboxActionOPENWITH(X2goMIMEboxAction):
+class X2GoMIMEboxActionOPENWITH(X2GoMIMEboxAction):
     &quot;&quot;&quot;\
     MIME box action that calls the system's ,,Open with...'' dialog on incoming files. Currently only
     properly implementable on Windows platforms.
@@ -191,18 +191,18 @@ class X2goMIMEboxActionOPENWITH(X2goMIMEboxAction):
 
     def __init__(self, client_instance=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        @param client_instance: the underlying L{X2goClient} instance
+        @param client_instance: the underlying L{X2GoClient} instance
         @type client_instance: C{obj}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goMIMEboxActionOPENWITH} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoMIMEboxActionOPENWITH} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         self.client_instance = client_instance
-        X2goMIMEboxAction.__init__(self, logger=logger, loglevel=loglevel)
+        X2GoMIMEboxAction.__init__(self, logger=logger, loglevel=loglevel)
 
     def _do_process(self, mimebox_file, mimebox_dir, ):
         &quot;&quot;&quot;\
@@ -236,10 +236,10 @@ class X2goMIMEboxActionOPENWITH(X2goMIMEboxAction):
             time.sleep(20)
 
 
-class X2goMIMEboxActionSAVEAS(X2goMIMEboxAction):
+class X2GoMIMEboxActionSAVEAS(X2GoMIMEboxAction):
     &quot;&quot;&quot;\
     MIME box action that allows saving incoming MIME box files to a local folder. What this 
-    MIME box actually does is calling a hook method in the L{X2goClient} instance that
+    MIME box actually does is calling a hook method in the L{X2GoClient} instance that
     can be hi-jacked by one of your application's methods which then can handle the ,,Save as...''
     request.
 
@@ -249,27 +249,27 @@ class X2goMIMEboxActionSAVEAS(X2goMIMEboxAction):
 
     def __init__(self, client_instance=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        @param client_instance: an L{X2goClient} instance, within your customized L{X2goClient} make sure 
+        @param client_instance: an L{X2GoClient} instance, within your customized L{X2GoClient} make sure 
             you have a C{HOOK_open_mimebox_saveas_dialog(filename=&lt;str&gt;)} method defined that will actually
             handle the incoming mimebox file.
         @type client_instance: C{obj}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goMIMEboxActionSAVEAS} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoMIMEboxActionSAVEAS} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
-        @raise X2goMIMEboxActionException: if the client_instance has not been passed to the SAVEAS MIME box action
+        @raise X2GoMIMEboxActionException: if the client_instance has not been passed to the SAVEAS MIME box action
 
         &quot;&quot;&quot;
         if client_instance is None:
-            raise x2go_exceptions.X2goMIMEboxActionException('the SAVEAS MIME box action needs to know the X2goClient instance (client=&lt;instance&gt;)')
-        X2goMIMEboxAction.__init__(self, client_instance=client_instance, logger=logger, loglevel=loglevel)
+            raise x2go_exceptions.X2GoMIMEboxActionException('the SAVEAS MIME box action needs to know the X2GoClient instance (client=&lt;instance&gt;)')
+        X2GoMIMEboxAction.__init__(self, client_instance=client_instance, logger=logger, loglevel=loglevel)
 
     def _do_process(self, mimebox_file, mimebox_dir):
         &quot;&quot;&quot;\
-        Call an L{X2goClient} hook method (C{HOOK_open_mimebox_saveas_dialog}) that
+        Call an L{X2GoClient} hook method (C{HOOK_open_mimebox_saveas_dialog}) that
         can handle the MIME box's SAVEAS action.
 
         @param mimebox_file: file name as placed in to the MIME box directory
@@ -282,7 +282,7 @@ class X2goMIMEboxActionSAVEAS(X2goMIMEboxAction):
         mimebox_file = os.path.normpath(mimebox_file)
         mimebox_dir = os.path.normpath(mimebox_dir)
 
-        self.logger('Session %s (%s) is calling X2goClient class hook method &lt;client_instance&gt;.HOOK_open_mimebox_saveas_dialog(%s)' % (self.session_name, self.profile_name, mimebox_file), loglevel=log.loglevel_NOTICE)
+        self.logger('Session %s (%s) is calling X2GoClient class hook method &lt;client_instance&gt;.HOOK_open_mimebox_saveas_dialog(%s)' % (self.session_name, self.profile_name, mimebox_file), loglevel=log.loglevel_NOTICE)
         self.client_instance.HOOK_open_mimebox_saveas_dialog(os.path.join(mimebox_dir, mimebox_file), profile_name=self.profile_name, session_name=self.session_name)
         time.sleep(60)
 
diff --git a/x2go/printactions.py b/x2go/printactions.py
index 1def760..23a8f83 100644
--- a/x2go/printactions.py
+++ b/x2go/printactions.py
@@ -1,7 +1,7 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -22,8 +22,8 @@
 Print jobs can either be sent to any of the local print queues (CUPS, Win32API),
 be opened in an external PDF viewer, be saved to a local folder or be handed 
 over to a custom (print) command. This is defined by four print action classes
-(L{X2goPrintActionDIALOG}, L{X2goPrintActionPDFVIEW}, L{X2goPrintActionPDFSAVE}, L{X2goPrintActionPRINT} and 
-L{X2goPrintActionPRINTCMD}).
+(L{X2GoPrintActionDIALOG}, L{X2GoPrintActionPDFVIEW}, L{X2GoPrintActionPDFSAVE}, L{X2GoPrintActionPRINT} and 
+L{X2GoPrintActionPRINTCMD}).
 
 &quot;&quot;&quot;
 __NAME__ = 'x2goprintactions-pylib'
@@ -55,7 +55,7 @@ import x2go_exceptions
 _PRINT_ENV = os.environ.copy()
 
 
-class X2goPrintAction(object):
+class X2GoPrintAction(object):
 
     __name__ = 'NAME'
     __description__ = 'DESCRIPTION'
@@ -65,23 +65,23 @@ class X2goPrintAction(object):
         This is a meta class and has no functionality as such. It is used as parent 
         class by &#187;real&#171; X2Go print actions.
 
-        @param client_instance: the underlying L{X2goClient} instance
+        @param client_instance: the underlying L{X2GoClient} instance
         @type client_instance: C{obj}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goPrintAction} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoPrintAction} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
 
-        # these get set from within the X2goPrintQueue class
+        # these get set from within the X2GoPrintQueue class
         self.profile_name = 'UNKNOWN'
         self.session_name = 'UNKNOWN'
 
@@ -105,7 +105,7 @@ class X2goPrintAction(object):
 
     def _do_print(self, pdf_file, job_title, spool_dir, ):
         &quot;&quot;&quot;
-        Perform the defined print action (doing nothing in L{X2goPrintAction} parent class).
+        Perform the defined print action (doing nothing in L{X2GoPrintAction} parent class).
 
         @param pdf_file: PDF file name as placed in to the X2Go spool directory
         @type pdf_file: C{str}
@@ -159,7 +159,7 @@ class X2goPrintAction(object):
         return _hr_path
 
 
-class X2goPrintActionPDFVIEW(X2goPrintAction):
+class X2GoPrintActionPDFVIEW(X2GoPrintAction):
     &quot;&quot;&quot;\
     Print action that views incoming print job in an external PDF viewer application.
 
@@ -171,14 +171,14 @@ class X2goPrintActionPDFVIEW(X2goPrintAction):
 
     def __init__(self, client_instance=None, pdfview_cmd=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        @param client_instance: the underlying L{X2goClient} instance
+        @param client_instance: the underlying L{X2GoClient} instance
         @type client_instance: C{obj}
         @param pdfview_cmd: command that starts the external PDF viewer application
         @type pdfview_cmd: C{str}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goPrintActionPDFVIEW} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoPrintActionPDFVIEW} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
@@ -186,7 +186,7 @@ class X2goPrintActionPDFVIEW(X2goPrintAction):
         if pdfview_cmd is None:
             pdfview_cmd = defaults.DEFAULT_PDFVIEW_CMD
         self.pdfview_cmd = pdfview_cmd
-        X2goPrintAction.__init__(self, client_instance=client_instance, logger=logger, loglevel=loglevel)
+        X2GoPrintAction.__init__(self, client_instance=client_instance, logger=logger, loglevel=loglevel)
 
     def _do_print(self, pdf_file, job_title, spool_dir, ):
         &quot;&quot;&quot;\
@@ -237,7 +237,7 @@ class X2goPrintActionPDFVIEW(X2goPrintAction):
             os.remove(_hr_filename)
 
 
-class X2goPrintActionPDFSAVE(X2goPrintAction):
+class X2GoPrintActionPDFSAVE(X2GoPrintAction):
     &quot;&quot;&quot;\
     Print action that saves incoming print jobs to a local folder.
 
@@ -249,14 +249,14 @@ class X2goPrintActionPDFSAVE(X2goPrintAction):
 
     def __init__(self, client_instance=None, save_to_folder=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        @param client_instance: the underlying L{X2goClient} instance
+        @param client_instance: the underlying L{X2GoClient} instance
         @type client_instance: C{obj}
         @param save_to_folder: saving location for incoming print jobs (PDF files)
         @type save_to_folder: C{str}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goPrintActionPDFSAVE} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoPrintActionPDFSAVE} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
@@ -269,7 +269,7 @@ class X2goPrintActionPDFSAVE(X2goPrintAction):
             save_to_folder = os.path.expanduser(save_to_folder)
         self.save_to_folder = save_to_folder
 
-        X2goPrintAction.__init__(self, client_instance=client_instance, logger=None, loglevel=loglevel)
+        X2GoPrintAction.__init__(self, client_instance=client_instance, logger=None, loglevel=loglevel)
 
         self.logger('Save location for incoming PDFs is: %s' % self.save_to_folder, loglevel=log.loglevel_DEBUG)
         if not os.path.exists(self.save_to_folder):
@@ -294,7 +294,7 @@ class X2goPrintActionPDFSAVE(X2goPrintAction):
         shutil.copy2(pdf_file, dest_file)
 
 
-class X2goPrintActionPRINT(X2goPrintAction):
+class X2GoPrintActionPRINT(X2GoPrintAction):
     &quot;&quot;&quot;\
     Print action that actually prints an incoming print job file.
 
@@ -304,20 +304,20 @@ class X2goPrintActionPRINT(X2goPrintAction):
 
     def __init__(self, client_instance=None, printer=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        @param client_instance: the underlying L{X2goClient} instance
+        @param client_instance: the underlying L{X2GoClient} instance
         @type client_instance: C{obj}
         @param printer: name of the preferred printer, if C{None} the system's/user's default printer will be used
         @type printer: C{str}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goPrintActionPRINT} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoPrintActionPRINT} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         self.printer = printer
-        X2goPrintAction.__init__(self, client_instance=client_instance, logger=logger, loglevel=loglevel)
+        X2GoPrintAction.__init__(self, client_instance=client_instance, logger=logger, loglevel=loglevel)
 
     def _do_print(self, pdf_file, job_title, spool_dir, ):
         &quot;&quot;&quot;\
@@ -420,12 +420,12 @@ class X2goPrintActionPRINT(X2goPrintAction):
             except OSError: pass
 
 
-class X2goPrintActionPRINTCMD(X2goPrintAction):
+class X2GoPrintActionPRINTCMD(X2GoPrintAction):
     &quot;&quot;&quot;\
     Print action that calls an external command for further processing of incoming print jobs.
 
     The print job's PDF filename will be prepended as last argument to the print command
-    used in L{X2goPrintActionPRINTCMD} instances.
+    used in L{X2GoPrintActionPRINTCMD} instances.
 
     &quot;&quot;&quot;
     __name__      = 'PRINTCMD'
@@ -433,14 +433,14 @@ class X2goPrintActionPRINTCMD(X2goPrintAction):
 
     def __init__(self, client_instance=None, print_cmd=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        @param client_instance: the underlying L{X2goClient} instance
+        @param client_instance: the underlying L{X2GoClient} instance
         @type client_instance: C{obj}
         @param print_cmd: external command to be called on incoming print jobs
         @type print_cmd: C{str}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goPrintActionPRINTCMD} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoPrintActionPRINTCMD} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
@@ -448,12 +448,12 @@ class X2goPrintActionPRINTCMD(X2goPrintAction):
         if print_cmd is None:
             print_cmd = defaults.DEFAULT_PRINTCMD_CMD
         self.print_cmd = print_cmd
-        X2goPrintAction.__init__(self, client_instance=client_instance, logger=logger, loglevel=loglevel)
+        X2GoPrintAction.__init__(self, client_instance=client_instance, logger=logger, loglevel=loglevel)
 
     def _do_print(self, pdf_file, job_title, spool_dir):
         &quot;&quot;&quot;\
         Execute an external command that has been defined on construction 
-        of this L{X2goPrintActionPRINTCMD} instance.
+        of this L{X2GoPrintActionPRINTCMD} instance.
 
         @param pdf_file: PDF file name as placed in to the X2Go spool directory
         @type pdf_file: C{str}
@@ -481,11 +481,11 @@ class X2goPrintActionPRINTCMD(X2goPrintAction):
         except OSError: pass
 
 
-class X2goPrintActionDIALOG(X2goPrintAction):
+class X2GoPrintActionDIALOG(X2GoPrintAction):
     &quot;&quot;&quot;\
     Print action that mediates opening a print dialog window. This class is rather empty,
     the actual print dialog box must be implemented in our GUI application (with the application's
-    L{X2goClient} instance.
+    L{X2GoClient} instance.
 
     &quot;&quot;&quot;
     __name__      = 'DIALOG'
@@ -493,28 +493,28 @@ class X2goPrintActionDIALOG(X2goPrintAction):
 
     def __init__(self, client_instance=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        @param client_instance: an L{X2goClient} instance, within your customized L{X2goClient} make sure 
+        @param client_instance: an L{X2GoClient} instance, within your customized L{X2GoClient} make sure 
             you have a C{HOOK_open_print_dialog(filename=&lt;str&gt;)} method defined that will actually
             open the print dialog.
         @type client_instance: C{obj}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goPrintActionDIALOG} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoPrintActionDIALOG} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
-        @raise X2goPrintActionException: if the client_instance has not been passed to the DIALOG print action
+        @raise X2GoPrintActionException: if the client_instance has not been passed to the DIALOG print action
 
         &quot;&quot;&quot;
         if client_instance is None:
-            raise x2go_exceptions.X2goPrintActionException('the DIALOG print action needs to know the X2goClient instance (client=&lt;instance&gt;)')
-        X2goPrintAction.__init__(self, client_instance=client_instance, logger=logger, loglevel=loglevel)
+            raise x2go_exceptions.X2GoPrintActionException('the DIALOG print action needs to know the X2GoClient instance (client=&lt;instance&gt;)')
+        X2GoPrintAction.__init__(self, client_instance=client_instance, logger=logger, loglevel=loglevel)
 
     def _do_print(self, pdf_file, job_title, spool_dir):
         &quot;&quot;&quot;\
         Execute an external command that has been defined on construction 
-        of this L{X2goPrintActionPRINTCMD} instance.
+        of this L{X2GoPrintActionPRINTCMD} instance.
 
         @param pdf_file: PDF file name as placed in to the X2Go spool directory
         @type pdf_file: C{str}
@@ -527,8 +527,8 @@ class X2goPrintActionDIALOG(X2goPrintAction):
         pdf_file = os.path.normpath(pdf_file)
         spool_dir = os.path.normpath(spool_dir)
 
-        self.logger('Session %s (%s) is calling X2goClient class hook method &lt;client_instance&gt;.HOOK_open_print_dialog' % (self.session_name, self.profile_name), loglevel=log.loglevel_NOTICE)
+        self.logger('Session %s (%s) is calling X2GoClient class hook method &lt;client_instance&gt;.HOOK_open_print_dialog' % (self.session_name, self.profile_name), loglevel=log.loglevel_NOTICE)
         _new_print_action = self.client_instance.HOOK_open_print_dialog(profile_name=self.profile_name, session_name=self.session_name)
-        if type(_new_print_action) != type(self):
+        if _new_print_action and type(_new_print_action) != type(self):
             _new_print_action._do_print(pdf_file, job_title, spool_dir)
 
diff --git a/x2go/printqueue.py b/x2go/printqueue.py
index cbf7403..9e76ca5 100644
--- a/x2go/printqueue.py
+++ b/x2go/printqueue.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,10 +18,10 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-L{X2goPrintQueue} sets up a thread that listens for incoming print jobs.
+L{X2GoPrintQueue} sets up a thread that listens for incoming print jobs.
 
 For each incoming print job in an X2Go session's spool directory an 
-individual thread is started (L{X2goPrintJob}) that handles the processing 
+individual thread is started (L{X2GoPrintJob}) that handles the processing 
 of the incoming print job.
 
 &quot;&quot;&quot;
@@ -39,14 +39,14 @@ import utils
 import log
 
 # we hide the default values from epydoc (that's why we transform them to _UNDERSCORE variables)
-from backends.printing import X2goClientPrinting as _X2goClientPrinting
+from backends.printing import X2GoClientPrinting as _X2GoClientPrinting
 
 from defaults import X2GO_PRINTING_FILENAME as _X2GO_PRINTING_FILENAME
 
 
-class X2goPrintQueue(threading.Thread):
+class X2GoPrintQueue(threading.Thread):
     &quot;&quot;&quot;\
-    If X2Go printing is supported in a particular L{X2goSession} instance
+    If X2Go printing is supported in a particular L{X2GoSession} instance
     this class provides a sub-thread for handling incoming X2Go print jobs.
 
     &quot;&quot;&quot;
@@ -63,7 +63,7 @@ class X2goPrintQueue(threading.Thread):
                  print_action=None,
                  print_action_args={},
                  client_instance=None,
-                 printing_backend=_X2goClientPrinting,
+                 printing_backend=_X2GoClientPrinting,
                  logger=None,
                  loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
@@ -75,21 +75,21 @@ class X2goPrintQueue(threading.Thread):
         @type print_action: C{str} or instance
         @param print_action_args: depending of the chosen C{print_action} this dictionary may contain different
             values; the C{print_action_args} will be passed on to the X2Go print action instance constructor, so 
-            refer to either of these: L{X2goPrintActionPDFVIEW}, L{X2goPrintActionPRINT} et al.
-        @param client_instance: the underlying L{X2goClient} instance
+            refer to either of these: L{X2GoPrintActionPDFVIEW}, L{X2GoPrintActionPRINT} et al.
+        @param client_instance: the underlying L{X2GoClient} instance
         @type client_instance: C{obj}
         @param printing_backend: the client printing configuration backend class
         @type printing_backend: C{obj}
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goPrintQueue} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoPrintQueue} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -136,7 +136,7 @@ class X2goPrintQueue(threading.Thread):
 
     def stop_thread(self):
         &quot;&quot;&quot;\
-        Stops this L{X2goPrintQueue} thread completely.
+        Stops this L{X2GoPrintQueue} thread completely.
 
         &quot;&quot;&quot;
         self.pause()
@@ -166,12 +166,12 @@ class X2goPrintQueue(threading.Thread):
 
     def set_print_action(self, print_action, **kwargs):
         &quot;&quot;&quot;\
-        Modify the print action of this L{X2goPrintQueue} thread during runtime. The 
+        Modify the print action of this L{X2GoPrintQueue} thread during runtime. The 
         change of print action will be valid for the next incoming print job.
 
         As kwargs you can pass arguments for the print action class to be set. Refer
-        to the class descriptions of L{X2goPrintActionDIALOG}, L{X2goPrintActionPDFVIEW},
-        L{X2goPrintActionPRINT}, etc.
+        to the class descriptions of L{X2GoPrintActionDIALOG}, L{X2GoPrintActionPDFVIEW},
+        L{X2GoPrintActionPRINT}, etc.
 
         @param print_action: new print action to be valid for incoming print jobs
         @type print_action: C{str} or C{class}
@@ -187,7 +187,7 @@ class X2goPrintQueue(threading.Thread):
 
     def run(self):
         &quot;&quot;&quot;\
-        Start this L{X2goPrintQueue} thread...
+        Start this L{X2GoPrintQueue} thread...
 
         &quot;&quot;&quot;
         self.logger('starting print queue thread: %s' % repr(self), loglevel=log.loglevel_DEBUG)
@@ -201,7 +201,7 @@ class X2goPrintQueue(threading.Thread):
 
                     for _job in self._incoming_print_jobs:
                         self.logger('processing incoming X2Go print job: %s' % _job[1], loglevel=log.loglevel_NOTICE)
-                        _new_printjob_thread = X2goPrintJob(target=x2go_printjob_handler,
+                        _new_printjob_thread = X2GoPrintJob(target=x2go_printjob_handler,
                                                             kwargs={ 
                                                             'job_file': _job[0],
                                                             'pdf_file': _job[1],
@@ -222,7 +222,7 @@ class X2goPrintQueue(threading.Thread):
 def x2go_printjob_handler(job_file=None, pdf_file=None, job_title=None, print_action=None, parent_thread=None, logger=None, ):
     &quot;&quot;&quot;\
     This function is called as a handler function for each incoming X2Go print job 
-    represented by the class L{X2goPrintJob}.
+    represented by the class L{X2GoPrintJob}.
 
     The handler function will (re-)read the &#187;printing&#171; configuration file (if no
     explicit C{print_action} is passed to this function...). It then will
@@ -232,11 +232,11 @@ def x2go_printjob_handler(job_file=None, pdf_file=None, job_title=None, print_ac
     @type pdf_file: C{str}
     @param job_title: human readable print job title
     @type job_title: C{str}
-    @param print_action: an instance of either of the possible C{X2goPrintActionXXX} classes
-    @type print_action: C{X2goPrintActionXXX} nstance
-    @param parent_thread: the L{X2goPrintQueue} thread that actually created this handler's L{X2goPrintJob} instance
+    @param print_action: an instance of either of the possible C{X2GoPrintActionXXX} classes
+    @type print_action: C{X2GoPrintActionXXX} nstance
+    @param parent_thread: the L{X2GoPrintQueue} thread that actually created this handler's L{X2GoPrintJob} instance
     @type parent_thread: C{obj}
-    @param logger: the L{X2goPrintQueue}'s logging instance
+    @param logger: the L{X2GoPrintQueue}'s logging instance
     @type logger: C{obj}
 
     &quot;&quot;&quot;
@@ -277,7 +277,7 @@ def x2go_printjob_handler(job_file=None, pdf_file=None, job_title=None, print_ac
         parent_thread.job_history = parent_thread.job_history[-100:]
 
 
-class X2goPrintJob(threading.Thread):
+class X2GoPrintJob(threading.Thread):
     &quot;&quot;&quot;\
     For each X2Go print job we create a sub-thread that let's 
     the print job be processed in the background.
diff --git a/x2go/pulseaudio.py b/x2go/pulseaudio.py
index 08b599e..ea8f49d 100644
--- a/x2go/pulseaudio.py
+++ b/x2go/pulseaudio.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -21,7 +21,7 @@
 #       none so far
 
 &quot;&quot;&quot;\
-X2goPulseAudio class - a Pulseaudio daemon guardian thread.
+X2GoPulseAudio class - a Pulseaudio daemon guardian thread.
 
 &quot;&quot;&quot;
 
@@ -49,7 +49,7 @@ import exceptions
 class OSNotSupportedException(exceptions.StandardError): pass
 &quot;&quot;&quot; Exception denoting that this operating system is not supported. &quot;&quot;&quot;
 
-class X2goPulseAudio(threading.Thread):
+class X2GoPulseAudio(threading.Thread):
     &quot;&quot;&quot;
     This class controls the Pulse Audio daemon.
     &quot;&quot;&quot;
@@ -60,11 +60,11 @@ class X2goPulseAudio(threading.Thread):
 
         @param path: full path to pulseaudio.exe
         @type path: C{str}
-        @param client_instance: the calling L{X2goClient} instance
-        @type client_instance: L{X2goClient} instance
-        @param logger: you can pass an L{X2goLogger} object to the L{X2goClientXConfig} constructor
+        @param client_instance: the calling L{X2GoClient} instance
+        @type client_instance: L{X2GoClient} instance
+        @param logger: you can pass an L{X2GoLogger} object to the L{X2GoClientXConfig} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
@@ -75,7 +75,7 @@ class X2goPulseAudio(threading.Thread):
             raise OSNotSupportedException('classes of x2go.pulseaudio module are for Windows only')
 
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -90,8 +90,8 @@ class X2goPulseAudio(threading.Thread):
 
     def run(self):
         &quot;&quot;&quot;\
-        This method is called once the C{X2goPulseAudio.start()} method has been called. To tear 
-        down the Pulseaudio daemon call the L{X2goPulseAudio.stop_thread()} method.
+        This method is called once the C{X2GoPulseAudio.start()} method has been called. To tear 
+        down the Pulseaudio daemon call the L{X2GoPulseAudio.stop_thread()} method.
 
         &quot;&quot;&quot;
         self._keepalive = True
diff --git a/x2go/registry.py b/x2go/registry.py
index 4669ea2..86521c0 100644
--- a/x2go/registry.py
+++ b/x2go/registry.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,7 +18,7 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goSessionRegistry class - the X2goClient's session registry backend
+X2GoSessionRegistry class - the X2GoClient's session registry backend
 
 &quot;&quot;&quot;
 __NAME__ = 'x2gosessregistry-pylib'
@@ -37,13 +37,13 @@ import session
 import x2go_exceptions
 
 # import the default terminal session backend
-from x2go.backends.control import X2goControlSession as _X2goControlSession
-from x2go.backends.terminal import X2goTerminalSession as _X2goTerminalSession
-from x2go.backends.info import X2goServerSessionInfo as _X2goServerSessionInfo
-from x2go.backends.info import X2goServerSessionList as _X2goServerSessionList
-from x2go.backends.proxy import X2goProxy as _X2goProxy
-from x2go.backends.settings import X2goClientSettings as _X2goClientSettings
-from x2go.backends.printing import X2goClientPrinting as _X2goClientPrinting
+from x2go.backends.control import X2GoControlSession as _X2GoControlSession
+from x2go.backends.terminal import X2GoTerminalSession as _X2GoTerminalSession
+from x2go.backends.info import X2GoServerSessionInfo as _X2GoServerSessionInfo
+from x2go.backends.info import X2GoServerSessionList as _X2GoServerSessionList
+from x2go.backends.proxy import X2GoProxy as _X2GoProxy
+from x2go.backends.settings import X2GoClientSettings as _X2GoClientSettings
+from x2go.backends.printing import X2GoClientPrinting as _X2GoClientPrinting
 
 from defaults import LOCAL_HOME as _LOCAL_HOME
 from defaults import X2GO_CLIENT_ROOTDIR as _X2GO_CLIENT_ROOTDIR
@@ -51,26 +51,26 @@ from defaults import X2GO_SESSIONS_ROOTDIR as _X2GO_SESSIONS_ROOTDIR
 from defaults import X2GO_SESSIONPROFILE_DEFAULTS as _X2GO_SESSIONPROFILE_DEFAULTS
 from defaults import X2GO_SSH_ROOTDIR as _X2GO_SSH_ROOTDIR
 
-class X2goSessionRegistry(object):
+class X2GoSessionRegistry(object):
     &quot;&quot;&quot;\
-    This class is utilized by L{X2goClient} instances to maintain a good overview on
-    session status of all associated L{X2goSession} instances.
+    This class is utilized by L{X2GoClient} instances to maintain a good overview on
+    session status of all associated L{X2GoSession} instances.
 
     &quot;&quot;&quot;
     def __init__(self, client_instance,
                  logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        @param client_instance: the L{X2goClient} instance that instantiated this L{X2goSessionRegistry} instance.
-        @type client_instance: L{X2goClient} instance
-        @param logger: you can pass an L{X2goLogger} object to the L{X2goClientXConfig} constructor
+        @param client_instance: the L{X2GoClient} instance that instantiated this L{X2GoSessionRegistry} instance.
+        @type client_instance: L{X2GoClient} instance
+        @param logger: you can pass an L{X2GoLogger} object to the L{X2GoClientXConfig} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -96,7 +96,7 @@ class X2goSessionRegistry(object):
         return self.registry.keys()
 
     def __repr__(self):
-        result = 'X2goSessionRegistry('
+        result = 'X2GoSessionRegistry('
         for p in dir(self):
             if '__' in p or not p in self.__dict__ or type(p) is types.InstanceType: continue
             result += p + '=' + str(self.__dict__[p]) + ','
@@ -105,21 +105,21 @@ class X2goSessionRegistry(object):
 
     def __call__(self, session_uuid):
         &quot;&quot;&quot;\
-        Returns the L{X2goSession} instance for a given session UUID hash.
+        Returns the L{X2GoSession} instance for a given session UUID hash.
 
         @param session_uuid: the X2Go session's UUID registry hash
         @type session_uuid: C{str}
 
-        @return: the corresponding L{X2goSession} instance
-        @rtype: L{X2goSession} instance
+        @return: the corresponding L{X2GoSession} instance
+        @rtype: L{X2GoSession} instance
 
-        @raise X2goSessionRegistryException: if the given session UUID could not be found
+        @raise X2GoSessionRegistryException: if the given session UUID could not be found
 
         &quot;&quot;&quot;
         try:
             return self.registry[session_uuid]
         except KeyError:
-            raise x2go_exceptions.X2goSessionRegistryException('No session found for UUID %s' % session_uuid)
+            raise x2go_exceptions.X2GoSessionRegistryException('No session found for UUID %s' % session_uuid)
 
     def disable_session_auto_registration(self):
         &quot;&quot;&quot;\
@@ -229,7 +229,7 @@ class X2goSessionRegistry(object):
 
     def update_status(self, session_uuid=None, profile_name=None, profile_id=None, session_list=None, force_update=False, newly_connected=False):
         &quot;&quot;&quot;\
-        Update the session status for L{X2goSession} that is represented by a given session UUID hash,
+        Update the session status for L{X2GoSession} that is represented by a given session UUID hash,
         profile name or profile ID.
 
         @param session_uuid: the X2Go session's UUID registry hash
@@ -240,23 +240,23 @@ class X2goSessionRegistry(object):
         @param profile_id: alternatively, a profile ID can be given (the stati of all registered sessions for this session 
             profile will be updated)
         @type profile_id: C{str}
-        @param session_list: an optional C{X2goServerSessionList*} instance (as returned by the L{X2goClient.list_sessions()} command can
+        @param session_list: an optional C{X2GoServerSessionList*} instance (as returned by the L{X2GoClient.list_sessions()} command can
             be passed to this method.
-        @type session_list: C{X2goServerSessionList*} instance
+        @type session_list: C{X2GoServerSessionList*} instance
         @param force_update: make sure the session status gets really updated
         @type force_update: C{bool}
 
         @return: C{True} if this method has been successful
         @rtype: C{bool}
 
-        @raise X2goSessionRegistryException: if the combination of C{session_uuid}, C{profile_name} and C{profile_id} does not match the requirement: 
+        @raise X2GoSessionRegistryException: if the combination of C{session_uuid}, C{profile_name} and C{profile_id} does not match the requirement: 
             only one of them
 
         &quot;&quot;&quot;
         if session_uuid and profile_name or session_uuid and profile_id or profile_name and profile_id:
-            raise x2go_exceptions.X2goSessionRegistryException('only one of the possible method parameters is allowed (session_uuid, profile_name or profile_id)')
+            raise x2go_exceptions.X2GoSessionRegistryException('only one of the possible method parameters is allowed (session_uuid, profile_name or profile_id)')
         elif session_uuid is None and profile_name is None and profile_id is None:
-            raise x2go_exceptions.X2goSessionRegistryException('at least one of the method parameters session_uuid, profile_name or profile_id must be given')
+            raise x2go_exceptions.X2GoSessionRegistryException('at least one of the method parameters session_uuid, profile_name or profile_id must be given')
 
         if session_uuid:
             session_uuids = [ session_uuid ]
@@ -267,8 +267,8 @@ class X2goSessionRegistry(object):
 
         for _session_uuid in session_uuids:
 
-            # only operate on instantiated X2goSession objects
-            if type(self(_session_uuid)) != session.X2goSession:
+            # only operate on instantiated X2GoSession objects
+            if type(self(_session_uuid)) != session.X2GoSession:
                 continue
 
             if not self(_session_uuid).update_status(session_list=session_list, force_update=force_update):
@@ -278,7 +278,7 @@ class X2goSessionRegistry(object):
             _last_status = copy.deepcopy(self(_session_uuid)._last_status)
             _current_status = copy.deepcopy(self(_session_uuid)._current_status)
 
-            # at this point we hook into the X2goClient instance and call notification methods
+            # at this point we hook into the X2GoClient instance and call notification methods
             # that can be used to inform an application that something has happened
 
             _profile_name = self(_session_uuid).get_profile_name()
@@ -360,9 +360,9 @@ class X2goSessionRegistry(object):
                 # session has terminated
                 self.client_instance.HOOK_on_session_has_terminated(session_uuid=_session_uuid, profile_name=_profile_name, session_name=_session_name)
                 try: self(_session_uuid).session_cleanup()
-                except x2go_exceptions.X2goSessionException: pass
+                except x2go_exceptions.X2GoSessionException: pass
                 try: self(_session_uuid).__del__()
-                except x2go_exceptions.X2goSessionException: pass
+                except x2go_exceptions.X2GoSessionException: pass
                 if len(self.virgin_sessions_of_profile_name(profile_name)) &gt; 1:
                     self.forget(_session_uuid)
 
@@ -388,13 +388,13 @@ class X2goSessionRegistry(object):
 
     def register_available_server_sessions(self, profile_name, session_list=None, newly_connected=False, re_register=False, skip_pubapp_sessions=False):
         &quot;&quot;&quot;\
-        Register server-side available X2Go sessions with this L{X2goSessionRegistry} instance for a given profile name.
+        Register server-side available X2Go sessions with this L{X2GoSessionRegistry} instance for a given profile name.
 
         @param profile_name: session profile name to register available X2Go sessions for
         @type profile_name: C{str}
-        @param session_list: an optional C{X2goServerSessionList*} instance (as returned by the L{X2goClient.list_sessions()} command can
+        @param session_list: an optional C{X2GoServerSessionList*} instance (as returned by the L{X2GoClient.list_sessions()} command can
             be passed to this method.
-        @type session_list: C{X2goServerSessionList*} instance
+        @type session_list: C{X2GoServerSessionList*} instance
         @param newly_connected: give a hint that the session profile got newly connected
         @type newly_connected: C{bool}
         @param re_register: re-register available sessions, needs to be done after changes to the session profile
@@ -424,7 +424,7 @@ class X2goSessionRegistry(object):
                 session_list = _ctrl_session.list_sessions()
 
             # make sure the session registry gets updated before registering new session
-            # (if the server name has changed, this will kick out obsolete X2goSessions)
+            # (if the server name has changed, this will kick out obsolete X2GoSessions)
             self.update_status(profile_name=profile_name, session_list=session_list, force_update=True)
             for session_name in session_list.keys():
                 if (session_name not in _session_names and not self._skip_auto_registration) or re_register:
@@ -467,13 +467,13 @@ class X2goSessionRegistry(object):
 
     def register(self, server, profile_id, profile_name,
                  session_name=None,
-                 control_backend=_X2goControlSession,
-                 terminal_backend=_X2goTerminalSession,
-                 info_backend=_X2goServerSessionInfo,
-                 list_backend=_X2goServerSessionList,
-                 proxy_backend=_X2goProxy,
-                 settings_backend=_X2goClientSettings,
-                 printing_backend=_X2goClientPrinting,
+                 control_backend=_X2GoControlSession,
+                 terminal_backend=_X2GoTerminalSession,
+                 info_backend=_X2GoServerSessionInfo,
+                 list_backend=_X2GoServerSessionList,
+                 proxy_backend=_X2GoProxy,
+                 settings_backend=_X2GoClientSettings,
+                 printing_backend=_X2GoClientPrinting,
                  client_rootdir=os.path.join(_LOCAL_HOME,_X2GO_CLIENT_ROOTDIR),
                  sessions_rootdir=os.path.join(_LOCAL_HOME,_X2GO_SESSIONS_ROOTDIR),
                  ssh_rootdir=os.path.join(_LOCAL_HOME,_X2GO_SSH_ROOTDIR),
@@ -482,7 +482,7 @@ class X2goSessionRegistry(object):
                  known_hosts=None,
                  **kwargs):
         &quot;&quot;&quot;\
-        Register a new L{X2goSession} instance with this L{X2goSessionRegistry}.
+        Register a new L{X2GoSession} instance with this L{X2GoSessionRegistry}.
 
         @param server: hostname of X2Go server
         @type server: C{str}
@@ -512,13 +512,13 @@ class X2goSessionRegistry(object):
         @type sessions_rootdir: C{str}
         @param ssh_rootdir: ssh base dir (default: ~/.ssh)
         @type ssh_rootdir: C{str}
-        @param keep_controlsession_alive: On last L{X2goSession.disconnect()} keep the associated C{X2goControlSession*} instance alive?
+        @param keep_controlsession_alive: On last L{X2GoSession.disconnect()} keep the associated C{X2GoControlSession*} instance alive?
         @&#359;ype keep_controlsession_alive: C{bool}
         @param add_to_known_hosts: Auto-accept server host validity?
         @type add_to_known_hosts: C{bool}
         @param known_hosts: the underlying Paramiko/SSH systems C{known_hosts} file
         @type known_hosts: C{str}
-        @param kwargs: all other options will be passed on to the constructor of the to-be-instantiated L{X2goSession} instance
+        @param kwargs: all other options will be passed on to the constructor of the to-be-instantiated L{X2GoSession} instance
         @type C{dict}
 
         @return: the session UUID of the newly registered (or re-registered) session
@@ -537,7 +537,7 @@ class X2goSessionRegistry(object):
         try:
             _params = self.client_instance.session_profiles.to_session_params(profile_id)
 
-        except x2go_exceptions.X2goProfileException:
+        except x2go_exceptions.X2GoProfileException:
             _params = utils._convert_SessionProfileOptions_2_SessionParams(_X2GO_SESSIONPROFILE_DEFAULTS)
 
         for _k in _params.keys():
@@ -571,7 +571,7 @@ class X2goSessionRegistry(object):
         try: del _params['profile_id'] 
         except: pass
 
-        s = session.X2goSession(server=server, control_session=control_session,
+        s = session.X2GoSession(server=server, control_session=control_session,
                                 profile_id=profile_id, profile_name=profile_name,
                                 session_name=session_name,
                                 control_backend=control_backend,
@@ -590,7 +590,7 @@ class X2goSessionRegistry(object):
                                 client_instance=self.client_instance,
                                 logger=self.logger, **_params)
 
-        session_uuid = s._X2goSession__get_uuid()
+        session_uuid = s._X2GoSession__get_uuid()
         self.logger('registering X2Go session %s...' % profile_name, log.loglevel_NOTICE)
         self.logger('registering X2Go session with UUID %s' % session_uuid, log.loglevel_DEBUG)
 
@@ -608,7 +608,7 @@ class X2goSessionRegistry(object):
 
     def has_session_of_session_name(self, session_name, match_profile_name=None):
         &quot;&quot;&quot;\
-        Detect if we know about an L{X2goSession} of name C{&lt;session_name&gt;}.
+        Detect if we know about an L{X2GoSession} of name C{&lt;session_name&gt;}.
 
         @param session_name: name of session to be searched for
         @type session_name: C{str}
@@ -623,20 +623,20 @@ class X2goSessionRegistry(object):
 
     def get_session_of_session_name(self, session_name, return_object=False, match_profile_name=None):
         &quot;&quot;&quot;\
-        Retrieve the L{X2goSession} instance with session name C{&lt;session_name&gt;}.
+        Retrieve the L{X2GoSession} instance with session name C{&lt;session_name&gt;}.
 
         @param session_name: name of session to be retrieved
         @type session_name: C{str}
-        @param return_object: if C{False} the session UUID hash will be returned, if C{True} the L{X2goSession} instance will be returned
+        @param return_object: if C{False} the session UUID hash will be returned, if C{True} the L{X2GoSession} instance will be returned
         @type return_object: C{bool}
         @param match_profile_name: returned sessions must match this profile name
         @type match_profile_name: C{str}
 
-        @return: L{X2goSession} object or its representing session UUID hash
-        @rtype: L{X2goSession} instance or C{str}
+        @return: L{X2GoSession} object or its representing session UUID hash
+        @rtype: L{X2GoSession} instance or C{str}
 
-        @raise X2goSessionRegistryException: if there is more than one L{X2goSession} registered for C{&lt;session_name&gt;} within
-            the same L{X2goClient} instance. This should never happen!
+        @raise X2GoSessionRegistryException: if there is more than one L{X2GoSession} registered for C{&lt;session_name&gt;} within
+            the same L{X2GoClient} instance. This should never happen!
 
         &quot;&quot;&quot;
         if match_profile_name is None:
@@ -651,7 +651,7 @@ class X2goSessionRegistry(object):
             else:
                 return session.get_uuid()
         elif len(found_sessions) &gt; 1:
-            raise x2go_exceptions.X2goSessionRegistryException('there should only be one registered session of name ,,%s\'\'' % session_name)
+            raise x2go_exceptions.X2GoSessionRegistryException('there should only be one registered session of name ,,%s\'\'' % session_name)
         else:
             return None
 
@@ -687,10 +687,10 @@ class X2goSessionRegistry(object):
 
     def connected_sessions(self, return_objects=True, return_profile_names=False, return_profile_ids=False, return_session_names=False):
         &quot;&quot;&quot;\
-        Retrieve a list of sessions that the underlying L{X2goClient} instances is currently connected to.
+        Retrieve a list of sessions that the underlying L{X2GoClient} instances is currently connected to.
         If none of the C{return_*} options is specified a list of session UUID hashes will be returned.
 
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_profile_names: return as list of profile names
         @type return_profile_names: C{bool}
@@ -707,10 +707,10 @@ class X2goSessionRegistry(object):
 
     def associated_sessions(self, return_objects=True, return_profile_names=False, return_profile_ids=False, return_session_names=False):
         &quot;&quot;&quot;\
-        Retrieve a list of sessions that are currently associated by an C{X2goTerminalSession*} to the underlying L{X2goClient} instance.
+        Retrieve a list of sessions that are currently associated by an C{X2GoTerminalSession*} to the underlying L{X2GoClient} instance.
         If none of the C{return_*} options is specified a list of session UUID hashes will be returned.
 
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_profile_names: return as list of profile names
         @type return_profile_names: C{bool}
@@ -730,7 +730,7 @@ class X2goSessionRegistry(object):
         Retrieve a list of sessions that are currently still in virgin state (not yet connected, associated etc.).
         If none of the C{return_*} options is specified a list of session UUID hashes will be returned.
 
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_profile_names: return as list of profile names
         @type return_profile_names: C{bool}
@@ -750,7 +750,7 @@ class X2goSessionRegistry(object):
         Retrieve a list of sessions that are currently in running state.
         If none of the C{return_*} options is specified a list of session UUID hashes will be returned.
 
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_profile_names: return as list of profile names
         @type return_profile_names: C{bool}
@@ -770,7 +770,7 @@ class X2goSessionRegistry(object):
         Retrieve a list of sessions that are currently in suspended state.
         If none of the C{return_*} options is specified a list of session UUID hashes will be returned.
 
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_profile_names: return as list of profile names
         @type return_profile_names: C{bool}
@@ -790,7 +790,7 @@ class X2goSessionRegistry(object):
         Retrieve a list of sessions that have terminated recently.
         If none of the C{return_*} options is specified a list of session UUID hashes will be returned.
 
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_profile_names: return as list of profile names
         @type return_profile_names: C{bool}
@@ -808,7 +808,7 @@ class X2goSessionRegistry(object):
     @property
     def has_running_sessions(self):
         &quot;&quot;&quot;\
-        Equals C{True} if the underlying L{X2goClient} instance has any running sessions at hand.
+        Equals C{True} if the underlying L{X2GoClient} instance has any running sessions at hand.
 
         &quot;&quot;&quot;
         return self.running_sessions() and len(self.running_sessions()) &gt; 0
@@ -816,7 +816,7 @@ class X2goSessionRegistry(object):
     @property
     def has_suspended_sessions(self):
         &quot;&quot;&quot;\
-        Equals C{True} if the underlying L{X2goClient} instance has any suspended sessions at hand.
+        Equals C{True} if the underlying L{X2GoClient} instance has any suspended sessions at hand.
 
         &quot;&quot;&quot;
         return self.suspended_sessions and len(self.suspended_sessions) &gt; 0
@@ -826,7 +826,7 @@ class X2goSessionRegistry(object):
         Retrieve a list of all registered sessions.
         If none of the C{return_*} options is specified a list of session UUID hashes will be returned.
 
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_profile_names: return as list of profile names
         @type return_profile_names: C{bool}
@@ -846,7 +846,7 @@ class X2goSessionRegistry(object):
         Retrieve a list of sessions that are currently _NOT_ in running state.
         If none of the C{return_*} options is specified a list of session UUID hashes will be returned.
 
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_profile_names: return as list of profile names
         @type return_profile_names: C{bool}
@@ -868,7 +868,7 @@ class X2goSessionRegistry(object):
 
         @param profile_name: session profile name
         @type profile_name: C{str}
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_session_names: return as list of X2Go session names
         @type return_session_names: C{bool}
@@ -886,12 +886,12 @@ class X2goSessionRegistry(object):
 
     def associated_sessions_of_profile_name(self, profile_name, return_objects=True, return_session_names=False):
         &quot;&quot;&quot;\
-        For a given session profile name retrieve a list of sessions that are currently associated by an C{X2goTerminalSession*} to this L{X2goClient} instance.
+        For a given session profile name retrieve a list of sessions that are currently associated by an C{X2GoTerminalSession*} to this L{X2GoClient} instance.
         If none of the C{return_*} options is specified a list of session UUID hashes will be returned.
 
         @param profile_name: session profile name
         @type profile_name: C{str}
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_session_names: return as list of X2Go session names
         @type return_session_names: C{bool}
@@ -914,7 +914,7 @@ class X2goSessionRegistry(object):
 
         @param profile_name: session profile name
         @type profile_name: C{str}
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_session_names: return as list of X2Go session names
         @type return_session_names: C{bool}
@@ -932,12 +932,12 @@ class X2goSessionRegistry(object):
 
     def registered_sessions_of_profile_name(self, profile_name, return_objects=True, return_session_names=False):
         &quot;&quot;&quot;\
-        For a given session profile name retrieve a list of sessions that are currently registered with this L{X2goClient} instance.
+        For a given session profile name retrieve a list of sessions that are currently registered with this L{X2GoClient} instance.
         If none of the C{return_*} options is specified a list of session UUID hashes will be returned.
 
         @param profile_name: session profile name
         @type profile_name: C{str}
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_session_names: return as list of X2Go session names
         @type return_session_names: C{bool}
@@ -955,13 +955,13 @@ class X2goSessionRegistry(object):
 
     def virgin_sessions_of_profile_name(self, profile_name, return_objects=True, return_session_names=False):
         &quot;&quot;&quot;\
-        For a given session profile name retrieve a list of sessions that are registered with this L{X2goClient} instance but have not
+        For a given session profile name retrieve a list of sessions that are registered with this L{X2GoClient} instance but have not
         yet been started (i.e. sessions that are in virgin state). If none of the C{return_*} options is specified a list of 
         session UUID hashes will be returned.
 
         @param profile_name: session profile name
         @type profile_name: C{str}
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_session_names: return as list of X2Go session names
         @type return_session_names: C{bool}
@@ -984,7 +984,7 @@ class X2goSessionRegistry(object):
 
         @param profile_name: session profile name
         @type profile_name: C{str}
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_session_names: return as list of X2Go session names
         @type return_session_names: C{bool}
@@ -1007,7 +1007,7 @@ class X2goSessionRegistry(object):
 
         @param profile_name: session profile name
         @type profile_name: C{str}
-        @param return_objects: return as list of L{X2goSession} instances
+        @param return_objects: return as list of L{X2GoSession} instances
         @type return_objects: C{bool}
         @param return_session_names: return as list of X2Go session names
         @type return_session_names: C{bool}
@@ -1025,13 +1025,13 @@ class X2goSessionRegistry(object):
 
     def control_session_of_profile_name(self, profile_name):
         &quot;&quot;&quot;\
-        For a given session profile name retrieve a the corresponding C{X2goControlSession*} instance.
+        For a given session profile name retrieve a the corresponding C{X2GoControlSession*} instance.
 
         @param profile_name: session profile name
         @type profile_name: C{str}
 
         @return: contol session instance
-        @rtype: C{X2goControlSession*} instance
+        @rtype: C{X2GoControlSession*} instance
 
         &quot;&quot;&quot;
         _sessions = self.registered_sessions_of_profile_name(profile_name, return_objects=True)
@@ -1070,7 +1070,7 @@ class X2goSessionRegistry(object):
 
         @param profile_name: the profile name that we query the master session of
         @type profile_name: C{str}
-        @param return_object: return L{X2goSession} instance
+        @param return_object: return L{X2GoSession} instance
         @type return_object: C{bool}
         @param return_session_name: return X2Go session name
         @type return_session_name: C{bool}
diff --git a/x2go/rforward.py b/x2go/rforward.py
index a138870..7105134 100644
--- a/x2go/rforward.py
+++ b/x2go/rforward.py
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -47,12 +47,12 @@ def x2go_transport_tcp_handler(chan, (origin_addr, origin_port), (server_addr, s
 
     However, additionally this handler function checks the server port of the incoming channel
     and detects if there are Paramiko/SSH reverse forwarding tunnels waiting for the incoming 
-    channels. The Paramiko/SSH reverse forwarding tunnels are initiated by an L{X2goSession} instance
+    channels. The Paramiko/SSH reverse forwarding tunnels are initiated by an L{X2GoSession} instance
     (currently supported: reverse tunneling auf audio data, reverse tunneling of SSH requests).
 
-    If the server port of an incoming Paramiko/SSH channel matches the configured port of an L{X2goRevFwTunnel} 
-    instance, this instance gets notified of the incoming channel and a new L{X2goRevFwChannelThread} is 
-    started. This L{X2goRevFwChannelThread} then takes care of the new channel's incoming data stream.
+    If the server port of an incoming Paramiko/SSH channel matches the configured port of an L{X2GoRevFwTunnel} 
+    instance, this instance gets notified of the incoming channel and a new L{X2GoRevFwChannelThread} is 
+    started. This L{X2GoRevFwChannelThread} then takes care of the new channel's incoming data stream.
 
     &quot;&quot;&quot;
     transport = chan.get_transport()
@@ -70,9 +70,9 @@ def x2go_transport_tcp_handler(chan, (origin_addr, origin_port), (server_addr, s
                 rev_tuns[session_name]['sshfs'][1].notify()
 
 
-class X2goRevFwTunnel(threading.Thread):
+class X2GoRevFwTunnel(threading.Thread):
     &quot;&quot;&quot;\
-    L{X2goRevFwTunnel} class objects are used to reversely tunnel 
+    L{X2GoRevFwTunnel} class objects are used to reversely tunnel 
     X2Go audio, X2Go printing and X2Go folder sharing / device mounting
     through Paramiko/SSH.
 
@@ -81,10 +81,10 @@ class X2goRevFwTunnel(threading.Thread):
         &quot;&quot;&quot;\
         Setup a reverse tunnel through Paramiko/SSH.
 
-        After the reverse tunnel has been setup up with L{X2goRevFwTunnel.start()} it waits
-        for notification from L{X2goRevFwTunnel.notify()} to accept incoming channels. This 
-        notification (L{X2goRevFwTunnel.notify()} gets called from within the transport's 
-        TCP handler function L{x2go_transport_tcp_handler} of the L{X2goSession} instance.
+        After the reverse tunnel has been setup up with L{X2GoRevFwTunnel.start()} it waits
+        for notification from L{X2GoRevFwTunnel.notify()} to accept incoming channels. This 
+        notification (L{X2GoRevFwTunnel.notify()} gets called from within the transport's 
+        TCP handler function L{x2go_transport_tcp_handler} of the L{X2GoSession} instance.
 
         @param server_port: the TCP/IP port on the X2Go server (starting point of the tunnel), 
             normally some number above 30000
@@ -95,18 +95,18 @@ class X2goRevFwTunnel(threading.Thread):
         @param remote_port: the TCP/IP port on the X2Go client (end point of the tunnel),
             normally an application's standard port (22 for SSH, 4713 for pulse audio, etc.)
         @type remote_port: int
-        @param ssh_transport: the L{X2goSession}'s Paramiko/SSH transport instance
+        @param ssh_transport: the L{X2GoSession}'s Paramiko/SSH transport instance
         @type ssh_transport: C{paramiko.Transport} instance
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goRevFwTunnel} constructor
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoRevFwTunnel} constructor
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: int
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -155,7 +155,7 @@ class X2goRevFwTunnel(threading.Thread):
     def pause(self):
         &quot;&quot;&quot;\
         Prevent acceptance of new incoming connections through the Paramiko/SSH
-        reverse forwarding tunnel. Also, any active connection on this L{X2goRevFwTunnel}
+        reverse forwarding tunnel. Also, any active connection on this L{X2GoRevFwTunnel}
         instance will be closed immediately, if this method is called.
 
         &quot;&quot;&quot;
@@ -177,14 +177,14 @@ class X2goRevFwTunnel(threading.Thread):
 
     def notify(self):
         &quot;&quot;&quot;\
-        Notify an L{X2goRevFwTunnel} instance of an incoming Paramiko/SSH channel.
+        Notify an L{X2GoRevFwTunnel} instance of an incoming Paramiko/SSH channel.
 
         If an incoming reverse tunnel channel appropriate for this instance has
-        been detected, this method gets called from the L{X2goSession}'s transport
+        been detected, this method gets called from the L{X2GoSession}'s transport
         TCP handler.
 
         The sent notification will trigger a C{thread.Condition()} waiting for notification
-        in L{X2goRevFwTunnel.run()}.
+        in L{X2GoRevFwTunnel.run()}.
 
         &quot;&quot;&quot;
         self.incoming_channel.acquire()
@@ -194,7 +194,7 @@ class X2goRevFwTunnel(threading.Thread):
 
     def stop_thread(self):
         &quot;&quot;&quot;\
-        Stops this L{X2goRevFwTunnel} thread completely.
+        Stops this L{X2GoRevFwTunnel} thread completely.
 
         &quot;&quot;&quot;
         self.pause()
@@ -220,23 +220,23 @@ class X2goRevFwTunnel(threading.Thread):
 
     def run(self):
         &quot;&quot;&quot;\
-        This method gets run once an L{X2goRevFwTunnel} has been started with its
-        L{start()} method. Use L{X2goRevFwTunnel}.stop_thread() to stop the
+        This method gets run once an L{X2GoRevFwTunnel} has been started with its
+        L{start()} method. Use L{X2GoRevFwTunnel}.stop_thread() to stop the
         reverse forwarding tunnel again. You can also temporarily lock the tunnel
-        down with L{X2goRevFwTunnel.pause()} and L{X2goRevFwTunnel.resume()}).
+        down with L{X2GoRevFwTunnel.pause()} and L{X2GoRevFwTunnel.resume()}).
 
-        L{X2goRevFwTunnel.run()} waits for notifications of an appropriate incoming
-        Paramiko/SSH channel (issued by L{X2goRevFwTunnel.notify()}). Appropriate in
+        L{X2GoRevFwTunnel.run()} waits for notifications of an appropriate incoming
+        Paramiko/SSH channel (issued by L{X2GoRevFwTunnel.notify()}). Appropriate in
         this context means, that its start point on the X2Go server matches the class's
         property C{server_port}.
 
         Once a new incoming channel gets announced by the L{notify()} method, a new 
-        L{X2goRevFwChannelThread} instance will be initialized. As a data stream handler,
+        L{X2GoRevFwChannelThread} instance will be initialized. As a data stream handler,
         the function L{x2go_rev_forward_channel_handler()} will be used.
 
         The channel will last till the connection gets dropped on the X2Go server side or 
-        until the tunnel gets paused by an L{X2goRevFwTunnel.pause()} call or stopped via the
-        L{X2goRevFwTunnel.stop_thread()} method.
+        until the tunnel gets paused by an L{X2GoRevFwTunnel.pause()} call or stopped via the
+        L{X2GoRevFwTunnel.stop_thread()} method.
 
         &quot;&quot;&quot;
         self._request_port_forwarding()
@@ -257,7 +257,7 @@ class X2goRevFwTunnel(threading.Thread):
 
             self.incoming_channel.release()
             if self._accept_channels and self._keepalive:
-                _new_chan_thread = X2goRevFwChannelThread(_chan, (self.remote_host, self.remote_port), 
+                _new_chan_thread = X2GoRevFwChannelThread(_chan, (self.remote_host, self.remote_port), 
                                                           target=x2go_rev_forward_channel_handler, 
                                                           kwargs={ 
                                                             'chan': _chan,
@@ -273,16 +273,16 @@ class X2goRevFwTunnel(threading.Thread):
 
 def x2go_rev_forward_channel_handler(chan=None, addr='', port=0, parent_thread=None, logger=None, ):
     &quot;&quot;&quot;\
-    Handle the data stream of a requested channel that got set up by a L{X2goRevFwTunnel} (Paramiko/SSH 
+    Handle the data stream of a requested channel that got set up by a L{X2GoRevFwTunnel} (Paramiko/SSH 
     reverse forwarding tunnel).
 
     The channel (and the corresponding connections) close either ...
 
         - ... if the connecting application closes the connection and thus, drops 
         the channel, or
-        - ... if the L{X2goRevFwTunnel} parent thread gets paused. The call
-        of L{X2goRevFwTunnel.pause()} on the instance can be used to shut down all incoming 
-        tunneled SSH connections associated to this L{X2goRevFwTunnel} instance
+        - ... if the L{X2GoRevFwTunnel} parent thread gets paused. The call
+        of L{X2GoRevFwTunnel.pause()} on the instance can be used to shut down all incoming 
+        tunneled SSH connections associated to this L{X2GoRevFwTunnel} instance
         from within a Python X2Go application.
 
     @param chan: channel
@@ -291,11 +291,11 @@ def x2go_rev_forward_channel_handler(chan=None, addr='', port=0, parent_thread=N
     @type addr: C{str}
     @param port: bind port
     @type port: C{int}
-    @param parent_thread: the calling L{X2goRevFwTunnel} instance
-    @type parent_thread: L{X2goRevFwTunnel} instance
-    @param logger: you can pass an L{X2goLogger} object to the
-        L{X2goRevFwTunnel} constructor
-    @type logger: L{X2goLogger} instance
+    @param parent_thread: the calling L{X2GoRevFwTunnel} instance
+    @type parent_thread: L{X2GoRevFwTunnel} instance
+    @param logger: you can pass an L{X2GoLogger} object to the
+        L{X2GoRevFwTunnel} constructor
+    @type logger: L{X2GoLogger} instance
 
     &quot;&quot;&quot;
     fw_socket = socket.socket()
@@ -332,7 +332,7 @@ def x2go_rev_forward_channel_handler(chan=None, addr='', port=0, parent_thread=N
     logger('Reverse tunnel %s closed from %r' % (chan, chan.origin_addr,), loglevel=log.loglevel_INFO)
 
 
-class X2goRevFwChannelThread(threading.Thread):
+class X2GoRevFwChannelThread(threading.Thread):
     &quot;&quot;&quot;\
     Starts a thread for each incoming Paramiko/SSH data channel trough the reverse
     forwarding tunnel.
@@ -342,7 +342,7 @@ class X2goRevFwChannelThread(threading.Thread):
         &quot;&quot;&quot;\
         Initializes a reverse forwarding channel thread.
 
-        @param channel: incoming Paramiko/SSH channel from the L{X2goSession}'s transport
+        @param channel: incoming Paramiko/SSH channel from the L{X2GoSession}'s transport
             accept queue
         @type channel: class
         @param remote: tuple (addr, port) that specifies the data endpoint of the channel
diff --git a/x2go/session.py b/x2go/session.py
index bca32ec..1c94138 100644
--- a/x2go/session.py
+++ b/x2go/session.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,11 +18,11 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-X2goSession class - a public API of Python X2Go, handling standalone X2Go 
+X2GoSession class - a public API of Python X2Go, handling standalone X2Go 
 sessions.
 
-This class is normally embedded into the context of an L{X2goClient}
-instance, but it is also possible to address L{X2goSession}s directly via this
+This class is normally embedded into the context of an L{X2GoClient}
+instance, but it is also possible to address L{X2GoSession}s directly via this
 class.
 
 To launch a session manually from the Python interactive shell, perform these
@@ -35,7 +35,7 @@ simple steps::
   &gt;&gt;&gt; import x2go
   &gt;&gt;&gt; import gevent
   Xlib.protocol.request.QueryExtension
-  &gt;&gt;&gt; s = x2go.session.X2goSession()
+  &gt;&gt;&gt; s = x2go.session.X2GoSession()
   &gt;&gt;&gt; s.set_server('&lt;my.x2go.server&gt;')
   &gt;&gt;&gt; s.set_port(&lt;ssh-port&gt;)
   &gt;&gt;&gt; s.connect('&lt;my-login&gt;', '&lt;my-password&gt;')
@@ -70,13 +70,13 @@ import utils
 import session
 import x2go_exceptions
 
-from x2go.backends.control import X2goControlSession as _X2goControlSession
-from x2go.backends.terminal import X2goTerminalSession as _X2goTerminalSession
-from x2go.backends.info import X2goServerSessionInfo as _X2goServerSessionInfo
-from x2go.backends.info import X2goServerSessionList as _X2goServerSessionList
-from x2go.backends.proxy import X2goProxy as _X2goProxy
-from x2go.backends.settings import X2goClientSettings as _X2goClientSettings
-from x2go.backends.printing import X2goClientPrinting as _X2goClientPrinting
+from x2go.backends.control import X2GoControlSession as _X2GoControlSession
+from x2go.backends.terminal import X2GoTerminalSession as _X2GoTerminalSession
+from x2go.backends.info import X2GoServerSessionInfo as _X2GoServerSessionInfo
+from x2go.backends.info import X2GoServerSessionList as _X2GoServerSessionList
+from x2go.backends.proxy import X2GoProxy as _X2GoProxy
+from x2go.backends.settings import X2GoClientSettings as _X2GoClientSettings
+from x2go.backends.printing import X2GoClientPrinting as _X2GoClientPrinting
 
 from defaults import X2GOCLIENT_OS as _X2GOCLIENT_OS
 from defaults import LOCAL_HOME as _LOCAL_HOME
@@ -98,7 +98,7 @@ _X2GO_SESSION_PARAMS = ('use_sshproxy', 'sshproxy_reuse_authinfo',
                         'connected', 'virgin', 'running', 'suspended', 'terminated', 'faulty'
                         'client_instance',
                        )
-&quot;&quot;&quot;A list of allowed X2Go pure session parameters (i.e. parameters that are passed on neither to an X2goControlSession, X2goSSHProxy nor an X2goControlSession object.&quot;&quot;&quot;
+&quot;&quot;&quot;A list of allowed X2Go pure session parameters (i.e. parameters that are passed on neither to an X2GoControlSession, X2GoSSHProxy nor an X2GoControlSession object.&quot;&quot;&quot;
 # options of the paramiko.SSHClient().connect() method, any option that is allowed for a terminal session instance
 _X2GO_TERMINAL_PARAMS = ('geometry', 'depth', 'link', 'pack', 'dpi',
                          'cache_type', 'kbtype', 'kblayout', 'kbvariant',
@@ -123,14 +123,14 @@ _X2GO_SSHPROXY_PARAMS = ('sshproxy_host', 'sshproxy_port', 'sshproxy_user', 'ssh
 &quot;&quot;&quot;A list of allowed X2Go SSH proxy parameters.&quot;&quot;&quot;
 
 
-class X2goSession(object):
+class X2GoSession(object):
     &quot;&quot;&quot;\
     Public API class for launching X2Go sessions. Recommended is to manage X2Go sessions from
-    within an L{X2goClient} instance. However, Python X2Go is designed in a way that it also
-    allows the management of singel L{X2goSession} instance.
+    within an L{X2GoClient} instance. However, Python X2Go is designed in a way that it also
+    allows the management of singel L{X2GoSession} instance.
 
-    Thus, you can use the L{X2goSession} class to manually set up X2Go sessions without 
-    L{X2goClient} context (session registry, session list cache, auto-registration of new
+    Thus, you can use the L{X2GoSession} class to manually set up X2Go sessions without 
+    L{X2GoClient} context (session registry, session list cache, auto-registration of new
     sessions etc.).
 
     &quot;&quot;&quot;
@@ -148,13 +148,13 @@ class X2goSession(object):
                  allow_share_local_folders=False,
                  share_local_folders=[],
                  restore_shared_local_folders=False,
-                 control_backend=_X2goControlSession,
-                 terminal_backend=_X2goTerminalSession,
-                 info_backend=_X2goServerSessionInfo,
-                 list_backend=_X2goServerSessionList,
-                 proxy_backend=_X2goProxy,
-                 settings_backend=_X2goClientSettings,
-                 printing_backend=_X2goClientPrinting,
+                 control_backend=_X2GoControlSession,
+                 terminal_backend=_X2GoTerminalSession,
+                 info_backend=_X2GoServerSessionInfo,
+                 list_backend=_X2GoServerSessionList,
+                 proxy_backend=_X2GoProxy,
+                 settings_backend=_X2GoClientSettings,
+                 printing_backend=_X2GoClientPrinting,
                  client_rootdir=os.path.join(_LOCAL_HOME, _X2GO_CLIENT_ROOTDIR),
                  sessions_rootdir=os.path.join(_LOCAL_HOME, _X2GO_SESSIONS_ROOTDIR),
                  ssh_rootdir=os.path.join(_LOCAL_HOME, _X2GO_SSH_ROOTDIR),
@@ -169,8 +169,8 @@ class X2goSession(object):
         &quot;&quot;&quot;\
         @param server: hostname of X2Go server
         @type server: C{str}
-        @param control_session: an already initialized C{X2goControlSession*} instance
-        @type control_session: C{X2goControlSession*} instance
+        @param control_session: an already initialized C{X2GoControlSession*} instance
+        @type control_session: C{X2GoControlSession*} instance
         @param use_sshproxy: for communication with X2Go server use an SSH proxy host
         @type use_sshproxy: C{bool}
         @param sshproxy_reuse_authinfo: for proxy authentication re-use the X2Go session's password / key file
@@ -192,7 +192,7 @@ class X2goSession(object):
         @param mimebox_extensions: whitelist of allowed X2Go MIME box extensions
         @type mimebox_extensions: C{list}
         @param mimebox_action: action for incoming X2Go MIME box files
-        @type mimebox_action: C{X2goMimeBoxAction*} or C{str}
+        @type mimebox_action: C{X2GoMimeBoxAction*} or C{str}
         @param allow_share_local_folders: enable local folder sharing support
         @type allow_share_local_folders: C{bool}
         @param share_local_folders: list of local folders to share with the remote X2Go session
@@ -219,7 +219,7 @@ class X2goSession(object):
         @type sessions_rootdir: C{str}
         @param ssh_rootdir: ssh base dir (default: ~/.ssh)
         @type ssh_rootdir: C{str}
-        @param keep_controlsession_alive: On last L{X2goSession.disconnect()} keep the associated C{X2goControlSession*} instance alive?
+        @param keep_controlsession_alive: On last L{X2GoSession.disconnect()} keep the associated C{X2GoControlSession*} instance alive?
         @&#359;ype keep_controlsession_alive: C{bool}
         @param add_to_known_hosts: Auto-accept server host validity?
         @type add_to_known_hosts: C{bool}
@@ -241,14 +241,14 @@ class X2goSession(object):
         @type terminated: C{bool}
         @param faulty: manipulate session state &#187;faulty&#171; by giving a pre-set value
         @type faulty: C{bool}
-        @param client_instance: if available, the underlying L{X2goClient} instance
-        @type client_instance: C{X2goClient} instance
+        @param client_instance: if available, the underlying L{X2GoClient} instance
+        @type client_instance: C{X2GoClient} instance
         @param params: further control session, terminal session and SSH proxy class options
         @type params: C{dict}
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -377,7 +377,7 @@ class X2goSession(object):
         return self.__get_uuid()
 
     def __repr__(self):
-        result = 'X2goSession('
+        result = 'X2GoSession('
         for p in dir(self):
             if '__' in p or not p in self.__dict__ or type(p) is types.InstanceType: continue
             result += p + '=' + str(self.__dict__[p]) + ','
@@ -428,9 +428,9 @@ class X2goSession(object):
 
     def get_client_instance(self):
         &quot;&quot;&quot;\
-        Return parent L{X2goClient} instance if avaiable.
+        Return parent L{X2GoClient} instance if avaiable.
 
-        return: L{X2goClient} instance this session is associated with
+        return: L{X2GoClient} instance this session is associated with
         rtype: C{obj}
 
         &quot;&quot;&quot;
@@ -467,6 +467,26 @@ class X2goSession(object):
         else:
             self.logger('HOOK_session_startup_failed: session startup for session profile ,,%s\'\' failed.' % self.profile_name, loglevel=log.loglevel_WARN)
 
+    def HOOK_list_desktops_timeout(self):
+        &quot;&quot;&quot;\
+        HOOK method: called if the x2golistdesktops command generates a timeout due to long execution time.
+
+        &quot;&quot;&quot;
+        if self.client_instance:
+            self.client_instance.HOOK_list_desktops_timeout(profile_name=self.profile_name)
+        else:
+            self.logger('HOOK_list_desktops_timeout: the server-side x2golistdesktops command for session profile %s took too long to return results. This can happen from time to time, please try again.' % self.profile_name, loglevel=log.loglevel_WARN)
+
+    def HOOK_no_such_desktop(self, desktop='UNKNOWN'):
+        &quot;&quot;&quot;\
+        HOOK method: called if it is tried to connect to a shared desktop that's not available (anymore).
+
+        &quot;&quot;&quot;
+        if self.client_instance:
+            self.client_instance.HOOK_no_such_desktop(profile_name=self.profile_name, desktop=desktop)
+        else:
+            self.logger('HOOK_no_such_desktop: the desktop %s (via session profile %s) is not available for sharing (anymore).' % (desktop, self.profile_name), loglevel=log.loglevel_WARN)
+
     def HOOK_rforward_request_denied(self, server_port=0):
         &quot;&quot;&quot;\
         HOOK method: called if a reverse port forwarding request has been denied.
@@ -496,12 +516,12 @@ class X2goSession(object):
         if self.client_instance:
             self.client_instance.HOOK_forwarding_tunnel_setup_failed(profile_name=self.profile_name, session_name=self.session_name, chain_host=chain_host, chain_port=chain_port)
         else:
-            self.logger('HOOK_forwarding_tunnel_setup_failed: Forwarding tunnel request to [%s]:%s for session %s (%s) was denied by remote X2go/SSH server. Session startup failed.' % (chain_host, chain_port, self.session_name, self.profile_name), loglevel=log.loglevel_WARN)
+            self.logger('HOOK_forwarding_tunnel_setup_failed: Forwarding tunnel request to [%s]:%s for session %s (%s) was denied by remote X2Go/SSH server. Session startup failed.' % (chain_host, chain_port, self.session_name, self.profile_name), loglevel=log.loglevel_WARN)
 
         # get rid of the faulty session...
         try:
             self._terminate()
-        except x2go_exceptions.X2goSessionException:
+        except x2go_exceptions.X2GoSessionException:
             pass
 
     def HOOK_printing_not_available(self):
@@ -544,7 +564,7 @@ class X2goSession(object):
         else:
             self.logger('HOOK_sshfs_not_available: the remote X2Go server (%s) denies SSHFS access for session %s. This will result in client-side folder sharing, printing and the MIME box feature being unavailable' % (self.profile_name, self.session_name), loglevel=log.loglevel_WARN)
 
-    def HOOK_check_host_dialog(self, host, port, fingerprint='no fingerprint', fingerprint_type='RSA'):
+    def HOOK_check_host_dialog(self, host, port, fingerprint='no fingerprint', fingerprint_type='UNKNOWN'):
         &quot;&quot;&quot;\
         HOOK method: called if a host check is requested. This hook has to either return C{True} (default) or C{False}.
 
@@ -568,11 +588,13 @@ class X2goSession(object):
 
     def init_control_session(self):
         &quot;&quot;&quot;\
-        Initialize a new control session (C{X2goControlSession*}).
+        Initialize a new control session (C{X2GoControlSession*}).
 
         &quot;&quot;&quot;
+        low_latency = self.terminal_params.has_key('link') and self.terminal_params['link'].lower() in ('modem', 'isdn')
+
         if self.control_session is None:
-            self.logger('initializing X2goControlSession', loglevel=log.loglevel_DEBUG)
+            self.logger('initializing X2GoControlSession', loglevel=log.loglevel_DEBUG)
             self.control_session = self.control_backend(profile_name=self.profile_name,
                                                         add_to_known_hosts=self.add_to_known_hosts,
                                                         known_hosts=self.known_hosts,
@@ -584,7 +606,10 @@ class X2goSession(object):
                                                         client_rootdir=self.client_rootdir,
                                                         sessions_rootdir=self.sessions_rootdir,
                                                         ssh_rootdir=self.ssh_rootdir,
+                                                        low_latency=low_latency,
                                                         logger=self.logger)
+        else:
+            self.control_session.low_latency = low_latency
     __init_control_session = init_control_session
 
     def is_master_session(self):
@@ -594,7 +619,7 @@ class X2goSession(object):
         The master session is the session has been launched first for a specific connection,
         it also is _the_ session that controls the client-side shared folders.
 
-        If this L{X2goSession} instance is a standalone instance (without parent L{X2goClient})
+        If this L{X2GoSession} instance is a standalone instance (without parent L{X2GoClient})
         this method will always return C{True}.
 
         @return: returns C{True} if this session is a master session
@@ -610,7 +635,7 @@ class X2goSession(object):
         &quot;&quot;&quot;\
         Declare this as a master session of a connection channel.
 
-        This method gets called by the L{X2goSessionRegistry} while sessions are starting or resuming and it relies on
+        This method gets called by the L{X2GoSessionRegistry} while sessions are starting or resuming and it relies on
         an already set-up terminal session.
 
         @param wait: wait for &lt;wait&gt; seconds before sharing local folders via the new master session
@@ -654,7 +679,7 @@ class X2goSession(object):
 
     def set_server(self, server):
         &quot;&quot;&quot;\
-        Modify server name after L{X2goSession} has already been initialized.
+        Modify server name after L{X2GoSession} has already been initialized.
 
         @param server: new server name
         @type server: C{str}
@@ -665,7 +690,7 @@ class X2goSession(object):
 
     def set_port(self, port):
         &quot;&quot;&quot;\
-        Modify server port after L{X2goSession} has already been initialized.
+        Modify server port after L{X2GoSession} has already been initialized.
 
         @param port: socket port of server to connect to
         @type port: C{int}
@@ -676,7 +701,7 @@ class X2goSession(object):
 
     def set_profile_name(self, profile_name):
         &quot;&quot;&quot;\
-        Modify session profile name after L{X2goSession} has already been initialized.
+        Modify session profile name after L{X2GoSession} has already been initialized.
 
         @param profile_name: new session profile name
         @type profile_name: C{str}
@@ -696,21 +721,21 @@ class X2goSession(object):
         @return: value for profile option C{&lt;option&gt;}
         @rtype: C{bool,str,int}
 
-        @raise X2goProfileException: if the session profile option is unknown
+        @raise X2GoProfileException: if the session profile option is unknown
 
         &quot;&quot;&quot;
         if option in _X2GO_SESSION_PARAMS + _X2GO_TERMINAL_PARAMS + _X2GO_SSHPROXY_PARAMS and hasattr(self, option):
             return eval(&quot;self.%s&quot; % option)
         else:
-            raise x2go_exceptions.X2goProfileException('Unknown session profile option: %s.' % option)
+            raise x2go_exceptions.X2GoProfileException('Unknown session profile option: %s.' % option)
     __get_session_profile_option = get_session_profile_option
 
     def update_params(self, params):
         &quot;&quot;&quot;\
-        This method can be used to modify L{X2goSession} parameters after the
-        L{X2goSession} instance has already been initialized.
+        This method can be used to modify L{X2GoSession} parameters after the
+        L{X2GoSession} instance has already been initialized.
 
-        @param params: a Python dictionary with L{X2goSession} parameters
+        @param params: a Python dictionary with L{X2GoSession} parameters
         @type params: C{dict}
 
         &quot;&quot;&quot;
@@ -797,7 +822,7 @@ class X2goSession(object):
 
     def get_uuid(self):
         &quot;&quot;&quot;\
-        Retrieve session UUID hash for this L{X2goSession}.
+        Retrieve session UUID hash for this L{X2GoSession}.
 
         @return: the session's UUID hash
         @rtype: C{str}
@@ -980,10 +1005,10 @@ class X2goSession(object):
 
     def get_control_session(self):
         &quot;&quot;&quot;\
-        Retrieve the control session (C{X2goControlSession*} backend) of this L{X2goSession}.
+        Retrieve the control session (C{X2GoControlSession*} backend) of this L{X2GoSession}.
 
-        @return: the L{X2goSession}'s control session
-        @rtype: C{X2goControlSession*} instance
+        @return: the L{X2GoSession}'s control session
+        @rtype: C{X2GoControlSession*} instance
 
         &quot;&quot;&quot;
         return self.control_session
@@ -991,9 +1016,9 @@ class X2goSession(object):
 
     def has_control_session(self):
         &quot;&quot;&quot;\
-        Check if this L{X2goSession} instance has an associated control session.
+        Check if this L{X2GoSession} instance has an associated control session.
 
-        @return: returns C{True} if this L{X2goSession} has a control session associated to itself
+        @return: returns C{True} if this L{X2GoSession} has a control session associated to itself
         @rtype: C{bool}
 
         &quot;&quot;&quot;
@@ -1002,10 +1027,10 @@ class X2goSession(object):
 
     def get_terminal_session(self):
         &quot;&quot;&quot;\
-        Retrieve the terminal session (C{X2goTerminalSession*} backend) of this L{X2goSession}.
+        Retrieve the terminal session (C{X2GoTerminalSession*} backend) of this L{X2GoSession}.
 
-        @return: the L{X2goSession}'s terminal session
-        @rtype: C{X2goControlTerminal*} instance
+        @return: the L{X2GoSession}'s terminal session
+        @rtype: C{X2GoControlTerminal*} instance
 
         &quot;&quot;&quot;
         if self.terminal_session == 'PENDING':
@@ -1015,9 +1040,9 @@ class X2goSession(object):
 
     def has_terminal_session(self):
         &quot;&quot;&quot;\
-        Check if this L{X2goSession} instance has an associated terminal session.
+        Check if this L{X2GoSession} instance has an associated terminal session.
 
-        @return: returns C{True} if this L{X2goSession} has a terminal session associated to itself
+        @return: returns C{True} if this L{X2GoSession} has a terminal session associated to itself
         @rtype: C{bool}
 
         &quot;&quot;&quot;
@@ -1029,7 +1054,7 @@ class X2goSession(object):
     def check_host(self):
         &quot;&quot;&quot;\
         Provide a host check mechanism. This method basically calls the L{HOOK_check_host_dialog()} method
-        which by itself calls the L{X2goClient.HOOK_check_host_dialog()} method. Make sure you
+        which by itself calls the L{X2GoClient.HOOK_check_host_dialog()} method. Make sure you
         override any of these to enable user interaction on X2Go server validity checks.
 
         @return: returns C{True} if an X2Go server host is valid for authentication
@@ -1098,7 +1123,7 @@ class X2goSession(object):
 
     def can_auto_connect(self):
         &quot;&quot;&quot;\
-        Check if a session is configured adequately to be able to auto-connect to the X2go
+        Check if a session is configured adequately to be able to auto-connect to the X2Go
         server (e.g. public key authentication).
 
         @return: returns C{True} if the session can auto-connect, C{False} otherwise, C{None}
@@ -1153,8 +1178,8 @@ class X2goSession(object):
                 look_for_keys=None, allow_agent=None,
                 use_sshproxy=None, sshproxy_reuse_authinfo=False, sshproxy_user='', sshproxy_password='', sshproxy_force_password_auth=False):
         &quot;&quot;&quot;\
-        Connects to the L{X2goSession}'s server host. This method basically wraps around 
-        the C{X2goControlSession*.connect()} method.
+        Connects to the L{X2GoSession}'s server host. This method basically wraps around 
+        the C{X2GoControlSession*.connect()} method.
 
         @param username: the username for the X2Go server that is going to be
             connected to (as a last minute way of changing the session username)
@@ -1189,8 +1214,8 @@ class X2goSession(object):
         @return: returns C{True} is the connection to the X2Go server has been successful
         @rtype C{bool}
 
-        @raise X2goSessionException: on control session exceptions
-        @raise X2goRemoteHomeException: if the remote home directory does not exist
+        @raise X2GoSessionException: on control session exceptions
+        @raise X2GoRemoteHomeException: if the remote home directory does not exist
         @raise Exception: any other exception during connecting is passed through
 
         &quot;&quot;&quot;
@@ -1246,9 +1271,9 @@ class X2goSession(object):
                                                               session_instance=self,
                                                               forward_sshagent=self.forward_sshagent,
                                                               **_params)
-            except x2go_exceptions.X2goControlSessionException, e:
-                raise x2go_exceptions.X2goSessionException(str(e))
-            except x2go_exceptions.X2goRemoteHomeException, e:
+            except x2go_exceptions.X2GoControlSessionException, e:
+                raise x2go_exceptions.X2GoSessionException(str(e))
+            except x2go_exceptions.X2GoRemoteHomeException, e:
                 self.disconnect()
                 raise e
             except:
@@ -1280,7 +1305,7 @@ class X2goSession(object):
 
     def disconnect(self):
         &quot;&quot;&quot;\
-        Disconnect this L{X2goSession} instance.
+        Disconnect this L{X2GoSession} instance.
 
         @return: returns C{True} if the disconnect operation has been successful
         @rtype: C{bool}
@@ -1296,7 +1321,7 @@ class X2goSession(object):
         self.unset_master_session()
         try:
             self.update_status(force_update=True)
-        except x2go_exceptions.X2goControlSessionException:
+        except x2go_exceptions.X2GoControlSessionException:
             pass
         retval = self.control_session.disconnect()
         return retval
@@ -1364,7 +1389,7 @@ class X2goSession(object):
         If X2Go client-side printing is enable within this X2Go session you can use
         this method to alter the way how incoming print spool jobs are handled/processed.
 
-        For further information, please refer to the documentation of the L{X2goClient.set_session_print_action()}
+        For further information, please refer to the documentation of the L{X2GoClient.set_session_print_action()}
         method.
 
         @param print_action: one of the named above print actions, either as string or class instance
@@ -1392,7 +1417,7 @@ class X2goSession(object):
         if self.control_session.has_session_died():
             self.HOOK_on_control_session_death()
         if not self.connected:
-            self._X2goSession__disconnect()
+            self._X2GoSession__disconnect()
         return self.connected
     __is_alive = is_alive
 
@@ -1414,7 +1439,7 @@ class X2goSession(object):
 
             self.control_session.clean_sessions(destroy_terminals=destroy_terminals, published_applications=published_applications)
         else:
-            self._X2goSession__disconnect()
+            self._X2GoSession__disconnect()
     __clean_sessions = clean_sessions
 
     def list_sessions(self, raw=False):
@@ -1426,14 +1451,14 @@ class X2goSession(object):
         @type raw: C{bool}
 
         @return: a session list (as data object or list of strings when called with C{raw=True} option)
-        @rtype: C{X2goServerSessionList*} instance or C{list}
+        @rtype: C{X2GoServerSessionList*} instance or C{list}
 
         &quot;&quot;&quot;
         try:
             return self.control_session.list_sessions(raw=raw)
-        except x2go_exceptions.X2goControlSessionException:
-            self.HOOK_on_control_session_death()
-            self._X2goSession__disconnect()
+        except x2go_exceptions.X2GoControlSessionException:
+            if self.connected: self.HOOK_on_control_session_death()
+            self._X2GoSession__disconnect()
             return None
     __list_sessions = list_sessions
 
@@ -1451,9 +1476,12 @@ class X2goSession(object):
         &quot;&quot;&quot;
         try:
             return self.control_session.list_desktops(raw=raw)
-        except x2go_exceptions.X2goControlSessionException:
-            self.HOOK_on_control_session_death()
-            self._X2goSession__disconnect()
+        except x2go_exceptions.X2GoTimeoutException:
+            if self.is_alive(): self.HOOK_list_desktop_timeout()
+            return []
+        except x2go_exceptions.X2GoControlSessionException:
+            if self.connected: self.HOOK_on_control_session_death()
+            self._X2GoSession__disconnect()
             return None
     __list_desktops = list_desktops
 
@@ -1462,7 +1490,7 @@ class X2goSession(object):
         Use the X2Go session registered under C{session_uuid} to
         retrieve its list of mounted client shares for that session.
 
-        @param raw: output the list of mounted client shares in X2go's
+        @param raw: output the list of mounted client shares in X2Go's
             raw C{x2golistmounts} format
         @type raw: C{bool}
 
@@ -1472,29 +1500,29 @@ class X2goSession(object):
         &quot;&quot;&quot;
         try:
             return self.control_session.list_mounts(self.session_name, raw=raw)
-        except x2go_exceptions.X2goControlSessionException:
-            self.HOOK_on_control_session_death()
-            self._X2goSession__disconnect()
+        except x2go_exceptions.X2GoControlSessionException:
+            if self.connected: self.HOOK_on_control_session_death()
+            self._X2GoSession__disconnect()
             return None
     __list_mounts = list_mounts
 
     def update_status(self, session_list=None, force_update=False):
         &quot;&quot;&quot;\
-        Update the current session status. The L{X2goSession} instance uses an internal
+        Update the current session status. The L{X2GoSession} instance uses an internal
         session status cache that allows to query the session status without the need
         of retrieving data from the remote X2Go server for each query.
 
-        The session status (if initialized properly with the L{X2goClient} constructor gets
+        The session status (if initialized properly with the L{X2GoClient} constructor gets
         updated in regularly intervals.
 
-        In case you use the L{X2goSession} class in standalone instances (that is: without
-        being embedded into an L{X2goSession} context) then run this method in regular
-        intervals to make sure the L{X2goSession}'s internal status cache information
+        In case you use the L{X2GoSession} class in standalone instances (that is: without
+        being embedded into an L{X2GoSession} context) then run this method in regular
+        intervals to make sure the L{X2GoSession}'s internal status cache information
         is always up-to-date.
 
-        @param session_list: provide an C{X2goServerSessionList*} that refers to X2Go sessions we want to update.
+        @param session_list: provide an C{X2GoServerSessionList*} that refers to X2Go sessions we want to update.
             This option is mainly for reducing server/client traffic.
-        @type session_list: C{X2goServerSessionList*} instance
+        @type session_list: C{X2GoServerSessionList*} instance
         @param force_update: force a session status update, if if the last update is less then 1 second ago
         @type force_update: C{bool}
 
@@ -1516,7 +1544,7 @@ class X2goSession(object):
             try:
                 session_list = self.control_session.list_sessions()
                 self.connected = True
-            except x2go_exceptions.X2goControlSessionException, e:
+            except x2go_exceptions.X2GoControlSessionException, e:
                 self.connected = False
                 self.running = None
                 self.suspended = None
@@ -1570,19 +1598,6 @@ class X2goSession(object):
         return False
     __is_published_applications_provider = is_published_applications_provider
 
-    def is_desktop_session(self):
-        &quot;&quot;&quot;\
-        Returns true if this session is configured as desktop session.
-
-        @return: returns C{True} if this session is a desktop session.
-        @rtype: C{bool}
-
-        &quot;&quot;&quot;
-        if self.has_terminal_session():
-            return self.terminal_session.is_desktop_session()
-        return False
-    __is_desktop_session = is_desktop_session
-
     def get_published_applications(self, lang=None, refresh=False, raw=False, very_raw=False, max_no_submenus=defaults.PUBAPP_MAX_NO_SUBMENUS):
         &quot;&quot;&quot;\
         Return a list of published menu items from the X2Go server
@@ -1637,7 +1652,7 @@ class X2goSession(object):
         @type all_suspended: C{bool}
         @param start: is no session is to be resumed, start a new session
         @type start: C{bool}
-        @param redirect_to_client: redirect this call to the L{X2goClient} instance (if available) to allow frontend interaction
+        @param redirect_to_client: redirect this call to the L{X2GoClient} instance (if available) to allow frontend interaction
         @type redirect_to_client: C{bool}
 
         @return: returns success (or failure) of starting/resuming this sessions
@@ -1658,10 +1673,13 @@ class X2goSession(object):
                         del session_infos[session_name]
 
                 if session_infos:
+                    sorted_session_names = utils.session_names_by_timestamp(session_infos)
                     if newest:
-                        return self.resume(session_name=utils.session_names_by_timestamp(session_infos)[-1])
+                        if sorted_session_names[0].find('RDP') == -1:
+                            return self.resume(session_name=sorted_session_names[-1])
                     elif oldest:
-                        return self.resume(session_name=utils.session_names_by_timestamp(session_infos)[-1])
+                        if sorted_session_names[-1].find('RDP') == -1:
+                            return self.resume(session_name=sorted_session_names[0])
                     elif all_suspended:
                         for session_name in [ _sn for _sn in session_infos.keys() if session_infos[_sn].is_suspended() ]:
                             return self.resume(session_name=session_name)
@@ -1785,7 +1803,7 @@ class X2goSession(object):
                     self._progress_status = 15
                     progress_event.set()
 
-                except x2go_exceptions.X2goSessionException:
+                except x2go_exceptions.X2GoSessionException:
                     pass
 
             self._progress_status = 20
@@ -1851,7 +1869,7 @@ class X2goSession(object):
                        (self._SUPPORTED_MIMEBOX and self.allow_mimebox) or \
                        (self._SUPPORTED_FOLDERSHARING and self.allow_share_local_folders):
                         self.has_terminal_session() and not self.faulty and self.terminal_session.start_sshfs()
-                except x2go_exceptions.X2goUserException, e:
+                except x2go_exceptions.X2GoUserException, e:
                     self.logger('%s' % str(e), loglevel=log.loglevel_WARN)
                     self.HOOK_sshfs_not_available()
                     self._SUPPORTED_PRINTING = False
@@ -1865,7 +1883,7 @@ class X2goSession(object):
                     try:
                         self.has_terminal_session() and not self.faulty and self.terminal_session.start_printing()
                         self.has_terminal_session() and not self.faulty and self.session_environment.update({'X2GO_SPOOLDIR': self.terminal_session.get_printing_spooldir(), })
-                    except x2go_exceptions.X2goUserException, e:
+                    except x2go_exceptions.X2GoUserException, e:
                         self.logger('%s' % str(e), loglevel=log.loglevel_WARN)
                         self.HOOK_printing_not_available()
                         self._SUPPORTED_PRINTING = False
@@ -1877,7 +1895,7 @@ class X2goSession(object):
                     try:
                         self.has_terminal_session() and not self.faulty and self.terminal_session.start_mimebox(mimebox_extensions=self.mimebox_extensions, mimebox_action=self.mimebox_action)
                         self.has_terminal_session() and self.session_environment.update({'X2GO_MIMEBOX': self.terminal_session.get_mimebox_spooldir(), })
-                    except x2go_exceptions.X2goUserException, e:
+                    except x2go_exceptions.X2GoUserException, e:
                         self.logger('%s' % str(e), loglevel=log.loglevel_WARN)
                         self.HOOK_mimebox_not_available()
                         self._SUPPORTED_MIMEBOX = False
@@ -1923,9 +1941,8 @@ class X2goSession(object):
             self._progress_status = -1
             progress_event.set()
 
-            self._X2goSession__disconnect()
+            self._X2GoSession__disconnect()
             return False
-
     __resume = resume
 
     def start(self, cmd=None, progress_event=None):
@@ -1971,8 +1988,8 @@ class X2goSession(object):
         @return: returns C{True} if starting the session has been successful, C{False} otherwise
         @rtype: C{bool}
 
-        @raise X2goDesktopSharingException: if the given desktop ID is not an available desktop session on the remote server
-        @raise X2goSessionException: if the available desktop session appears to be dead, in fact
+        @raise X2GoDesktopSharingException: if the given desktop ID is not an available desktop session on the remote server
+        @raise X2GoSessionException: if the available desktop session appears to be dead, in fact
 
         &quot;&quot;&quot;
         self._lock.acquire()
@@ -2009,8 +2026,8 @@ class X2goSession(object):
         @return: returns C{True} if starting the session has been successful, C{False} otherwise
         @rtype: C{bool}
 
-        @raise X2goDesktopSharingException: if the given desktop ID is not an available desktop session on the remote server
-        @raise X2goSessionException: if the available desktop session appears to be dead, in fact
+        @raise X2GoDesktopSharingException: if the given desktop ID is not an available desktop session on the remote server
+        @raise X2GoSessionException: if the available desktop session appears to be dead, in fact
 
         &quot;&quot;&quot;
         self.terminal_session = 'PENDING'
@@ -2026,11 +2043,15 @@ class X2goSession(object):
 
         _desktop = desktop or '%s@%s' % (user, display)
         if check_desktop_list:
-            if not _desktop in self._X2goSession__list_desktops():
+            desktop_list = self._X2GoSession__list_desktops()
+            if not _desktop in desktop_list:
                 _orig_desktop = _desktop
                 _desktop = '%s.0' % _desktop
-                if not _desktop in self._X2goSession__list_desktops():
-                    raise x2go_exceptions.X2goDesktopSharingException('No such desktop ID: %s' % _orig_desktop)
+                if not _desktop in desktop_list:
+                    self.HOOK_no_such_desktop(desktop=_orig_desktop)
+                    self._progress_status = -1
+                    progress_event.set()
+                    return False
 
         self._progress_status = 33
         progress_event.set()
@@ -2055,12 +2076,12 @@ class X2goSession(object):
 
             except ValueError:
                 # x2gostartagent output parsing will result in a ValueError. This one we will catch
-                # here and change it into an X2goSessionException
+                # here and change it into an X2GoSessionException
 
                 self._progress_status = -1
                 progress_event.set()
 
-                raise x2go_exceptions.X2goSessionException('the session on desktop %s is seemingly dead' % _desktop)
+                raise x2go_exceptions.X2GoSessionException('the session on desktop %s is seemingly dead' % _desktop)
 
             self._progress_status = 90
             progress_event.set()
@@ -2093,11 +2114,59 @@ class X2goSession(object):
             self._progress_status = -1
             progress_event.set()
 
-            self._X2goSession__disconnect()
+            self._X2GoSession__disconnect()
 
         return False
     __share_desktop = share_desktop
 
+    def is_desktop_session(self):
+        &quot;&quot;&quot;\
+        Test if this X2Go session is a desktop session.
+
+        @return: C{True} if this session is of session type desktop ('D').
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        if self.has_terminal_session():
+            return self.terminal_session.is_desktop_session()
+    __is_desktop_session = is_desktop_session
+
+    def is_rootless_session(self):
+        &quot;&quot;&quot;\
+        Test if this X2Go session is a rootless session.
+
+        @return: C{True} if this session is of session type rootless ('R').
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        if self.has_terminal_session():
+            return self.terminal_session.is_rootless_session()
+    __is_rootless_session = is_rootless_session
+
+    def is_shadow_session(self):
+        &quot;&quot;&quot;\
+        Test if this X2Go session is a desktop sharing (aka shadow) session.
+
+        @return: C{True} if this session is of session type shadow ('S').
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        if self.has_terminal_session():
+            return self.terminal_session.is_shadow_session()
+    __is_shadow_session = is_shadow_session
+
+    def is_pubapp_session(self):
+        &quot;&quot;&quot;\
+        Test if this X2Go session is a published applications session.
+
+        @return: C{True} if this session is of session type published applications ('P').
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        if self.has_terminal_session():
+            return self.terminal_session.is_pubapp_session()
+    __is_pubapp_session = is_pubapp_session
+
     def suspend(self):
         &quot;&quot;&quot;\
         Suspend this X2Go session.
@@ -2105,7 +2174,7 @@ class X2goSession(object):
         @return: returns C{True} if suspending the session has been successful, C{False} otherwise
         @rtype: C{bool}
 
-        @raise X2goSessionException: if the session could not be suspended
+        @raise X2GoSessionException: if the session could not be suspended
 
         &quot;&quot;&quot;
         self._lock.acquire()
@@ -2125,7 +2194,7 @@ class X2goSession(object):
         @return: returns C{True} if suspending the session has been successful, C{False} otherwise
         @rtype: C{bool}
 
-        @raise X2goSessionException: if the session could not be suspended
+        @raise X2GoSessionException: if the session could not be suspended
 
         &quot;&quot;&quot;
         if self.is_alive():
@@ -2161,10 +2230,10 @@ class X2goSession(object):
                     return True
 
             else:
-                raise x2go_exceptions.X2goSessionException('cannot suspend session')
+                raise x2go_exceptions.X2GoSessionException('cannot suspend session')
 
         else:
-            self._X2goSession__disconnect()
+            self._X2GoSession__disconnect()
 
         return False
     __suspend = suspend
@@ -2176,7 +2245,7 @@ class X2goSession(object):
         @return: returns C{True} if terminating the session has been successful, C{False} otherwise
         @rtype: C{bool}
 
-        @raise X2goSessionException: if the session could not be terminated
+        @raise X2GoSessionException: if the session could not be terminated
 
         &quot;&quot;&quot;
         self._lock.acquire()
@@ -2196,7 +2265,7 @@ class X2goSession(object):
         @return: returns C{True} if terminating the session has been successful, C{False} otherwise
         @rtype: C{bool}
 
-        @raise X2goSessionException: if the session could not be terminated
+        @raise X2GoSessionException: if the session could not be terminated
 
         &quot;&quot;&quot;
         if self.is_alive():
@@ -2231,17 +2300,17 @@ class X2goSession(object):
                     self.session_cleanup()
                     return True
             else:
-                raise x2go_exceptions.X2goSessionException('cannot terminate session')
+                raise x2go_exceptions.X2GoSessionException('cannot terminate session')
 
         else:
-            self._X2goSession__disconnect()
+            self._X2GoSession__disconnect()
 
         return False
     __terminate = terminate
 
     def get_profile_name(self):
         &quot;&quot;&quot;\
-        Retrieve the profile name of this L{X2goSession} instance.
+        Retrieve the profile name of this L{X2GoSession} instance.
 
         @return: X2Go client profile name of the session
         @rtype: C{str}
@@ -2252,7 +2321,7 @@ class X2goSession(object):
 
     def get_profile_id(self):
         &quot;&quot;&quot;\
-        Retrieve the profile ID of this L{X2goSession} instance.
+        Retrieve the profile ID of this L{X2GoSession} instance.
 
         @return: the session profile's id
         @rtype: C{str}
@@ -2267,7 +2336,7 @@ class X2goSession(object):
 
     def session_ok(self):
         &quot;&quot;&quot;\
-        Test if this C{X2goSession} is
+        Test if this C{X2GoSession} is
         in a healthy state.
 
         @return: C{True} if session is ok, C{False} otherwise
@@ -2304,7 +2373,7 @@ class X2goSession(object):
 
     def is_connected(self):
         &quot;&quot;&quot;\
-        Test if the L{X2goSession}'s control session is connected to the 
+        Test if the L{X2GoSession}'s control session is connected to the 
         remote X2Go server.
 
         @return: C{True} if session is connected, C{False} otherwise
@@ -2322,7 +2391,7 @@ class X2goSession(object):
 
     def is_running(self, update_status=False):
         &quot;&quot;&quot;\
-        Test if the L{X2goSession}'s terminal session is up and running.
+        Test if the L{X2GoSession}'s terminal session is up and running.
 
         @return: C{True} if session is running, C{False} otherwise
         @rtype: C{bool}
@@ -2344,7 +2413,7 @@ class X2goSession(object):
 
     def is_suspended(self, update_status=False):
         &quot;&quot;&quot;\
-        Test if the L{X2goSession}'s terminal session is in suspended state.
+        Test if the L{X2GoSession}'s terminal session is in suspended state.
 
         @return: C{True} if session is suspended, C{False} otherwise
         @rtype: C{bool}
@@ -2366,7 +2435,7 @@ class X2goSession(object):
 
     def has_terminated(self, update_status=False):
         &quot;&quot;&quot;\
-        Test if the L{X2goSession}'s terminal session has terminated.
+        Test if the L{X2GoSession}'s terminal session has terminated.
 
         @return: C{True} if session has terminated, C{False} otherwise
         @rtype: C{bool}
@@ -2432,7 +2501,7 @@ class X2goSession(object):
             this X2Go session
         @rtype: C{bool}
 
-        @raise X2goSessionException: if this L{X2goSession} does not have an associated terminal session
+        @raise X2GoSessionException: if this L{X2GoSession} does not have an associated terminal session
 
         &quot;&quot;&quot;
         # compat for Python-X2Go (&lt;=0.1.1.6)
@@ -2466,7 +2535,7 @@ class X2goSession(object):
                             self._restore_exported_folders[local_path] = False
 
         else:
-            raise x2go_exceptions.X2goSessionException('this X2goSession object does not have any associated terminal')
+            raise x2go_exceptions.X2GoSessionException('this X2GoSession object does not have any associated terminal')
         return retval
 
     __share_local_folder = share_local_folder
@@ -2491,7 +2560,7 @@ class X2goSession(object):
                     for _folder in self.share_local_folders:
                         try:
                             retval = self.share_local_folder(_folder, update_exported_folders=False) and retval
-                        except x2go_exceptions.X2goUserException, e:
+                        except x2go_exceptions.X2GoUserException, e:
                             retval = False
                             self.logger('%s' % str(e), loglevel=log.loglevel_WARN)
                     if update_exported_folders:
@@ -2516,7 +2585,7 @@ class X2goSession(object):
             inside this X2Go session
         @rtype: C{bool}
 
-        @raise X2goSessionException: if this L{X2goSession} does not have an associated terminal session
+        @raise X2GoSessionException: if this L{X2GoSession} does not have an associated terminal session
 
         &quot;&quot;&quot;
         retval = False
@@ -2535,7 +2604,7 @@ class X2goSession(object):
                     self.shared_folders[local_path]['status'] = 'mounted'
 
         else:
-            raise x2go_exceptions.X2goSessionException('this X2goSession object does not have any associated terminal')
+            raise x2go_exceptions.X2GoSessionException('this X2GoSession object does not have any associated terminal')
 
         return retval
     __unshare_local_folder = unshare_local_folder
@@ -2554,7 +2623,7 @@ class X2goSession(object):
             inside this X2Go session
         @rtype: C{bool}
 
-        @raise X2goSessionException: if this L{X2goSession} does not have an associated terminal session
+        @raise X2GoSessionException: if this L{X2GoSession} does not have an associated terminal session
 
         &quot;&quot;&quot;
         if self.has_terminal_session():
@@ -2574,7 +2643,7 @@ class X2goSession(object):
                         self._update_restore_exported_folders()
                     return retval
         else:
-            raise x2go_exceptions.X2goSessionException('this X2goSession object does not have any associated terminal')
+            raise x2go_exceptions.X2GoSessionException('this X2GoSession object does not have any associated terminal')
         return False
     __unshare_all_local_folders = unshare_all_local_folders
 
diff --git a/x2go/sftpserver.py b/x2go/sftpserver.py
index 839f664..02f90a2 100644
--- a/x2go/sftpserver.py
+++ b/x2go/sftpserver.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 
 # The Python X2Go sFTPServer code was originally written by Richard Murri, 
 # for further information see his website: <A HREF="http://www.richardmurri.com">http://www.richardmurri.com</A>
@@ -22,7 +22,7 @@
 
 &quot;&quot;&quot;\
 For sharing local folders via sFTP/sshfs Python X2Go implements its own sFTP 
-server (as end point of reverse forwarding tunnel requests). Thus, Python X2go
+server (as end point of reverse forwarding tunnel requests). Thus, Python X2Go
 does not need a locally installed SSH daemon on the client side machine.
 
 The Python X2Go sFTP server code was originally written by Richard Murri, 
@@ -55,17 +55,17 @@ class _SSHServer(paramiko.ServerInterface):
 
         @param auth_key: Server key that the client has to authenticate against
         @type auth_key: C{paramiko.RSAKey} instance
-        @param session_instance: the calling L{X2goSession} instance
-        @type session_instance: L{X2goSession} instance
-        @param logger: you can pass an L{X2goLogger} object to the L{X2goClientXConfig} constructor
+        @param session_instance: the calling L{X2GoSession} instance
+        @type session_instance: L{X2GoSession} instance
+        @param logger: you can pass an L{X2GoLogger} object to the L{X2GoClientXConfig} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -162,9 +162,9 @@ class _SFTPServerInterface(paramiko.SFTPServerInterface):
         @type server: C{paramiko.ServerInterface} instance
         @param chroot: chroot environment for this SFTP interface
         @type chroot: C{str}
-        @param logger: you can pass an L{X2goLogger} object to the L{X2goClientXConfig} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the L{X2GoClientXConfig} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
         @param server_event: a C{threading.Event} instance that can signal SFTP session termination
@@ -172,7 +172,7 @@ class _SFTPServerInterface(paramiko.SFTPServerInterface):
 
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -490,7 +490,7 @@ class _SFTPServerInterface(paramiko.SFTPServerInterface):
             self.server_event.set()
 
 
-class X2goRevFwTunnelToSFTP(rforward.X2goRevFwTunnel):
+class X2GoRevFwTunnelToSFTP(rforward.X2GoRevFwTunnel):
     &quot;&quot;&quot;\
     A reverse fowarding tunnel with an sFTP server at its endpoint. This blend of a Paramiko/SSH
     reverse forwarding tunnel is used to provide access to local X2Go client folders
@@ -505,22 +505,22 @@ class X2goRevFwTunnelToSFTP(rforward.X2goRevFwTunnel):
         @param server_port: the TCP/IP port on the X2Go server (starting point of the tunnel), 
             normally some number above 30000
         @type server_port: C{int}
-        @param ssh_transport: the L{X2goSession}'s Paramiko/SSH transport instance
+        @param ssh_transport: the L{X2GoSession}'s Paramiko/SSH transport instance
         @type ssh_transport: C{paramiko.Transport} instance
         @param auth_key: Paramiko/SSH RSAkey object that has to be authenticated against by
             the remote sFTP client
         @type auth_key: C{paramiko.RSAKey} instance
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goRevFwTunnelToSFTP} constructor
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoRevFwTunnelToSFTP} constructor
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
         &quot;&quot;&quot;
         self.ready = False
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -541,22 +541,22 @@ class X2goRevFwTunnelToSFTP(rforward.X2goRevFwTunnel):
 
     def run(self):
         &quot;&quot;&quot;\
-        This method gets run once an L{X2goRevFwTunnelToSFTP} has been started with its
-        L{start()} method. Use L{X2goRevFwTunnelToSFTP}.stop_thread() to stop the
+        This method gets run once an L{X2GoRevFwTunnelToSFTP} has been started with its
+        L{start()} method. Use L{X2GoRevFwTunnelToSFTP}.stop_thread() to stop the
         reverse forwarding tunnel again (refer also to its pause() and resume() method).
 
-        L{X2goRevFwTunnelToSFTP.run()} waits for notifications of an appropriate incoming
-        Paramiko/SSH channel (issued by L{X2goRevFwTunnelToSFTP.notify()}). Appropriate in
+        L{X2GoRevFwTunnelToSFTP.run()} waits for notifications of an appropriate incoming
+        Paramiko/SSH channel (issued by L{X2GoRevFwTunnelToSFTP.notify()}). Appropriate in
         this context means, that its starting point on the X2Go server matches the class's
         property C{server_port}.
 
         Once a new incoming channel gets announced by the L{notify()} method, a new 
-        L{X2goRevFwSFTPChannelThread} instance will be initialized. As a data stream handler,
+        L{X2GoRevFwSFTPChannelThread} instance will be initialized. As a data stream handler,
         the function L{x2go_rev_forward_sftpchannel_handler()} will be used.
 
         The channel will last till the connection gets dropped on the X2Go server side or 
-        until the tunnel gets paused by an L{X2goRevFwTunnelToSFTP.pause()} call or 
-        stopped via the C{X2goRevFwTunnelToSFTP.stop_thread()} method.
+        until the tunnel gets paused by an L{X2GoRevFwTunnelToSFTP.pause()} call or 
+        stopped via the C{X2GoRevFwTunnelToSFTP.stop_thread()} method.
 
         &quot;&quot;&quot;
         self._request_port_forwarding()
@@ -577,7 +577,7 @@ class X2goRevFwTunnelToSFTP(rforward.X2goRevFwTunnel):
 
             self.incoming_channel.release()
             if self._accept_channels and self._keepalive:
-                _new_chan_thread = X2goRevFwSFTPChannelThread(_chan,
+                _new_chan_thread = X2GoRevFwSFTPChannelThread(_chan,
                                                               target=x2go_rev_forward_sftpchannel_handler, 
                                                               kwargs={ 
                                                                'chan': _chan,
@@ -592,15 +592,15 @@ class X2goRevFwTunnelToSFTP(rforward.X2goRevFwTunnel):
 
 def x2go_rev_forward_sftpchannel_handler(chan=None, auth_key=None, logger=None):
     &quot;&quot;&quot;\
-    Handle incoming sFTP channels that got setup by an L{X2goRevFwTunnelToSFTP} instance.
+    Handle incoming sFTP channels that got setup by an L{X2GoRevFwTunnelToSFTP} instance.
 
     The channel (and the corresponding connections) close either ...
 
         - ... if the connecting application closes the connection and thus, drops 
         the sFTP channel, or
-        - ... if the L{X2goRevFwTunnelToSFTP} parent thread gets paused. The call
-        of L{X2goRevFwTunnelToSFTP.pause()} on the instance can be used to shut down all incoming 
-        tunneled SSH connections associated to this L{X2goRevFwTunnelToSFTP} instance
+        - ... if the L{X2GoRevFwTunnelToSFTP} parent thread gets paused. The call
+        of L{X2GoRevFwTunnelToSFTP.pause()} on the instance can be used to shut down all incoming 
+        tunneled SSH connections associated to this L{X2GoRevFwTunnelToSFTP} instance
         from within a Python X2Go application.
 
     @param chan: an incoming sFTP channel
@@ -608,8 +608,8 @@ def x2go_rev_forward_sftpchannel_handler(chan=None, auth_key=None, logger=None):
     @param auth_key: Paramiko/SSH RSAkey object that has to be authenticated against by
         the remote sFTP client
     @type auth_key: C{paramiko.RSAKey} instance
-    @param logger: you must pass an L{X2goLogger} object to this handler method
-    @type logger: C{X2goLogger} instance
+    @param logger: you must pass an L{X2GoLogger} object to this handler method
+    @type logger: C{X2GoLogger} instance
 
     &quot;&quot;&quot;
     if logger is None:
@@ -643,5 +643,5 @@ def x2go_rev_forward_sftpchannel_handler(chan=None, auth_key=None, logger=None):
     logger('sFTP channel %s closed down' % chan, loglevel=log.loglevel_DEBUG)
 
 
-class X2goRevFwSFTPChannelThread(rforward.X2goRevFwChannelThread): pass
-&quot;&quot;&quot;A clone of L{rforward.X2goRevFwChannelThread}.&quot;&quot;&quot;
+class X2GoRevFwSFTPChannelThread(rforward.X2GoRevFwChannelThread): pass
+&quot;&quot;&quot;A clone of L{rforward.X2GoRevFwChannelThread}.&quot;&quot;&quot;
diff --git a/x2go/sshproxy.py b/x2go/sshproxy.py
index df50f2b..7bdb5e5 100644
--- a/x2go/sshproxy.py
+++ b/x2go/sshproxy.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -18,7 +18,7 @@
 # 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 
 &quot;&quot;&quot;\
-L{X2goSSHProxy} class - providing a forwarding tunnel for connecting to servers behind firewalls.
+L{X2GoSSHProxy} class - providing a forwarding tunnel for connecting to servers behind firewalls.
 
 &quot;&quot;&quot;
 __NAME__ = 'x2gosshproxy-pylib'
@@ -47,9 +47,9 @@ from x2go.defaults import X2GO_SSH_ROOTDIR as _X2GO_SSH_ROOTDIR
 import x2go._paramiko
 x2go._paramiko.monkey_patch_paramiko()
 
-class X2goSSHProxy(paramiko.SSHClient, threading.Thread):
+class X2GoSSHProxy(paramiko.SSHClient, threading.Thread):
     &quot;&quot;&quot;\
-    X2goSSHProxy can be used to proxy X2Go connections through a firewall via SSH.
+    X2GoSSHProxy can be used to proxy X2Go connections through a firewall via SSH.
 
     &quot;&quot;&quot;
     fw_tunnel = None
@@ -65,7 +65,7 @@ class X2goSSHProxy(paramiko.SSHClient, threading.Thread):
                  session_instance=None,
                  logger=None, loglevel=log.loglevel_DEFAULT, ):
         &quot;&quot;&quot;\
-        Initialize an X2goSSHProxy instance. Use an instance of this class to tunnel X2Go requests through
+        Initialize an X2GoSSHProxy instance. Use an instance of this class to tunnel X2Go requests through
         a proxying SSH server (i.e. to subLANs that are separated by firewalls or to private IP subLANs that
         are NATted behind routers).
 
@@ -125,20 +125,20 @@ class X2goSSHProxy(paramiko.SSHClient, threading.Thread):
 
         @param ssh_rootdir: local user's SSH base directory (default: ~/.ssh)
         @type ssh_rootdir: C{str}
-        @param session_instance: the L{X2goSession} instance that builds up this SSH proxying tunnel
-        @type session_instance: L{X2goSession} instance
-        @param logger: you can pass an L{X2goLogger} object to the
-            L{X2goSSHProxy} constructor
-        @type logger: L{X2goLogger} instance
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param session_instance: the L{X2GoSession} instance that builds up this SSH proxying tunnel
+        @type session_instance: L{X2GoSession} instance
+        @param logger: you can pass an L{X2GoLogger} object to the
+            L{X2GoSSHProxy} constructor
+        @type logger: L{X2GoLogger} instance
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: int
 
-        @raise X2goSSHProxyAuthenticationException: if the SSH proxy caused a C{paramiko.AuthenticationException}
-        @raise X2goSSHProxyException: if the SSH proxy caused a C{paramiko.SSHException}
+        @raise X2GoSSHProxyAuthenticationException: if the SSH proxy caused a C{paramiko.AuthenticationException}
+        @raise X2GoSSHProxyException: if the SSH proxy caused a C{paramiko.SSHException}
         &quot;&quot;&quot;
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -147,7 +147,7 @@ class X2goSSHProxy(paramiko.SSHClient, threading.Thread):
 
         if sshproxy_port: self.port = sshproxy_port
 
-        # translate between X2goSession options and paramiko.SSHCLient.connect() options
+        # translate between X2GoSession options and paramiko.SSHCLient.connect() options
         # if &lt;hostname&gt;:&lt;port&gt; is used for sshproxy_host, then this &lt;port&gt; is used
         if sshproxy_host:
             if sshproxy_host.find(':'):
@@ -207,7 +207,7 @@ class X2goSSHProxy(paramiko.SSHClient, threading.Thread):
             self.load_host_keys(self.known_hosts)
 
         if not add_to_known_hosts and session_instance:
-            self.set_missing_host_key_policy(checkhosts.X2goInteractiveAddPolicy(caller=self, session_instance=session_instance))
+            self.set_missing_host_key_policy(checkhosts.X2GoInteractiveAddPolicy(caller=self, session_instance=session_instance))
 
         if add_to_known_hosts:
             self.set_missing_host_key_policy(paramiko.AutoAddPolicy())
@@ -241,10 +241,10 @@ class X2goSSHProxy(paramiko.SSHClient, threading.Thread):
 
                 except x2go_exceptions.AuthenticationException, e:
                     self.close()
-                    raise x2go_exceptions.X2goSSHProxyAuthenticationException('pubkey auth mechanisms both failed')
+                    raise x2go_exceptions.X2GoSSHProxyAuthenticationException('pubkey auth mechanisms both failed')
                 except x2go_exceptions.SSHException, e:
                     self.close()
-                    raise x2go_exceptions.X2goSSHProxyAuthenticationException('interactive authentication required')
+                    raise x2go_exceptions.X2GoSSHProxyAuthenticationException('interactive authentication required')
                 except:
                     raise
 
@@ -267,14 +267,14 @@ class X2goSSHProxy(paramiko.SSHClient, threading.Thread):
                                 )
                 except x2go_exceptions.AuthenticationException:
                     self.close()
-                    raise x2go_exceptions.X2goSSHProxyAuthenticationException('interactive auth mechanisms failed')
+                    raise x2go_exceptions.X2GoSSHProxyAuthenticationException('interactive auth mechanisms failed')
                 except:
                     self.close()
                     raise
 
         except (x2go_exceptions.SSHException, IOError), e:
             self.close()
-            raise x2go_exceptions.X2goSSHProxyException(str(e))
+            raise x2go_exceptions.X2GoSSHProxyException(str(e))
         except:
             self.close()
             raise
@@ -288,7 +288,6 @@ class X2goSSHProxy(paramiko.SSHClient, threading.Thread):
         Wraps around a Paramiko/SSH host key check.
 
         &quot;&quot;&quot;
-        # hostname rewrite for localhost, force to IPv4
         _hostname = self.hostname
 
         # force into IPv4 for localhost connections
@@ -298,14 +297,14 @@ class X2goSSHProxy(paramiko.SSHClient, threading.Thread):
         _valid = False
         (_valid, _hostname, _port, _fingerprint, _fingerprint_type) = checkhosts.check_ssh_host_key(self, _hostname, port=self.port)
         if not _valid and self.session_instance:
-            _valid = self.session_instance.HOOK_check_host_dialog(_hostname, _port, fingerprint=_fingerprint, fingerprint_type=_fingerprint_type)
+            _valid = self.session_instance.HOOK_check_host_dialog(self.remote_host, self.remote_port, fingerprint=_fingerprint, fingerprint_type=_fingerprint_type)
         return _valid
 
     def run(self):
         &quot;&quot;&quot;\
         Start the SSH proxying tunnel...
 
-        @raise X2goSSHProxyException: if the SSH proxy could not retrieve an SSH transport for proxying a X2Go server-client connection
+        @raise X2GoSSHProxyException: if the SSH proxy could not retrieve an SSH transport for proxying a X2Go server-client connection
 
         &quot;&quot;&quot;
         if self.get_transport() is not None and self.get_transport().is_authenticated():
@@ -332,7 +331,17 @@ class X2goSSHProxy(paramiko.SSHClient, threading.Thread):
                 gevent.sleep(.1)
 
         else:
-            raise x2go_exceptions.X2goSSHProxyException('SSH proxy connection could not retrieve an SSH transport')
+            raise x2go_exceptions.X2GoSSHProxyException('SSH proxy connection could not retrieve an SSH transport')
+
+    def get_local_proxy_host(self):
+        &quot;&quot;&quot;\
+        Retrieve the local IP socket address this SSH proxying tunnel is (about to) bind/bound to.
+
+        @return: local IP socket address
+        @rtype: C{str}
+
+        &quot;&quot;&quot;
+        return self.local_host
 
     def get_local_proxy_port(self):
         &quot;&quot;&quot;\
@@ -344,6 +353,26 @@ class X2goSSHProxy(paramiko.SSHClient, threading.Thread):
         &quot;&quot;&quot;
         return self.local_port
 
+    def get_remote_host(self):
+        &quot;&quot;&quot;\
+        Retrieve the remote IP socket address at the remote end of the SSH proxying tunnel.
+
+        @return: remote IP socket address
+        @rtype: C{str}
+
+        &quot;&quot;&quot;
+        return self.remote_host
+
+    def get_remote_port(self):
+        &quot;&quot;&quot;\
+        Retrieve the remote IP socket port of the target system's SSH daemon.
+
+        @return: remote SSH port
+        @rtype: C{int}
+
+        &quot;&quot;&quot;
+        return self.remote_port
+
     def stop_thread(self):
         &quot;&quot;&quot;\
         Tear down the SSH proxying tunnel.
diff --git a/x2go/tests/test_printing.py b/x2go/tests/test_printing.py
index 77dba3b..8ac6487 100644
--- a/x2go/tests/test_printing.py
+++ b/x2go/tests/test_printing.py
@@ -23,7 +23,7 @@ import tempfile
 # Python X2Go modules
 import x2go
 
-class TestX2goClientPrinting(unittest.TestCase):
+class TestX2GoClientPrinting(unittest.TestCase):
 
     def test_client_printing_dialog(self):
         _printing = &quot;&quot;&quot;\
@@ -42,8 +42,8 @@ defaultprinter=PDF
         tf = tempfile.NamedTemporaryFile()
         print &gt;&gt; tf, _printing
         tf.seek(0)
-        p_action = x2go.backends.printing.X2goClientPrinting(config_files=tf.name, client_instance='DUMMY')
-        self.assertEqual(type(p_action.print_action), x2go.printactions.X2goPrintActionDIALOG)
+        p_action = x2go.backends.printing.X2GoClientPrinting(config_files=tf.name, client_instance='DUMMY')
+        self.assertEqual(type(p_action.print_action), x2go.printactions.X2GoPrintActionDIALOG)
         tf.close()
 
     def test_client_printing_pdfview(self):
@@ -62,8 +62,8 @@ defaultprinter=PDF
         tf = tempfile.NamedTemporaryFile()
         print &gt;&gt; tf, _printing
         tf.seek(0)
-        p_action = x2go.backends.printing.X2goClientPrinting(config_files=tf.name)
-        self.assertEqual(type(p_action.print_action), x2go.printactions.X2goPrintActionPDFVIEW)
+        p_action = x2go.backends.printing.X2GoClientPrinting(config_files=tf.name)
+        self.assertEqual(type(p_action.print_action), x2go.printactions.X2GoPrintActionPDFVIEW)
         tf.close()
 
     def test_client_printing_pdfsave(self):
@@ -82,8 +82,8 @@ defaultprinter=PDF
         tf = tempfile.NamedTemporaryFile()
         print &gt;&gt; tf, _printing
         tf.seek(0)
-        p_action = x2go.backends.printing.X2goClientPrinting(config_files=tf.name)
-        self.assertEqual(type(p_action.print_action), x2go.printactions.X2goPrintActionPDFSAVE)
+        p_action = x2go.backends.printing.X2GoClientPrinting(config_files=tf.name)
+        self.assertEqual(type(p_action.print_action), x2go.printactions.X2GoPrintActionPDFSAVE)
         tf.close()
 
     def test_client_printing_print(self):
@@ -102,8 +102,8 @@ defaultprinter=PDF
         tf = tempfile.NamedTemporaryFile()
         print &gt;&gt; tf, _printing
         tf.seek(0)
-        p_action = x2go.backends.printing.X2goClientPrinting(config_files=tf.name)
-        self.assertEqual(type(p_action.print_action), x2go.printactions.X2goPrintActionPRINT)
+        p_action = x2go.backends.printing.X2GoClientPrinting(config_files=tf.name)
+        self.assertEqual(type(p_action.print_action), x2go.printactions.X2GoPrintActionPRINT)
         tf.close()
 
     def test_client_printing_printcmd(self):
@@ -122,12 +122,12 @@ defaultprinter=PDF
         tf = tempfile.NamedTemporaryFile()
         print &gt;&gt; tf, _printing
         tf.seek(0)
-        p_action = x2go.backends.printing.X2goClientPrinting(config_files=tf.name)
-        self.assertEqual(type(p_action.print_action), x2go.printactions.X2goPrintActionPRINTCMD)
+        p_action = x2go.backends.printing.X2GoClientPrinting(config_files=tf.name)
+        self.assertEqual(type(p_action.print_action), x2go.printactions.X2GoPrintActionPRINTCMD)
         tf.close()
 
 def test_suite():
     from unittest import TestSuite, makeSuite
     suite = TestSuite()
-    suite.addTest(makeSuite(TestX2goClientPrinting))
+    suite.addTest(makeSuite(TestX2GoClientPrinting))
     return suite
diff --git a/x2go/utils.py b/x2go/utils.py
index ab98120..03fd9a8 100644
--- a/x2go/utils.py
+++ b/x2go/utils.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -163,7 +163,7 @@ def _convert_SessionProfileOptions_2_SessionParams(options):
     @param options: a dictionary of options, parameter names as in the X2Go ,,sessions'' file
     @type options: C{dict}
 
-    @return: session options as used in C{X2goSession} instances
+    @return: session options as used in C{X2GoSession} instances
     @rtype: C{dict}
 
     &quot;&quot;&quot;
@@ -205,7 +205,6 @@ def _convert_SessionProfileOptions_2_SessionParams(options):
             'sshproxyport': 'sshproxy_port',
             'sshproxyuser': 'sshproxy_user',
             'sshproxykeyfile': 'sshproxy_key_filename',
-            'sshproxytunnel': 'sshproxy_tunnel',
             'sessiontitle': 'session_title',
             'setsessiontitle': 'set_session_title',
             'published': 'published_applications',
@@ -214,6 +213,7 @@ def _convert_SessionProfileOptions_2_SessionParams(options):
             'forwardsshagent': 'forward_sshagent',
             'autologin': 'look_for_keys',
             'sshproxyautologin': 'sshproxy_look_for_keys',
+            'uniquehostkeyaliases': 'unique_hostkey_aliases',
     }
     _speed_dict = {
             '0': 'modem',
@@ -328,7 +328,20 @@ def _convert_SessionProfileOptions_2_SessionParams(options):
         _params['sshproxy_key_filename'] = _params['key_filename']
     del _params['sshproxysamepass']
 
-    # currently known but ignored in Python X2go
+    if _params['use_sshproxy']:
+
+        # compat code for Python X2Go 0.2.1.0 -&gt; 0.2.2.0
+        if options.has_key('sshproxytunnel'):
+            if not options['sshproxytunnel'].startswith('DEPRECATED'):
+                _params['server'] = options['sshproxytunnel'].split(&quot;:&quot;)[-2]
+                _params['port'] = options['sshproxytunnel'].split(&quot;:&quot;)[-1]
+            try: del _params['sshproxytunnel']
+            except KeyError: pass
+
+        _params['sshproxy_tunnel'] = 'localhost:44444:%s:%s' % (_params['server'], _params['port'])
+
+
+    # currently known but ignored in Python X2Go
     _ignored_options = [
             'startsoundsystem',
             'soundtunnel',
@@ -336,6 +349,7 @@ def _convert_SessionProfileOptions_2_SessionParams(options):
             'icon',
             'xinerama',
             'multidisp',
+            'display',
             'krblogin',
             'directrdp',
             'directrdpsettings',
@@ -353,7 +367,7 @@ def session_names_by_timestamp(session_infos):
     &quot;&quot;&quot;\
     Sorts session profile names by their timestamp (as used in the file format's section name).
 
-    @param session_infos: a dictionary of session infos as reported by L{X2goClient.list_sessions()}
+    @param session_infos: a dictionary of session infos as reported by L{X2GoClient.list_sessions()}
     @type session_infos: C{dict}
 
     @return: a timestamp-sorted list of session names found in C{session_infos}
diff --git a/x2go/x2go_exceptions.py b/x2go/x2go_exceptions.py
index a8eaa3f..be69208 100644
--- a/x2go/x2go_exceptions.py
+++ b/x2go/x2go_exceptions.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -39,33 +39,61 @@ BadHostKeyException = paramiko.AuthenticationException
 SSHException = paramiko.SSHException
 &quot;&quot;&quot;inherited from Python Paramiko library&quot;&quot;&quot;
 
-class _X2goException(exceptions.BaseException): pass
-class X2goClientException(_X2goException): pass
-class X2goClientPrintingException(_X2goException): pass
-class X2goClientSettingsException(_X2goException): pass
-class X2goSessionException(_X2goException): pass
-class X2goControlSessionException(_X2goException): pass
-class X2goRemoteHomeException(_X2goException): pass
-class X2goHostKeyException(_X2goException): pass
-class X2goSSHProxyHostKeyException(_X2goException): pass
-class X2goTerminalSessionException(_X2goException): pass
-class X2goSessionCacheException(_X2goException): pass
-class X2goUserException(_X2goException): pass
-class X2goProfileException(_X2goException): pass
-class X2goSessionRegistryException(_X2goException): pass
-class X2goFwTunnelException(_X2goException): pass
-class X2goRevFwTunnelException(_X2goException): pass
-class X2goPrintException(_X2goException): pass
-class X2goPrintQueueException(_X2goException): pass
-class X2goPrintActionException(_X2goException): pass
-class X2goProxyException(_X2goException): pass
-class X2goMIMEboxActionException(_X2goException): pass
-class X2goMIMEboxQueueException(_X2goException): pass
-class X2goSSHProxyException(_X2goException): pass
-class X2goSSHProxyAuthenticationException(_X2goException): pass
-class X2goNotImplementedYetException(_X2goException): pass
-class X2goDesktopSharingException(_X2goException): pass
-class X2goTimeOutException(_X2goException): pass
+class _X2GoException(exceptions.BaseException): pass
+class X2GoClientException(_X2GoException): pass
+class X2GoClientPrintingException(_X2GoException): pass
+class X2GoClientSettingsException(_X2GoException): pass
+class X2GoSessionException(_X2GoException): pass
+class X2GoControlSessionException(_X2GoException): pass
+class X2GoRemoteHomeException(_X2GoException): pass
+class X2GoHostKeyException(_X2GoException): pass
+class X2GoSSHProxyHostKeyException(_X2GoException): pass
+class X2GoTerminalSessionException(_X2GoException): pass
+class X2GoSessionCacheException(_X2GoException): pass
+class X2GoUserException(_X2GoException): pass
+class X2GoProfileException(_X2GoException): pass
+class X2GoSessionRegistryException(_X2GoException): pass
+class X2GoFwTunnelException(_X2GoException): pass
+class X2GoRevFwTunnelException(_X2GoException): pass
+class X2GoPrintException(_X2GoException): pass
+class X2GoPrintQueueException(_X2GoException): pass
+class X2GoPrintActionException(_X2GoException): pass
+class X2GoProxyException(_X2GoException): pass
+class X2GoMIMEboxActionException(_X2GoException): pass
+class X2GoMIMEboxQueueException(_X2GoException): pass
+class X2GoSSHProxyException(_X2GoException): pass
+class X2GoSSHProxyAuthenticationException(_X2GoException): pass
+class X2GoNotImplementedYetException(_X2GoException): pass
+class X2GoDesktopSharingException(_X2GoException): pass
+class X2GoTimeOutException(_X2GoException): pass
 if _X2GOCLIENT_OS != 'Windows':
     # faking Windows errors on non-Windows systems...
-    class WindowsError(_X2goException): pass
+    class WindowsError(_X2GoException): pass
+
+# compat section
+class X2goClientException(_X2GoException): pass
+class X2goClientPrintingException(_X2GoException): pass
+class X2goClientSettingsException(_X2GoException): pass
+class X2goSessionException(_X2GoException): pass
+class X2goControlSessionException(_X2GoException): pass
+class X2goRemoteHomeException(_X2GoException): pass
+class X2goHostKeyException(_X2GoException): pass
+class X2goSSHProxyHostKeyException(_X2GoException): pass
+class X2goTerminalSessionException(_X2GoException): pass
+class X2goSessionCacheException(_X2GoException): pass
+class X2goUserException(_X2GoException): pass
+class X2goProfileException(_X2GoException): pass
+class X2goSessionRegistryException(_X2GoException): pass
+class X2goFwTunnelException(_X2GoException): pass
+class X2goRevFwTunnelException(_X2GoException): pass
+class X2goPrintException(_X2GoException): pass
+class X2goPrintQueueException(_X2GoException): pass
+class X2goPrintActionException(_X2GoException): pass
+class X2goProxyException(_X2GoException): pass
+class X2goMIMEboxActionException(_X2GoException): pass
+class X2goMIMEboxQueueException(_X2GoException): pass
+class X2goSSHProxyException(_X2GoException): pass
+class X2goSSHProxyAuthenticationException(_X2GoException): pass
+class X2goNotImplementedYetException(_X2GoException): pass
+class X2goDesktopSharingException(_X2GoException): pass
+class X2goTimeOutException(_X2GoException): pass
diff --git a/x2go/xserver.py b/x2go/xserver.py
index edcb596..ba9e91d 100644
--- a/x2go/xserver.py
+++ b/x2go/xserver.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (C) 2010-2012 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
+# Copyright (C) 2010-2013 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 #
 # Python X2Go is free software; you can redistribute it and/or modify
 # it under the terms of the GNU Affero General Public License as published by
@@ -43,9 +43,9 @@ from defaults import X2GO_CLIENTXCONFIG_DEFAULTS as _X2GO_CLIENTXCONFIG_DEFAULTS
 import inifiles
 import utils
 
-class X2goClientXConfig(inifiles.X2goIniFile):
+class X2GoClientXConfig(inifiles.X2GoIniFile):
     &quot;&quot;&quot;\
-    Configuration file based XServer startup settings for X2goClient instances.
+    Configuration file based XServer startup settings for X2GoClient instances.
 
     This class is needed for Windows systems and (maybe soon) for Unix desktops using Wayland.
 
@@ -54,11 +54,11 @@ class X2goClientXConfig(inifiles.X2goIniFile):
 
     def __init__(self, config_files=_X2GO_XCONFIG_CONFIGFILES, defaults=None, logger=None, loglevel=log.loglevel_DEFAULT):
         &quot;&quot;&quot;\
-        Constructs an L{X2goClientXConfig} instance. This is normally done by an L{X2goClient} instance.
-        You can retrieve this L{X2goClientXConfig} instance with the C{X2goClient.get_client_xconfig()} 
+        Constructs an L{X2GoClientXConfig} instance. This is normally done by an L{X2GoClient} instance.
+        You can retrieve this L{X2GoClientXConfig} instance with the C{X2GoClient.get_client_xconfig()} 
         method.
 
-        On construction the L{X2goClientXConfig} instance is filled with values from the configuration files::
+        On construction the L{X2GoClientXConfig} instance is filled with values from the configuration files::
 
             /etc/x2goclient/xconfig
             ~/.x2goclient/xconfig
@@ -71,9 +71,9 @@ class X2goClientXConfig(inifiles.X2goIniFile):
         @type config_files: C{list}
         @param defaults: a Python dictionary with configuration file defaults (use on your own risk)
         @type defaults: C{dict}
-        @param logger: you can pass an L{X2goLogger} object to the L{X2goClientXConfig} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the L{X2GoClientXConfig} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
@@ -83,7 +83,7 @@ class X2goClientXConfig(inifiles.X2goIniFile):
             class OSNotSupportedException(exceptions.StandardError): pass
             raise OSNotSupportedException('classes of x2go.xserver module are for Windows only')
 
-        inifiles.X2goIniFile.__init__(self, config_files, defaults=defaults, logger=logger, loglevel=loglevel)
+        inifiles.X2GoIniFile.__init__(self, config_files, defaults=defaults, logger=logger, loglevel=loglevel)
 
         _known_xservers = utils.merge_ordered_lists(self.defaultValues['XServers']['known_xservers'], self.known_xservers)
 
@@ -155,7 +155,7 @@ class X2goClientXConfig(inifiles.X2goIniFile):
     @property
     def xserver_launch_possible(self):
         &quot;&quot;&quot;\
-        Detect if there is an XServer (that is known to Python X2go) installed on the system.
+        Detect if there is an XServer (that is known to Python X2Go) installed on the system.
         Equals C{True} if we have found an installed XServer that we can launch.
 
         &quot;&quot;&quot;
@@ -239,7 +239,7 @@ class X2goClientXConfig(inifiles.X2goIniFile):
             pass
 
 
-class X2goXServer(threading.Thread):
+class X2GoXServer(threading.Thread):
     &quot;&quot;&quot;
     This class is responsible for starting/stopping an external XServer application.
 
@@ -253,11 +253,11 @@ class X2goXServer(threading.Thread):
 
         @param xserver_name: name of the XServer to start (refer to the xconfig file for available names)
         @type xserver_name: C{str}
-        @param xserver_config: XServer configuration node (as derived from L{X2goClientXConfig.get_xserver_config()}
+        @param xserver_config: XServer configuration node (as derived from L{X2GoClientXConfig.get_xserver_config()}
         @type xserver_config: C{dict}
-        @param logger: you can pass an L{X2goLogger} object to the L{X2goClientXConfig} constructor
+        @param logger: you can pass an L{X2GoLogger} object to the L{X2GoClientXConfig} constructor
         @type logger: C{obj}
-        @param loglevel: if no L{X2goLogger} object has been supplied a new one will be
+        @param loglevel: if no L{X2GoLogger} object has been supplied a new one will be
             constructed with the given loglevel
         @type loglevel: C{int}
 
@@ -268,7 +268,7 @@ class X2goXServer(threading.Thread):
             raise OSNotSupportedException('classes of x2go.xserver module are for Windows only')
 
         if logger is None:
-            self.logger = log.X2goLogger(loglevel=loglevel)
+            self.logger = log.X2GoLogger(loglevel=loglevel)
         else:
             self.logger = copy.deepcopy(logger)
         self.logger.tag = __NAME__
@@ -296,7 +296,7 @@ class X2goXServer(threading.Thread):
 
     def run(self):
         &quot;&quot;&quot;\
-        Start this L{X2goXServer} thread. This will launch the configured XServer application.
+        Start this L{X2GoXServer} thread. This will launch the configured XServer application.
 
         &quot;&quot;&quot;
         self._keepalive = True


hooks/post-receive
-- 
python-x2go.git (Python X2Go Client API)

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;python-x2go.git&quot; (Python X2Go Client API).

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004138.html">[X2go-Commits] python-x2go.git - master (branch) updated:	0.2.1.1-46-g720f39f
</A></li>
	<LI>Next message: <A HREF="004139.html">[X2go-Commits] python-x2go.git - build-baikal (branch) created:	0.4.0.0
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4140">[ date ]</a>
              <a href="thread.html#4140">[ thread ]</a>
              <a href="subject.html#4140">[ subject ]</a>
              <a href="author.html#4140">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2go-commits
mailing list</a><br>
</body></html>
