<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2go-Commits] python-x2go.git - build-main (branch) updated:	0.1.1.6-22-g539ca3e
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2011-September/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2go-Commits%5D%20python-x2go.git%20-%20build-main%20%28branch%29%20updated%3A%0A%090.1.1.6-22-g539ca3e&In-Reply-To=%3C20110925001113.B8C625DD11%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001576.html">
   <LINK REL="Next"  HREF="001578.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2go-Commits] python-x2go.git - build-main (branch) updated:	0.1.1.6-22-g539ca3e</H1>
    <B>X2go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2go-Commits%5D%20python-x2go.git%20-%20build-main%20%28branch%29%20updated%3A%0A%090.1.1.6-22-g539ca3e&In-Reply-To=%3C20110925001113.B8C625DD11%40ymir%3E"
       TITLE="[X2go-Commits] python-x2go.git - build-main (branch) updated:	0.1.1.6-22-g539ca3e">git-admin at x2go.org
       </A><BR>
    <I>Sun Sep 25 02:11:13 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="001576.html">[X2go-Commits] python-x2go.git - release/0.1.1.x (branch) updated:	0.1.1.6-22-g539ca3e
</A></li>
        <LI>Next message: <A HREF="001578.html">[X2go-Commits] pyhoca-gui.git - master (branch) updated:	0.1.0.6-45-g8298fa5
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1577">[ date ]</a>
              <a href="thread.html#1577">[ thread ]</a>
              <a href="subject.html#1577">[ subject ]</a>
              <a href="author.html#1577">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, build-main has been updated
       via  539ca3ee9ed07ddfce6f2a6d90f876479c8f87a9 (commit)
       via  a5ed9d2b9cb15374aa0e5205f728fd50efd04b6b (commit)
       via  142e587cb4bfe2b5a506ed20dac04eaba77f258a (commit)
       via  4d2df56dd9d1e5ef727dd8dd3ae861f09b8780b9 (commit)
       via  82e793ae95f1af4cb414147ee70e93fb5ea7ab42 (commit)
       via  38dbb697abfb29908554824ce34b000173322775 (commit)
       via  8e23ff85e4203e551a109d354284b86ee015d905 (commit)
       via  d1064100febd0837fa8b6d66b8efd13deb5780d0 (commit)
       via  396398819979ac483f7f48c5dbf18055767f2a9e (commit)
       via  e150e61c74db05607e3f1c3e96440d65023e0b95 (commit)
       via  3a5ffa6774dc7a48eb20d20ca804a2cc702d7b25 (commit)
       via  e61623461dc3e29676ca06c76197b692005a5695 (commit)
       via  40c62d9845b7933a16d078272c30ec67273e2f13 (commit)
       via  d099f64c325f4a1971187bf681b40535063e023c (commit)
       via  343da76cc8807349013c715ab42cdac64ff0b952 (commit)
       via  3b26a3812c88d578e75e0d15e372bccc5e4e1f49 (commit)
       via  35cc30107306bb97af7b25b1f8ab9dfb9a32a801 (commit)
       via  3a4e5e374bbe43c4ebbbe56bd4ad526fac57a61c (commit)
       via  535521affad151325cfa4fe452542d358e974745 (commit)
       via  45c359a40ef64df8daded86e6e7328036f545e3f (commit)
       via  6fd557ede24430dac8b67b2341152969ad5b1584 (commit)
       via  1696e45dd9d579abeb65dcb26a45bde017a1629f (commit)
      from  c20bb5b5be476562ddb64b7064a375986f8955bb (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
-----------------------------------------------------------------------

Summary of changes:
 README                            |   22 +++----
 TODO                              |    2 +-
 debian/changelog                  |   23 +++++++
 setup.py                          |    2 +-
 x2go/__init__.py                  |    2 +-
 x2go/backends/control/_stdout.py  |   15 ++++
 x2go/backends/proxy/base.py       |    2 +-
 x2go/backends/terminal/_stdout.py |   91 ++++++++++++++++++++------
 x2go/client.py                    |  132 +++++++++++++++++++++++++++++++++++-
 x2go/forward.py                   |    3 +
 x2go/rforward.py                  |    1 +
 x2go/session.py                   |  114 +++++++++++++++++++++++++++++---
 x2go/utils.py                     |   22 +++++-
 13 files changed, 376 insertions(+), 55 deletions(-)

The diff of changes is:
diff --git a/README b/README
index 933f874..aa0b9bd 100644
--- a/README
+++ b/README
@@ -70,26 +70,22 @@ and wholeheartedness concerning this inner process.
 
 Ubuntu:
 -------
-create /etc/apt/sources.list.d/nwt.list and put the following line into it:
+We use Launchpad for Ubuntu packaging:
 
-&lt;snip&gt;
-deb <A HREF="http://packages.das-netzwerkteam.de/ubuntu">http://packages.das-netzwerkteam.de/ubuntu</A> {lucid|maverick|natty} main
-&lt;/snip&gt;
-
-If you run a newer Ubuntu version, replace &#187;lucid&#171; with your version (&#187;maverick&#171;, ...)
-
-Then run the following commands:
+  $ add-apt-repository ppa:x2go/stable
+  $ apt-get update
+  $ apt-get install python-x2go
 
-  $ sudo apt-get update
-  $ sudo apt-get install python-x2go
+From Ubuntu oneiric on python-x2go is also available as a part of the 
+Ubuntu GNU/Linux distribution.
 
 
 Debian:
 -------
-create /etc/apt/sources.list.d/nwt.list and put the following line into it:
+create /etc/apt/sources.list.d/x2go.list and put the following line into it:
 
 &lt;snip&gt;
-deb <A HREF="http://packages.das-netzwerkteam.de/debian">http://packages.das-netzwerkteam.de/debian</A> {squeeze|wheezy|sid} main
+deb <A HREF="http://packages.x2go.org/debian">http://packages.x2go.org/debian</A> {squeeze|wheezy|sid} main
 &lt;/snip&gt;
 
 Then run the following commands as super-user root:
@@ -134,6 +130,6 @@ check if your issues have already been solved in the HEAD of python-x2go code.
 For now, bugs can be reported via mail to <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>
 
 
-light+love, 20110701
+light+love, 20110718
 Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;
 
diff --git a/TODO b/TODO
index 52ceb74..6b44905 100644
--- a/TODO
+++ b/TODO
@@ -4,7 +4,7 @@ Published under the terms of the GNU General Public License.
 See <A HREF="http://www.gnu.org/licenses/gpl.html">http://www.gnu.org/licenses/gpl.html</A> for a recent copy.
 
 
-=== pyhton-x2go TODOs ===
+=== python-x2go TODOs ===
 
 as of 20110701
 --------------
diff --git a/debian/changelog b/debian/changelog
index 858e98e..918594b 100644
--- a/debian/changelog
+++ b/debian/changelog
@@ -1,3 +1,26 @@
+python-x2go (0.1.1.7-0-x2go1) unstable; urgency=low
+
+  [ Mike Gabriel ]
+  * New upstream version (0.1.1.7), bugfix+feature release for 0.1.1.x series:
+    - Add support for x2goumount-session calls.
+    - Differentiate between spool folders and data folders when unsharing
+      all folders, return exitcode from X2goTerminalSessionSTDOUT.unshare_*
+      methods.
+    - Use TCP_NODELAY socket option for audio rev forwarding tunnels.
+    - Use TCP_NODELAY socket option for graphics forwarding tunnels.
+    - Typo fixes in session.py, related to calling _X2goSession__disconnect
+      method.
+    - Compatibility fix for X2go folder sharing (session profile attribute:
+      export).
+    - Provide test method to query server if folder sharing is available.
+    - Test for existence of remote home directory on connect.
+
+  [ Dick Kniep ]
+  * Fix for upstream version 0.1.1.7:
+    - Typo in utils.py (true instead of True).
+
+ -- Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike.gabriel at das-netzwerkteam.de</A>&gt;  Sun, 25 Sep 2011 02:08:01 +0200
+
 python-x2go (0.1.1.6-0~x2go1) unstable; urgency=low
 
   * New upstream version (0.1.1.6), bugfix release for 0.1.1.x series:
diff --git a/setup.py b/setup.py
index e8253b6..a0be2fa 100755
--- a/setup.py
+++ b/setup.py
@@ -30,5 +30,5 @@ setup(
     url = '<A HREF="http://www.x2go.org">http://www.x2go.org</A>',
     packages = find_packages('.'),
     package_dir = {'': '.'},
-    install_requires = ['setuptools', &quot;gevent&quot;, &quot;paramiko&quot; ]
+    install_requires = ['setuptools', 'gevent', 'paramiko', ]
 )
diff --git a/x2go/__init__.py b/x2go/__init__.py
index 576547d..100a162 100644
--- a/x2go/__init__.py
+++ b/x2go/__init__.py
@@ -158,7 +158,7 @@ Contact
 &quot;&quot;&quot;
 
 __NAME__    = 'python-x2go'
-__VERSION__ = '0.1.1.6'
+__VERSION__ = '0.1.1.7'
 
 from gevent import monkey
 monkey.patch_all()
diff --git a/x2go/backends/control/_stdout.py b/x2go/backends/control/_stdout.py
index 4936189..e382493 100644
--- a/x2go/backends/control/_stdout.py
+++ b/x2go/backends/control/_stdout.py
@@ -256,6 +256,11 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
         #return username in self._x2go_remote_group('x2gousers')
         return True
 
+    def is_folder_sharing_available(self):
+        if self.remote_username() in self._x2go_remote_group('fuse'):
+            return True
+        return False
+
     def remote_username(self):
         &quot;&quot;&quot;\
         Returns the control session's remote username.
@@ -486,6 +491,10 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
 
         if self.get_transport():
             self.session_died = False
+
+        if not self.home_exists():
+            raise x2go_exceptions.X2goControlSessionException('remote home directory does not exist')
+
         return (self.get_transport() is not None)
 
     def dissociate(self, terminal_session):
@@ -540,6 +549,12 @@ class X2goControlSessionSTDOUT(paramiko.SSHClient):
             return False
 
 
+    def home_exists(self):
+        if self._x2go_exec_command('stat -tL &quot;%s&quot;', loglevel=log.loglevel_DEBUG):
+            return True
+        return False
+
+
     def is_alive(self):
         if self._x2go_exec_command('echo', loglevel=log.loglevel_DEBUG):
             return True
diff --git a/x2go/backends/proxy/base.py b/x2go/backends/proxy/base.py
index 9558b83..da12d6a 100644
--- a/x2go/backends/proxy/base.py
+++ b/x2go/backends/proxy/base.py
@@ -242,7 +242,7 @@ class X2goProxyBASE(threading.Thread):
             the parent class method X2goProxyBASE.process_proxy_options()
 
         &quot;&quot;&quot;
-        # do the logging of remaining options, call
+        # do the logging of remaining options
         if self.proxy_options:
             self.logger('ignoring non-processed proxy options: %s' % self.proxy_options, loglevel=log.loglevel_INFO)
 
diff --git a/x2go/backends/terminal/_stdout.py b/x2go/backends/terminal/_stdout.py
index 92dac9f..51bee99 100644
--- a/x2go/backends/terminal/_stdout.py
+++ b/x2go/backends/terminal/_stdout.py
@@ -444,7 +444,7 @@ class X2goTerminalSessionSTDOUT(object):
         Initialize Paramiko/SSH reverse forwarding tunnel for X2go folder sharing.
 
         &quot;&quot;&quot;
-        if self.session_info.username not in self.control_session._x2go_remote_group('fuse'):
+        if self.control_session.is_folder_sharing_available():
             raise x2go_exceptions.X2goUserException('remote user %s is not member of X2go server group fuse' % self.session_info.username)
 
         # start reverse SSH tunnel for sshfs (folder sharing, printing)
@@ -499,7 +499,7 @@ class X2goTerminalSessionSTDOUT(object):
         spool_dir = os.path.join(self.session_info.local_container, 'spool')
         if not os.path.exists(spool_dir):
             os.mkdir(spool_dir)
-        self.share_local_folder(folder_name=spool_dir, folder_type='spool')
+        self.share_local_folder(local_path=spool_dir, folder_type='spool')
         self.print_queue = printqueue.X2goPrintQueue(profile_name=self.profile_name,
                                                      session_name=self.session_info.name,
                                                      spool_dir=spool_dir,
@@ -542,7 +542,7 @@ class X2goTerminalSessionSTDOUT(object):
         mimebox_dir = os.path.join(self.session_info.local_container, 'mimebox')
         if not os.path.exists(mimebox_dir):
             os.mkdir(mimebox_dir)
-        self.share_local_folder(folder_name=mimebox_dir, folder_type='mimebox')
+        self.share_local_folder(local_path=mimebox_dir, folder_type='mimebox')
         self.mimebox_queue = mimebox.X2goMIMEboxQueue(profile_name=self.profile_name,
                                                       session_name=self.session_info.name,
                                                       mimebox_dir=mimebox_dir,
@@ -576,13 +576,13 @@ class X2goTerminalSessionSTDOUT(object):
         &quot;&quot;&quot;
         return '%s/%s' % (self.session_info.remote_container, 'mimebox')
 
-    def share_local_folder(self, folder_name=None, folder_type='disk'):
+    def share_local_folder(self, local_path=None, folder_type='disk'):
         &quot;&quot;&quot;\
         Share a local folder with the X2go session.
 
-        @param folder_name: the full path to an existing folder on the local 
+        @param local_path: the full path to an existing folder on the local 
             file system
-        @type folder_name: str
+        @type local_path: str
         @param folder_type: one of 'disk' (a folder on your local hard drive), 'rm' (removeable device), 
             'cdrom' (CD/DVD Rom) or 'spool' (for X2go print spooling)
         @type folder_type: str
@@ -591,23 +591,23 @@ class X2goTerminalSessionSTDOUT(object):
         @rtype: bool
 
         &quot;&quot;&quot;
-        if self.session_info.username not in self.control_session._x2go_remote_group('fuse'):
+        if self.control_session.is_folder_sharing_available():
             raise x2go_exceptions.X2goUserException('remote user %s is not member of X2go server group fuse' % self.session_info.username)
 
-        if folder_name is None:
+        if local_path is None:
             self.logger('no folder name given...', log.loglevel_WARN)
             return False
 
-        if type(folder_name) not in (types.StringType, types.UnicodeType):
+        if type(local_path) not in (types.StringType, types.UnicodeType):
             self.logger('folder name needs to be of type StringType...', log.loglevel_WARN)
             return False
 
-        if not os.path.exists(folder_name):
-            self.logger('local folder does not exist: %s' % folder_name, log.loglevel_WARN)
+        if not os.path.exists(local_path):
+            self.logger('local folder does not exist: %s' % local_path, log.loglevel_WARN)
             return False
 
-        folder_name = os.path.normpath(folder_name)
-        self.logger('sharing local folder: %s' % folder_name, log.loglevel_INFO)
+        local_path = os.path.normpath(local_path)
+        self.logger('sharing local folder: %s' % local_path, log.loglevel_INFO)
 
         _auth_rsakey = self.control_session._x2go_session_auth_rsakey
         _host_rsakey = defaults.RSAHostKey
@@ -628,9 +628,9 @@ class X2goTerminalSessionSTDOUT(object):
         _server_encoding = self.params.server_encoding
 
         if _X2GOCLIENT_OS == 'Windows':
-            folder_name = folder_name.replace('\\', '/')
-            folder_name = folder_name.replace(':', '')
-            folder_name = '/windrive/%s' % folder_name
+            local_path = local_path.replace('\\', '/')
+            local_path = local_path.replace(':', '')
+            local_path = '/windrive/%s' % local_path
             _convert_encoding = True
             _client_encoding = 'WINDOWS-1252'
 
@@ -647,7 +647,7 @@ class X2goTerminalSessionSTDOUT(object):
                          str(self.session_info.name), 
                          '&quot;%s&quot;' % _CURRENT_LOCAL_USER,
                          _x2go_key_fname,
-                         '%s__REVERSESSH_PORT__%s; ' % (folder_name, self.session_info.sshfs_port),
+                         '%s__REVERSESSH_PORT__%s; ' % (local_path, self.session_info.sshfs_port),
                          'rm -f %s %s.ident' % (_x2go_key_fname, _x2go_key_fname), 
                        ]
 
@@ -659,7 +659,7 @@ class X2goTerminalSessionSTDOUT(object):
                          str(self.session_info.name), 
                          '&quot;%s&quot;' % _CURRENT_LOCAL_USER,
                          _x2go_key_fname,
-                         '%s__PRINT_SPOOL___REVERSESSH_PORT__%s; ' % (folder_name, self.session_info.sshfs_port),
+                         '%s__PRINT_SPOOL___REVERSESSH_PORT__%s; ' % (local_path, self.session_info.sshfs_port),
                          'rm -f %s %s.ident' % (_x2go_key_fname, _x2go_key_fname), 
                        ]
 
@@ -671,12 +671,63 @@ class X2goTerminalSessionSTDOUT(object):
                          str(self.session_info.name), 
                          '&quot;%s&quot;' % _CURRENT_LOCAL_USER,
                          _x2go_key_fname,
-                         '%s__MIMEBOX_SPOOL___REVERSESSH_PORT__%s; ' % (folder_name, self.session_info.sshfs_port),
+                         '%s__MIMEBOX_SPOOL___REVERSESSH_PORT__%s; ' % (local_path, self.session_info.sshfs_port),
                          'rm -f %s %s.ident' % (_x2go_key_fname, _x2go_key_fname), 
                        ]
 
         (stdin, stdout, stderr) = self.control_session._x2go_exec_command(cmd_line)
-        self.logger('x2gomountdirs output is : %s' % stdout.read().split('\n'), log.loglevel_NOTICE)
+        _stdout = stdout.read().split('\n')
+        self.logger('x2gomountdirs output is : %s' % _stdout, log.loglevel_NOTICE)
+        if _stdout[5].endswith('ok'):
+            return True
+        return False
+
+    def unshare_all_local_folders(self):
+        &quot;&quot;&quot;\
+        Unshare all local folders mount in the X2go session.
+
+        @return: returns C{True} if all local folders could be successfully unmounted from the X2go server session
+        @rtype: bool
+
+        &quot;&quot;&quot;
+        self.logger('unsharing all local folders from session %s' % self.session_info, log.loglevel_INFO)
+
+        cmd_line = [ 'export HOSTNAME &amp;&amp;',
+                     'x2goumount-session', 
+                     self.session_info.name,
+                   ]
+
+        (stdin, stdout, stderr) = self.control_session._x2go_exec_command(cmd_line)
+        if not stderr.read():
+            self.logger('x2goumount-session (all mounts) for session %s has been successful' % self.session_info, log.loglevel_NOTICE)
+            return True
+        else:
+            self.logger('x2goumount-session (all mounts) for session %s failed' % self.session_info, log.loglevel_ERROR)
+            return False
+
+    def unshare_local_folder(self, local_path):
+        &quot;&quot;&quot;\
+        Unshare local folder given as &lt;local_path&gt; from X2go session.
+
+        @return: returns C{True} if the local folder &lt;local_path&gt; could be successfully unmounted from the X2go server session
+        @rtype: bool
+
+        &quot;&quot;&quot;
+        self.logger('unsharing local folder from session %s' % self.session_info, log.loglevel_INFO)
+
+        cmd_line = [ 'export HOSTNAME &amp;&amp;',
+                     'x2goumount-session', 
+                     self.session_info.name,
+                     local_path,
+                   ]
+
+        (stdin, stdout, stderr) = self.control_session._x2go_exec_command(cmd_line)
+        if not stderr.read():
+            self.logger('x2goumount-session (%s) for session %s has been successful' % (local_path, self.session_info, ), log.loglevel_NOTICE)
+            return True
+        else:
+            self.logger('x2goumount-session (%s) for session %s failed' % (local_path, self.session_info, ), log.loglevel_ERROR)
+            return False
 
     def color_depth(self):
         &quot;&quot;&quot;\
diff --git a/x2go/client.py b/x2go/client.py
index 396757b..0d4061b 100644
--- a/x2go/client.py
+++ b/x2go/client.py
@@ -1470,7 +1470,34 @@ class X2goClient(object):
             return session_name not in [ s for s in self.server_running_sessions(session_uuid)  + self.server_suspended_sessions(session_uuid) ]
     __has_session_terminated = has_session_terminated
 
-    def share_local_folder_with_session(self, session_uuid=None, folder_name=_LOCAL_HOME, profile_name=None):
+    def is_folder_sharing_available(self, session_uuid=None, profile_name=None):
+        &quot;&quot;&quot;\
+        Test if local folder sharing is available for X2go session with unique ID &lt;session_uuid&gt; or
+        session profile &lt;profile_name&gt;.
+
+        @param session_uuid: the X2go session's UUID registry hash
+        @type session_uuid: C{str}
+        @param profile_name: alternatively, the profile name can be used to perform this query
+        @type profile_name: C{str}
+
+        @return: returns C{True} if the profile/session supports local folder sharing
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        if session_uuid is None and profile_name:
+            _connected = self._X2goClient__client_connected_sessions_of_profile_name(profile_name, return_objects=False)
+            if len(_connected) &gt; 0:
+                session_uuid = _connected[0]
+        if session_uuid:
+            return self.session_registry(session_uuid).is_folder_sharing_available()
+        else:
+            self.logger('Cannot find a terminal session for profile ,,%s\'\' that can be used to query folder sharing capabilities' % profile_name, loglevel=log.loglevel_WARN)
+            return False
+    __is_folder_sharing_available = is_folder_sharing_available
+    __profile_is_folder_sharing_available = is_folder_sharing_available
+    __session_is_folder_sharing_available = is_folder_sharing_available
+
+    def share_local_folder(self, session_uuid=None, local_path=None, profile_name=None, folder_name=None):
         &quot;&quot;&quot;\
         Share a local folder with the X2go session registered as C{session_uuid}.
 
@@ -1480,8 +1507,10 @@ class X2goClient(object):
 
         @param session_uuid: the X2go session's UUID registry hash
         @type session_uuid: C{str}
-        @param folder_name: the full path to an existing folder on the local (client-side)
+        @param local_path: the full path to an existing folder on the local (client-side)
             file system
+        @type local_path: C{str}
+        @param folder_name: synonymous to C{local_path}
         @type folder_name: C{str}
         @param profile_name: alternatively, the profile name can be used to share local folders
         @type profile_name: C{str}
@@ -1490,16 +1519,111 @@ class X2goClient(object):
         @rtype: C{bool}
 
         &quot;&quot;&quot;
+        # compat for Python-X2go (&lt;=0.1.1.6)
+        if folder_name: local_path = folder_name
+
         if session_uuid is None and profile_name:
             _associated = self._X2goClient__client_associated_sessions_of_profile_name(profile_name, return_objects=False)
             if len(_associated) &gt; 0:
                 session_uuid = _associated[0]
         if session_uuid:
-            return self.session_registry(session_uuid).share_local_folder(folder_name=folder_name)
+            return self.session_registry(session_uuid).share_local_folder(local_path=local_path)
         else:
             self.logger('Cannot find a terminal session for profile ,,%s\'\' to share a local folder with' % profile_name, loglevel=log.loglevel_WARN)
             return False
-    __share_local_folder_with_session = share_local_folder_with_session
+    __share_local_folder = share_local_folder
+    __share_local_folder_with_session = share_local_folder
+    __share_local_folder_with_profile = share_local_folder
+
+    def unshare_all_local_folders(self, session_uuid=None, profile_name=None):
+        &quot;&quot;&quot;\
+        Unshare all local folders mounted in X2go session registered as
+        C{session_uuid}.
+
+        When calling this method all client-side mounted folders on the X2go 
+        server (via sshfs) for session with ID &lt;session_uuid&gt; will get
+        unmounted.
+
+        @param session_uuid: the X2go session's UUID registry hash
+        @type session_uuid: C{str}
+        @param profile_name: alternatively, the profile name can be used to unshare
+            mounted folders
+        @type profile_name: C{str}
+
+        @return: returns C{True} if all local folders could be successfully unmounted
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        if session_uuid is None and profile_name:
+            _associated = self._X2goClient__client_associated_sessions_of_profile_name(profile_name, return_objects=False)
+            if len(_associated) &gt; 0:
+                session_uuid = _associated[0]
+        if session_uuid:
+            return self.session_registry(session_uuid).unshare_all_local_folders()
+        else:
+            self.logger('Cannot find a terminal session for profile ,,%s\'\' from which to unmount local folders' % profile_name, loglevel=log.loglevel_WARN)
+            return False
+    unshare_all_local_folders_from_session = unshare_all_local_folders
+    unshare_all_local_folders_from_profile = unshare_all_local_folders
+    __unshare_all_local_folders_from_session = unshare_all_local_folders
+    __unshare_all_local_folders_from_profile = unshare_all_local_folders
+
+    def unshare_local_folder(self, session_uuid=None, profile_name=None, local_path=None):
+        &quot;&quot;&quot;\
+        Unshare local folder that is mounted in the X2go session registered as
+        C{session_uuid}.
+
+        When calling this method the given client-side mounted folder on the X2go 
+        server (via sshfs) for session with ID &lt;session_uuid&gt; will get
+        unmounted.
+
+        @param session_uuid: the X2go session's UUID registry hash
+        @type session_uuid: C{str}
+        @param profile_name: alternatively, the profile name can be used to unshare
+            mounted folders
+        @type profile_name: C{str}
+        @param local_path: the full path of a local folder that is mounted within X2go
+            session with session ID &lt;session_uuid&gt; (or recognized via profile name) and that
+            shall be unmounted from that session.
+        @type local_path: C{str}
+
+        @return: returns C{True} if all local folders could be successfully unmounted
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        if session_uuid is None and profile_name:
+            _associated = self._X2goClient__client_associated_sessions_of_profile_name(profile_name, return_objects=False)
+            if len(_associated) &gt; 0:
+                session_uuid = _associated[0]
+        if session_uuid:
+            return self.session_registry(session_uuid).unshare_local_folder(local_path=local_path)
+        else:
+            self.logger('Cannot find a terminal session for profile ,,%s\'\' from which to unmount local folders' % profile_name, loglevel=log.loglevel_WARN)
+            return False
+    unshare_local_folder_from_session = unshare_local_folder
+    unshare_local_folder_from_profile = unshare_local_folder
+    __unshare_local_folder_from_session = unshare_local_folder
+    __unshare_local_folder_from_profile = unshare_local_folder
+
+    def get_shared_folders(self, session_uuid=None, profile_name=None):
+        &quot;&quot;&quot;\
+        Get a list of local folders mounted within X2go session with session hash &lt;session_uuid&gt;
+        from this client.
+
+        @return: returns a C{list} of those local folder names that are mounted within X2go session &lt;session_uuid&gt;.
+        @rtype: C{list}
+
+        &quot;&quot;&quot;
+        if session_uuid is None and profile_name:
+            _associated = self._X2goClient__client_associated_sessions_of_profile_name(profile_name, return_objects=False)
+            if len(_associated) &gt; 0:
+                session_uuid = _associated[0]
+        if session_uuid:
+            return self.session_registry(session_uuid).get_shared_folders()
+    session_get_shared_folders = get_shared_folders
+    profile_get_shared_folders = get_shared_folders
+    __session_get_shared_folders = get_shared_folders
+    __profile_get_shared_folders = get_shared_folders
 
     ###
     ### Provide access to the X2goClient's session registry
diff --git a/x2go/forward.py b/x2go/forward.py
index f87e964..b6d0947 100644
--- a/x2go/forward.py
+++ b/x2go/forward.py
@@ -94,6 +94,9 @@ class X2goFwServer(StreamServer):
         &quot;&quot;&quot;
         self.fw_socket = fw_socket
 
+        # disable Nagle algorithm in TCP/IP protocol
+        self.fw_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
+
         _success = False
         _count = 0
         _maxwait = 20
diff --git a/x2go/rforward.py b/x2go/rforward.py
index 0388b85..8dfa805 100644
--- a/x2go/rforward.py
+++ b/x2go/rforward.py
@@ -300,6 +300,7 @@ def x2go_rev_forward_channel_handler(chan=None, addr='', port=0, parent_thread=N
 
     &quot;&quot;&quot;
     fw_socket = socket.socket()
+    fw_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
     if logger is None:
         def _dummy_logger(msg, l):
             pass
diff --git a/x2go/session.py b/x2go/session.py
index 7d1c95e..ed1e8b5 100644
--- a/x2go/session.py
+++ b/x2go/session.py
@@ -236,6 +236,7 @@ class X2goSession(object):
         self.terminal_params = {}
         self.sshproxy_params = {}
         self.update_params(params)
+        self.shared_folders = []
 
         self.session_environment = {}
 
@@ -878,7 +879,7 @@ class X2goSession(object):
         try:
             return self.control_session.list_sessions(raw=raw)
         except X2goControlSessionException:
-            self._X2goSession_disconnect()
+            self._X2goSession__disconnect()
             return None
     __list_sessions = list_sessions
 
@@ -902,7 +903,7 @@ class X2goSession(object):
             else:
                 return []
         except X2goControlSessionException:
-            self._X2goSession_disconnect()
+            self._X2goSession__disconnect()
             return None
     __list_desktops = list_desktops
 
@@ -1057,14 +1058,13 @@ class X2goSession(object):
 
                 if self._SUPPORTED_MIMEBOX and self.allow_mimebox:
                     self.terminal_session and not self.faulty and self.terminal_session.start_mimebox(mimebox_extensions=self.mimebox_extensions, mimebox_action=self.mimebox_action)
-                    self.session_environment.update({'X2GO_MIMEBOX': self.terminal_session.get_mimebox_spooldir(), })
+                    self.terminal_session and self.session_environment.update({'X2GO_MIMEBOX': self.terminal_session.get_mimebox_spooldir(), })
 
-                if self._SUPPORTED_FOLDERSHARING and self.share_local_folders:
+                if self.share_local_folders and self.terminal_session and not self.faulty and self.is_folder_sharing_available():
                     if _control.get_transport().reverse_tunnels[self.terminal_session.get_session_name()]['sshfs'][1] is not None:
                         for _folder in self.share_local_folders:
                             self.share_local_folder(_folder)
 
-
                 self.virgin = False
                 self.suspended = False
                 self.running = True
@@ -1179,6 +1179,10 @@ class X2goSession(object):
         &quot;&quot;&quot;
         if self.is_alive():
             if self.has_terminal_session():
+
+                # unshare mounted folders
+                self.unshare_all_local_folders()
+
                 if self.terminal_session.suspend():
 
                     self.running = False
@@ -1217,8 +1221,11 @@ class X2goSession(object):
         &quot;&quot;&quot;
         if self.is_alive():
             if self.has_terminal_session():
-                if self.terminal_session.terminate():
 
+                # unmount shared folders
+                self.unshare_all_local_folders()
+
+                if self.terminal_session.terminate():
                     self.running = False
                     self.suspended = False
                     self.terminated = True
@@ -1381,12 +1388,28 @@ class X2goSession(object):
         return self.terminated
     __has_terminated = has_terminated
 
-    def share_local_folder(self, folder_name):
+    def is_folder_sharing_available(self):
+        &quot;&quot;&quot;\
+        Test if the remote session allows sharing of local folders with the session.
+
+        @return: returns C{True} if local folder sharing is available in the remote session
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        if self._SUPPORTED_FOLDERSHARING and self.allow_share_local_folders:
+            if self.is_connected():
+                return self.control_session.is_folder_sharing_available()
+        else:
+            self.logger('local folder sharing is disabled for this session profile', loglevel=log.loglevel_WARN)
+
+    def share_local_folder(self, local_path=None, folder_name=None):
         &quot;&quot;&quot;\
         Share a local folder with this registered X2go session.
 
-        @param folder_name: the full path to an existing folder on the local
+        @param local_path: the full path to an existing folder on the local
             file system
+        @type local_path: C{str}
+        @param folder_name: synonymous to C{local_path}
         @type folder_name: C{str}
 
         @return: returns C{True} if the local folder has been successfully mounted within
@@ -1394,15 +1417,86 @@ class X2goSession(object):
         @rtype: C{bool}
 
         &quot;&quot;&quot;
+        # compat for Python-X2go (&lt;=0.1.1.6)
+        if folder_name: local_path=folder_name
+
         if self.has_terminal_session():
-            if self.allow_share_local_folders:
-                return self.terminal_session.share_local_folder(folder_name=folder_name)
+            if self._SUPPORTED_FOLDERSHARING and self.allow_share_local_folders:
+                if self.terminal_session.share_local_folder(local_path=local_path):
+                    self.shared_folders.append(local_path)
+                    return True
+                return False
             else:
                 self.logger('local folder sharing is disabled for this session profile', loglevel=log.loglevel_WARN)
         else:
             raise X2goSessionException('this X2goSession object does not have any associated terminal')
     __share_local_folder = share_local_folder
 
+    def unshare_all_local_folders(self, force_all=False):
+        &quot;&quot;&quot;\
+        Unshare all local folders mounted within this X2go session.
+
+        @param force_all: Really unmount _all_ shared folders, including the print spool folder and
+            the MIME box spool dir (not recommended).
+        @type force_all: C{bool}
+
+        @return: returns C{True} if all local folders could be successfully unmounted
+            inside this X2go session
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        if self.has_terminal_session():
+            if self._SUPPORTED_FOLDERSHARING and self.allow_share_local_folders:
+                if force_all:
+                    self.shared_folders = []
+                    return self.terminal_session.unshare_all_local_folders()
+                else:
+                    retval = 0
+                    for _shared_folder in self.shared_folders:
+                        retval = retval | self.terminal_session.unshare_local_folder(_shared_folder)
+                    self.shared_folders = []
+                    return retval
+            else:
+                self.logger('local folder sharing is disabled for this session profile', loglevel=log.loglevel_WARN)
+        else:
+            raise X2goSessionException('this X2goSession object does not have any associated terminal')
+        return False
+    __unshare_all_local_folders = unshare_all_local_folders
+
+    def unshare_local_folder(self, local_path=None):
+        &quot;&quot;&quot;\
+        Unshare a local folder that is mounted within this X2go session.
+
+        @param local_path: the full path to an existing folder on the local
+            file system that is mounted in this X2go session and shall be
+            unmounted
+        @type local_path: C{str}
+        @return: returns C{True} if all local folders could be successfully unmounted
+            inside this X2go session
+        @rtype: C{bool}
+
+        &quot;&quot;&quot;
+        if self.has_terminal_session():
+            if self._SUPPORTED_FOLDERSHARING and self.allow_share_local_folders and local_path in self.shared_folders:
+                self.shared_folders.remove(local_path)
+                return self.terminal_session.unshare_local_folder(local_path=local_path)
+            else:
+                self.logger('local folder sharing is disabled for this session profile', loglevel=log.loglevel_WARN)
+        else:
+            raise X2goSessionException('this X2goSession object does not have any associated terminal')
+    __unshare_local_folder = unshare_local_folder
+
+    def get_shared_folders(self):
+        &quot;&quot;&quot;\
+        Get a list of local folders mounted within this X2go session from this client.
+
+        @return: returns a C{list} of those folder names that are mounted with this X2go session.
+        @rtype: C{list}
+
+        &quot;&quot;&quot;
+        return self.shared_folders
+    __get_shared_folders = get_shared_folders
+
     def is_locked(self):
         &quot;&quot;&quot;\
         Query session if it is locked by some command being processed.
diff --git a/x2go/utils.py b/x2go/utils.py
index 5d023d9..9af2ef1 100644
--- a/x2go/utils.py
+++ b/x2go/utils.py
@@ -144,7 +144,6 @@ def _convert_SessionProfileOptions_2_SessionParams(_options):
             'speed': 'link',
             'sshport': 'port',
             'useexports': 'allow_share_local_folders',
-            'export': 'share_local_folders',
             'usemimebox': 'allow_mimebox',
             'mimeboxextensions': 'mimebox_extensions',
             'mimeboxaction': 'mimebox_action',
@@ -204,8 +203,22 @@ def _convert_SessionProfileOptions_2_SessionParams(_options):
 
     del _params['fstunnel']
 
-    if _params.has_key('share_local_folders'):
-        _params['share_local_folders'] = [ f for f in _params['share_local_folders'].split(',') if f ]
+    if _params.has_key('export'):
+
+        _export = _params['export']
+        del _params['export']
+        # fix for wrong export field usage in PyHoca-GUI/CLI and python-x2go before 20110923
+        _export = _export.replace(&quot;,&quot;, &quot;;&quot;)
+
+        _export = _export.strip().strip('&quot;').strip().strip(';').strip()
+        _export_list = [ f for f in _export.split(';') if f ]
+
+        _params['share_local_folders'] = []
+        for _shared_folder in _export_list:
+            # fix for wrong export field usage in PyHoca-GUI/CLI and python-x2go before 20110923
+            if not &quot;:&quot; in _shared_folder: _shared_folder = &quot;%s:1&quot; % _shared_folder
+            if _shared_folder.split(&quot;:&quot;)[1] == &quot;1&quot;:
+                _params['share_local_folders'].append(_shared_folder.split(&quot;:&quot;)[0])
 
     if not _options['fullscreen']:
         _params['geometry'] = '%sx%s' % (_options['width'], _options['height'])
@@ -444,5 +457,6 @@ def is_color_depth_ok(depth_session, depth_local):
     if depth_session == depth_local:
         return True
     if ( ( depth_session == 24 or depth_session == 32 ) and ( depth_local == 24 or depth_local == 32 ) ):
-        return true;
+        return True;
     return False
+


hooks/post-receive
-- 
python-x2go.git (Python X2go Client API)

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;python-x2go.git&quot; (Python X2go Client API).


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001576.html">[X2go-Commits] python-x2go.git - release/0.1.1.x (branch) updated:	0.1.1.6-22-g539ca3e
</A></li>
	<LI>Next message: <A HREF="001578.html">[X2go-Commits] pyhoca-gui.git - master (branch) updated:	0.1.0.6-45-g8298fa5
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1577">[ date ]</a>
              <a href="thread.html#1577">[ thread ]</a>
              <a href="subject.html#1577">[ subject ]</a>
              <a href="author.html#1577">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2go-commits
mailing list</a><br>
</body></html>
