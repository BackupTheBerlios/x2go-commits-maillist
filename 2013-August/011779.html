<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxcompshad/3.5.0-2-69-g9bfca1c
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2013-August/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-baikal%20%28branch%29%20updated%3A%0A%09nxcompshad/3.5.0-2-69-g9bfca1c&In-Reply-To=%3C20130830142412.3BA1B5DB39%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011771.html">
   <LINK REL="Next"  HREF="011799.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxcompshad/3.5.0-2-69-g9bfca1c</H1>
    <B>X2Go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-baikal%20%28branch%29%20updated%3A%0A%09nxcompshad/3.5.0-2-69-g9bfca1c&In-Reply-To=%3C20130830142412.3BA1B5DB39%40ymir%3E"
       TITLE="[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxcompshad/3.5.0-2-69-g9bfca1c">git-admin at x2go.org
       </A><BR>
    <I>Fri Aug 30 16:24:12 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="011771.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	redist-client/3.5.0.20-14-g2a41a2c
</A></li>
        <LI>Next message: <A HREF="011799.html">[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxproxy/3.5.0-1-78-g65f882e
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11779">[ date ]</a>
              <a href="thread.html#11779">[ thread ]</a>
              <a href="subject.html#11779">[ subject ]</a>
              <a href="author.html#11779">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, build-baikal has been updated
       via  9bfca1c2da8a72613ebf7406ef40f74ebe9799cb (commit)
       via  bf85c6e696693ef5a277c0334c01493dedf4fadd (commit)
       via  c70adf725d3fea94eabdde467b8b8b106a796c0a (commit)
       via  2208f4f9ecf967579a364021f0847b3ad1d7777c (commit)
       via  3d8e85c4749ee9e55601f6e540311008bf8f77af (commit)
       via  3b4404668c6794f9d0665905f4e22c1a0fafac21 (commit)
       via  9f7021392b921ad44163024ed8ca538195d3ac9c (commit)
       via  c7dc0c3cdec2e0f2fa2d52f8d446d0e83623a8a0 (commit)
       via  8fa612d1a931096ff57c9b90df0f13e6cd638da8 (commit)
      from  5e502cbb195be17d5d742295f4a2e6f0c603a8d7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
-----------------------------------------------------------------------

Summary of changes:
 nxcompshad/CHANGELOG              |  404 +++
 {nx-X11 =&gt; nxcompshad}/COPYING    |    0
 nxcompshad/Core.cpp               |  614 ++++
 nxcompshad/Core.h                 |  204 ++
 nxcompshad/Input.cpp              |  167 ++
 nxcompshad/Input.h                |   91 +
 nxcompshad/LICENSE                |   22 +
 nxcompshad/Logger.cpp             |  116 +
 nxcompshad/Logger.h               |  159 +
 nxcompshad/Makefile.in            |  192 ++
 nxcompshad/Manager.cpp            |  252 ++
 nxcompshad/Manager.h              |  115 +
 nxcompshad/Misc.h                 |   42 +
 nxcompshad/Poller.h               |   31 +
 nxcompshad/Regions.h              |   35 +
 nxcompshad/Shadow.cpp             |  470 +++
 nxcompshad/Shadow.h               |  101 +
 nxcompshad/Updater.cpp            |  383 +++
 nxcompshad/Updater.h              |   95 +
 {nxcomp =&gt; nxcompshad}/VERSION    |    0
 nxcompshad/Win.cpp                | 1137 ++++++++
 nxcompshad/Win.h                  |  224 ++
 nxcompshad/X11.cpp                | 1586 ++++++++++
 nxcompshad/X11.h                  |  131 +
 nxcompshad/configure              | 5778 +++++++++++++++++++++++++++++++++++++
 nxcompshad/configure.in           |  287 ++
 {nxcomp =&gt; nxcompshad}/install-sh |    0
 27 files changed, 12636 insertions(+)
 create mode 100644 nxcompshad/CHANGELOG
 copy {nx-X11 =&gt; nxcompshad}/COPYING (100%)
 create mode 100644 nxcompshad/Core.cpp
 create mode 100644 nxcompshad/Core.h
 create mode 100644 nxcompshad/Input.cpp
 create mode 100644 nxcompshad/Input.h
 create mode 100644 nxcompshad/LICENSE
 create mode 100644 nxcompshad/Logger.cpp
 create mode 100644 nxcompshad/Logger.h
 create mode 100644 nxcompshad/Makefile.in
 create mode 100644 nxcompshad/Manager.cpp
 create mode 100644 nxcompshad/Manager.h
 create mode 100644 nxcompshad/Misc.h
 create mode 100644 nxcompshad/Poller.h
 create mode 100644 nxcompshad/Regions.h
 create mode 100644 nxcompshad/Shadow.cpp
 create mode 100644 nxcompshad/Shadow.h
 create mode 100644 nxcompshad/Updater.cpp
 create mode 100644 nxcompshad/Updater.h
 copy {nxcomp =&gt; nxcompshad}/VERSION (100%)
 create mode 100644 nxcompshad/Win.cpp
 create mode 100644 nxcompshad/Win.h
 create mode 100644 nxcompshad/X11.cpp
 create mode 100644 nxcompshad/X11.h
 create mode 100755 nxcompshad/configure
 create mode 100644 nxcompshad/configure.in
 copy {nxcomp =&gt; nxcompshad}/install-sh (100%)

The diff of changes is:
diff --git a/nxcompshad/CHANGELOG b/nxcompshad/CHANGELOG
new file mode 100644
index 0000000..3472a4a
--- /dev/null
+++ b/nxcompshad/CHANGELOG
@@ -0,0 +1,404 @@
+ChangeLog:
+
+nxcompshad-3.5.0-2
+
+- Fixed TR03G02189. Now key combinations involving the Shift keys
+  are recognized correctly.
+
+nxcompshad-3.5.0-1
+
+- Opened the 3.5.0 branch based on nxcompshad-3.4.0-3.
+
+- Updated copyright to year 2011.
+
+nxcompshad-3.4.0-3
+
+- Updated copyright to year 2010.
+
+nxcompshad-3.4.0-2
+
+- Fixed TR08G02256. Now the Shadow session is shown correctly with
+  MIT-SHM extension disabled.
+
+- Improved updateShadowFrameBuffer() and ~Poller() functions.
+
+- Avoided memory leak.
+
+nxcompshad-3.4.0-1
+
+- Opened the 3.4.0 branch based on nxcompshad-3.3.0-3.
+
+- Updated version number.
+
+- Updated copyright to year 2009.
+
+- Improved error messages logging in case of initialization failures.
+
+nxcompshad-3.3.0-3
+
+- Fixed TR01G02158. Keymap initialization could be incorrect because
+  of a type mismatch on 64 bit platforms.
+
+nxcompshad-3.3.0-2
+
+- Updated VERSION.
+
+nxcompshad-3.3.0-1
+
+- Opened the 3.3.0 branch based on nxcompshad-3.2.0-3.
+
+nxcompshad-3.2.0-3
+
+- Improved keycode translation.
+
+nxcompshad-3.2.0-2
+
+- Solved a problem when sending fake modifier events.
+
+- Added support for keyboard events handling for the web player.
+
+- Changed keycodes translation for Solaris keyboard.
+
+- Corrected a problem for keycodes translation from Solaris keyboard.
+
+- Fixed TR02F02001. In shadow session the shadower's keyboard layout
+  could be wrong. Now keycodes are correctly translated if master and
+  shadow keyboards have different layouts.
+
+- Added NXShadowGetScreenSize() and NXShadowSetScreenSize() functions,
+  so that the shadow session can handle correctly the resize of the
+  master session window.
+
+- Solved a compilation problem on GCC 4.3.
+
+nxcompshad-3.2.0-1
+
+- Opened the 3.2.0 branch based on nxcompshad-3.1.0-2.
+
+nxcompshad-3.1.0-2
+
+- Updated file VERSION to match the current release version.
+
+nxcompshad-3.1.0-1
+
+- Opened the 3.1.0 branch based on nxcompshad-3.0.0-19.
+
+nxcompshad-3.0.0-19
+
+- Skip initialization of damage extension if it was already disabled.
+
+nxcompshad-3.0.0-18
+
+- The poller destructor checks if the damage extension is in use.
+
+- Small changes to the function getting the screen content in the case
+  damage is not in use.
+
+nxcompshad-3.0.0-17
+
+- Cleanup of some log messages.
+
+nxcompshad-3.0.0-16
+
+- Disabled some log message in the functions initializing the poller.
+
+nxcompshad-3.0.0-15
+
+- Before calling XTest functions, it is checked if the connection to
+  master X server has been initialized.
+
+nxcompshad-3.0.0-14
+
+- After the shm segment is created, its mode is changed and it is
+  marked for destroying. A check on the number of attaches is done.
+
+nxcompshad-3.0.0-13
+
+- Creating the shm segment even if the uid of master X server can't be
+  retrieved.
+
+- Fixed reallocation of update region.
+
+- Checking if the master X server provides XTest extension.
+
+nxcompshad-3.0.0-12
+
+- Fixed a compiler warning on AMD64 platform.
+
+- Changed configure script to add -fPIC option.
+
+- Fixed a mismatch in UpdateManager destructor.
+
+nxcompshad-3.0.0-11
+
+- Fixed the function setting the uid of shm segment.
+
+- Sync with the master X server before marking the shm segment to be
+  destroyed.
+
+nxcompshad-3.0.0-10
+
+- Setting the shm segments as readable only by the master X server
+  process.
+
+- Mark shm segments to be destroyed when the last process detach.
+
+- Enabled keycode translation in order to allow keyboards of different
+  models to work.
+
+nxcompshad-3.0.0-9
+
+- Changed the LICENSE file to state that the software is only made
+  available under the version 2 of the GPL.
+
+- Added file COPYING.
+
+- Changes to translate keycodes between different keyboard types. The
+  keycodes are translated through the keysym.
+
+- Changes to convert a Mode_switch key to ISO_Level3_Shift if it is
+  needed.
+
+nxcompshad-3.0.0-8
+
+- Added interface function NXShadowDisableShm disabling the use of
+  MIT-SHM extension.
+
+- Added interface function NXShadowDisableDamage disabling the use of
+  DAMAGE extension.
+
+- Added interface function NXShadowSetDisplayUid setting the uid of
+  shadowed X server
+
+- Changed the owner of shared memory segments to the uid of the sha-
+  dowed X server.
+
+- Fixed logWarning method.
+
+- Moved the code initializing the use of shared memory to shmInit
+  method of X11 Poller.
+
+nxcompshad-3.0.0-7
+
+- Removed the class qualifier in the declaration of destroyUpdate-
+  ManagerRegion().
+
+nxcompshad-3.0.0-6
+
+- Fixed build errors on 64 bit platforms.
+
+- Called XTestGrabControl to override possible grabs of the X server.
+
+nxcompshad-3.0.0-5
+
+- Added some stub members to the Poller class. These are intended to
+  handle keyboard state.
+
+- Changes in the default polling algorithm to disable the line pri-
+  ority persistence.
+
+nxcompshad-3.0.0-4
+
+- If a low layer handling of screen changes is available (DAMAGE in
+  case of X11), polling routine uses it and returns immediately.
+
+- Creating a Damage notify object if the extension is supported.
+
+- DamageNotify events are saved in the update region. After all avail-
+  able events have been handled, the content of screen is retrieved
+  by ShnGetImage requests.
+
+- XDamageSubtract and XSync are done before any event handling.
+
+- Damages are requested as raw rectangles.
+
+- Added Xdamage and Xrandr to required libraries.
+
+- Fixed a problem with some lines not refreshed in shadowing mode.
+
+nxcompshad-3.0.0-3
+
+- Added destroyUpdateManagerRegion() method to UpdateManager class.
+
+- Turned off some log messages.
+
+- Changed configure.in to remove warnings related to deprecated header
+  files and options.
+
+- Changed Makefile.in to remove autom4te.cache dir if the target is
+  'distclean'.
+
+- Removed multi-word file names.
+
+nxcompshad-3.0.0-2
+
+- Changes to get the screen of original display by a ShmGetImage.
+
+- Exit the polling loop if more than 50 ms have elapsed.
+
+nxcompshad-3.0.0-1
+
+- Created nxcompshad based on nxshadow-3.0.0-7.
+
+nxshadow-3.0.0-7
+
+- Deleted files KeyCursorTmp.cpp, scancodes.h, constant.h.
+
+- Renamed NXshadow.h to Shadow.h.
+
+- Merged NXshadowEvent.h with Shadow.h.
+
+- Fixed configure.in, changed Makefile.in to build Xcompshad library,
+  rebuilt configure script.
+
+nxshadow-3.0.0-6
+
+- Implemented a callback mechanism to ask the caller program if screen
+  polling have to be suspended.
+
+nxshadow-3.0.0-5
+
+- Changes to comply with the library name.
+
+- Fixed a bug in CorePoller that could prevent the update of the last
+  line of a rectangle.
+
+nxshadow-3.0.0-4
+
+- Removed some parameters of the NXShadowAddUpdaterDisplay() function.
+
+nxshadow-3.0.0-3
+
+- Updated copyright notices to the current year.
+
+- Code cleanup in KeysCursorTmp.c file.
+
+nxshadow-3.0.0-2
+
+- If master agent uses shared memory extension, the GetImage is rea-
+  lized by XShmGetImage() function.
+
+- Added new parameters to NXShadowAddUpdaterDisplay() function, the
+  depth and bit mask color of the master display.
+
+nxshadow-3.0.0-1
+
+- Opened the nxshadow-3.0.0 branch based on the nxaccess-3.0.0-13.
+
+- Renamed NXaccess.h NXaccessEvent.h and RegionM.h files as NXshadow.h
+  NXshadowEvent.h and Regions.h.
+
+- Modified the Makefile.in file and configure scripts in order to
+  compile the component.
+
+nxaccess-3.0.0-13
+
+- Fixed X11Poller.cpp pre-processing.
+
+nxaccess-3.0.0-12
+
+- Fixed build problems on Solaris.
+
+nxaccess-3.0.0-11
+
+- Added NXShadowUpdateBuffer() function. This function creates the
+  buffer for the polling.
+
+- If the scaline fails, the polling will suspend for 50 ms.
+
+- Added some functions in order to access data member class.
+
+nxaccess-3.0.0-10
+
+- Used XTEST extension to make the shared display create input events.
+
+nxaccess-3.0.0-9
+
+- Added the mouse events.
+
+- Now, it's possible to connect to X server display or agent display,
+  the display's content is captured by GetImage and sent to another
+  display by PutImage.
+
+nxaccess-3.0.0-8
+
+- Added KeysCursorTmp.cpp file.
+
+- Solved a problem with the keys, when the window lost focus the Key-
+  Release events weren't propagated.
+
+nxaccess-3.0.0-7
+
+- Added functions in order to remove issues with some keys combina-
+  tion.
+
+nxaccess-3.0.0-6
+
+- Added functions to simulate keys Ctrl + Alt + Del in order to run
+  the Task Manager application.
+
+- Now nxaccess is able to manage all switches between desktops.
+
+nxaccess-3.0.0-5
+
+- Solved a problem with the cursor shape. After a while, the cursor
+  shape are no more updated.
+
+- Now the cursor is updated only when it changes its shape.
+
+- Removed a dirty lines after screen updates.
+
+- Removed the unused file Keyboard.cpp.
+
+- Added the colorCorrect() macro in NXaccess.h.
+
+- Removed the colorCorrect() function in Updater.cpp.
+
+nxaccess-3.0.0-4
+
+- Renamed some source files and functions conforming them to the name
+  of component.
+
+nxaccess-3.0.0-3
+
+- Removed the parameter of type Display in all methods of the class
+  Poller.
+
+- Print, Break and Pause keys are enabled.
+
+nxaccess-3.0.0-2
+
+- Modified the Makefile.in in order to avoid compiling the executive
+  file.
+
+- Removed the unused file Main.cpp.
+
+- The Windows keys are enabled.
+
+- Synchronized local and remote states of Num_Lock, Caps_Lock and
+  Scroll_Lock.
+
+- Updated the NoMachine copyright notices.
+
+nxaccess-3.0.0-1
+
+- Opened the 3.0.0 branch based on the nxmirror-2.0.0-3.
+
+nxmirror-2.0.0-3
+
+- Added the keyboard events for all layouts.
+
+- The mouse wheel button is enabled.
+
+nxmirror-2.0.0-2
+
+- Completed implementation of the keyboard events only for italian
+  layout.
+
+- Added the mouse events and shape cursor.
+
+nxmirror-2.0.0-1
+
+- Opened the 2.0.0 branch based on the 1.5.0-60.
+
+- Added CHANGELOG.
diff --git a/nx-X11/COPYING b/nxcompshad/COPYING
similarity index 100%
copy from nx-X11/COPYING
copy to nxcompshad/COPYING
diff --git a/nxcompshad/Core.cpp b/nxcompshad/Core.cpp
new file mode 100644
index 0000000..6f94493
--- /dev/null
+++ b/nxcompshad/Core.cpp
@@ -0,0 +1,614 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;string.h&gt;
+#include &lt;sys/time.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &quot;Core.h&quot;
+#include &quot;Logger.h&quot;
+
+const int CorePoller::maxSliceHeight_ = 20;
+const int CorePoller::minSliceHeight_ = 3;
+
+const char CorePoller::interlace_[] =
+{
+  0, 16,
+  8, 24,
+  4, 20, 12, 28,
+  2, 18, 10, 26, 6, 22, 14, 30,
+  1, 17,
+  9, 25,
+  5, 21, 13, 29,
+  3, 19, 11, 27, 7, 23, 15, 31
+};
+
+CorePoller::CorePoller(Input *input, Display *display) : input_(input)
+{
+  logTrace(&quot;CorePoller::CorePoller&quot;);
+
+  buffer_ = NULL;
+  lastUpdatedRegion_ = NULL;
+  lineStatus_ = NULL;
+  linePriority_ = NULL;
+  lefts_ = NULL;
+  rights_ = NULL;
+}
+
+CorePoller::~CorePoller()
+{
+  logTrace(&quot;CorePoller::~CorePoller&quot;);
+
+  if (buffer_ != NULL)
+  {
+    delete [] buffer_;
+
+    buffer_ = NULL;
+  }
+
+  if (lastUpdatedRegion_ != NULL)
+  {
+    XDestroyRegion(lastUpdatedRegion_);
+
+    lastUpdatedRegion_ = NULL;
+  }
+
+  if (lineStatus_ != NULL)
+  {
+    delete [] lineStatus_;
+
+    lineStatus_ = NULL;
+  }
+
+  if (linePriority_ != NULL)
+  {
+    delete [] linePriority_;
+
+    linePriority_ = NULL;
+  }
+
+  if (lefts_ != NULL)
+  {
+    delete [] lefts_;
+
+    lefts_ = NULL;
+  }
+
+  if (rights_ != NULL)
+  {
+    delete [] rights_;
+
+    rights_ = NULL;
+  }
+}
+
+int CorePoller::init()
+{
+  logTrace(&quot;CorePoller::init&quot;);
+
+  createFrameBuffer();
+
+  if (buffer_ == NULL)
+  {
+    logError(&quot;CorePoller::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  logTest(&quot;CorePoller::init&quot;, &quot;Allocated frame buffer at [%p] for [%d] bytes.&quot;,
+            buffer_, bpl_ * height_);
+
+  if (lastUpdatedRegion_ != NULL)
+  {
+    XDestroyRegion(lastUpdatedRegion_);
+
+    lastUpdatedRegion_ = NULL;
+  }
+
+  lastUpdatedRegion_ = XCreateRegion();
+
+  if (lineStatus_ != NULL)
+  {
+    delete[] lineStatus_;
+  }
+
+  lineStatus_ = new LineStatus[height_ + 1];
+
+  if (lineStatus_ == NULL)
+  {
+    logError(&quot;CorePoller::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  //
+  // We need this boundary element to
+  // speed up the algo.
+  //
+
+  if (linePriority_ != NULL)
+  {
+    delete[] linePriority_;
+  }
+
+  linePriority_ = new int [height_ + 1];
+
+  if (linePriority_ == NULL)
+  {
+    logError(&quot;CorePoller::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  for (unsigned int i = 0; i &lt; height_; i++)
+  {
+    linePriority_[i] = HIGHEST_PRIORITY;
+  }
+
+  if (lefts_ != NULL)
+  {
+    delete[] lefts_;
+  }
+
+  lefts_ = new int [height_];
+
+  if (rights_ != NULL)
+  {
+    delete[] rights_;
+  }
+
+  rights_ = new int [height_];
+
+  for (unsigned int i = 0; i &lt; height_; i++)
+  {
+    rights_[i] = lefts_[i] = 0;
+  }
+
+  return 1;
+}
+
+int CorePoller::isChanged(int (*checkIfInputCallback)(void *), void *arg, int *suspended)
+{
+  logTrace(&quot;CorePoller::isChanged&quot;);
+
+#if defined(__CYGWIN32__) || defined(WIN32)
+
+  checkDesktop();
+
+#endif
+
+#if !defined(__CYGWIN32__) &amp;&amp; !defined(WIN32)
+
+  if (mirror_ == 1)
+  {
+    int result = mirrorChanges_;
+
+    mirrorChanges_ = 0;
+
+    return result;
+  }
+
+#endif
+
+  logDebug(&quot;CorePoller:isChanged&quot;, &quot;Going to use default polling algorithm.\n&quot;);
+
+  //
+  // In order to allow this function to
+  // be suspended and resumed later, we
+  // need to save these two status vars.
+  // 
+
+  static int idxIlace = 0;
+  static int curLine = 0;
+
+
+  const long timeout = 50;
+  long oldTime;
+  long newTime;
+  struct timeval ts;
+
+  gettimeofday(&amp;ts, NULL);
+
+  oldTime = ts.tv_sec * 1000 + ts.tv_usec / 1000;
+
+  if (curLine == 0) // &amp;&amp; idxIlace == 0 ?
+  {
+    for (unsigned int i = 0; i &lt; height_; i++)
+    {
+      lineStatus_[i] = LINE_NOT_CHECKED;
+    }
+  }
+
+  int foundChanges = 0;
+
+  foundChanges = 0;
+
+  int curIlace = interlace_[idxIlace];
+
+  bool moveBackward = false;
+
+  logDebug(&quot;CorePoller::isChanged&quot;, &quot;Interlace index [%d] interlace [%d].&quot;, idxIlace, curIlace);
+
+  for (; curLine &lt; (int) height_; curLine++)
+  {
+    logDebug(&quot;CorePoller::isChanged&quot;, &quot;Analizing line [%d] move backward [%d] status [%d] priority [%d].&quot;,
+                curLine, moveBackward, lineStatus_[curIlace], linePriority_[curLine]);
+
+    //
+    // Ask the caller if the polling have to be suspended.
+    //
+
+    if ((*checkIfInputCallback)(arg) == 1)
+    {
+      *suspended = 1;
+
+      break;
+    }
+
+    //
+    // Suspend if too much time is elapsed.
+    //
+
+    gettimeofday(&amp;ts, NULL);
+
+    newTime = ts.tv_sec * 1000 + ts.tv_usec / 1000;
+
+    if (newTime - oldTime &gt;= timeout)
+    {
+      *suspended = 1;
+
+      break;
+    }
+
+    oldTime = newTime;
+
+    if (lineStatus_[curLine] != LINE_NOT_CHECKED)
+    {
+      continue;
+    }
+
+    if (moveBackward)
+    {
+      moveBackward = false;
+    }
+    else
+    {
+      switch (linePriority_[curLine])
+      {
+        case 1:
+        case 29:
+        {
+          //
+          // It was a priority,
+          // but now it may not be.
+          //
+        }
+        case 31:
+        {
+          //
+          // Not a priority, still isn't.
+          //
+
+          linePriority_[curLine] = NOT_PRIORITY;
+
+          break;
+        }
+        case 0:
+        {
+          //
+          // Make it a priority.
+          //
+
+          linePriority_[curLine] = PRIORITY;
+
+          break;
+        }
+        default:
+        {
+          linePriority_[curLine]--;
+
+          break;
+        }
+      }
+
+      if ((linePriority_[curLine] &gt; PRIORITY) &amp;&amp; ((curLine &amp; 31) != curIlace))
+      {
+        continue;
+      }
+    }
+
+    XRectangle rect = {0, curLine, width_, 1};
+
+    char *buffer;
+
+    logDebug(&quot;CorePoller::isChanged&quot;, &quot;Checking line [%d].&quot;, curLine);
+
+    if ((buffer = getRect(rect)) == NULL)
+    {
+      logDebug(&quot;CorePoller::isChanged&quot;, &quot;Failed to retrieve line [%d].&quot;, curLine);
+
+      return -1;
+    }
+
+    if (memcmp(buffer, buffer_ + curLine * bpl_, bpl_) == 0 || differ(buffer, rect) == 0)
+    {
+      logDebug(&quot;CorePoller::isChanged&quot;, &quot;Data buffer didn't change.&quot;);
+
+      lineStatus_[curLine] = LINE_NOT_CHANGED;
+
+      continue;
+    }
+
+    rect.x = lefts_[rect.y];
+    rect.width = rights_[rect.y] - lefts_[rect.y] + 1;
+
+    update(buffer + rect.x * bpp_, rect);
+
+    foundChanges = 1;
+
+    lineStatus_[curLine] = LINE_HAS_CHANGED;
+
+    //
+    // Wake up the next line.
+    //
+
+    if (linePriority_[curLine + 1] &gt; PRIORITY)
+    {
+      linePriority_[curLine + 1] = HIGHEST_PRIORITY;
+    }
+
+    //
+    // Give this line priority.
+    //
+
+    linePriority_[curLine] = HIGHEST_PRIORITY;
+
+    //
+    // Wake up previous line.
+    //
+
+    if (curLine &gt; 0 &amp;&amp; lineStatus_[curLine - 1] == LINE_NOT_CHECKED)
+    {
+      moveBackward = true;
+      curLine -= 2;
+    }
+  }
+
+  //
+  // Execution reached the end of loop.
+  //
+
+  if (curLine == (int) height_)
+  {
+    idxIlace = (idxIlace + 1) % 32;
+
+    curLine = 0;
+  }
+
+  //
+  // Create the region of changed pixels.
+  //
+
+  if (foundChanges)
+  {
+    int start, last, curLine, left, right;
+
+    for (curLine = 0; curLine &lt; (int) height_; curLine++)
+    {
+      if (lineStatus_[curLine] == LINE_HAS_CHANGED)
+      {
+        break;
+      }
+    }
+
+    start = curLine;
+    last = curLine;
+
+    left = lefts_[curLine];
+    right = rights_[curLine];
+    curLine++;
+
+    while (1)
+    {
+      for (; curLine &lt; (int) height_; curLine++)
+      {
+        if (lineStatus_[curLine] == LINE_HAS_CHANGED)
+        {
+          break;
+        }
+      }
+
+      if (curLine == (int) height_)
+      {
+        break;
+      }
+
+      if ((curLine - last &gt; minSliceHeight_) || (last - start &gt; maxSliceHeight_))
+      {
+        XRectangle rect = {left, start, right - left + 1, last - start + 1};
+
+        XUnionRectWithRegion(&amp;rect, lastUpdatedRegion_, lastUpdatedRegion_);
+
+        start = curLine;
+        left = lefts_[curLine];
+        right = rights_[curLine];
+      }
+      else
+      {
+        if (lefts_[curLine] &lt; left)
+        {
+          left = lefts_[curLine];
+        }
+
+        if (rights_[curLine] &gt; right)
+        {
+          right = rights_[curLine];
+        }
+      }
+
+      last = curLine;
+
+      curLine++;
+    }
+
+    //
+    // Send last block.
+    //
+
+    if (last &gt;= start)
+    {
+      XRectangle rect = {left, start, right - left + 1, last - start + 1};
+
+      XUnionRectWithRegion(&amp;rect, lastUpdatedRegion_, lastUpdatedRegion_);
+    }
+  }
+
+  return foundChanges;
+}
+
+int CorePoller::differ(char *buffer, XRectangle r)
+{
+  logTrace(&quot;CorePoller::differ&quot;);
+
+  int bpl = bpp_ * r.width;
+  int i;
+  char *pBuf;
+  char *pFb;
+
+  pBuf = (buffer);
+  pFb = (buffer_ + r.x + r.y * bpl_);
+
+  for (i = 0; i &lt; bpl; i++)
+  {
+    if (*pFb++ != *pBuf++)
+    {
+      lefts_[r.y] = i / bpp_;
+
+      break;
+    }
+  }
+
+  if (i == bpl)
+  {
+    return 0;
+  }
+
+  pBuf = (buffer) + bpl - 1;
+  pFb = (buffer_ + r.x + r.y * bpl_) + bpl - 1;
+
+  int j = i - 1;
+
+  for (i = bpl - 1; i &gt; j; i--)
+  {
+    if (*pFb-- != *pBuf--)
+    {
+      rights_[r.y] = i / bpp_;
+
+      break;
+    }
+  }
+
+  return 1;
+}
+
+void CorePoller::update(char *src, XRectangle r)
+{
+  logTrace(&quot;CorePoller::update&quot;);
+
+  char *dst = buffer_ + r.x * bpp_ + r.y * bpl_;
+  int bpl = bpp_ * r.width;
+
+  for (unsigned int i = 0; i &lt; r.height; i++)
+  {
+    if(((r.x * bpp_ + r.y * bpl_) + bpl) &gt; (bpl_ * height_))
+    {
+      //
+      // Out of bounds. Maybe a resize is going on.
+      //
+
+      continue;
+    }
+
+    memcpy(dst, src, bpl);
+
+    src += bpl;
+
+    dst += bpl_;
+  }
+}
+
+void CorePoller::handleEvent(Display *display, XEvent *event)
+{
+  logTrace(&quot;CorePoller::handleEvent&quot;);
+
+  switch (event -&gt; type)
+  {
+    case KeyPress:
+    case KeyRelease:
+    {
+      handleKeyboardEvent(display, event);
+      break;
+    }
+    case ButtonPress:
+    case ButtonRelease:
+    case MotionNotify:
+    {
+      handleMouseEvent(display, event);
+      break;
+    }
+    default:
+    {
+      logTest(&quot;CorePoller::handleEvent&quot;, &quot;Handling unexpected event [%d] from display [%p].&quot;,
+                  event -&gt; type, display);
+      break;
+    }
+  }
+}
+
+void CorePoller::handleWebKeyEvent(KeySym keysym, Bool isKeyPress)
+{
+  logTrace(&quot;CorePoller::handleWebKeyEvent&quot;);
+
+  handleWebKeyboardEvent(keysym, isKeyPress);
+}
+
+void CorePoller::handleInput()
+{
+  while (input_ -&gt; checkIfEvent())
+  {
+    Display *display = input_ -&gt; currentDisplay();
+    XEvent *event = input_ -&gt; popEvent();
+
+    handleEvent(display, event);
+
+    delete event;
+  }
+}
+
+void CorePoller::createFrameBuffer()
+{
+  logTrace(&quot;CorePoller::createFrameBuffer&quot;);
+
+  if (buffer_ == NULL)
+  {
+    buffer_ = new char[bpl_ * height_];
+  }
+}
diff --git a/nxcompshad/Core.h b/nxcompshad/Core.h
new file mode 100644
index 0000000..9bc8a64
--- /dev/null
+++ b/nxcompshad/Core.h
@@ -0,0 +1,204 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef CorePoller_H
+#define CorePoller_H
+
+#include &lt;stdio.h&gt;
+
+#include &quot;Logger.h&quot;
+#include &quot;Regions.h&quot;
+#include &quot;Input.h&quot;
+
+typedef enum{
+  LINE_HAS_CHANGED,
+  LINE_NOT_CHECKED,
+  LINE_NOT_CHANGED
+} LineStatus;
+
+typedef enum{
+  HIGHEST_PRIORITY = 0,
+  PRIORITY = 30,
+  NOT_PRIORITY = 90
+} LinePriority;
+
+class CorePoller
+{
+  public:
+
+  CorePoller(Input*, Display*);
+
+  virtual ~CorePoller();
+
+  virtual int init();
+
+  unsigned int width() const;
+
+  unsigned int height() const;
+
+  unsigned char depth() const;
+
+  int isChanged(int (*)(void*), void *, int *);
+
+  char *getFrameBuffer() const;
+
+  void destroyFrameBuffer();
+
+  void createFrameBuffer();
+
+  Region lastUpdatedRegion();
+
+  Region getLastUpdatedRegion();
+
+  void handleInput();
+
+  void handleEvent(Display *, XEvent *);
+
+  void handleWebKeyEvent(KeySym keysym, Bool isKeyPress);
+
+  Display *getShadowDisplay();
+
+  void setShadowDisplay(Display *shadowDisplay);
+
+  protected:
+
+  unsigned int bpp_;
+
+  unsigned int bpl_;
+
+  unsigned int width_;
+
+  unsigned int height_;
+
+  int depth_;
+
+  char *buffer_;
+
+  unsigned long redMask_;
+  unsigned long greenMask_;
+  unsigned long blueMask_;
+  unsigned long colorMask_[3];
+
+  char mirror_;
+
+  char mirrorChanges_;
+
+  virtual int updateShadowFrameBuffer(void) = 0;
+
+  virtual char *getRect(XRectangle r) = 0;
+
+  int imageByteOrder_;
+
+  #ifdef __CYGWIN32__
+  virtual char checkDesktop(void) = 0;
+  #endif
+
+  Display *shadowDisplay_;
+
+  void update(char *src, XRectangle r);
+
+  Region lastUpdatedRegion_;
+
+  private:
+
+  virtual void handleKeyboardEvent(Display *, XEvent *) = 0;
+
+  virtual void handleWebKeyboardEvent(KeySym keysym, Bool isKeyPress) = 0;
+
+  virtual void handleMouseEvent(Display *, XEvent *) = 0;
+
+  Input *input_;
+
+  static const int maxSliceHeight_;
+  static const int minSliceHeight_;
+
+  LineStatus *lineStatus_;
+  int *linePriority_;
+
+  static const char interlace_[];
+
+  int *lefts_;
+  int *rights_;
+
+  // FIXME: Make them friend.
+
+  int differ(char *src, XRectangle r);
+};
+
+inline unsigned int CorePoller::width() const
+{
+  return width_;
+}
+
+inline unsigned int CorePoller::height() const
+{
+  return height_;
+}
+
+inline unsigned char CorePoller::depth() const
+{
+  return depth_;
+}
+
+inline char *CorePoller::getFrameBuffer() const
+{
+  return buffer_;
+}
+
+inline void CorePoller::destroyFrameBuffer()
+{
+  if (buffer_ != NULL)
+  {
+    delete[] buffer_;
+    buffer_ = NULL;
+  }
+}
+
+inline Region CorePoller::lastUpdatedRegion()
+{
+  Region region = lastUpdatedRegion_;
+
+  lastUpdatedRegion_ = XCreateRegion();
+
+  if (lastUpdatedRegion_ == NULL)
+  {
+    logError(&quot;CorePoller::lastUpdatedRegion&quot;, ESET(ENOMEM));
+
+    lastUpdatedRegion_ = region;
+
+    return NULL;
+  }
+
+  return region;
+}
+
+inline Region CorePoller::getLastUpdatedRegion()
+{
+  return lastUpdatedRegion_;
+}
+
+inline Display *CorePoller::getShadowDisplay()
+{
+  return shadowDisplay_ ;
+}
+
+inline void CorePoller::setShadowDisplay(Display *shadowDisplay)
+{
+  shadowDisplay_ = shadowDisplay;
+}
+
+#endif /* CorePoller_H */
diff --git a/nxcompshad/Input.cpp b/nxcompshad/Input.cpp
new file mode 100644
index 0000000..f9bf181
--- /dev/null
+++ b/nxcompshad/Input.cpp
@@ -0,0 +1,167 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;string.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &quot;Input.h&quot;
+#include &quot;Logger.h&quot;
+
+Input::Input()
+{
+  logTrace(&quot;Input::Input&quot;);
+
+  eventsHead_ = NULL;
+  eventsTail_ = NULL;
+  keymap_ = NULL;
+}
+
+Input::~Input()
+{
+  logTrace(&quot;Input::~Input&quot;);
+
+  Event *head = eventsHead_;
+
+  while (head)
+  {
+    Event *next = head -&gt; next;
+
+    delete head -&gt; event;
+    delete head;
+
+    head = next;
+  }
+
+  if (keymap_ != NULL)
+  {
+    logDebug(&quot;Input::~Input&quot;, &quot;Delete keymap_ [%p].&quot;, keymap_);
+
+    delete [] keymap_;
+  }
+}
+
+void Input::pushEvent(Display *display, XEvent *event)
+{
+  Event *tail = new Event;
+
+  if (tail == NULL)
+  {
+    logError(&quot;Input::pushEvent&quot;, ESET(ENOMEM));
+
+    return;
+  }
+
+  tail -&gt; next = NULL;
+  tail -&gt; display = display;
+  tail -&gt; event = event;
+
+  if (eventsHead_ == NULL)
+  {
+    eventsHead_ = tail;
+  }
+  else
+  {
+    eventsTail_ -&gt; next = tail;
+  }
+
+  eventsTail_ = tail;
+}
+
+XEvent *Input::popEvent()
+{
+  Event *head = eventsHead_;
+
+  if (head == NULL)
+  {
+    return 0;
+  }
+
+  XEvent *event = head -&gt; event;
+
+  eventsHead_ = head -&gt; next;
+
+  delete head;
+
+  if (eventsHead_ == NULL)
+  {
+    eventsTail_ = NULL;
+  }
+
+  return event;
+}
+
+int Input::removeAllEvents(Display *display)
+{
+  logTrace(&quot;Input::removeAllEvents&quot;);
+
+  int nRemoved = 0;
+
+  Event *current = eventsHead_;
+
+  while (current)
+  {
+    if (display == current -&gt; display)
+    {
+      //
+      // Update head of list.
+      //
+
+      if (current == eventsHead_)
+      {
+        eventsHead_ = current -&gt; next;
+      }
+
+      //
+      // Update tail of list.
+      //
+
+      if (current == eventsTail_)
+      {
+        eventsTail_ = eventsHead_;
+
+        while (eventsTail_ &amp;&amp; eventsTail_ -&gt; next)
+        {
+          eventsTail_ = eventsTail_ -&gt; next;
+        }
+      }
+
+      //
+      // Remove event.
+      //
+
+      Event *next = current -&gt; next;
+
+      delete current -&gt; event;
+      delete current;
+
+      current = next;
+
+      nRemoved++;
+    }
+    else
+    {
+      current = current -&gt; next;
+    }
+  }
+
+  return nRemoved;
+}
+
diff --git a/nxcompshad/Input.h b/nxcompshad/Input.h
new file mode 100644
index 0000000..6250e79
--- /dev/null
+++ b/nxcompshad/Input.h
@@ -0,0 +1,91 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Input_H
+#define Input_H
+
+#include &lt;X11/Xlib.h&gt;
+
+typedef struct Event
+{
+  struct Event *next;
+  Display *display;
+  XEvent *event;
+} Event;
+
+class Input
+{
+  public:
+
+  Input();
+
+  ~Input();
+
+  int checkIfEvent();
+
+  void pushEvent(Display *, XEvent *);
+
+  XEvent *popEvent();
+  Display *currentDisplay();
+
+  int removeAllEvents(Display *);
+
+  void setKeymap(char *keymap);
+  char *getKeymap();
+
+  void setShadowDisplayName(char *shadowDisplayName);
+  char *getShadowDisplayName();
+
+  private:
+
+  Event *eventsHead_;
+  Event *eventsTail_;
+  char *keymap_;
+  char *shadowDisplayName_;
+};
+
+inline Display *Input::currentDisplay()
+{
+  return eventsHead_ ? eventsHead_ -&gt; display : NULL;
+}
+
+inline int Input::checkIfEvent()
+{
+  return (eventsHead_ != NULL);
+}
+
+inline void Input::setKeymap(char *keymap)
+{
+  keymap_ = keymap;
+}
+
+inline char *Input::getKeymap()
+{
+  return keymap_;
+}
+
+inline void Input::setShadowDisplayName(char *shadowDisplayName)
+{
+  shadowDisplayName_ = shadowDisplayName;
+}
+
+inline char *Input::getShadowDisplayName()
+{
+  return shadowDisplayName_;
+}
+
+#endif /* Input_H */
diff --git a/nxcompshad/LICENSE b/nxcompshad/LICENSE
new file mode 100644
index 0000000..2c7f95a
--- /dev/null
+++ b/nxcompshad/LICENSE
@@ -0,0 +1,22 @@
+Copyright (c) 2001, 2011 NoMachine - <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>
+
+NXCOMPSHAD and NX extensions to X are copyright of NoMachine.
+
+Redistribution and use of this software is allowed according to the
+following terms:
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License Version 2, and
+not any other version, as published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTA-
+BILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, you can request a copy to NoMachine
+or write to the Free Software Foundation, Inc., 59 Temple Place,
+Suite 330, Boston, MA  02111-1307 USA
+
+All rights reserved.
diff --git a/nxcompshad/Logger.cpp b/nxcompshad/Logger.cpp
new file mode 100644
index 0000000..c367c5d
--- /dev/null
+++ b/nxcompshad/Logger.cpp
@@ -0,0 +1,116 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMP, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;unistd.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#define DEBUG
+
+#include &quot;Misc.h&quot;
+#include &quot;Logger.h&quot;
+
+Logger logger;
+
+void Logger::user(const char *format, va_list arguments)
+{
+  char string[1024];
+
+  vsnprintf(string, 1024, format, arguments);
+
+  fprintf(stderr, &quot;%s\n&quot;, string);
+}
+
+void Logger::error(const char *name, int error)
+{
+  fprintf(stderr, &quot;PANIC! %s: Failed with code %d: %s\n&quot;,
+               name, error, strerror(error));
+}
+
+void Logger::warning(const char *name, const char *format, va_list arguments)
+{
+  char string[1024];
+
+  vsnprintf(string, 1024, format, arguments);
+
+  fprintf(stderr, &quot;%s: WARNING! %s\n&quot;, name, string);
+}
+
+void Logger::test(const char *name, const char *format, va_list arguments)
+{
+  char string[1024];
+
+  vsnprintf(string, 1024, format, arguments);
+
+  fprintf(stderr, &quot;%s: %s\n&quot;, name, string);
+}
+
+void Logger::trace(const char *name)
+{
+  fprintf(stderr, &quot;%s\n&quot;, name);
+}
+
+void Logger::debug(const char *name, const char *format, va_list arguments)
+{
+  char string[1024];
+
+  vsnprintf(string, 1024, format, arguments);
+
+  fprintf(stderr, &quot;%s: %s\n&quot;, name, string);
+}
+
+void Logger::dump(const char *name, const char *data, int size)
+{
+  fprintf(stderr, &quot;%s: Dumping %d bytes of data at %p\n&quot;,
+              name, size, data);
+
+  for (int i = 0; i &lt; size;)
+  {
+    fprintf(stderr, &quot;[%d]\t&quot;, i);
+
+    int t = i;
+
+    for (unsigned int ii = 0; i &lt; size &amp;&amp; ii &lt; 8; i++, ii++)
+    {
+      fprintf(stderr, &quot;%02x/%d\t&quot;, data[i] &amp; 0xff, data[i]);
+    }
+
+    for (unsigned int ii = i % 8; ii &gt; 0 &amp;&amp; ii &lt; 8; ii++)
+    {
+      fprintf(stderr, &quot;\t&quot;);
+    }
+
+    i = t;
+
+    for (unsigned int ii = 0; i &lt; size &amp;&amp; ii &lt; 8; i++, ii++)
+    {
+      if (isprint(data[i]))
+      {
+        fprintf(stderr, &quot;%c&quot;, data[i]);
+      }
+      else
+      {
+        fprintf(stderr, &quot;.&quot;);
+      }
+    }
+
+    fprintf(stderr, &quot;\n&quot;);
+  }
+}
diff --git a/nxcompshad/Logger.h b/nxcompshad/Logger.h
new file mode 100644
index 0000000..94e4da8
--- /dev/null
+++ b/nxcompshad/Logger.h
@@ -0,0 +1,159 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMP, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Logger_H
+#define Logger_H
+
+#include &lt;errno.h&gt;
+#include &lt;stdarg.h&gt;
+
+//
+// Error handling macros.
+//
+
+#define ESET(e)  (errno = (e))
+#define EGET()   (errno)
+#define ESTR()   strerror(errno)
+
+extern class Logger logger;
+
+class Logger
+{
+  public:
+
+  void user(const char *format, va_list arguments);
+
+  void error(const char *name, int error);
+
+  void warning(const char *name, const char *format, va_list arguments);
+
+  void test(const char *name, const char *format, va_list arguments);
+
+  void trace(const char *name);
+
+  void debug(const char *name, const char *format, va_list arguments);
+
+  void dump(const char *name, const char *data, int size);
+};
+
+static inline void logUser(const char *format, ...) \
+    __attribute__((format(printf, 1, 2))) __attribute__((__unused__));
+
+static inline void logError(const char *name, int error) \
+    __attribute__((__unused__));
+
+static inline void logWarning(const char *name, const char *format, ...) \
+    __attribute__((__unused__));
+
+static inline void logTest(const char *name, const char *format, ...) \
+    __attribute__((format(printf, 2, 3))) __attribute__((__unused__));
+
+static inline void logTrace(const char *name) \
+    __attribute__((__unused__));
+
+static inline void logDebug(const char *name, const char *format, ...) \
+    __attribute__((format(printf, 2, 3))) __attribute__((__unused__));
+
+static inline void logDump(const char *name, const char *data, int size) \
+    __attribute__((__unused__));
+
+static inline void logUser(const char *format, ...)
+{
+  va_list arguments;
+
+  va_start(arguments, format);
+
+  logger.user(format, arguments);
+
+  va_end(arguments);
+}
+
+static inline void logError(const char *name, int error)
+{
+  #if defined(DEBUG) || defined(TEST) || \
+          defined(WARNING) || defined(PANIC)
+
+  logger.error(name, error);
+
+  #endif
+}
+
+static inline void logWarning(const char *name, const char *format, ...)
+{
+  #if defined(DEBUG) || defined(TEST) || \
+          defined(WARNING)
+
+  va_list arguments;
+
+  va_start(arguments, format);
+
+  logger.warning(name, format, arguments);
+
+  va_end(arguments);
+
+  #endif
+}
+
+static inline void logTest(const char *name, const char *format, ...)
+{
+  #if defined(TEST)
+
+  va_list arguments;
+
+  va_start(arguments, format);
+
+  logger.test(name, format, arguments);
+
+  va_end(arguments);
+
+  #endif
+}
+
+static inline void logTrace(const char *name)
+{
+  #if defined(DEBUG)
+
+  logger.trace(name);
+
+  #endif
+}
+
+static inline void logDebug(const char *name, const char *format, ...)
+{
+  #if defined(DEBUG)
+
+  va_list arguments;
+
+  va_start(arguments, format);
+
+  logger.debug(name, format, arguments);
+
+  va_end(arguments);
+
+  #endif
+}
+
+static inline void logDump(const char *name, const char *data, int size)
+{
+  #if defined(TEST)
+
+  logger.dump(name, data, size);
+
+  #endif
+}
+
+#endif /* Logger_H */
diff --git a/nxcompshad/Makefile.in b/nxcompshad/Makefile.in
new file mode 100644
index 0000000..1580a35
--- /dev/null
+++ b/nxcompshad/Makefile.in
@@ -0,0 +1,192 @@
+############################################################################
+#                                                                          #
+#  Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>          #
+#                                                                          #
+#  NXCOMP, NX protocol compression and NX extensions to this software      #
+#  are copyright of NoMachine. Redistribution and use of the present       #
+#  software is allowed according to terms specified in the file LICENSE    #
+#  which comes in the source distribution.                                 #
+#                                                                          #
+#  Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.        #
+#                                                                          #
+#  NX and NoMachine are trademarks of Medialogic S.p.A.                    #
+#                                                                          #
+#  All rights reserved.                                                    #
+#                                                                          #
+############################################################################
+
+#
+# Get values from configure script.
+#
+
+VERSION=@VERSION@
+LIBVERSION=@LIBVERSION@
+
+#
+# We would really like to enable all warnings, -Wredundant-decls,
+# though, gives a warning caused by pthread.h and unistd.h and
+# GCC 3.4 was changed in a way that it now complains about some
+# of the -W directives we used before (-Wmissing-declarations,
+# -Wnested-externs, -Wstrict-prototypes and -Wmissing-prototypes).
+#
+
+CXX         = @CXX@
+CXXFLAGS    = @CXXFLAGS@ @X_CFLAGS@ @DEFS@ \
+              -Wall -Wpointer-arith
+CXXINCLUDES =
+CXXDEFINES  =
+
+#
+# C programs don't share the C++ flags. They should
+# have their own @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">CCFLAGS at .</A>
+#
+
+CC          = @CC@
+CCFLAGS     = @X_CFLAGS@ @DEFS@ \
+              -Wall -Wpointer-arith
+CCINCLUDES  =
+CCDEFINES   =
+
+LDFLAGS     = @LDFLAGS@
+LIBS        = @LIBS@ -L/usr/X11R6/lib -lX11
+
+#
+# Only if THREADS is defined.
+#
+# LIBS = $(LIBS) -lpthread
+#
+
+#
+# Only if you want ElectricFence.
+#
+# LIBS = $(LIBS) -lefence
+#
+
+#
+# Only if you want mpatrol.
+#
+# LIBS = $(LIBS) -lmpatrol -lbfd -liberty
+#
+
+srcdir      = @srcdir@
+prefix      = @prefix@
+exec_prefix = @exec_prefix@
+bindir      = @bindir@
+man1dir     = @mandir@/man1
+VPATH       = @srcdir@
+
+INSTALL         = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA    = @INSTALL_DATA@
+
+#
+# This should be autodetected.
+#
+
+MAKEDEPEND     = @MAKEDEPEND@
+DEPENDINCLUDES = -I/usr/include/g++ -I/usr/include/g++-3
+
+.SUFFIXES: .cpp.c
+
+.cpp.o:
+	$(CXX) -c $(CXXFLAGS) $(CXXINCLUDES) $(CXXDEFINES) $&lt;
+.c.o:
+	$(CC) -c $(CCFLAGS) $(CCINCLUDES) $(CCDEFINES) $&lt;
+
+LIBRARY = Xcompshad
+
+LIBNAME    = lib$(LIBRARY)
+LIBFULL    = lib$(LIBRARY).so.$(VERSION)
+LIBLOAD    = lib$(LIBRARY).so.$(LIBVERSION)
+LIBSHARED  = lib$(LIBRARY).so
+LIBARCHIVE = lib$(LIBRARY).a
+
+MSRC   = Main.c
+
+CSRC   =
+
+CXXSRC = Core.cpp \
+	 Input.cpp \
+	 Logger.cpp \
+	 Shadow.cpp \
+	 X11.cpp \
+	 Win.cpp \
+	 Updater.cpp \
+	 Manager.cpp
+
+MOBJ   = $(MSRC:.c.cpp=.o)
+COBJ   = $(CSRC:.c=.o)
+CXXOBJ = $(CXXSRC:.cpp=.o)
+
+MLIBS  = -L. -lXShadow
+
+ifeq ($(findstring -lgdi32,$(LIBS)),-lgdi32)
+
+# We need a smarter way to detect windows
+# platform.
+
+LIBDLL       = cyg$(LIBRARY).dll
+LIBDLLSTATIC = lib${LIBRARY}.dll.a
+
+all: depend $(LIBARCHIVE) $(LIBDLL)
+
+else
+
+EXTRALIBS = -lXtst -lXrandr -lXdamage
+
+all: depend $(LIBFULL) $(LIBLOAD) $(LIBSHARED) $(LIBARCHIVE)
+
+endif
+
+$(LIBFULL):	$(CXXOBJ) $(COBJ)
+		$(CXX) -o $@ $(LDFLAGS) $(CXXOBJ) $(COBJ) $(LIBS) $(EXTRALIBS)
+
+$(LIBLOAD):	$(LIBFULL)
+		rm -f $(LIBLOAD)
+		ln -s $(LIBFULL) $(LIBLOAD)
+
+$(LIBSHARED):	$(LIBFULL)
+		rm -f $(LIBSHARED)
+		ln -s $(LIBFULL) $(LIBSHARED)
+
+$(LIBARCHIVE):	$(CXXOBJ) $(COBJ)
+		rm -f  $(LIBARCHIVE)
+		ar clq $(LIBARCHIVE) $(CXXOBJ) $(COBJ)
+		ranlib $(LIBARCHIVE)
+
+$(LIBDLL): $(LIBARCHIVE)
+		$(CC) -o $@ \
+		-shared \
+		-Wl,--out-implib=$(LIBDLLSTATIC) \
+		-Wl,--export-all-symbols \
+		-Wl,--enable-auto-import \
+		-Wl,--whole-archive ${LIBARCHIVE} \
+		-Wl,--no-whole-archive \
+		${LIBS} -L/usr/X11R6/lib
+
+$(PROGRAM):	$(MOBJ) $(COBJ) $(CXXOBJ) $(LIBDLL)
+#		$(CC) $(CCFLAGS) -o $@ $(MOBJ) $(MLIBS)
+
+depends:	depend.status
+
+depend:		depend.status
+
+depend.status:	
+		if [ -x $(MAKEDEPEND) ] ; then \
+			$(MAKEDEPEND) $(CXXINCLUDES) $(CCINCLUDES) \
+                        $(DEPENDINCLUDES) -f Makefile $(MSRC) $(CSRC) $(CXXSRC) 2&gt;/dev/null; \
+		fi
+		touch depend.status
+
+install:	install.bin install.man
+
+install.bin:
+
+install.man:
+
+clean:
+		-rm -f *~ *.o *.bak st?????? core core.* *.out.* *.exe.stackdump \
+		$(LIBFULL) $(LIBLOAD) $(LIBSHARED) $(LIBARCHIVE) $(LIBDLL) $(LIBDLLSTATIC) $(PROGRAM) $(PROGRAM).exe
+
+distclean:	clean
+		-rm -rf config.status config.log config.cache depend.status Makefile tags autom4te.cache
diff --git a/nxcompshad/Manager.cpp b/nxcompshad/Manager.cpp
new file mode 100644
index 0000000..ba9260a
--- /dev/null
+++ b/nxcompshad/Manager.cpp
@@ -0,0 +1,252 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xutil.h&gt;
+#include &lt;X11/keysym.h&gt;
+#include &lt;string.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &quot;Manager.h&quot;
+#include &quot;Logger.h&quot;
+
+UpdateManager::UpdateManager(int w, int h, char *f, Input *i)
+  : width_(w), height_(h), frameBuffer_(f), input_(i)
+{
+  logTrace(&quot;UpdateManager::UpdateManager&quot;);
+
+  nUpdater = 0;
+  updaterVector = NULL;
+  updateManagerRegion_ = NULL;
+}
+
+UpdateManager::~UpdateManager()
+{
+  logTrace(&quot;UpdateManager::~UpdateManager&quot;);
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    delete updaterVector[i];
+  }
+
+  delete [] updaterVector;
+}
+
+Updater *UpdateManager::createUpdater(char *displayName, Display *display)
+{
+  Updater *updater = new Updater(displayName, display);
+
+  if (updater == NULL)
+  {
+    logError(&quot;UpdateManager::createUpdater&quot;, ESET(ENOMEM));
+
+    return NULL;
+  }
+
+  if (updater -&gt; init(width_, height_, frameBuffer_, input_) == -1)
+  {
+    logError(&quot;UpdateManager::createUpdater&quot;, EGET());
+
+    delete updater;
+
+    return NULL;
+  }
+
+  return updater;
+}
+
+UpdaterHandle UpdateManager::addUpdater(char *displayName, Display *display)
+{
+  Updater *newUpdater = createUpdater(displayName, display);
+
+  if (newUpdater == NULL)
+  {
+    logError(&quot;UpdateManager::addUpdater&quot;, EGET());
+
+    return NULL;
+  }
+
+  Updater **newUpdaterVector = new Updater*[nUpdater + 1];
+
+  if (newUpdaterVector == NULL)
+  {
+    logError(&quot;UpdateManager::addUpdater&quot;, ESET(ENOMEM));
+
+    delete newUpdater;
+
+    return NULL;
+  }
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    newUpdaterVector[i] = updaterVector[i];
+  }
+
+  newUpdaterVector[nUpdater] = newUpdater;
+
+  delete [] updaterVector;
+
+  updaterVector = newUpdaterVector;
+
+  nUpdater++;
+
+  logTest(&quot;UpdateManager::AddUpdater&quot;, &quot;Number of updaters [%d].&quot;, nUpdater);
+
+  return reinterpret_cast&lt;UpdaterHandle&gt;(newUpdater);
+}
+
+int UpdateManager::removeAllUpdaters()
+{
+  logTest(&quot;UpdateManager::removeAllUpdaters&quot;, &quot;Number of updaters [%d].&quot;, nUpdater);
+
+  int nullUpdaters = 0;
+
+  for (int i = nUpdater; i &gt; 0; i--)
+  {
+    if (removeUpdater(reinterpret_cast&lt;UpdaterHandle&gt;(updaterVector[i - 1])) == 0)
+    {
+      nullUpdaters++;
+    }
+  }
+
+  if (nUpdater == 0)
+  {
+    return 1;
+  }
+
+  if (nUpdater == nullUpdaters)
+  {
+    logTest(&quot;UpdateManager::removeAllUpdaters&quot;, &quot;Ignored null records in Updater vector.&quot;);
+
+    return 0;
+  }
+
+  logTest(&quot;UpdateManager::removeAllUpdaters&quot;, &quot;Failed to remove some updaters.&quot;);
+
+  return -1;
+}
+
+int UpdateManager::removeUpdater(UpdaterHandle handle)
+{
+  Updater * const updater = (Updater*) handle;
+
+  logTest(&quot;UpdateManager::removeUpdater&quot;, &quot;Removing Updater [%p].&quot;, updater);
+
+  if (updater == NULL)
+  {
+    return 0;
+  }
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    if (updater == updaterVector[i])
+    {
+      updaterVector[i] = updaterVector[nUpdater - 1];
+
+      nUpdater--;
+
+      delete updater;
+
+      return 1;
+    }
+  }
+
+  logTest(&quot;UpdateManager::removeUpdater&quot;, &quot;Couldn't find Updater [%p].&quot;, updater);
+
+  return -1;
+}
+
+void UpdateManager::addRegion(Region region)
+{
+  logTrace(&quot;UpdateManager::addRegion&quot;);
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    updaterVector[i] -&gt; addRegion(region);
+  }
+
+  XDestroyRegion(region);
+}
+
+void UpdateManager::update()
+{
+  logTrace(&quot;UpdateManager::update&quot;);
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    /*updaterVector[i] -&gt; update();*/
+    if (updaterVector[i] -&gt; getUpdateRegion())
+    {
+      logDebug(&quot;UpdateManager::update&quot;, &quot;pRegion [%p] rect[%ld].&quot;,
+                   updaterVector[i] -&gt; getUpdateRegion(), (updaterVector[i] -&gt; getUpdateRegion()) -&gt; numRects);
+
+      updateManagerRegion_ = updaterVector[i] -&gt; getUpdateRegion();
+      //
+      // FIXME: Remove me.
+      //
+      for (int j = 0; j &lt; updateManagerRegion_ -&gt; numRects; j++)
+      {
+        int x = updateManagerRegion_ -&gt; rects[j].x1;
+        int y = updateManagerRegion_ -&gt; rects[j].y1;
+        unsigned int width = updateManagerRegion_ -&gt; rects[j].x2 - updateManagerRegion_ -&gt; rects[j].x1;
+        unsigned int height = updateManagerRegion_ -&gt; rects[j].y2 - updateManagerRegion_ -&gt; rects[j].y1;
+        logDebug(&quot;UpdateManager::update&quot;, &quot;x[%d]y[%d]width[%u]height[%u], updateManagerRegion_[%p]&quot;,
+                  x, y, width, height, updateManagerRegion_);
+      }
+    }
+  }
+}
+
+void UpdateManager::handleInput()
+{
+  logTrace(&quot;UpdateManager::handleInput&quot;);
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    try
+    {
+      updaterVector[i] -&gt; handleInput();
+    }
+    catch (UpdaterClosing u)
+    {
+      logTest(&quot;UpdateManager::handleInput&quot;, &quot;Catched exception UpdaterClosing().&quot;);
+
+      removeUpdater((UpdaterHandle)updaterVector[i]);
+
+      //
+      // Now the i-element of the updaterVector
+      // is changed. We don't want to skip it.
+      //
+
+      i--;
+    }
+  }
+}
+
+void UpdateManager::newRegion()
+{
+  logTrace(&quot;UpdateManager::newRegion&quot;);
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    updaterVector[i] -&gt; newRegion();
+  }
+}
diff --git a/nxcompshad/Manager.h b/nxcompshad/Manager.h
new file mode 100644
index 0000000..2677549
--- /dev/null
+++ b/nxcompshad/Manager.h
@@ -0,0 +1,115 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef UpdateManager_H
+#define UpdateManager_H
+
+#include &lt;X11/Xlib.h&gt;
+
+#include &quot;Updater.h&quot;
+#include &quot;Regions.h&quot;
+#include &quot;Input.h&quot;
+
+typedef char* UpdaterHandle;
+
+class UpdateManager
+{
+  public:
+
+  UpdateManager(int, int, char *, Input *);
+
+  ~UpdateManager();
+
+  void handleInput();
+
+  void addRegion(Region);
+
+  void update();
+
+  UpdaterHandle addUpdater(char *displayName, Display *display);
+
+  int removeUpdater(UpdaterHandle);
+
+  int removeAllUpdaters();
+
+  int numberOfUpdaters();
+
+  int getWidth();
+
+  int getHeight();
+
+  char *getBuffer();
+
+  Region getUpdateManagerRegion();
+
+  void destroyUpdateManagerRegion();
+
+  void newRegion();
+
+  private:
+
+  Updater *createUpdater(char *displayName, Display *display);
+
+  int width_;
+  int height_;
+  char *frameBuffer_;
+  Input *input_;
+
+  int nUpdater;
+
+  Updater **updaterVector;
+
+  Region updateManagerRegion_;
+
+};
+
+inline int UpdateManager::numberOfUpdaters()
+{
+  return nUpdater;
+}
+
+inline int UpdateManager::getWidth()
+{
+  return width_;
+}
+
+inline int UpdateManager::getHeight()
+{
+  return height_;
+}
+
+inline char *UpdateManager::getBuffer()
+{
+  return frameBuffer_;
+}
+
+inline Region UpdateManager::getUpdateManagerRegion()
+{
+  return updateManagerRegion_;
+}
+
+inline void UpdateManager::destroyUpdateManagerRegion()
+{
+  if (updateManagerRegion_ != NULL)
+  {
+    XDestroyRegion(updateManagerRegion_);
+
+    updateManagerRegion_ = NULL;
+  }
+}
+
+#endif /* UpdateManager_H */
diff --git a/nxcompshad/Misc.h b/nxcompshad/Misc.h
new file mode 100644
index 0000000..6dc8635
--- /dev/null
+++ b/nxcompshad/Misc.h
@@ -0,0 +1,42 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Misc_H
+#define Misc_H
+
+#include &lt;iostream&gt;
+
+#include &lt;errno.h&gt;
+#include &lt;string.h&gt;
+
+using namespace std;
+
+//
+// Error handling macros.
+//
+
+#define ESET(e)  (errno = (e))
+#define EGET()   (errno)
+#define ESTR()   strerror(errno)
+
+//
+// Log file.
+//
+
+extern ostream *logofs;
+
+#endif /* Misc_H */
diff --git a/nxcompshad/Poller.h b/nxcompshad/Poller.h
new file mode 100644
index 0000000..4435b5b
--- /dev/null
+++ b/nxcompshad/Poller.h
@@ -0,0 +1,31 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Poller_H
+#define Poller_H
+
+#if defined(__CYGWIN32__) || defined(WIN32)
+
+#include &quot;Win.h&quot;
+
+#else
+
+#include &quot;X11.h&quot;
+
+#endif
+
+#endif /* Poller_H */
diff --git a/nxcompshad/Regions.h b/nxcompshad/Regions.h
new file mode 100644
index 0000000..b9303dc
--- /dev/null
+++ b/nxcompshad/Regions.h
@@ -0,0 +1,35 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Region_H
+#define Region_H
+
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xutil.h&gt;
+
+typedef struct {
+    short x1, x2, y1, y2;
+} Box, BOX, BoxRec, *BoxPtr;
+
+typedef struct _XRegion {
+    long size;
+    long numRects;
+    BOX *rects;
+    BOX extents;
+};
+
+#endif /* Region_H */
diff --git a/nxcompshad/Shadow.cpp b/nxcompshad/Shadow.cpp
new file mode 100644
index 0000000..f9525ad
--- /dev/null
+++ b/nxcompshad/Shadow.cpp
@@ -0,0 +1,470 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;signal.h&gt;
+#include &lt;string.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &quot;Logger.h&quot;
+#include &quot;Shadow.h&quot;
+#include &quot;Poller.h&quot;
+#include &quot;Manager.h&quot;
+
+typedef struct {
+    KeySym  *map;
+    KeyCode minKeyCode,
+            maxKeyCode;
+    int     mapWidth;
+} KeySymsRec, *KeySymsPtr;
+
+KeySymsPtr NXShadowKeymap = NULL;
+
+ShadowOptions NXShadowOptions = {1, 1, -1};
+
+static int mirrorException = 0;
+
+static UpdateManager *updateManager;
+static Poller *poller;
+static Input *input;
+
+int NXShadowRemoveAllUpdaters();
+
+inline bool NXShadowNotInitialized()
+{
+  //
+  // updateManager depends on input and poller.
+  // So this test seem redundant.
+  //
+  // return (input == NULL) || (poller == NULL) || (updateManager == NULL);
+  //
+
+  return (updateManager == NULL);
+}
+
+#ifdef NEED_SIGNAL_HANDLER
+static void NXSignalHandler(int signal)
+{
+  logTest(&quot;NXSignalHandler&quot;, &quot;Got signal [%d]&quot;, signal);
+
+  if (signal == SIGINT)
+  {
+    mirrorException = 1;
+  }
+  else if (signal == SIGTERM)
+  {
+    mirrorException = 1;
+  }
+}
+
+static int NXInitSignal()
+{
+  logTrace(&quot;NXInitSignal&quot;);
+
+  struct sigaction sa;
+
+  sa.sa_handler = NXSignalHandler;
+  sigfillset(&amp;sa.sa_mask);
+  sa.sa_flags = 0;
+
+  int res;
+
+  while ((res = sigaction(SIGINT, &amp;sa, NULL)) == -1 &amp;&amp;
+             errno == EINTR);
+
+  if (res == -1)
+  {
+    logError(&quot;NXInitSignal&quot;, EGET());
+
+    return -1;
+  }
+
+  return 1;
+}
+#endif
+
+static void NXHandleException()
+{
+  if (mirrorException)
+  {
+    mirrorException = 0;
+
+    NXShadowRemoveAllUpdaters();
+  }
+}
+
+static int NXCreateInput(char *keymap, char *shadowDisplayName)
+{
+  logTrace(&quot;NXCreateInput&quot;);
+
+  input = new Input;
+
+  if (input == NULL)
+  {
+    logError(&quot;NXCreateInput&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  input -&gt; setKeymap(keymap);
+
+  input -&gt; setShadowDisplayName(shadowDisplayName);
+
+  return 1;
+}
+
+static int NXCreatePoller(Display *display, Display **shadowDisplay)
+{
+  logTrace(&quot;NXCreatePoller&quot;);
+
+  if (input == NULL)
+  {
+    logError(&quot;NXCreatePoller&quot;, ESET(EBADFD));
+
+    return -1;
+  }
+
+  poller = new Poller(input,display);
+
+  if (poller == NULL)
+  {
+    logError(&quot;NXCreatePoller&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  if (poller -&gt; init() == -1)
+  {
+    logWarning(&quot;NXCreatePoller&quot;, &quot;Failed to initialize poller.&quot;);
+
+    return -1;
+  }
+
+  *shadowDisplay = poller -&gt; getShadowDisplay();
+
+  logTest(&quot;NXCreatePoller&quot;, &quot;Poller geometry [%d, %d], ShadowDisplay[%p].&quot;, poller -&gt; width(),
+              poller -&gt; height(), (Display *) *shadowDisplay);
+
+  return 1;
+}
+
+static int NXCreateUpdateManager()
+{
+  logTrace(&quot;NXCreateUpdateManager&quot;);
+
+  if (input == NULL || poller == NULL)
+  {
+    logError(&quot;NXCreateUpdateManager&quot;, ESET(EBADFD));
+
+    return -1;
+  }
+
+  updateManager = new UpdateManager(poller -&gt; width(), poller -&gt; height(),
+                                        poller -&gt; getFrameBuffer(), input);
+
+  if (updateManager == NULL)
+  {
+    logError(&quot;NXCreateUpdateManager&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  return 1;
+}
+
+void  NXShadowResetOptions()
+{
+  NXShadowOptions.optionShmExtension = 1;
+  NXShadowOptions.optionDamageExtension = 1;
+}
+
+//
+// Exported functions.
+//
+
+int NXShadowHasUpdaters()
+{
+  logTrace(&quot;NXShadowHasUpdaters&quot;);
+
+  return (updateManager &amp;&amp; updateManager -&gt; numberOfUpdaters()) ? 1 : 0;
+}
+
+int NXShadowRemoveAllUpdaters()
+{
+  logTrace(&quot;NXShadowRemoveAllUpdaters&quot;);
+
+  return updateManager ? updateManager -&gt; removeAllUpdaters() : 0;
+}
+
+int NXShadowRemoveUpdater(UpdaterHandle handle)
+{
+  logTrace(&quot;NXShadowRemoveUpdater&quot;);
+
+  return updateManager ? updateManager -&gt; removeUpdater(handle) : 0;
+}
+
+UpdaterHandle NXShadowAddUpdater(char *displayName)
+{
+  logTrace(&quot;NXShadowAddUpdater&quot;);
+
+  return updateManager ? updateManager -&gt; addUpdater(displayName, NULL) : NULL;
+}
+
+int NXShadowAddUpdaterDisplay(void *dpy, int *w, int *h, unsigned char *d)
+{
+  Display *display = reinterpret_cast&lt;Display*&gt;(dpy);
+
+  logTrace(&quot;NXShadowAddUpdaterDisplay&quot;);
+
+  if ((updateManager ? updateManager -&gt; addUpdater(NULL, display) : NULL) == NULL)
+  {
+    logTest(&quot;NXShadowAddUpdaterDisplay&quot;, &quot;Error&quot;);
+
+    return 0;
+  }
+
+  *w = updateManager -&gt; getWidth();
+  *h = updateManager -&gt; getHeight();
+  *d = poller -&gt; depth();
+
+  return 1;
+}
+
+int NXShadowCreate(void *dpy, char *keymap, char* shadowDisplayName, void **shadowDpy)
+{
+  logTrace(&quot;NXShadowCreate&quot;);
+
+  Display *display = reinterpret_cast&lt;Display*&gt;(dpy);
+  Display **shadowDisplay = reinterpret_cast&lt;Display**&gt;(shadowDpy);
+
+/*  if (NXInitSignal() != 1)
+  {
+    logError(&quot;NXShadowCreate&quot;, EGET());
+
+    return -1;
+  }*/
+
+  if (NXCreateInput(keymap, shadowDisplayName) != 1)
+  {
+    logError(&quot;NXShadowCreate&quot;, EGET());
+
+    return -1;
+  }
+
+  if (NXCreatePoller(display, shadowDisplay) != 1)
+  {
+    logWarning(&quot;NXShadowCreate&quot;, &quot;NXCreatePoller failed.&quot;);
+
+    return -1;
+  }
+
+  if (NXCreateUpdateManager() != 1)
+  {
+    logError(&quot;NXShadowCreate&quot;, EGET());
+
+    return -1;
+  }
+
+  return 1;
+}
+
+#if !defined(__CYGWIN32__) &amp;&amp; !defined(WIN32)
+
+void NXShadowSetDisplayUid(int uid)
+{
+  NXShadowOptions.optionShadowDisplayUid = uid;
+}
+
+void NXShadowDisableShm(void)
+{
+  logUser(&quot;NXShadowDisableShm: Disabling SHM.\n&quot;);
+
+  NXShadowOptions.optionShmExtension = 0;
+}
+
+void NXShadowDisableDamage(void)
+{
+  NXShadowOptions.optionDamageExtension = 0;
+}
+
+void NXShadowGetScreenSize(int *w, int *h)
+{
+  poller -&gt; getScreenSize(w, h);
+}
+
+void NXShadowSetScreenSize(int *w, int *h)
+{
+  poller -&gt; setScreenSize(w, h);
+}
+
+#endif
+
+void NXShadowDestroy()
+{
+  if (poller)
+  {
+    delete poller;
+
+    poller = NULL;
+  }
+
+  if (updateManager)
+  {
+    delete updateManager;
+
+    updateManager = NULL;
+  }
+
+  if (input)
+  {
+    delete input;
+
+    input = NULL;
+  }
+}
+
+void NXShadowHandleInput()
+{
+  logTrace(&quot;NXShadowHandleInput&quot;);
+
+  if (NXShadowNotInitialized())
+  {
+    logError(&quot;NXShadowHandleInput - NXShadow not properly initialized.&quot;, ESET(EBADFD));
+
+    return;
+  }
+
+  NXHandleException();
+
+  updateManager -&gt; handleInput();
+
+  poller -&gt; handleInput();
+}
+
+int NXShadowHasChanged(int (*callback)(void *), void *arg, int *suspended)
+{
+  int result;
+
+  logTrace(&quot;NXShadowHasChanged&quot;);
+
+  if (NXShadowNotInitialized())
+  {
+    logError(&quot;NXShadowHasChanged - NXShadow not properly initialized.&quot;, ESET(EBADFD));
+
+    return -1;
+  }
+
+  //
+  // FIXME
+  //updateManager -&gt; destroyUpdateManagerRegion();
+  //
+
+  updateManager -&gt; newRegion();
+
+#if !defined(__CYGWIN32__) &amp;&amp; !defined(WIN32)
+  poller -&gt; getEvents();
+#endif
+
+  result = poller -&gt; isChanged(callback, arg, suspended);
+
+  if (result == 1)
+  {
+    updateManager -&gt; addRegion(poller -&gt; lastUpdatedRegion());
+
+    return 1;
+  }
+  else if (result == -1)
+  {
+    logTest(&quot;NXShadowHasChanged&quot;, &quot;Scanline error.&quot;);
+    return -1;
+  }
+
+  return 0;
+}
+
+void NXShadowExportChanges(long *numRects, char **pBox)
+{
+  Region pReg;
+
+  logTrace(&quot;NXShadowExportChanges&quot;);
+
+  if (NXShadowNotInitialized())
+  {
+    logError(&quot;NXShadowExportChanges - NXShadow not properly initialized.&quot;, ESET(EBADFD));
+  }
+
+  updateManager -&gt; update();
+  pReg = updateManager -&gt; getUpdateManagerRegion();
+  *numRects = pReg -&gt; numRects;
+  *pBox = (char *)pReg -&gt; rects;
+
+  logTest(&quot;NXShadowExportChanges&quot;, &quot;numRects [%ld] pBox[%p], pReg-&gt;numRects[%ld], rects[%p], size[%lu]&quot;,
+              *numRects, *pBox, pReg -&gt; numRects, &amp;(pReg -&gt; rects -&gt; x2),
+                  (unsigned long) sizeof(pReg -&gt; rects -&gt; x2));
+}
+
+void NXShadowEvent(Display *display, XEvent event)
+{
+  poller -&gt; handleEvent(display, &amp;event);
+}
+
+void NXShadowWebKeyEvent(KeySym keysym, Bool isKeyPress)
+{
+  poller -&gt; handleWebKeyEvent(keysym, isKeyPress);
+}
+
+#ifdef __CYGWIN32__
+
+int NXShadowCaptureCursor(unsigned int wnd, void *vis)
+{
+  Window window = (Window)wnd;
+  Visual *visual = reinterpret_cast&lt;Visual*&gt;(vis);
+
+  logTrace(&quot;NXShadowCaptureCursor&quot;);
+
+  logTest(&quot;NXShadowCaptureCursor&quot;,&quot;Init&quot;);
+
+  return poller -&gt; updateCursor(window, visual);
+}
+
+#endif
+
+void NXShadowUpdateBuffer(void **buffer)
+{
+  char **fBuffer = reinterpret_cast&lt;char **&gt;(buffer);
+
+  if (*fBuffer != NULL)
+  {
+    poller -&gt; destroyFrameBuffer();
+
+    poller -&gt; init();
+  }
+
+  *fBuffer = poller -&gt; getFrameBuffer();
+
+  logTest(&quot;NXShadowUpdateBuffer&quot;,&quot;New frame buffer [0x%p]&quot;, (void *)*fBuffer);
+}
+
+void NXShadowInitKeymap(void *keysyms)
+{
+  NXShadowKeymap = (KeySymsPtr) keysyms;
+
+  logTest(&quot;NXShadowInitKeymap&quot;,&quot;KeySyms pointer [0x%p]&quot;, (void *)NXShadowKeymap);
+}
diff --git a/nxcompshad/Shadow.h b/nxcompshad/Shadow.h
new file mode 100644
index 0000000..e1eddb9
--- /dev/null
+++ b/nxcompshad/Shadow.h
@@ -0,0 +1,101 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Shadow_H
+#define Shadow_H
+
+#include &lt;X11/Xlib.h&gt;
+
+#define NXShadowCorrectColor(length, buffer) \
+\
+{ \
+  unsigned short a; \
+  unsigned short b; \
+  unsigned short *shorts; \
+  int i; \
+\
+  length &gt;&gt;= 1; \
+  shorts = (unsigned short *)buffer; \
+  for (i = 0; i &lt; length ; i++) \
+  { \
+    a = shorts[i]; \
+\
+    b = a &amp; 63; \
+    a &lt;&lt;= 1; \
+    a = (a &amp; ~127) | b; \
+\
+    shorts[i] = a; \
+  } \
+}
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef char* UpdaterHandle;
+
+typedef struct _ShadowOptions
+{
+  char  optionShmExtension;
+  char  optionDamageExtension;
+  int   optionShadowDisplayUid;
+} ShadowOptions;
+
+extern ShadowOptions NXShadowOptions;
+
+extern int           NXShadowCreate(void *, char *, char *, void **);
+extern void          NXShadowDestroy(void);
+
+/*
+ * Use an already opened Display connection.
+ * We use &lt;void *&gt; instead of &lt;Display *&gt; to avoid
+ * useless dependences from Xlib headers.
+ */
+
+extern int NXShadowAddUpdaterDisplay(void *display, int *width, int *height,
+                                         unsigned char *depth);
+extern UpdaterHandle NXShadowAddUpdater(char *displayName);
+extern int           NXShadowRemoveUpdater(UpdaterHandle handle);
+extern int           NXShadowRemoveAllUpdaters(void);
+
+extern void          NXShadowHandleInput(void);
+extern int           NXShadowHasChanged(int (*)(void *), void *, int *);
+extern void          NXShadowExportChanges(long *, char **);
+extern int           NXShadowHasUpdaters(void);
+extern int           NXShadowCaptureCursor(unsigned int wnd, void *vis);
+extern void          NXShadowColorCorrect(int, int, unsigned int, unsigned int, char *);
+extern void          NXShadowUpdateBuffer(void **);
+
+extern void          NXShadowEvent(Display *, XEvent);
+extern void          NXShadowWebKeyEvent(KeySym keysym, Bool isKeyPress);
+
+extern void          NXShadowSetDisplayUid(int uid);
+
+extern void          NXShadowDisableShm(void);
+extern void          NXShadowDisableDamage(void);
+
+extern void          NXShadowGetScreenSize(int *width, int *height);
+extern void          NXShadowSetScreenSize(int *width, int *height);
+
+extern void          NXShadowInitKeymap(void *keysyms);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Shadow_H */
+
diff --git a/nxcompshad/Updater.cpp b/nxcompshad/Updater.cpp
new file mode 100644
index 0000000..245c6ce
--- /dev/null
+++ b/nxcompshad/Updater.cpp
@@ -0,0 +1,383 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xutil.h&gt;
+#include &lt;X11/keysym.h&gt;
+#include &lt;string.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+//
+#include &lt;stdio.h&gt;
+//
+#include &quot;Updater.h&quot;
+#include &quot;Logger.h&quot;
+
+Updater::Updater(char *displayName, Display *display)
+{
+  logTrace(&quot;Updater::Updater&quot;);
+
+  displayName_ = displayName;
+  display_ = display;
+  closeDisplay_ = false;
+  image_ = NULL;
+  updateRegion_ = NULL;
+  buffer_ = NULL;
+}
+
+Updater::~Updater()
+{
+  logTrace(&quot;Updater::~Updater&quot;);
+
+  if (input_)
+  {
+    int removedEvents = input_ -&gt; removeAllEvents(display_);
+
+    logTest(&quot;Updater::~Updater&quot;, &quot;Removed events in input queue is [%d].&quot;, removedEvents);
+  }
+
+  if (display_)
+  {
+    XDestroyWindow(display_, window_);
+    XFreePixmap(display_, pixmap_);
+
+    if (closeDisplay_)
+    {
+      XCloseDisplay(display_);
+    }
+  }
+
+  if (image_)
+  {
+    image_ -&gt; data = NULL;
+
+    XDestroyImage(image_);
+  }
+
+  if (updateRegion_)
+  {
+    XDestroyRegion(updateRegion_);
+  }
+}
+
+int Updater::init(int width, int height, char *fb, Input *input)
+{
+  logTrace(&quot;Updater::init&quot;);
+
+  if (fb == NULL || input == NULL || width &lt;= 0 || height &lt;= 0)
+  {
+    logError(&quot;Updater::init&quot;, ESET(EINVAL));
+
+    return -1;
+  }
+
+  width_ = width;
+  height_ = height;
+  buffer_ = fb;
+  input_ = input;
+/*
+  if (display_ == NULL)
+  {
+    display_ = XOpenDisplay(displayName_);
+
+    closeDisplay_ = true;
+
+    if (display_ == NULL)
+    {
+      logError(&quot;Updater::init&quot;, ESET(ENOMSG));
+
+      return -1;
+    }
+  }
+*/
+  depth_ = DefaultDepth(display_, DefaultScreen(display_));
+
+  if (depth_ == 8) bpl_ = width_;
+  else if (depth_ == 16) bpl_ = width_ * 2;
+  else bpl_ = width_ * 4;
+
+  logTest(&quot;Updater::init&quot;, &quot;Server geometry [%d, %d] depth [%d] bpl [%d].&quot;, width_, height_, depth_, bpl_);
+
+/*  int bitmap_pad = 8;
+
+  image_ = XCreateImage(display_, DefaultVisual(display_, DefaultScreen(display_)), depth_, ZPixmap, 0,
+                            buffer_, width_, height_, bitmap_pad, 0);
+
+  if (image_ == NULL)
+  {
+    logError(&quot;Updater::init&quot;, ESET(ENOMSG));
+
+    logTest(&quot;Updater::init&quot;, &quot;Failed to create default image.&quot;);
+
+    return -1;
+  }
+
+  pixmap_ = XCreatePixmap(display_, DefaultRootWindow(display_), width_, height_, depth_);
+
+  unsigned int mask = CWBackPixmap | CWBorderPixel | CWEventMask;
+
+  XSetWindowAttributes attributes;
+
+  attributes.background_pixmap = pixmap_;
+  attributes.border_pixel = WhitePixel(display_, DefaultScreen(display_));
+  attributes.event_mask = KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask;
+
+  window_ = XCreateWindow(display_, DefaultRootWindow(display_),
+                              0, 0, width_, height_, 0, depth_, InputOutput,
+                                  DefaultVisual(display_, DefaultScreen(display_)), mask, &amp;attributes);
+
+  if (window_ == None)
+  {
+    logError(&quot;Updater::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  XSizeHints *size_hints;
+
+  if ((size_hints = XAllocSizeHints()) == NULL)
+  {
+    logError(&quot;Updater::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  size_hints -&gt; flags = PMinSize | PMaxSize;
+  size_hints -&gt; min_width = width_;
+  size_hints -&gt; max_width = width_;
+  size_hints -&gt; min_height = height_;
+  size_hints -&gt; max_height = height_;
+
+  XSetWMNormalHints(display_, window_, size_hints);
+
+  XFree(size_hints);
+
+  Atom deleteWMatom = XInternAtom(display_, &quot;WM_DELETE_WINDOW&quot;, 1);
+
+  XSetWMProtocols(display_, window_, &amp;deleteWMatom, 1);
+
+  XMapWindow(display_, window_);*/
+
+  updateRegion_ = XCreateRegion();
+
+  logTest(&quot;Updater::init&quot;, &quot;updateRegion_[%p]&quot;, updateRegion_);
+  return 1;
+}
+
+void Updater::addRegion(Region region)
+{
+  //
+  // FIXME: Is this too paranoid ?
+  //
+
+  if (updateRegion_ == NULL)
+  {
+    logError(&quot;Updater::addRegion&quot;, ESET(EINVAL));
+
+    return;
+  }
+
+  XUnionRegion(region, updateRegion_, updateRegion_);
+}
+
+void Updater::update()
+{
+  logTrace(&quot;Updater::update&quot;);
+
+  if (updateRegion_ == NULL)
+  {
+    logError(&quot;Updater::update&quot;, ESET(EINVAL));
+
+    return;
+  }
+
+  logTest(&quot;Updater::update&quot;, &quot;Number of rectangles [%ld].&quot;, updateRegion_ -&gt; numRects);
+
+/*  for (; updateRegion_ -&gt; numRects &gt; 0; updateRegion_ -&gt; numRects--)
+  {
+    int n = updateRegion_ -&gt; numRects - 1;
+
+    int x = updateRegion_ -&gt; rects[n].x1;
+    int y = updateRegion_ -&gt; rects[n].y1;
+    unsigned int width = updateRegion_ -&gt; rects[n].x2 - updateRegion_ -&gt; rects[n].x1;
+    unsigned int height = updateRegion_ -&gt; rects[n].y2 - updateRegion_ -&gt; rects[n].y1;
+
+    logDebug(&quot;Updater::update&quot;, &quot;Sending rectangle: [%d, %d, %d, %d].&quot;, x, y, width, height);
+
+    //
+    // We need to update the extents.
+    //
+
+    int bitmap_pad;
+
+    if (depth_ == 32 || depth_ == 24)
+    {
+      bitmap_pad = 32;
+    }
+    else if (depth_ == 16)
+    {
+      if ((width &amp; 1) == 0)
+      {
+        bitmap_pad = 32;
+      }
+      else
+      {
+        bitmap_pad = 16;
+      }
+    }
+    else if ((width &amp; 3) == 0)
+    {
+      bitmap_pad = 32;
+    }
+    else if ((width &amp; 1) == 0)
+    {
+      bitmap_pad = 16;
+    }
+    else
+    {
+      bitmap_pad = 8;
+    }*/
+
+/*    image_ -&gt; bitmap_pad = bitmap_pad;*/
+
+   /* NXShadowCorrectColor(x, y, width, height);*/
+
+/*    XPutImage(display_, pixmap_, DefaultGC(display_, DefaultScreen(display_)),
+                  image_, x, y, x, y, width, height);
+
+    XClearArea(display_, window_, x, y, width, height, 0);
+  }*/
+
+  //
+  // Should we reduces the box vector ?
+  //
+  // BOX *box = Xrealloc(updateRegion_ -&gt; rects,
+  //                         updateRegion_ -&gt; numRects == 0 ? sizeof(BOX) :
+  //                             updateRegion_ -&gt; numRects * sizeof(BOX));
+  //
+  // if (box)
+  // {
+  //   updateRegion_ -&gt; rects = box;
+  //   updateRegion_ -&gt; size = 1;
+  // }
+  //
+
+  if (updateRegion_ -&gt; numRects == 0)
+  {
+    updateRegion_ -&gt; extents.x1 = 0;
+    updateRegion_ -&gt; extents.y1 = 0;
+    updateRegion_ -&gt; extents.x2 = 0;
+    updateRegion_ -&gt; extents.y2 = 0;
+  }
+  else
+  {
+    //
+    // FIXME: We have to update the region extents.
+    //
+
+    logTest(&quot;Updater::update&quot;, &quot;Region extents has not been updated.&quot;);
+  }
+}
+
+void Updater::handleInput()
+{
+  logTrace(&quot;Updater::handleInput&quot;);
+
+  XEvent *event = new XEvent;
+
+  if (event == NULL)
+  {
+    logError(&quot;Updater::handleInput&quot;, ESET(ENOMEM));
+
+    return;
+  }
+
+  while (XCheckIfEvent(display_, event, anyEventPredicate, NULL))
+  {
+    switch (event -&gt; type)
+    {
+     /* case ClientMessage:
+      {
+        Atom wmProtocols = XInternAtom(display_, &quot;WM_PROTOCOLS&quot;, 0);
+        Atom wmDeleteWindow = XInternAtom(display_, &quot;WM_DELETE_WINDOW&quot;, 0);
+
+        if (event -&gt; xclient.message_type == wmProtocols &amp;&amp;
+                (Atom)event -&gt; xclient.data.l[0] == wmDeleteWindow)
+        {
+          logTest(&quot;Updater::handleInput&quot;, &quot;Got client message of type WM_PROTOCOLS and value WM_DELETE_WINDOW,&quot;
+                      &quot; throwing exception UpdaterClosing.&quot;);
+
+          delete event;
+
+          throw UpdaterClosing();
+        }
+        else
+        {
+          logTest(&quot;Updater::handleInput&quot;, &quot;Unexpected client message type [%ld] format [%d] first value [%ld]&quot;,
+                      event -&gt; xclient.message_type, event -&gt; xclient.format, event -&gt; xclient.data.l[0]);
+        }
+
+        break;
+      }*/
+      case KeyPress:
+      case KeyRelease:
+      case ButtonPress:
+      case ButtonRelease:
+      case MotionNotify:
+      {
+        input_ -&gt; pushEvent(display_, event);
+
+        event = new XEvent;
+
+        if (event == NULL)
+        {
+          logError(&quot;Updater::handleInput&quot;, ESET(ENOMEM));
+
+          return;
+        }
+
+        break;
+      }
+      default:
+      {
+        logTest(&quot;Updater::handleInput&quot;, &quot;Handling unexpected event [%d].&quot;, event -&gt; type);
+
+        break;
+      }
+    }
+  }
+
+  delete event;
+}
+
+void Updater::newRegion()
+{
+  if (updateRegion_ != NULL)
+  {
+    XDestroyRegion(updateRegion_);
+  }
+
+  updateRegion_ = XCreateRegion();
+
+  logTest(&quot;Updater::newRegion&quot;, &quot;updateRegion_ [%p].&quot;, updateRegion_);
+}
+//
+// Private functions.
+//
diff --git a/nxcompshad/Updater.h b/nxcompshad/Updater.h
new file mode 100644
index 0000000..daa26c1
--- /dev/null
+++ b/nxcompshad/Updater.h
@@ -0,0 +1,95 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Updater_H
+#define Updater_H
+
+#include &lt;X11/Xlib.h&gt;
+
+#include &quot;Regions.h&quot;
+#include &quot;Input.h&quot;
+
+class UpdaterClosing {};
+
+class Updater
+{
+  public:
+
+  Updater(char *displayName, Display *display);
+
+  ~Updater();
+
+  int init(int, int, char *, Input*);
+
+  void addRegion(Region r);
+
+  void update();
+
+  void handleInput();
+
+  XImage *getImage();
+
+  Region getUpdateRegion();
+
+  void newRegion();
+
+  private:
+
+  Input *input_;
+
+  static inline Bool anyEventPredicate(Display*, XEvent*, XPointer);
+
+  void handleKeyboardEvent(XEvent &amp;event);
+
+  char *displayName_;
+
+  char *buffer_;
+
+  bool closeDisplay_;
+
+  Display *display_;
+
+  int depth_;
+
+  int width_;
+  int height_;
+
+  int bpl_;
+
+  Window window_;
+  XImage *image_;
+
+  Pixmap pixmap_;
+
+  Region updateRegion_;
+
+};
+
+Bool Updater::anyEventPredicate(Display*, XEvent*, XPointer)
+{
+  return true;
+}
+
+inline XImage* Updater::getImage()
+{
+  return image_;
+}
+inline Region Updater::getUpdateRegion()
+{
+  return updateRegion_;
+}
+#endif /* Updater_H */
diff --git a/nxcomp/VERSION b/nxcompshad/VERSION
similarity index 100%
copy from nxcomp/VERSION
copy to nxcompshad/VERSION
diff --git a/nxcompshad/Win.cpp b/nxcompshad/Win.cpp
new file mode 100644
index 0000000..481cbca
--- /dev/null
+++ b/nxcompshad/Win.cpp
@@ -0,0 +1,1137 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#if defined(__CYGWIN32__) || defined(WIN32)
+
+#include &lt;X11/keysym.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &quot;Poller.h&quot;
+#include &quot;Logger.h&quot;
+
+Poller::Poller(Input *input, Display *display, int depth) : CorePoller(input, display)
+{
+  logTrace(&quot;Poller::Poller&quot;);
+
+  screenDC_ = NULL;
+  screenBmp_ = NULL;
+  memoryDC_ = NULL;
+  pDIBbits_ = NULL;
+  DIBBuffer_ = NULL;
+  pKey_ = NULL;
+  pMouse_ = NULL;
+  path_ = NULL;
+  keymapName_ = input -&gt; getKeymap();
+  keymap_ = NULL;
+  toggleButtonState_ = 0;
+  serverModifierState_ = 0;
+  display_ = display;
+  depth_ = DefaultDepth(display_, DefaultScreen(display_));
+  oldCursor_ = 0;
+  xCursor_ = 0;
+}
+
+Poller::~Poller()
+{
+  logTrace(&quot;Poller::~Poller&quot;);
+
+  if (screenDC_)
+  {
+    BOOL result = ReleaseDC(NULL, screenDC_);
+
+    logTest(&quot;Poller::~Poller&quot;, &quot;ReleaseDC returned [%d].&quot;, result);
+
+    screenDC_ = NULL;
+  }
+
+  if (memoryDC_)
+  {
+    BOOL result = DeleteDC(memoryDC_);
+
+    logTest(&quot;Poller::~Poller&quot;, &quot;DeleteDC returned [%d].&quot;, result);
+
+    memoryDC_ = NULL;
+  }
+
+  if (screenBmp_)
+  {
+    BOOL result = DeleteObject(screenBmp_);
+
+    logTest(&quot;Poller::~Poller&quot;, &quot;DeleteObject returned [%d].&quot;, result);
+
+    screenBmp_ = NULL;
+  }
+
+  if (DIBBuffer_)
+  {
+    logDebug(&quot;Poller::~Poller&quot;, &quot;Delete DIBBuffer_ [%p].&quot;, DIBBuffer_);
+
+    delete [] DIBBuffer_;
+  }
+
+  if (pKey_)
+  {
+    logDebug(&quot;Poller::~Poller&quot;, &quot; pKey_[%p].&quot;, pKey_);
+
+    delete [] pKey_;
+  }
+
+  if (pMouse_)
+  {
+    logDebug(&quot;Poller::~Poller&quot;, &quot; pMouse_[%p].&quot;, pMouse_);
+
+    delete [] pMouse_;
+  }
+
+  if (keymap_)
+  {
+    logDebug(&quot;Poller::~Poller&quot;, &quot; keymap_[%p].&quot;, keymap_);
+
+    delete [] keymap_;
+  }
+}
+
+int Poller::init()
+{
+  logTrace(&quot;Poller::init&quot;);
+
+  int maxLengthArrayINPUT = 6;
+
+  platformOS();
+
+  pKey_ = new INPUT [maxLengthArrayINPUT];
+
+  if (pKey_ == NULL)
+  {
+    logError(&quot;Poller::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  for (int i = 0; i &lt; maxLengthArrayINPUT; i++)
+  {
+    pKey_[i].type = INPUT_KEYBOARD;
+    pKey_[i].ki.wVk = (WORD) 0;
+    pKey_[i].ki.time = (DWORD) 0;
+    pKey_[i].ki.dwExtraInfo = (DWORD) 0;
+  }
+
+  pMouse_ = new INPUT;
+
+  if (pMouse_ == NULL)
+  {
+    logError(&quot;Poller::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  pMouse_ -&gt; type = INPUT_MOUSE;
+
+  pMouse_ -&gt; mi.dx = 0;
+  pMouse_ -&gt; mi.dy = 0;
+  pMouse_ -&gt; mi.mouseData = (DWORD) 0;
+  pMouse_ -&gt; mi.time = 0;
+  pMouse_ -&gt; mi.dwExtraInfo = (ULONG_PTR) NULL;
+
+  screenDC_ = GetDC(NULL);
+
+  if (screenDC_ == NULL)
+  {
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  switch(depth_)
+  {
+    case 8:
+    {
+      depth_ = 16;
+      break;
+    }
+    case 16:
+    {
+      depth_ = 16;
+      break;
+    }
+    case 24:
+    {
+      depth_ = 32;
+      break;
+    }
+    default:
+    {
+      logError(&quot;Poller::init&quot;, ESET(EINVAL));
+
+      return -1;
+    }
+  }
+
+  width_ = GetDeviceCaps(screenDC_, HORZRES);
+  height_ = GetDeviceCaps(screenDC_, VERTRES);
+
+  bpl_ = width_ * (depth_ &gt;&gt; 3);
+  bpp_ = (depth_ &gt;&gt; 3);
+
+  logTest(&quot;Poller::init&quot;, &quot;Screen geometry is [%d, %d] depth is [%d] bpl [%d] bpp [%d].&quot;,
+              width_, height_, depth_, bpl_, bpp_);
+
+  logTest(&quot;Poller::init&quot;, &quot;Got device context at [%p] screen size is (%d,%d).&quot;,
+            screenDC_, width_, height_);
+
+  memoryDC_ = CreateCompatibleDC(screenDC_);
+
+  if (memoryDC_ == NULL)
+  {
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  //
+  // Delete the old bitmap for the memory device.
+  //
+
+  HBITMAP bitmap = (HBITMAP) GetCurrentObject(memoryDC_, OBJ_BITMAP);
+
+  if (bitmap &amp;&amp; DeleteObject(bitmap) == 0)
+  {
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+  }
+
+  //
+  // Bitmap header describing the bitmap we want to get from GetDIBits.
+  //
+
+  bmi_.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
+  bmi_.bmiHeader.biWidth         = width_;
+  bmi_.bmiHeader.biHeight        = -height_;
+  bmi_.bmiHeader.biPlanes        = 1;
+  bmi_.bmiHeader.biBitCount      = depth_;
+  bmi_.bmiHeader.biCompression   = BI_RGB;
+  bmi_.bmiHeader.biSizeImage     = 0;
+  bmi_.bmiHeader.biXPelsPerMeter = 0;
+  bmi_.bmiHeader.biYPelsPerMeter = 0;
+  bmi_.bmiHeader.biClrUsed       = 0;
+  bmi_.bmiHeader.biClrImportant  = 0;
+
+  screenBmp_ = CreateDIBSection(memoryDC_, &amp;bmi_, DIB_RGB_COLORS, &amp;pDIBbits_, NULL, 0);
+  ReleaseDC(NULL,memoryDC_);
+
+  if (screenBmp_ == NULL)
+  {
+    logTest (&quot;Poller::init&quot;, &quot;This video device is not supporting DIB section&quot;);
+
+    pDIBbits_ = NULL;
+
+    screenBmp_ = CreateCompatibleBitmap(screenDC_, width_, height_);
+
+    if (screenBmp_ == NULL)
+    {
+      logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+      return -1;
+    }
+
+    if (SelectObject(memoryDC_, screenBmp_) == NULL)
+    {
+      logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+      return -1;
+    }
+  }
+  else
+  {
+    logTest (&quot;Poller::init&quot;, &quot;Enabled the DIB section&quot;);
+
+    if (SelectObject(memoryDC_, screenBmp_) == NULL)
+    {
+      logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+      return -1;
+    }
+  }
+
+  //
+  // Check if the screen device raster capabilities
+  // support the bitmap transfer.
+  //
+
+  if ((GetDeviceCaps(screenDC_, RASTERCAPS) &amp; RC_BITBLT) == 0)
+  {
+    logTest(&quot;Poller::init&quot;, &quot;This video device is not supporting the bitmap transfer.&quot;);
+
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  //
+  // Check if the memory device raster capabilities
+  // support the GetDIBits and SetDIBits functions.
+  //
+
+  if ((GetDeviceCaps(memoryDC_, RASTERCAPS) &amp; RC_DI_BITMAP) == 0)
+  {
+    logTest(&quot;Poller::init&quot;, &quot;This memory device is not supporting the GetDIBits and SetDIBits &quot;
+               &quot;function.&quot;);
+
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  if (GetDeviceCaps(screenDC_, PLANES) != 1)
+  {
+    logTest(&quot;Poller::init&quot;, &quot;This video device has more than 1 color plane.&quot;);
+
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  return CorePoller::init();
+}
+
+//
+// FIXME: Remove me.
+//
+
+void ErrorExit(LPTSTR lpszFunction)
+{
+    LPVOID lpMsgBuf;
+    DWORD dw = GetLastError();
+
+    FormatMessage(
+        FORMAT_MESSAGE_ALLOCATE_BUFFER |
+        FORMAT_MESSAGE_FROM_SYSTEM,
+        NULL,
+        dw,
+        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+        (LPTSTR) &amp;lpMsgBuf,
+        0, NULL );
+
+    logTest(lpszFunction, &quot; Failed with error [%ld]: %s&quot;, dw, (char*)lpMsgBuf);
+
+    LocalFree(lpMsgBuf);
+    ExitProcess(dw);
+}
+
+//
+// FIXME: End.
+//
+
+char *Poller::getRect(XRectangle r)
+{
+  logTrace(&quot;Poller::getRect&quot;);
+
+  logDebug(&quot;Poller::getRect&quot;, &quot;Going to retrive rectangle [%d, %d, %d, %d].&quot;,
+              r.x, r.y, r.width, r.height);
+
+  //
+  // The CAPTUREBLT operation could be a very
+  // cpu-consuming task. We should make some
+  // test to see how much it is expensive.
+  // Anyway we get tooltip windows and any
+  // other special effect not included with
+  // only the SRCCOPY operation.
+  //
+
+  if (BitBlt(memoryDC_, r.x, r.y, r.width, r.height,
+                 screenDC_, r.x, r.y, SRCCOPY | CAPTUREBLT) == 0)
+  {
+    logError(&quot;Poller::getRect&quot;, ESET(ENOMSG));
+
+    logTest(&quot;Poller::getRect&quot;, &quot;Failed to perform a bit-block transfer.&quot;);
+    logTest(&quot;Poller::getRect&quot;, &quot;bit-block error=%lu&quot;, GetLastError());
+
+    return NULL;
+  }
+
+  // bmi_.bmiHeader.biWidth = r.width;
+  // bmi_.bmiHeader.biHeight = -r.height;
+
+  if (pDIBbits_ == NULL)
+  {
+    static long nPixel = 0;
+
+    if (nPixel &lt; r.width * r.height)
+    {
+
+      if (DIBBuffer_)
+      {
+        delete [] DIBBuffer_;
+      }
+
+      nPixel = r.width * r.height;
+
+      DIBBuffer_ = new char [nPixel * bpp_];
+
+      if (DIBBuffer_ == NULL)
+      {
+        logError(&quot;Poller::getRect&quot;, ESET(ENOMEM));
+
+        nPixel = 0;
+
+        return NULL;
+      }
+    }
+
+    if (GetDIBits(memoryDC_, screenBmp_, height_ - r.height - r.y, r.height,
+                      DIBBuffer_, &amp;bmi_, DIB_RGB_COLORS) == 0)
+    {
+      logError(&quot;Poller::getRect&quot;, ESET(ENOMSG));
+
+      logTest(&quot;Poller::getRect&quot;, &quot;Failed to retrieve the screen bitmap.&quot;);
+
+      return NULL;
+    }
+
+    return DIBBuffer_;
+  }
+  else
+  {
+    return (char *) pDIBbits_ + r.y * bpl_ + r.x * bpp_;
+  }
+}
+
+void Poller::handleKeyboardEvent(Display *display, XEvent *event)
+{
+  KeySym keysym;
+  char *keyname = new char [31];
+  keyTranslation tr = {0, 0};
+  unsigned char scancode = 0;
+  int lengthArrayINPUT = 0;
+
+  if (XLookupString((XKeyEvent *) event, keyname, 30, &amp;keysym, NULL) &gt; 0)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;keyname %s, keysym [%x]&quot;, keyname, (unsigned int)keysym);
+  }
+
+  if (specialKeys(keysym, event -&gt; xkey.state, event -&gt; type) == 1)
+  {
+    delete[] keyname;
+    return;
+  }
+
+  tr = xkeymapTranslateKey(keysym, event -&gt; xkey.keycode, event -&gt; xkey.state);
+  scancode = tr.scancode;
+
+  logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;keyname [%s] scancode [0x%x], keycode[0x%x], keysym [%x]&quot;, keyname,
+              tr.scancode, event -&gt;xkey.keycode, (unsigned int)keysym);
+
+  if (scancode == 0)
+  {
+    delete[] keyname;
+    return;
+  }
+
+  if (event -&gt; type == KeyPress)
+  {
+    int test1 = MapVirtualKey(scancode, MAPVK_VSC_TO_VK_EX);
+    int test2 = MapVirtualKey(0x24, MAPVK_VSC_TO_VK_EX);
+
+    if (test1 == test2)
+    {
+      simulateCtrlAltDel();
+    }
+
+    if (isModifier(scancode) == 0)
+    {
+      savedServerModifierState_ = serverModifierState_;
+    }
+
+    ensureServerModifiers(tr, &amp;lengthArrayINPUT);
+    if (sendInput(scancode, 1, &amp;lengthArrayINPUT) == 0)
+    {
+      logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;lengthArrayINPUT [%d].&quot;, lengthArrayINPUT);
+    }
+    restoreServerModifiers(scancode);
+  }
+  else if (event -&gt; type == KeyRelease)
+  {
+    if (sendInput(scancode, 0, &amp;lengthArrayINPUT) == 0)
+    {
+      logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;lengthArrayINPUT [%d].&quot;, lengthArrayINPUT);
+    }
+  }
+
+  updateModifierState(scancode, (event -&gt; type == KeyPress));
+
+  delete[] keyname;
+}
+
+void Poller::handleWebKeyboardEvent(KeySym keysym, Bool isKeyPress)
+{
+/*
+FIXME
+*/
+}
+
+void Poller::handleMouseEvent(Display *display, XEvent *event)
+{
+  DWORD flg = 0;
+  DWORD whl = 0;
+
+  if (event -&gt; type == ButtonPress)
+  {
+    logTest(&quot;Poller::handleMouseEvent&quot;, &quot;ButtonPress.\n&quot;);
+    switch (event -&gt; xbutton.button)
+    {
+      case Button1:
+      {
+        flg = MOUSEEVENTF_LEFTDOWN;
+        break;
+      }
+      case Button2:
+      {
+        flg = MOUSEEVENTF_MIDDLEDOWN;
+        break;
+      }
+      case Button3:
+      {
+        flg = MOUSEEVENTF_RIGHTDOWN;
+        break;
+      }
+      case Button4:
+      {
+        flg = MOUSEEVENTF_WHEEL;
+        whl = WHEEL_DELTA;
+        pMouse_ -&gt; mi.mouseData = whl;
+        break;
+      }
+      case Button5:
+      {
+        flg = MOUSEEVENTF_WHEEL;
+        whl = (DWORD) (-WHEEL_DELTA);
+        pMouse_ -&gt; mi.mouseData = whl;
+        break;
+      }
+    }
+  }
+  else if (event -&gt; type == ButtonRelease)
+  {
+    switch (event -&gt; xbutton.button)
+    {
+      case Button1:
+      {
+        flg = MOUSEEVENTF_LEFTUP;
+        break;
+      }
+      case Button2:
+      {
+        flg = MOUSEEVENTF_MIDDLEUP;
+        break;
+      }
+      case Button3:
+      {
+        flg = MOUSEEVENTF_RIGHTUP;
+        break;
+      }
+      case Button4:
+      {
+        flg = MOUSEEVENTF_WHEEL;
+        whl = 0;
+        pMouse_ -&gt; mi.mouseData = whl;
+        break;
+      }
+      case Button5:
+      {
+        flg = MOUSEEVENTF_WHEEL;
+        whl = 0;
+        pMouse_ -&gt; mi.mouseData = whl;
+        break;
+      }
+    }
+  }
+  else if (event -&gt; type == MotionNotify)
+  {
+    logTest(&quot;Poller::handleMouseEvent&quot;, &quot;SetCursor - MotionNotify&quot;);
+
+    SetCursorPos(event -&gt; xmotion.x, event -&gt; xmotion.y);
+  }
+
+  if (flg &gt; 0)
+  {
+  //  logTest(&quot;Poller::handleMouseEvent&quot;, &quot;SetCursor - flg &gt; 0&quot;);
+    //
+    // FIXME: move the cursor to the pace the event occurred
+    //
+
+    SetCursorPos(event -&gt; xbutton.x, event -&gt; xbutton.y);
+
+    //
+    // FIXME: Remove me: send the click/release event
+    // mouse_event(flg, 0, 0, whl, (ULONG_PTR)NULL);
+    //
+
+    pMouse_ -&gt; mi.dwFlags = flg;
+
+    if (SendInput(1, pMouse_, sizeof(INPUT)) == 0)
+    {
+      logTest(&quot;Poller::handleMouseEvent&quot;, &quot;Failed SendInput&quot;);
+    }
+  }
+}
+
+int Poller::updateCursor(Window wnd, Visual* vis)
+{
+  BYTE *mBits, *andBits, *xorBits;
+
+  logTrace(&quot;Poller::Cursor&quot;);
+
+  //
+  // Retrieve mouse cursor handle.
+  //
+
+  CURSORINFO cursorInfo;
+  cursorInfo.cbSize = sizeof(CURSORINFO);
+
+  if (GetCursorInfo(&amp;cursorInfo) == 0)
+  {
+    logTest(&quot;Poller::Cursor&quot;, &quot;GetCursorInfo() failed [%u].\n&quot;, (unsigned int)GetLastError());
+    LocalFree(&amp;cursorInfo);
+    return -1;
+  }
+
+  HCURSOR hCursor = cursorInfo.hCursor;
+
+  if (hCursor == 0)
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;Cursor Handle is NULL. Error[%u].\n&quot;, (unsigned int)GetLastError());
+    return 1;
+  }
+
+  if (hCursor == oldCursor_)
+  {
+    LocalFree(&amp;cursorInfo);
+    return 1;
+  }
+  else
+  {
+    oldCursor_ = hCursor;
+  }
+
+  //
+  // Get cursor info.
+  //
+
+  //  logTest(&quot;Poller::Cursor&quot;,&quot;hCursor [%xH] GetCursor [%xH].\n&quot;, hCursor, GetCursor());
+
+  ICONINFO iconInfo;
+  if (GetIconInfo(hCursor, &amp;iconInfo) == 0)
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;GetIconInfo() failed. Error[%d].&quot;, (unsigned int)GetLastError());
+    LocalFree(&amp;iconInfo);
+    //    return -1;
+  }
+
+  BOOL isColorCursor = FALSE;
+  if (iconInfo.hbmColor != NULL)
+  {
+    isColorCursor = TRUE;
+  }
+
+  if (iconInfo.hbmMask == NULL)
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;Cursor bitmap handle is NULL.\n&quot;);
+    return -1;
+  }
+
+  //
+  // Check bitmap info for the cursor
+  //
+
+  BITMAP bmMask;
+  if (!GetObject(iconInfo.hbmMask, sizeof(BITMAP), (LPVOID)&amp;bmMask))
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;GetObject() for bitmap failed.\n&quot;);
+    DeleteObject(iconInfo.hbmMask);
+    LocalFree(&amp;bmMask);
+    return -1;
+  }
+
+  if (bmMask.bmPlanes != 1 || bmMask.bmBitsPixel != 1)
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;Incorrect data in cursor bitmap.\n&quot;);
+    LocalFree(&amp;bmMask);
+    DeleteObject(iconInfo.hbmMask);
+    return -1;
+  }
+
+  // Get monochrome bitmap data for cursor
+  // NOTE: they say we should use GetDIBits() instead of GetBitmapBits().
+  mBits = new BYTE[bmMask.bmWidthBytes * bmMask.bmHeight];
+
+  if (mBits == NULL)//Data bitmap
+  {
+    DeleteObject(iconInfo.hbmMask);
+    DestroyCursor(cursorInfo.hCursor);
+    LocalFree(&amp;iconInfo);
+    LocalFree(&amp;bmMask);
+    delete[] mBits;
+    return -1;
+  }
+
+  BOOL success = GetBitmapBits(iconInfo.hbmMask, bmMask.bmWidthBytes * bmMask.bmHeight, mBits);
+
+  if (!success)
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;GetBitmapBits() failed.\n&quot;);
+    delete[] mBits;
+    return -1;
+  }
+
+  andBits = mBits;
+
+  long width = bmMask.bmWidth;
+  long height = (isColorCursor) ? bmMask.bmHeight : bmMask.bmHeight/2;
+
+  //
+  // The bitmask is formatted so that the upper half is
+  // the icon AND bitmask and the lower half is the icon XOR bitmask.
+  //
+
+  if (!isColorCursor)
+  {
+    xorBits = andBits + bmMask.bmWidthBytes * height;
+
+/*    logTest(&quot;Poller::Cursor&quot;,&quot;no color widthB[%ld] width[%ld] height[%ld] totByte[%ld] mbits[%ld].\n&quot;,
+                 bmMask.bmWidthBytes,width,height,success,bmMask.bmHeight * bmMask.bmWidthBytes);*/
+
+    if (xCursor_ &gt; 0)
+    {
+      XFreeCursor(display_, xCursor_);
+    }
+
+    xCursor_ = createCursor(wnd, vis, (unsigned int)iconInfo.xHotspot, (unsigned int)iconInfo.yHotspot,
+                    width, height, (unsigned char *)xorBits, (unsigned char *)andBits);
+
+    XDefineCursor(display_, wnd, xCursor_);
+  }
+
+  delete []mBits;
+  DeleteObject(iconInfo.hbmMask);
+  LocalFree(&amp;bmMask);
+  DestroyCursor(cursorInfo.hCursor);
+  LocalFree(&amp;iconInfo);
+
+  return success;
+}
+
+unsigned char Poller::specialKeys(unsigned int keysym, unsigned int state, int pressed)
+{
+  return 0;
+}
+
+void Poller::ensureServerModifiers(keyTranslation tr, int *lengthArrayINPUT)
+{
+  return;
+}
+
+void Poller::restoreServerModifiers(UINT scancode)
+{
+  keyTranslation dummy;
+  int lengthArrayINPUT = 0;
+
+  if (isModifier(scancode) == 1)
+  {
+    return;
+  }
+
+  dummy.scancode = 0;
+  dummy.modifiers = savedServerModifierState_;
+  ensureServerModifiers(dummy, &amp;lengthArrayINPUT);
+  if (sendInput(0, 0, &amp;lengthArrayINPUT) == 0)
+  {
+    logTest(&quot;Poller::restoreServerModifiers&quot;, &quot;lengthArrayINPUT [%d]&quot;, lengthArrayINPUT);
+  }
+}
+
+int Poller::updateShadowFrameBuffer(void)
+{
+  return 1;
+}
+
+void Poller::addToKeymap(char *keyname, unsigned char scancode, unsigned short modifiers, char *mapname)
+{
+  return;
+}
+
+FILE *Poller::xkeymapOpen(char *filename)
+{
+  return NULL;
+}
+
+int Poller::xkeymapRead(char *mapname)
+{
+  return 1;
+}
+
+void Poller::xkeymapInit(char *keyMapName)
+{
+  return;
+}
+
+keyTranslation Poller::xkeymapTranslateKey(unsigned int keysym, unsigned int keycode,
+                                               unsigned int state)
+{
+  keyTranslation tr = { 0, 0 };
+
+  return tr;
+}
+
+unsigned char Poller::getKeyState(unsigned int state, unsigned int keysym)
+{
+  return 0;
+}
+
+char *Poller::getKsname(unsigned int keysym)
+{
+        char *ksname = NULL;
+
+        return ksname;
+}
+
+//
+// Routine used to fool Winlogon into thinking CtrlAltDel was pressed
+//
+char Poller::simulateCtrlAltDel(void)
+{
+  HDESK oldDesktop = GetThreadDesktop(GetCurrentThreadId());
+
+  //
+  // Switch into the Winlogon desktop.
+  //
+  if (selectDesktopByName(&quot;Winlogon&quot;) == 0)
+  {
+    logTest(&quot;SimulateCtrlAltDelThreadFn&quot;,&quot;Failed to select logon desktop.&quot;);
+    return 0;
+  }
+
+  logTest(&quot;SimulateCtrlAltDelThreadFn&quot;,&quot;Generating ctrl-alt-del.&quot;);
+
+  //
+  // Winlogon uses hotkeys to trap Ctrl-Alt-Del.
+  //
+  PostMessage(HWND_BROADCAST, WM_HOTKEY, 0, MAKELONG(MOD_ALT | MOD_CONTROL, VK_DELETE));
+
+  //
+  // Switch back to our original desktop.
+  //
+  if (oldDesktop != NULL)
+  {
+    selectDesktop(oldDesktop);
+  }
+
+  return 1;
+}
+
+// Switches the current thread into a different desktop by desktop handle
+// This call takes care of all the evil memory management involved
+char Poller::selectDesktop(HDESK newDesktop)
+{
+  //
+  // Only on NT.
+  //
+  if (isWinNT())
+  {
+    HDESK oldDesktop = GetThreadDesktop(GetCurrentThreadId());
+
+    DWORD dummy;
+    char newName[256];
+
+    if (GetUserObjectInformation(newDesktop, UOI_NAME, &amp;newName, 256, &amp;dummy) == 0)
+    {
+      logDebug(&quot;Poller::selectDesktop&quot;,&quot;GetUserObjectInformation() failed. Error[%lu].&quot;, GetLastError());
+      return 0;
+    }
+
+    logTest(&quot;Poller::selectDesktop&quot;,&quot;New Desktop to [%s] (%x) from (%x).&quot;,
+                 newName, (unsigned int)newDesktop, (unsigned int)oldDesktop);
+
+    //
+    // Switch the desktop.
+    //
+    if(SetThreadDesktop(newDesktop) == 0)
+    {
+      logDebug(&quot;Poller::SelectDesktop&quot;,&quot;Unable to SetThreadDesktop(), Error=%lu.&quot;, GetLastError());
+      return 0;
+    }
+
+    //
+    // Switched successfully - destroy the old desktop.
+    //
+    if (CloseDesktop(oldDesktop) == 0)
+    {
+      logDebug(&quot;Poller::selectHdesk&quot;,&quot;Failed to close old desktop (%x), Error=%lu.&quot;,
+                   (unsigned int)oldDesktop, GetLastError());
+      return 0;
+    }
+  }
+
+  return 1;
+}
+
+//
+// Switches the current thread into a different desktop, by name
+// Calling with a valid desktop name will place the thread in that desktop.
+// Calling with a NULL name will place the thread in the current input desktop.
+//
+
+char Poller::selectDesktopByName(char *name)
+{
+  //
+  // Only on NT.
+  //
+  if (isWinNT())
+  {
+    HDESK desktop;
+
+    if (name != NULL)
+    {
+      //
+      // Attempt to open the named desktop.
+      //
+      desktop = OpenDesktop(name, 0, FALSE,
+                                DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW |
+                                DESKTOP_ENUMERATE | DESKTOP_HOOKCONTROL |
+                                DESKTOP_WRITEOBJECTS | DESKTOP_READOBJECTS |
+                                DESKTOP_SWITCHDESKTOP | GENERIC_WRITE);
+    }
+    else
+    {
+      //
+      // Open the input desktop.
+      //
+      desktop = OpenInputDesktop(0, FALSE,
+                                     DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW |
+                                     DESKTOP_ENUMERATE | DESKTOP_HOOKCONTROL |
+                                     DESKTOP_WRITEOBJECTS | DESKTOP_READOBJECTS |
+                                     DESKTOP_SWITCHDESKTOP | GENERIC_WRITE);
+    }
+
+    if (desktop == NULL)
+    {
+      logDebug(&quot;Poller::selectDesktopByName&quot;,&quot;Unable to open desktop, Error=%lu.&quot;, GetLastError());
+      return 0;
+    }
+
+    //
+    // Switch to the new desktop
+    //
+    if (selectDesktop(desktop) == 0)
+    {
+      //
+      // Failed to enter the new desktop, so free it!
+      //
+      logDebug(&quot;Poller::selectDesktopByName&quot;,&quot;Failed to select desktop.&quot;);
+
+      if (CloseDesktop(desktop) == 0)
+      {
+        logDebug(&quot;Poller::selectDesktopByName&quot;,&quot;Failed to close desktop, Error=%lu.&quot;, GetLastError());
+        return 0;
+      }
+    }
+
+    return 1;
+  }
+
+  return (name == NULL);
+}
+
+void Poller::platformOS()
+{
+    OSVERSIONINFO osversioninfo;
+    osversioninfo.dwOSVersionInfoSize = sizeof(osversioninfo);
+
+    //
+    // Get the current OS version.
+    //
+    if (GetVersionEx(&amp;osversioninfo) == 0)
+    {
+      platformID_ = 0;
+    }
+    platformID_ = osversioninfo.dwPlatformId;
+
+//
+//    versionMajor = osversioninfo.dwMajorVersion;
+//    versionMinor = osversioninfo.dwMinorVersion;
+//
+}
+
+char Poller::checkDesktop()
+{
+  //
+  // Only on NT.
+  //
+  if (isWinNT())
+  {
+    //
+    // Get the input and thread desktops.
+    //
+    HDESK desktop = GetThreadDesktop(GetCurrentThreadId());
+    HDESK inputDesktop = OpenInputDesktop(0, FALSE,
+                        DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW |
+                        DESKTOP_ENUMERATE | DESKTOP_HOOKCONTROL |
+                        DESKTOP_WRITEOBJECTS | DESKTOP_READOBJECTS |
+                        DESKTOP_SWITCHDESKTOP | GENERIC_WRITE);
+
+    if (inputDesktop == NULL)
+    {
+      return 0;
+    }
+
+    DWORD dummy;
+    char desktopName[256];
+    char inputName[256];
+
+    if (GetUserObjectInformation(desktop, UOI_NAME, &amp;desktopName, 256, &amp;dummy) == 0)
+    {
+      if (CloseDesktop(inputDesktop) == 0)
+      {
+        logDebug(&quot;Poller::checkDesktop&quot;, &quot;Failed to close desktop, Error[%d].&quot;, (unsigned int)GetLastError());
+        return 0;
+      }
+    }
+
+    if (GetUserObjectInformation(inputDesktop, UOI_NAME, &amp;inputName, 256, &amp;dummy) == 0)
+    {
+      if (CloseDesktop(inputDesktop) == 0)
+      {
+        logDebug(&quot;Poller::checkDesktop&quot;, &quot;Failed to close input desktop, Error[%d].&quot;, (unsigned int)GetLastError());
+        return 0;
+      }
+    }
+
+    if (strcmp(desktopName, inputName) != 0)
+    {
+      //
+      // Switch to new desktop.
+      //
+      selectDesktop(inputDesktop);
+    }
+
+    if (CloseDesktop(desktop) == 0)
+    {
+      logDebug(&quot;Poller::checkDesktop&quot;, &quot;Failed to close input desktop, Error[%d].&quot;, (unsigned int)GetLastError());
+      return 0;
+    }
+
+    if (CloseDesktop(inputDesktop) == 0)
+    {
+      logDebug(&quot;Poller::checkDesktop&quot;, &quot;Failed to close input desktop, Error[%d].&quot;, (unsigned int)GetLastError());
+      return 0;
+    }
+  }
+
+  return 1;
+}
+
+unsigned char Poller::isModifier(UINT scancode)
+{
+  return 0;
+}
+
+void Poller::updateModifierState(UINT scancode, unsigned char pressed)
+{
+  return;
+}
+
+Cursor Poller::createCursor(Window wnd, Visual *vis,unsigned int x, unsigned int y,
+                                int width, int height, unsigned char *xormask, unsigned char *andmask)
+{
+  Pixmap maskglyph, cursorglyph;
+  XColor bg, fg;
+  Cursor xcursor;
+  unsigned char *cursor;
+  unsigned char *mask, *pmask, *pcursor, tmp;
+  int scanline, offset;
+
+  scanline = (width + 7) / 8;
+  offset = scanline * height;
+
+  pmask = andmask;
+  pcursor = xormask;
+  for (int i = 0; i &lt; offset; i++)
+  {
+    //
+    // The pixel is black if both the bit of andmask and xormask is one.
+    //
+
+    tmp = *pcursor &amp; *pmask;
+    *pcursor ^= tmp;
+    *pmask ^= tmp;
+
+    *pmask = ~(*pmask);
+
+    pmask++;
+    pcursor++;
+  }
+
+  cursor = new unsigned char[offset];
+  memcpy(cursor, xormask, offset);
+
+  mask = new unsigned char[offset];
+  memcpy(mask, andmask, offset);
+
+  fg.red = fg.blue = fg.green = 0xffff;
+  bg.red = bg.blue = bg.green = 0x0000;
+  fg.flags = bg.flags = DoRed | DoBlue | DoGreen;
+
+  cursorglyph = createGlyph(wnd, vis, width, height, cursor);
+  maskglyph = createGlyph(wnd, vis, width, height, mask);
+
+  xcursor = XCreatePixmapCursor(display_, cursorglyph, maskglyph, &amp;fg, &amp;bg, x, y);
+
+  XFreePixmap(display_, maskglyph);
+  XFreePixmap(display_, cursorglyph);
+  delete[]mask;
+  delete[]cursor;
+
+  return xcursor;
+}
+
+Pixmap Poller::createGlyph(Window wnd, Visual *visual, int width, int height, unsigned char *data)
+{
+  XImage *image;
+  Pixmap bitmap;
+  int scanline;
+  GC glyphGC;
+
+  scanline = (width + 7) / 8;
+
+  bitmap = XCreatePixmap(display_, wnd, width, height, 1);
+  glyphGC = XCreateGC(display_, bitmap, 0, NULL);
+
+  image = XCreateImage(display_, visual, 1, ZPixmap, 0, (char *)data, width, height, 8, scanline);
+  image-&gt;byte_order = 1; // MSBFirst -- LSBFirst = 0
+  image-&gt;bitmap_bit_order = 1;
+  XInitImage(image);
+
+/*  logTest(&quot;Poller::createGlyph&quot;,&quot;XPutImage on pixmap %d,%d,%d,%d.\n&quot;,
+              0, 0, width, height);*/
+  XPutImage(display_, bitmap, glyphGC, image, 0, 0, 0, 0, width, height);
+  XFree(image);
+
+  return bitmap;
+}
+#endif /* defined(__CYGWIN32__) || defined(WIN32) */
diff --git a/nxcompshad/Win.h b/nxcompshad/Win.h
new file mode 100644
index 0000000..fe591ff
--- /dev/null
+++ b/nxcompshad/Win.h
@@ -0,0 +1,224 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifdef __CYGWIN32__
+
+#ifndef Win32Poller_H
+#define Win32Poller_H
+
+//#include &lt;X11/X.h&gt;
+
+#include &lt;Windows.h&gt;
+#include &lt;wingdi.h&gt;
+#include &lt;winable.h&gt;
+#include &lt;winuser.h&gt;
+
+#define CAPTUREBLT 0x40000000
+
+#define KEYEVENTF_SCANCODE 0x00000008
+#define MAPVK_VSC_TO_VK_EX 3
+//
+// The CAPTUREBLT is a raster operation used
+// in bit blit transfer.
+//
+// Using this operation includes any windows
+// that are layered on top of your window in
+// the resulting image. By default, the image
+// only contains your window.
+//
+
+#include &quot;Core.h&quot;
+
+typedef struct _keyTranslation
+{
+ unsigned char scancode;
+ unsigned short modifiers;
+
+}keyTranslation;
+
+class Poller : public CorePoller
+{
+  public:
+
+  Display *display_;
+  keyTranslation *keymap_;
+  unsigned char keymapLoaded_;
+  int minKeycode_;
+
+  Poller(Input *, Display *display, int = 16);
+
+  ~Poller();
+
+  int init();
+
+  int updateCursor(Window, Visual*);
+
+  private:
+
+  
+  int Poller::updateShadowFrameBuffer(void);
+  void handleKeyboardEvent(Display *, XEvent *);
+  void handleWebKeyboardEvent(KeySym keysym, Bool isKeyPress);
+  void addToKeymap(char *keyname, unsigned char scancode, unsigned short modifiers, char *mapname);
+  int xkeymapRead(char *mapname);
+  FILE *xkeymapOpen(char *filename);
+  void xkeymapInit(char *keyMapName);
+  keyTranslation xkeymapTranslateKey(unsigned int keysym, unsigned int keycode, unsigned int state);
+  unsigned char getKeyState(unsigned int state, unsigned int keysym);
+  char *getKsname(unsigned int keysym);
+  unsigned char specialKeys(unsigned int keysym, unsigned int state, int pressed);
+
+  unsigned char toggleSwitch(unsigned char ToggleStateClient, unsigned char ToggleStateServer, UINT scancode,
+                                 int *lengthArrayINPUT);
+
+  void updateModifierState(UINT, unsigned char);
+
+  unsigned char toggleServerState(UINT scancode);
+  unsigned char keyState(UINT scancode, UINT mapType);
+  unsigned char keyStateAsync(UINT scancode);
+
+  void handleMouseEvent(Display *, XEvent *);
+
+  Cursor createCursor(Window wnd, Visual *vis, unsigned int x, unsigned int y, int width,
+                           int height, unsigned char *xormask, unsigned char *andmask);
+
+  Pixmap createGlyph(Window wnd, Visual *visual, int width, int height, unsigned char *data);
+
+  char isWinNT();
+  char selectDesktop(HDESK new_desktop);
+  char selectDesktopByName(char *name);
+  void platformOS();
+  char simulateCtrlAltDel(void);
+  DWORD platformID_;
+
+  INPUT *pKey_, *pMouse_;
+
+  char *keymapName_;
+  char *path_;
+
+  unsigned char toggleButtonState_;
+  unsigned short serverModifierState_;
+  unsigned short savedServerModifierState_;
+
+  void ensureServerModifiers(keyTranslation tr, int *lenghtArrayINPUT);
+  void restoreServerModifiers(UINT scancode);
+  unsigned char isModifier(UINT scancode);
+
+  char sendInput(unsigned char scancode, unsigned char pressed, int *lengthArrayINPUT);
+
+  char *getRect(XRectangle);
+  char checkDesktop();
+
+  char *DIBBuffer_;
+
+  HCURSOR oldCursor_;
+
+  VOID *pDIBbits_;
+  HDC screenDC_;
+  HDC memoryDC_;
+  BITMAPINFO bmi_;
+  HBITMAP screenBmp_;
+
+  Cursor xCursor_;
+
+};
+
+#undef TEST
+
+inline unsigned char Poller::toggleSwitch(unsigned char ToggleStateClient, unsigned char ToggleStateServer,
+                                              UINT scancode, int *lengthArrayINPUT)
+{
+  return 1;
+}
+
+inline unsigned char Poller::toggleServerState(UINT scancode)
+{
+  return (GetKeyState(MapVirtualKeyEx(scancode, 3, GetKeyboardLayout((DWORD)NULL))) &amp; 0x1);
+}
+
+inline unsigned char Poller::keyStateAsync(UINT vKeycode)
+{
+  return GetAsyncKeyState(vKeycode);
+}
+
+inline unsigned char Poller::keyState(UINT code, UINT mapType)
+{
+  if (mapType == 0)
+  {
+    //
+    // Virtual Keycode
+    //
+    return ((GetKeyState(code) &amp; 0x80) == 0x80);
+  }
+  else
+  {
+    //
+    // scancode
+    //
+    return ((GetKeyState(MapVirtualKeyEx(code, 3, GetKeyboardLayout((DWORD)NULL))) &amp; 0x80) == 0x80);
+  }
+}
+
+inline char Poller::isWinNT()
+{
+  return (platformID_ == VER_PLATFORM_WIN32_NT);
+}
+
+inline char Poller::sendInput(unsigned char scancode, unsigned char pressed, int *lengthArrayINPUT)
+{
+  DWORD keyEvent = 0;
+  DWORD extended = 0;
+
+  if (scancode &gt; 0)
+  {
+    if (pressed == 0)
+    {
+      keyEvent = KEYEVENTF_KEYUP;
+    }
+
+    if (scancode &amp; 0x80)
+    {
+      scancode &amp;= ~0x80;
+      extended = KEYEVENTF_EXTENDEDKEY;
+    }
+
+    pKey_[*lengthArrayINPUT].ki.wScan = (WORD) scancode;
+    pKey_[*lengthArrayINPUT].ki.dwFlags = (DWORD) (keyEvent | KEYEVENTF_SCANCODE | extended);
+    (*lengthArrayINPUT)++;
+  }
+
+
+  if (*lengthArrayINPUT &gt; 0)                                                                                                   {
+    // FIXME: Remove me.
+    logTest(&quot;Poller::sendInput&quot;, &quot;length Input [%d] event: %s&quot;, *lengthArrayINPUT,
+              pressed == 1 ? &quot;KeyPress&quot;: &quot;KeyRelease&quot;);
+
+    if (SendInput(*lengthArrayINPUT, pKey_, sizeof(INPUT)) == 0)
+    {
+      logTest(&quot;Poller::sendInput&quot;, &quot;Failed SendInput, event: %s&quot;, pressed == 1 ? &quot;KeyPress&quot;: &quot;KeyRelease&quot;);
+      *lengthArrayINPUT = 0;
+      return 0;
+    }
+
+    *lengthArrayINPUT = 0;
+  }
+
+  return 1;
+}
+#endif /* Win32Poller_H */
+
+#endif /* __CYGWIN32__ */
diff --git a/nxcompshad/X11.cpp b/nxcompshad/X11.cpp
new file mode 100644
index 0000000..2d1140f
--- /dev/null
+++ b/nxcompshad/X11.cpp
@@ -0,0 +1,1586 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#if !defined(__CYGWIN32__) &amp;&amp; !defined(WIN32)
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &lt;X11/Xlibint.h&gt;
+#include &lt;X11/Xproto.h&gt;
+#include &lt;X11/extensions/XTest.h&gt;
+#include &lt;X11/keysym.h&gt;
+#include &lt;string.h&gt;
+#include &lt;sys/ipc.h&gt;
+#include &lt;sys/shm.h&gt;
+
+#include &quot;Poller.h&quot;
+#include &quot;Logger.h&quot;
+#include &quot;Shadow.h&quot;
+
+#define ROUNDUP(nbytes, pad) ((((nbytes) + ((pad)-1)) / (pad)) * ((pad)&gt;&gt;3))
+
+#undef  TRANSLATE_KEYCODES
+#define TRANSLATE_ALWAYS
+
+typedef struct {
+    KeySym  *map;
+    KeyCode minKeyCode,
+            maxKeyCode;
+    int     mapWidth;
+} KeySymsRec, *KeySymsPtr;
+
+extern KeySymsPtr NXShadowKeymap;
+
+typedef struct _KeyPressed
+{
+  KeyCode keyRcvd;
+  KeyCode keySent;
+  struct _KeyPressed *next;
+} KeyPressedRec;
+
+static KeyPressedRec *shadowKeyPressedPtr = NULL;
+
+static KeySym *shadowKeysyms = NULL;
+static KeySym *masterKeysyms = NULL;
+
+static KeySym *shadowKeymap = NULL;
+
+static int shadowMinKey, shadowMaxKey, shadowMapWidth;
+static int masterMinKey, masterMaxKey, masterMapWidth;
+
+static int leftShiftOn = 0;
+static int rightShiftOn = 0;
+static int modeSwitchOn = 0;
+static int level3ShiftOn = 0;
+static int altROn = 0;
+
+static int sentFakeLShiftPress = 0;
+static int sentFakeLShiftRelease = 0;
+static int sentFakeRShiftRelease = 0;
+static int sentFakeModeSwitchPress = 0;
+static int sentFakeModeSwitchRelease = 0;
+static int sentFakeLevel3ShiftPress = 0;
+static int sentFakeLevel3ShiftRelease = 0;
+static int sentFakeAltRRelease = 0;
+
+static int shmInitTrap = 0;
+
+Poller::Poller(Input *input, Display *display, int depth) : CorePoller(input, display)
+{
+  logTrace(&quot;Poller::Poller&quot;);
+
+  display_ = NULL;
+  shadowDisplayName_ = input -&gt; getShadowDisplayName();
+
+  tmpBuffer_ = NULL;
+
+  xtestExtension_  = -1;
+  shmExtension_    = -1;
+  randrExtension_  = -1;
+  damageExtension_ = -1;
+
+  shadowDisplayUid_ = -1;
+
+  image_ = NULL;
+
+  shminfo_ = NULL;
+}
+
+Poller::~Poller()
+{
+  logTrace(&quot;Poller::~Poller&quot;);
+
+  if (shmExtension_ == 1)
+  {
+    XShmDetach(display_, shminfo_);
+    XDestroyImage(image_);
+    shmdt(shminfo_ -&gt; shmaddr);
+    shmctl(shminfo_ -&gt; shmid, IPC_RMID, 0);
+  }
+
+  if (shminfo_ != NULL)
+  {
+    delete shminfo_;
+
+    shminfo_ = NULL;
+  }
+
+  if (display_ != NULL)
+  {
+    XCloseDisplay(display_);
+  }
+
+  if (tmpBuffer_ != NULL &amp;&amp; shmExtension_ != -1 &amp;&amp; damageExtension_ == 1)
+  {
+    XFree(tmpBuffer_);
+
+    tmpBuffer_ = NULL;
+  }
+}
+
+int Poller::init()
+{
+  logTrace(&quot;Poller::init&quot;);
+
+  if (display_ == NULL)
+  {
+    display_ = XOpenDisplay(shadowDisplayName_);
+
+    setShadowDisplay(display_);
+  }
+
+  logTest(&quot;Poller::init:&quot; ,&quot;Shadow display [%p] name [%s].&quot;, (Display *) display_, shadowDisplayName_);
+
+  if (display_ == NULL)
+  {
+    logTest(&quot;Poller::init&quot;, &quot;Failed to connect to display [%s].&quot;, shadowDisplayName_ ? shadowDisplayName_ : &quot;&quot;);
+
+    return -1;
+  }
+
+  setRootSize();
+
+  logTest(&quot;Poller::init&quot;, &quot;Screen geometry is [%d, %d] depth is [%d] bpl [%d] bpp [%d].&quot;,
+              width_, height_, depth_, bpl_, bpp_);
+
+  xtestInit();
+
+  shmInit();
+
+  randrInit();
+
+  damageInit();
+
+  return CorePoller::init();
+}
+
+int Poller::updateShadowFrameBuffer(void)
+{
+  if (shmExtension_ == 1)
+  {
+    if (XShmGetImage(display_, DefaultRootWindow(display_), image_, 0, 0, AllPlanes) == 0)
+    {
+      logDebug(&quot;Poller::updateShadowFrameBuffer&quot;, &quot;XShmGetImage failed!&quot;);
+
+      return -1;
+    }
+  }
+  else
+  {
+    image_ = XGetImage(display_, DefaultRootWindow(display_), 0, 0, width_,
+                           height_, AllPlanes, ZPixmap);
+
+    if (image_ == NULL)
+    {
+      logDebug(&quot;Poller::updateShadowFrameBuffer&quot;, &quot;XGetImage failed!&quot;);
+
+      return -1;
+    }
+  }
+
+  return 1;
+}
+
+char *Poller::getRect(XRectangle r)
+{
+  logTrace(&quot;Poller::getRect&quot;);
+
+  logDebug(&quot;Poller::getRect&quot;, &quot;Going to retrive rectangle [%d, %d, %d, %d].&quot;,
+              r.x, r.y, r.width, r.height);
+
+  if (shmExtension_ == 1)
+  {
+    if (damageExtension_ == 1)
+    {
+      image_ -&gt; width = r.width;
+      image_ -&gt; height = r.height;
+
+      image_ -&gt; bytes_per_line = ROUNDUP((image_ -&gt; bits_per_pixel * image_ -&gt; width), image_ -&gt; bitmap_pad);
+
+      if (XShmGetImage(display_, DefaultRootWindow(display_), image_, r.x, r.y, AllPlanes) == 0)
+      {
+        logDebug(&quot;Poller::getRect&quot;, &quot;XShmGetImage failed!&quot;);
+
+        return NULL;
+      }
+
+      tmpBuffer_ = image_ -&gt; data;
+    }
+    else
+    {
+      image_ -&gt; width  = r.width;
+      image_ -&gt; height = r.height; 
+
+      image_ -&gt; bytes_per_line = ROUNDUP((image_ -&gt; bits_per_pixel * image_ -&gt; width), image_ -&gt; bitmap_pad);
+
+      if (XShmGetImage(display_, DefaultRootWindow(display_), image_, r.x, r.y, AllPlanes) == 0)
+      {
+        logDebug(&quot;Poller::getRect&quot;, &quot;XShmGetImage failed!&quot;);
+      }
+
+      tmpBuffer_ = image_ -&gt; data;
+    }
+  }
+  else
+  {
+    if (tmpBuffer_)
+    {
+      XFree(tmpBuffer_);
+      tmpBuffer_ = NULL;
+    }
+
+    image_ = XGetImage(display_, DefaultRootWindow(display_), r.x, r.y, r.width, r.height, AllPlanes, ZPixmap);
+
+    if (image_ == NULL)
+    {
+      logError(&quot;Poller::getRect&quot;, ESET(ENOMSG));
+
+      return NULL;
+    }
+
+    tmpBuffer_ = image_ -&gt; data;
+
+    if (image_ -&gt; obdata)
+    {
+      XFree(image_ -&gt; obdata);
+    }
+
+    XFree(image_);
+
+    image_ = NULL;
+  }
+
+  return tmpBuffer_;
+}
+
+void Poller::shmInit(void)
+{
+  int major, minor;
+  int pixmaps;
+
+  logTest(&quot;Poller::shmInit&quot;, &quot;Added shmExtension_ [%d].&quot;, shmExtension_);
+
+  if (shmExtension_ &gt;= 0)
+  {
+    logDebug(&quot;Poller::shmInit&quot;, &quot;Called with shared memory already initialized.&quot;);
+
+    if (shmInitTrap == 0)
+    {
+      return;
+    }
+  }
+
+  if (shmExtension_ &lt; 0 &amp;&amp; NXShadowOptions.optionShmExtension == 0)
+  {
+    shmExtension_ = 0;
+
+    logUser(&quot;Poller::shmInit: Disabling use of MIT-SHM extension.\n&quot;);
+
+    return;
+  }
+
+  if (XShmQueryVersion(display_, &amp;major, &amp;minor, &amp;pixmaps) == 0)
+  {
+    logDebug(&quot;Poller::shmInit&quot;, &quot;MIT_SHM: Shared memory extension not available.&quot;);
+
+    shmExtension_ = 0;
+  }
+  else
+  {
+    logDebug(&quot;Poller::shmInit&quot;, &quot;MIT_SHM: Shared memory extension available.&quot;);
+
+    if (shminfo_ != NULL)
+    {
+      destroyShmImage();
+    }
+
+    shminfo_ = (XShmSegmentInfo* ) new XShmSegmentInfo;
+
+    if (shminfo_ == NULL)
+    {
+      logError(&quot;Poller::shmInit&quot;, ESET(ENOMEM));
+
+      shmExtension_ = 0;
+
+      return;
+    }
+
+    image_ = (XImage *)XShmCreateImage(display_, display_ -&gt; screens[0].root_visual, depth_, ZPixmap,
+                                           NULL,  shminfo_, width_, height_);
+
+    if (image_ == NULL)
+    {
+      logError(&quot;Poller::shmInit&quot;, ESET(ENOMSG));
+
+      shmExtension_ = 0;
+
+      return;
+    }
+
+    shadowDisplayUid_ = NXShadowOptions.optionShadowDisplayUid;
+
+    logDebug(&quot;Poller::shmInit&quot;, &quot;Master X server uid [%d].&quot;, NXShadowOptions.optionShadowDisplayUid);
+
+    shminfo_ -&gt; shmid = shmget(IPC_PRIVATE, image_ -&gt; bytes_per_line * image_ -&gt; height, IPC_CREAT | 0666);
+
+    if (shminfo_ -&gt; shmid &lt; 0)
+    {
+      logDebug(&quot;Poller::shmInit&quot;, &quot;kernel id error.&quot;);
+
+      shmExtension_ = 0;
+
+      return;
+    }
+
+    logDebug(&quot;Poller::shmInit&quot;, &quot;Created shm segment with shmid [%d].&quot;, shminfo_ -&gt; shmid);
+
+    shminfo_ -&gt; shmaddr = (char *)shmat(shminfo_ -&gt; shmid, 0, 0);
+
+    if (shminfo_ -&gt; shmaddr &lt; 0)
+    {
+      logWarning(&quot;Poller::shmInit&quot;, &quot;Couldn't attach to shm segment.&quot;);
+    }
+
+    logDebug(&quot;Poller::shmInit&quot;, &quot;shminfo_ -&gt; shmaddr [%p].&quot;, shminfo_ -&gt; shmaddr);
+
+    image_ -&gt; data = shminfo_ -&gt; shmaddr;
+
+    shminfo_ -&gt; readOnly = 0;
+
+    if (XShmAttach(display_, shminfo_) == 0)
+    {
+      logDebug(&quot;Poller::shmInit&quot;, &quot;XShmAttach failed.&quot;);
+
+      shmExtension_ = 0;
+
+      return;
+    }
+
+    //
+    // Mark the shm segment to be destroyed after
+    // the last process detach. Let the X server
+    // complete the X_ShmAttach request, before.
+    //
+
+    XSync(display_, 0);
+
+    struct shmid_ds ds;
+
+    shmctl(shminfo_ -&gt; shmid, IPC_STAT, &amp;ds);
+
+    if (shadowDisplayUid_ != -1)
+    {
+      ds.shm_perm.uid = (ushort) shadowDisplayUid_;
+    }
+    else
+    {
+      logWarning(&quot;Poller::shmInit&quot;, &quot;Couldn't set uid for shm segment.&quot;);
+    }
+
+    ds.shm_perm.mode = 0600;
+
+    shmctl(shminfo_ -&gt; shmid, IPC_SET, &amp;ds);
+
+    shmctl(shminfo_ -&gt; shmid, IPC_STAT, &amp;ds);
+
+    shmctl(shminfo_ -&gt; shmid, IPC_RMID, 0);
+
+    logDebug(&quot;Poller::shmInit&quot;, &quot;Number of attaches to shm segment [%d] are [%d].\n&quot;,
+                 shminfo_ -&gt; shmid, (int) ds.shm_nattch);
+
+    if (ds.shm_nattch &gt; 2)
+    {
+      logWarning(&quot;Poller::shmInit&quot;, &quot;More than two attaches to the shm segment.&quot;);
+
+      destroyShmImage();
+
+      shmExtension_ = 0;
+
+      return;
+    }
+
+    shmExtension_ = 1;
+  }
+}
+
+void Poller::keymapShadowInit(Display *display)
+{
+  int i, len;
+  CARD32 *map;
+
+  if (NXShadowKeymap != NULL)
+  {
+    shadowMinKey   = NXShadowKeymap -&gt; minKeyCode;
+    shadowMaxKey   = NXShadowKeymap -&gt; maxKeyCode;
+    shadowMapWidth = NXShadowKeymap -&gt; mapWidth;
+
+    len = (shadowMaxKey - shadowMinKey + 1) * shadowMapWidth;
+
+    map = (CARD32 *) NXShadowKeymap -&gt; map;
+
+    if (shadowKeymap != NULL)
+    {
+      free(shadowKeymap);
+    }
+
+    shadowKeymap = (KeySym *) malloc(len * sizeof(KeySym));
+
+    if (shadowKeymap != NULL)
+    {
+      for (i = 0; i &lt; len; i++)
+      {
+        shadowKeymap[i] = map[i];
+      }
+
+      shadowKeysyms = shadowKeymap;
+    }
+  }
+
+  if (shadowKeysyms == NULL)
+  {
+    XDisplayKeycodes(display, &amp;shadowMinKey, &amp;shadowMaxKey);
+
+    shadowKeysyms = XGetKeyboardMapping(display, shadowMinKey, shadowMaxKey - shadowMinKey + 1,
+                                            &amp;shadowMapWidth);
+  }
+
+  #ifdef DEBUG
+  if (shadowKeysyms != NULL)
+  {
+    for (i = 0; i &lt; (shadowMaxKey - shadowMinKey + 1) * shadowMapWidth; i++)
+    {
+      if (i % shadowMapWidth == 0)
+      {
+        logDebug(&quot;Poller::keymapShadowInit&quot;, &quot;keycode [%d]&quot;, (int) (i / shadowMapWidth));
+      }
+
+      logDebug(&quot;\tkeysym&quot;, &quot; [%x] [%s]&quot;, (unsigned int) shadowKeysyms[i], XKeysymToString(shadowKeysyms[i]));
+    }
+  }
+  #endif
+}
+
+void Poller::keymapMasterInit()
+{
+  XDisplayKeycodes(display_, &amp;masterMinKey, &amp;masterMaxKey);
+
+  masterKeysyms = XGetKeyboardMapping(display_, masterMinKey, masterMaxKey - masterMinKey + 1,
+                                          &amp;masterMapWidth);
+
+  #ifdef DEBUG
+  if (masterKeysyms != NULL)
+  {
+    for (int i = 0; i &lt; (masterMaxKey - masterMinKey + 1) * masterMapWidth; i++)
+    {
+      if (i % masterMapWidth == 0)
+      {
+        logDebug(&quot;Poller::keymapMasterInit&quot;, &quot;keycode [%d]&quot;, (int) (i / masterMapWidth));
+      }
+
+      logDebug(&quot;\tkeysym&quot;, &quot; [%x] [%s]&quot;, (unsigned int) masterKeysyms[i], XKeysymToString(masterKeysyms[i]));
+    }
+  }
+  #endif
+}
+
+KeySym Poller::keymapKeycodeToKeysym(KeyCode keycode, KeySym *keysyms,
+                                         int minKey, int mapWidth, int col)
+{
+  int index = ((keycode - minKey) * mapWidth) + col;
+  return keysyms[index];
+}
+
+KeyCode Poller::keymapKeysymToKeycode(KeySym keysym, KeySym *keysyms,
+                                          int minKey, int maxKey, int mapWidth, int *col)
+{
+  for (int i = 0; i &lt; (maxKey - minKey + 1) * mapWidth; i++)
+  {
+    if (keysyms[i] == keysym)
+    {
+      *col = i % mapWidth;
+      return i / mapWidth + minKey;
+    }
+  }
+  return 0;
+}
+
+KeyCode Poller::translateKeysymToKeycode(KeySym keysym, int *col)
+{
+  KeyCode keycode;
+
+  keycode = keymapKeysymToKeycode(keysym, masterKeysyms, masterMinKey,
+                                      masterMaxKey, masterMapWidth, col);
+
+  if (keycode == 0)
+  {
+    if (((keysym &gt;&gt; 8) == 0) &amp;&amp; (keysym &gt;= XK_a) &amp;&amp; (keysym &lt;= XK_z))
+    {
+      /*
+       * The master session has a Solaris keyboard.
+       */
+
+      keysym -= XK_a - XK_A;
+
+      keycode = keymapKeysymToKeycode(keysym, masterKeysyms, masterMinKey,
+                                          masterMaxKey, masterMapWidth, col);
+    }
+    else if (keysym == XK_Shift_R)
+    {
+      keysym = XK_Shift_L;
+
+      keycode = keymapKeysymToKeycode(keysym, masterKeysyms, masterMinKey,
+                                          masterMaxKey, masterMapWidth, col);
+    }
+    else if (keysym == XK_Shift_L)
+    {
+      keysym = XK_Shift_R;
+
+      keycode = keymapKeysymToKeycode(keysym, masterKeysyms, masterMinKey,
+                                          masterMaxKey, masterMapWidth, col);
+    }
+    else if (keysym == XK_ISO_Level3_Shift)
+    {
+      keysym = XK_Mode_switch;
+
+      if ((keycode = keymapKeysymToKeycode(keysym, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, col)) == 0)
+      {
+        keysym = XK_Alt_R;
+
+        keycode = keymapKeysymToKeycode(keysym, masterKeysyms, masterMinKey,
+                                            masterMaxKey, masterMapWidth, col);
+      }
+    }
+    else if (keysym == XK_Alt_R)
+    {
+      keysym = XK_ISO_Level3_Shift;
+
+      if ((keycode = keymapKeysymToKeycode(keysym, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, col)) == 0)
+      {
+        keysym = XK_Mode_switch;
+
+        keycode = keymapKeysymToKeycode(keysym, masterKeysyms, masterMinKey,
+                                            masterMaxKey, masterMapWidth, col);
+      }
+    }
+  }
+  return keycode;
+}
+
+Bool Poller::checkModifierKeys(KeySym keysym, Bool isKeyPress)
+{
+  switch (keysym)
+  {
+    case XK_Shift_L:
+      leftShiftOn = isKeyPress;
+      return True;
+    case XK_Shift_R:
+      rightShiftOn = isKeyPress;
+      return True;
+    case XK_Mode_switch:
+      modeSwitchOn = isKeyPress;
+      return True;
+    case XK_ISO_Level3_Shift:
+      level3ShiftOn = isKeyPress;
+      return True;
+    case XK_Alt_R:
+      altROn = isKeyPress;
+      return True;
+    default:
+      return False;
+  }
+}
+
+void Poller::sendFakeModifierEvents(int pos, Bool skip)
+{
+  KeySym fakeKeysym;
+  int col;
+
+  if ((!leftShiftOn &amp;&amp; !rightShiftOn) &amp;&amp;
+          (!modeSwitchOn &amp;&amp; !level3ShiftOn &amp;&amp; !altROn))
+  {
+    if (pos == 1 || pos == 3)
+    {
+      fakeKeysym = keymapKeysymToKeycode(XK_Shift_L, masterKeysyms, masterMinKey,
+                                             masterMaxKey, masterMapWidth, &amp;col);
+      XTestFakeKeyEvent(display_, fakeKeysym, 1, 0);
+      sentFakeLShiftPress = 1;
+    }
+    if (pos == 2 || pos == 3)
+    {
+      fakeKeysym = keymapKeysymToKeycode(XK_ISO_Level3_Shift, masterKeysyms, masterMinKey,
+                                             masterMaxKey, masterMapWidth, &amp;col);
+
+      if (fakeKeysym == 0)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_Mode_switch, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        sentFakeModeSwitchPress = 1;
+      }
+      else
+      {
+        sentFakeLevel3ShiftPress = 1;
+      }
+
+      XTestFakeKeyEvent(display_, fakeKeysym, 1, 0);
+    }
+  }
+
+  else if ((leftShiftOn || rightShiftOn) &amp;&amp;
+               (!modeSwitchOn &amp;&amp; !level3ShiftOn &amp;&amp; !altROn))
+  {
+    if ((pos == 0 &amp;&amp; !skip) || pos == 2)
+    {
+      if (leftShiftOn)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_Shift_L, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+        sentFakeLShiftRelease = 1;
+      }
+      if (rightShiftOn)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_Shift_R, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+        sentFakeRShiftRelease = 1;
+      }
+    }
+    if (pos == 2 || pos ==3)
+    {
+      fakeKeysym = keymapKeysymToKeycode(XK_ISO_Level3_Shift, masterKeysyms, masterMinKey,
+                                             masterMaxKey, masterMapWidth, &amp;col);
+
+      if (fakeKeysym == 0)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_Mode_switch, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        sentFakeModeSwitchPress = 1;
+      }
+      else
+      {
+        sentFakeLevel3ShiftPress = 1;
+      }
+
+      XTestFakeKeyEvent(display_, fakeKeysym, 1, 0);
+    }
+  }
+
+  else if ((!leftShiftOn &amp;&amp; !rightShiftOn) &amp;&amp;
+               (modeSwitchOn || level3ShiftOn || altROn))
+  {
+    if (pos == 1 || pos == 3)
+    {
+      fakeKeysym = keymapKeysymToKeycode(XK_Shift_L, masterKeysyms, masterMinKey,
+                                             masterMaxKey, masterMapWidth, &amp;col);
+      XTestFakeKeyEvent(display_, fakeKeysym, 1, 0);
+      sentFakeLShiftPress = 1;
+    }
+    if (pos == 0 || pos == 1)
+    {
+      if (modeSwitchOn)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_Mode_switch, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+        sentFakeModeSwitchRelease = 1;
+      }
+      if (level3ShiftOn)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_ISO_Level3_Shift, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+        sentFakeLevel3ShiftRelease = 1;
+      }
+      if (altROn)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_Alt_R, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+        sentFakeAltRRelease = 1;
+      }
+    }
+  }
+
+  else if ((leftShiftOn || rightShiftOn) &amp;&amp;
+               (modeSwitchOn || level3ShiftOn || altROn))
+  {
+    if (pos == 0 || pos == 2)
+    {
+      if (leftShiftOn)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_Shift_L, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+        sentFakeLShiftRelease = 1;
+      }
+      if (rightShiftOn)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_Shift_R, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+        sentFakeRShiftRelease = 1;
+      }
+    }
+    if (pos == 0 || pos == 1)
+    {
+      if (modeSwitchOn)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_Mode_switch, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+        sentFakeModeSwitchRelease = 1;
+      }
+      if (level3ShiftOn)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_ISO_Level3_Shift, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+        sentFakeLevel3ShiftRelease = 1;
+      }
+      if (altROn)
+      {
+        fakeKeysym = keymapKeysymToKeycode(XK_Alt_R, masterKeysyms, masterMinKey,
+                                               masterMaxKey, masterMapWidth, &amp;col);
+        XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+        sentFakeAltRRelease = 1;
+      }
+    }
+  }
+}
+
+void Poller::cancelFakeModifierEvents()
+{
+  KeySym fakeKeysym;
+  int col;
+
+  if (sentFakeLShiftPress)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Fake Shift_L key press event has been sent&quot;);
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Sending fake Shift_L key release event&quot;);
+
+    fakeKeysym = keymapKeysymToKeycode(XK_Shift_L, masterKeysyms, masterMinKey,
+                                           masterMaxKey, masterMapWidth, &amp;col);
+    XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+
+    sentFakeLShiftPress = 0;
+  }
+
+  if (sentFakeLShiftRelease)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Fake Shift_L key release event has been sent&quot;);
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Sending fake Shift_L key press event&quot;);
+
+    fakeKeysym = keymapKeysymToKeycode(XK_Shift_L, masterKeysyms, masterMinKey,
+                                           masterMaxKey, masterMapWidth, &amp;col);
+    XTestFakeKeyEvent(display_, fakeKeysym, 1, 0);
+
+    sentFakeLShiftRelease = 0;
+  }
+
+  if (sentFakeRShiftRelease)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Fake Shift_R key release event has been sent&quot;);
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Sending fake Shift_R key press event&quot;);
+
+    fakeKeysym = keymapKeysymToKeycode(XK_Shift_R, masterKeysyms, masterMinKey,
+                                           masterMaxKey, masterMapWidth, &amp;col);
+    XTestFakeKeyEvent(display_, fakeKeysym, 1, 0);
+
+    sentFakeRShiftRelease = 0;
+  }
+
+  if (sentFakeModeSwitchPress)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Fake Mode_switch key press event has been sent&quot;);
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Sending fake Mode_switch key release event&quot;);
+
+    fakeKeysym = keymapKeysymToKeycode(XK_Mode_switch, masterKeysyms, masterMinKey,
+                                           masterMaxKey, masterMapWidth, &amp;col);
+    XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+
+    sentFakeModeSwitchPress = 0;
+  }
+
+  if (sentFakeModeSwitchRelease)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Fake Mode_switch key release event has been sent&quot;);
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Sending Mode_switch key press event&quot;);
+
+    fakeKeysym = keymapKeysymToKeycode(XK_Mode_switch, masterKeysyms, masterMinKey,
+                                           masterMaxKey, masterMapWidth, &amp;col);
+    XTestFakeKeyEvent(display_, fakeKeysym, 1, 0);
+
+    sentFakeModeSwitchRelease = 0;
+  }
+
+  if (sentFakeLevel3ShiftPress)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Fake ISO_Level3_Shift key press event has been sent&quot;);
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Sending fake ISO_Level3_Shift key release event&quot;);
+
+    fakeKeysym = keymapKeysymToKeycode(XK_ISO_Level3_Shift, masterKeysyms, masterMinKey,
+                                           masterMaxKey, masterMapWidth, &amp;col);
+    XTestFakeKeyEvent(display_, fakeKeysym, 0, 0);
+
+    sentFakeLevel3ShiftPress = 0;
+  }
+
+  if (sentFakeLevel3ShiftRelease)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Fake ISO_Level3_Shift key release event has been sent&quot;);
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Sending fake ISO_Level3_Shift key press event&quot;);
+
+    fakeKeysym = keymapKeysymToKeycode(XK_ISO_Level3_Shift, masterKeysyms, masterMinKey,
+                                           masterMaxKey, masterMapWidth, &amp;col);
+    XTestFakeKeyEvent(display_, fakeKeysym, 1, 0);
+
+    sentFakeLevel3ShiftRelease = 0;
+  }
+
+  if (sentFakeAltRRelease)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Fake XK_Alt_R key release event has been sent&quot;);
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Sending fake XK_Alt_R key press event&quot;);
+
+    fakeKeysym = keymapKeysymToKeycode(XK_Alt_R, masterKeysyms, masterMinKey,
+                                           masterMaxKey, masterMapWidth, &amp;col);
+    XTestFakeKeyEvent(display_, fakeKeysym, 1, 0);
+
+    sentFakeAltRRelease = 0;
+  }
+}
+
+Bool Poller::keyIsDown(KeyCode keycode)
+{
+  KeyPressedRec *downKey;
+
+  downKey = shadowKeyPressedPtr;
+
+  while (downKey)
+  {
+    if (downKey -&gt; keyRcvd == keycode)
+    {
+      return True;
+    }
+    downKey = downKey -&gt; next;
+  }
+
+  return False;
+}
+
+void Poller::addKeyPressed(KeyCode received, KeyCode sent)
+{
+  KeyPressedRec *downKey;
+
+  if (!keyIsDown(received))
+  {
+    if (shadowKeyPressedPtr == NULL)
+    {
+      shadowKeyPressedPtr = (KeyPressedRec *) malloc(sizeof(KeyPressedRec));
+
+      shadowKeyPressedPtr -&gt; keyRcvd = received;
+      shadowKeyPressedPtr -&gt; keySent = sent;
+      shadowKeyPressedPtr -&gt; next = NULL;
+    }
+    else
+    {
+      downKey = shadowKeyPressedPtr;
+
+      while (downKey -&gt; next != NULL)
+      {
+        downKey = downKey -&gt; next;
+      }
+
+      downKey -&gt; next = (KeyPressedRec *) malloc(sizeof(KeyPressedRec));
+
+      downKey -&gt; next -&gt; keyRcvd = received;
+      downKey -&gt; next -&gt; keySent = sent;
+      downKey -&gt; next -&gt; next = NULL;
+    }
+  }
+}
+
+KeyCode Poller::getKeyPressed(KeyCode received)
+{
+  KeyCode sent;
+  KeyPressedRec *downKey;
+  KeyPressedRec *tempKey;
+
+  if (shadowKeyPressedPtr != NULL)
+  {
+    if (shadowKeyPressedPtr -&gt; keyRcvd == received)
+    {
+      sent = shadowKeyPressedPtr -&gt; keySent;
+
+      tempKey = shadowKeyPressedPtr;
+      shadowKeyPressedPtr = shadowKeyPressedPtr -&gt; next;
+      free(tempKey);
+
+      return sent;
+    }
+    else
+    {
+      downKey = shadowKeyPressedPtr;
+
+      while (downKey -&gt; next != NULL)
+      {
+        if (downKey -&gt; next -&gt; keyRcvd == received)
+        {
+          sent = downKey -&gt; next -&gt; keySent;
+
+          tempKey = downKey -&gt; next;
+          downKey -&gt; next = downKey -&gt; next -&gt; next;
+          free(tempKey);
+
+          return sent;
+        }
+        else
+        {
+          downKey = downKey -&gt; next;
+        }
+      }
+    }
+  }
+  return 0;
+}
+
+void Poller::handleKeyboardEvent(Display *display, XEvent *event)
+{
+  if (xtestExtension_ == 0 || display_ == 0)
+  {
+    return;
+  }
+
+  logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Handling event at [%p]&quot;, event);
+
+#ifdef TRANSLATE_ALWAYS
+
+  KeyCode keycode;
+  KeySym keysym;
+
+  int col = 0;
+
+  Bool isKeyPress = False;
+  Bool isModifier = False;
+  Bool isShiftComb = False;
+  Bool skip = False;
+
+  if (event -&gt; type == KeyPress)
+  {
+    isKeyPress = True;
+  }
+
+  if (shadowKeysyms == NULL)
+  {
+    keymapShadowInit(event -&gt; xkey.display);
+  }
+
+  if (masterKeysyms == NULL)
+  {
+    keymapMasterInit();
+  }
+
+  if (shadowKeysyms == NULL || masterKeysyms == NULL)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Unable to initialize keymaps. Do not translate&quot;);
+
+    keycode = event -&gt; xkey.keycode;
+
+    goto SendKeycode;
+  }
+
+  keysym = keymapKeycodeToKeysym(event -&gt; xkey.keycode, shadowKeysyms,
+                                   shadowMinKey, shadowMapWidth, 0);
+
+  isModifier = checkModifierKeys(keysym, isKeyPress);
+
+  if (event -&gt; type == KeyRelease)
+  {
+    KeyCode keycodeToSend;
+
+    keycodeToSend = getKeyPressed(event -&gt; xkey.keycode);
+
+    if (keycodeToSend)
+    {
+      keycode = keycodeToSend;
+
+      goto SendKeycode;
+    }
+  }
+
+  /*
+   * Convert case for Solaris keyboard.
+   */
+
+  if (((keysym &gt;&gt; 8) == 0) &amp;&amp; (keysym &gt;= XK_A) &amp;&amp; (keysym &lt;= XK_Z))
+  {
+    if (!leftShiftOn &amp;&amp; !rightShiftOn)
+    {
+      keysym += XK_a - XK_A;
+    }
+    else
+    {
+      skip = True;
+    }
+  }
+
+  if (!isModifier)
+  {
+    if ((leftShiftOn || rightShiftOn) &amp;&amp;
+            (!modeSwitchOn &amp;&amp; !level3ShiftOn &amp;&amp; !altROn) &amp;&amp;
+                !skip)
+    {
+      KeySym tempKeysym = keymapKeycodeToKeysym(event -&gt; xkey.keycode, shadowKeysyms,
+                                                    shadowMinKey, shadowMapWidth, 1);
+
+      if (tempKeysym == 0)
+      {
+        isShiftComb = True;
+      }
+      else
+      {
+        keysym = tempKeysym;
+      }
+    }
+    else if ((!leftShiftOn &amp;&amp; !rightShiftOn) &amp;&amp;
+                 (modeSwitchOn || level3ShiftOn || altROn))
+    {
+      keysym = keymapKeycodeToKeysym(event -&gt; xkey.keycode, shadowKeysyms,
+                                         shadowMinKey, shadowMapWidth, 2);
+    }
+    else if ((leftShiftOn || rightShiftOn) &amp;&amp;
+                 (modeSwitchOn || level3ShiftOn || altROn))
+    {
+      keysym = keymapKeycodeToKeysym(event -&gt; xkey.keycode, shadowKeysyms,
+                                       shadowMinKey, shadowMapWidth, 3);
+    }
+  }
+
+  if (keysym == 0)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Null keysym. Return&quot;);
+
+    return;
+  }
+
+  logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;keysym [%x] [%s]&quot;,
+              (unsigned int)keysym, XKeysymToString(keysym));
+
+  if (keysym == XK_Mode_switch)
+  {
+    keysym = XK_ISO_Level3_Shift;
+  }
+
+  keycode = translateKeysymToKeycode(keysym, &amp;col);
+
+  if (keycode == 0)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;No keycode found for keysym [%x] [%s]. Return&quot;,
+                (unsigned int)keysym, XKeysymToString(keysym));
+    return;
+  }
+
+  logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;keycode [%d] translated into keycode [%d]&quot;,
+              (int)event -&gt; xkey.keycode, (unsigned int)keycode);
+
+  if (event -&gt; type == KeyPress)
+  {
+    addKeyPressed(event -&gt; xkey.keycode, keycode);
+  }
+
+  /*
+   * Send fake modifier events.
+   */
+
+  if (!isModifier &amp;&amp; isShiftComb == False)
+  {
+    sendFakeModifierEvents(col, ((keysym &gt;&gt; 8) == 0) &amp;&amp; (keysym &gt;= XK_A) &amp;&amp; (keysym &lt;= XK_Z));
+  }
+
+SendKeycode:
+
+  /*
+   * Send the event.
+   */
+
+  XTestFakeKeyEvent(display_, keycode, isKeyPress, 0);
+
+  /*
+   * Check if fake modifier events have been sent.
+   */
+
+  cancelFakeModifierEvents();
+
+#else // TRANSLATE_ALWAYS
+
+  //
+  // Use keysyms to translate keycodes across different
+  // keyboard models. Unuseful when both keyboards have
+  // same keycodes (e.g. both are pc keyboards).
+  //
+
+  #ifdef TRANSLATE_KEYCODES
+
+  KeyCode keycode = XKeysymToKeycode(display_, XK_A);
+
+  if (XKeysymToKeycode(event -&gt; xkey.display, XK_A) != keycode)
+  {
+    KeySym keysym = XKeycodeToKeysym(event -&gt; xkey.display, event -&gt; xkey.keycode, 0);
+  
+    if (keysym == XK_Mode_switch || keysym == XK_ISO_Level3_Shift)
+    {
+      logUser(&quot;Poller::handleKeyboardEvent: keysym [%x].\n&quot;, (unsigned int)keysym);
+  
+      if (XKeycodeToKeysym(display_, 113, 0) == XK_ISO_Level3_Shift ||
+             (XKeycodeToKeysym(display_, 124, 0) == XK_ISO_Level3_Shift))
+      {
+        event -&gt; xkey.keycode = 113;
+      }
+      else
+      {
+        event -&gt; xkey.keycode = XKeysymToKeycode(display_, XK_Mode_switch);
+      }
+  
+      logUser(&quot;Poller::handleKeyboardEvent: keycode translated to [%x].\n&quot;, (unsigned int)event -&gt; xkey.keycode);
+    }
+    else
+    {
+      event -&gt; xkey.keycode = XKeysymToKeycode(display_, keysym);
+    }
+  }
+
+  #endif // TRANSLATE_KEYCODES
+
+  if (event -&gt; type == KeyPress)
+  {
+    XTestFakeKeyEvent(display_, event -&gt; xkey.keycode, 1, 0);
+  }
+  else if (event -&gt; type == KeyRelease)
+  {
+    XTestFakeKeyEvent(display_, event -&gt; xkey.keycode, 0, 0);
+  }
+
+#endif // TRANSLATE_ALWAYS
+}
+
+void Poller::handleWebKeyboardEvent(KeySym keysym, Bool isKeyPress)
+{
+  KeyCode keycode;
+  int col;
+
+  if (masterKeysyms == NULL)
+  {
+    keymapMasterInit();
+  }
+
+  if (masterKeysyms == NULL)
+  {
+    logTest(&quot;Poller::handleWebKeyboardEvent&quot;, &quot;Unable to initialize keymap&quot;);
+
+    return;
+  }
+
+  keycode = translateKeysymToKeycode(keysym, &amp;col);
+
+  if (keycode == 0)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;No keycode found for keysym [%x] [%s]. Return&quot;,
+                (unsigned int)keysym, XKeysymToString(keysym));
+    return;
+  }
+
+  logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;keysym [%x] [%s] translated into keycode [%x]&quot;,
+              (unsigned int)keysym, XKeysymToString(keysym), (unsigned int)keycode);
+
+  /*
+   * Send fake modifier events.
+   */
+
+  if (!checkModifierKeys(keysym, isKeyPress))
+  {
+    sendFakeModifierEvents(col, False);
+  }
+
+  /*
+   * Send the event.
+   */
+
+  XTestFakeKeyEvent(display_, keycode, isKeyPress, 0);
+
+  /*
+   * Check if fake modifier events have been sent.
+   */
+
+  cancelFakeModifierEvents();
+
+}
+
+void Poller::handleMouseEvent(Display *display, XEvent *event)
+{
+  if (xtestExtension_ == 0 || display_ == 0)
+  {
+    return;
+  }
+
+  if (event -&gt; type == MotionNotify)
+  {
+    XTestFakeMotionEvent(display_, 0, event -&gt; xmotion.x, event -&gt; xmotion.y, 0);
+  }
+  else if (event -&gt; type == ButtonPress)
+  {
+    XTestFakeButtonEvent(display_, event -&gt; xbutton.button, True, 0);
+  }
+  else if (event -&gt; type == ButtonRelease)
+  {
+    XTestFakeButtonEvent(display_, event -&gt; xbutton.button, False, 0);
+  }
+
+  XFlush(display_);
+}
+
+void Poller::setRootSize(void)
+{
+  width_ = WidthOfScreen(DefaultScreenOfDisplay(display_));
+  height_ = HeightOfScreen(DefaultScreenOfDisplay(display_));
+  depth_ = DefaultDepth(display_, DefaultScreen(display_));
+
+  if (depth_ == 8) bpp_ = 1;
+  else if (depth_ == 16) bpp_ = 2;
+  else bpp_ = 4;
+
+  bpl_ = width_ * bpp_;
+}
+
+void Poller::destroyShmImage(void)
+{
+    XShmDetach(display_, shminfo_);
+    XDestroyImage(image_);
+    image_ = NULL;
+
+    shmdt(shminfo_ -&gt; shmaddr);
+    shmctl(shminfo_ -&gt; shmid, IPC_RMID, 0);
+
+    delete shminfo_;
+    shminfo_ = NULL;
+}
+
+void Poller::xtestInit(void)
+{
+  int eventBase;
+  int errorBase;
+  int versionMajor;
+  int versionMinor;
+  int result;
+
+  xtestExtension_ = 0;
+
+  result = XTestQueryExtension(display_, &amp;eventBase, &amp;errorBase, &amp;versionMajor, &amp;versionMinor);
+
+  if (result == 0)
+  {
+    xtestExtension_ = 0;
+
+    logWarning(&quot;Poller::xtestInit&quot;, &quot;Failed while querying for XTEST extension.&quot;);
+  }
+  else
+  {
+    logDebug(&quot;Poller::xtestInit&quot;, &quot;XTEST version %d.%d.&quot;, versionMajor, versionMinor);
+
+    xtestExtension_ = 1;
+  }
+
+  //
+  // Make this client impervious to grabs.
+  //
+
+  if (xtestExtension_ == 1)
+  {
+    XTestGrabControl(display_, 1);
+  }
+}
+
+void Poller::randrInit(void)
+{
+  int randrEventBase;
+  int randrErrorBase;
+
+  if (XRRQueryExtension(display_, &amp;randrEventBase, &amp;randrErrorBase) == 0)
+  {
+    logWarning(&quot;Poller::randrInit&quot;, &quot;Randr extension not supported on this &quot;
+                   &quot;display.&quot;);
+
+    randrExtension_ = 0;
+
+    return;
+  }
+
+  XRRSelectInput(display_, DefaultRootWindow(display_),
+                     RRScreenChangeNotifyMask);
+
+  randrEventBase_ = randrEventBase;
+
+  randrExtension_ = 1;
+
+  return;
+}
+
+void Poller::damageInit(void)
+{
+  int damageMajorVersion = 0;
+  int damageMinorVersion = 0;
+
+  int damageEventBase = 0;
+  int damageErrorBase = 0;
+
+  if (damageExtension_ &gt;= 0)
+  {
+    logDebug(&quot;Poller::damageInit&quot;, &quot;Called with damage already initialized.&quot;);
+  }
+
+  if (damageExtension_ == 0)
+  {
+    logDebug(&quot;Poller::damageInit&quot;, &quot;Damage disabled. Skip initialization.&quot;);
+
+    return;
+  }
+
+  if (damageExtension_ &lt; 0 &amp;&amp; NXShadowOptions.optionDamageExtension == 0)
+  {
+    damageExtension_ = 0;
+
+    logUser(&quot;Poller::damageInit: Disabling use of DAMAGE extension.\n&quot;);
+
+    return;
+  }
+
+  damageExtension_ = 0;
+
+  mirrorChanges_ = 0;
+
+  if (XDamageQueryExtension(display_, &amp;damageEventBase, &amp;damageErrorBase) == 0)
+  {
+    logUser(&quot;Poller::damageInit: DAMAGE not supported.\n&quot;);
+
+    return;
+  }
+  #ifdef DEBUG
+  else
+  {
+    fprintf(stderr, &quot;Poller::damageInit: DAMAGE supported. &quot;
+                &quot;Event base [%d] error base [%d].\n&quot;, damageEventBase, damageErrorBase);
+  }
+  #endif
+
+  damageEventBase_ = damageEventBase;
+
+  if (XDamageQueryVersion(display_, &amp;damageMajorVersion, &amp;damageMinorVersion) == 0)
+  {
+    logWarning(&quot;Poller::damageInit&quot;, &quot;Error on querying DAMAGE version.\n&quot;);
+
+    damageExtension_ = 0;
+
+    return;
+  }
+  #ifdef DEBUG
+  else
+  {
+    fprintf(stderr, &quot;Poller::damageInit: DAMAGE version %d.%d.\n&quot;,
+                damageMajorVersion, damageMinorVersion);
+  }
+  #endif
+
+  damage_ = XDamageCreate(display_, DefaultRootWindow(display_), XDamageReportRawRectangles);
+
+  damageExtension_= 1;
+
+  mirror_ = 1;
+
+  return;
+}
+
+void Poller::getEvents(void)
+{
+  XEvent X;
+
+  if (damageExtension_ == 1)
+  {
+    XDamageSubtract(display_, damage_, None, None);
+  }
+
+  XSync(display_, 0);
+
+  while (XCheckIfEvent(display_, &amp;X, anyEventPredicate, NULL) == 1)
+  {
+    if (randrExtension_ == 1 &amp;&amp; (X.type == randrEventBase_ + RRScreenChangeNotify || X.type == ConfigureNotify))
+    {
+      XRRUpdateConfiguration(&amp;X);
+
+      handleRRScreenChangeNotify(&amp;X);
+
+      continue;
+    }
+
+    if (damageExtension_ == 1 &amp;&amp; X.type == damageEventBase_ + XDamageNotify)
+    {
+      handleDamageNotify(&amp;X);
+    }
+  }
+
+  if (damageExtension_ == 1)
+  {
+    updateDamagedAreas();
+  }
+
+  XFlush(display_);
+}
+
+void Poller::handleRRScreenChangeNotify(XEvent *X)
+{
+  return;
+}
+
+void Poller::handleDamageNotify(XEvent *X)
+{
+  XDamageNotifyEvent *e = (XDamageNotifyEvent *) X;
+
+  //
+  //  e-&gt;drawable is the window ID of the damaged window
+  //  e-&gt;geometry is the geometry of the damaged window
+  //  e-&gt;area     is the bounding rect for the damaged area
+  //  e-&gt;damage   is the damage handle returned by XDamageCreate()
+  //
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;handleDamageNotify: drawable [%d] damage [%d] geometry [%d][%d][%d][%d] area [%d][%d][%d][%d].\n&quot;,
+              (int) e -&gt; drawable, (int) e -&gt; damage, e -&gt; geometry.x, e -&gt; geometry.y,
+                  e -&gt; geometry.width, e -&gt; geometry.height, e -&gt; area.x, e -&gt; area.y,
+                      e -&gt; area.width, e -&gt; area.height);
+  #endif
+
+  XRectangle rectangle = {e -&gt; area.x, e -&gt; area.y, e -&gt; area.width, e -&gt; area.height};
+
+  XUnionRectWithRegion(&amp;rectangle, lastUpdatedRegion_, lastUpdatedRegion_);
+
+  mirrorChanges_ = 1;
+
+  return;
+}
+
+void Poller::updateDamagedAreas(void)
+{
+  BOX *boxPtr;
+
+  XRectangle rectangle;
+
+  int i;
+  int y;
+  
+  for (i = 0; i &lt; lastUpdatedRegion_ -&gt; numRects; i++)
+  {
+    boxPtr = lastUpdatedRegion_ -&gt; rects + i;
+
+    if (shmExtension_ == 1)
+    {
+      image_ -&gt; width  = boxPtr -&gt; x2 - boxPtr -&gt; x1;
+      image_ -&gt; height = boxPtr -&gt; y2 - boxPtr -&gt; y1;
+      image_ -&gt; bytes_per_line =
+          ROUNDUP((image_ -&gt; bits_per_pixel * image_ -&gt; width),
+                      image_ -&gt; bitmap_pad);
+      
+      if (XShmGetImage(display_, DefaultRootWindow(display_), image_,
+                           boxPtr -&gt; x1, boxPtr -&gt; y1, AllPlanes) == 0)
+      {
+        logDebug(&quot;Poller::updateDamagedAreas&quot;, &quot;XShmGetImage failed!&quot;);
+
+        return;
+      }
+    }
+    else if (shmExtension_ == 0)
+    {
+      image_ = XGetImage(display_, DefaultRootWindow(display_), boxPtr -&gt; x1,
+                             boxPtr -&gt; y1, boxPtr -&gt; x2 - boxPtr -&gt; x1,
+                                 boxPtr -&gt; y2 - boxPtr -&gt; y1, AllPlanes,
+                                     ZPixmap);
+
+      if (image_ == NULL)
+      {
+        logDebug(&quot;Poller::updateDamagedAreas&quot;, &quot;XGetImage failed!&quot;);
+
+        return;
+      }
+
+      image_ -&gt; width  = boxPtr -&gt; x2 - boxPtr -&gt; x1;
+      image_ -&gt; height = boxPtr -&gt; y2 - boxPtr -&gt; y1;
+      image_ -&gt; bytes_per_line =
+          ROUNDUP((image_ -&gt; bits_per_pixel * image_ -&gt; width),
+                      image_ -&gt; bitmap_pad);
+    }
+
+    rectangle.height = 1;
+    rectangle.width = image_ -&gt; width;
+    rectangle.x = boxPtr -&gt; x1;
+    rectangle.y = boxPtr -&gt; y1;
+
+    for (y = 0; y &lt; image_ -&gt; height; y++)
+    {
+      update(image_ -&gt; data + y * image_ -&gt; bytes_per_line, rectangle);
+
+      rectangle.y++; 
+    }
+
+    if (shmExtension_ != 1)
+    {
+       XDestroyImage(image_);
+
+      image_ = NULL;
+    }
+  }
+
+  return;
+}
+
+void Poller::getScreenSize(int *w, int *h)
+{
+  *w = WidthOfScreen(DefaultScreenOfDisplay(display_));
+  *h = HeightOfScreen(DefaultScreenOfDisplay(display_));
+}
+
+void Poller::setScreenSize(int *w, int *h)
+{
+  setRootSize();
+
+  shmInitTrap = 1;
+  shmInit();
+  shmInitTrap = 0;
+
+  *w = width_;
+  *h = height_;
+
+  logDebug(&quot;Poller::setScreenSize&quot;, &quot;New size of screen [%d, %d]&quot;, width_, height_);
+}
+
+int anyEventPredicate(Display *display, XEvent *event, XPointer parameter)
+{
+  return 1;
+}
+
+#endif /* !defined(__CYGWIN32__) &amp;&amp; !defined(WIN32) */
diff --git a/nxcompshad/X11.h b/nxcompshad/X11.h
new file mode 100644
index 0000000..2127542
--- /dev/null
+++ b/nxcompshad/X11.h
@@ -0,0 +1,131 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef X11Poller_H
+#define X11Poller_H
+
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/extensions/XShm.h&gt;
+#include &lt;X11/extensions/Xdamage.h&gt;
+#include &lt;X11/extensions/Xrandr.h&gt;
+
+#include &quot;Core.h&quot;
+
+class Poller : public CorePoller
+{
+  public:
+
+  Poller(Input *, Display *display, int = 0);
+
+  ~Poller();
+
+  int init();
+
+  void setRootSize();
+
+  void destroyShmImage();
+
+  void getEvents(void);
+
+  void getScreenSize(int *width, int *height);
+
+  void setScreenSize(int *width, int *height);
+
+  private:
+
+  Display *display_;
+
+  char *shadowDisplayName_;
+
+  int shadowDisplayUid_;
+
+  char *tmpBuffer_;
+
+  char xtestExtension_;
+
+  char shmExtension_;
+
+  char randrExtension_;
+
+  int randrEventBase_;
+
+  char damageExtension_;
+
+  int damageEventBase_;
+
+  Damage damage_;
+
+  Region repair_;
+
+  char damageChanges_;
+
+  XShmSegmentInfo *shminfo_;
+
+  XImage *image_;
+
+  int updateShadowFrameBuffer(void);
+
+  char *getRect(XRectangle);
+
+  void keymapShadowInit(Display *display);
+
+  void keymapMasterInit();
+
+  KeySym keymapKeycodeToKeysym(KeyCode keycode, KeySym *keysyms,
+                                   int minKey, int per, int col);
+
+  KeyCode keymapKeysymToKeycode(KeySym keysym, KeySym *keysyms,
+                                    int minKey, int maxKey, int per, int *col);
+
+  KeyCode translateKeysymToKeycode(KeySym keysym, int *col);
+
+  Bool checkModifierKeys(KeySym keysym, Bool isKeyPress);
+
+  void sendFakeModifierEvents(int pos, Bool skip);
+
+  void cancelFakeModifierEvents();
+
+  Bool keyIsDown(KeyCode keycode);
+
+  void addKeyPressed(KeyCode received, KeyCode sent);
+
+  KeyCode getKeyPressed(KeyCode received);
+
+  void handleKeyboardEvent(Display *display, XEvent *);
+
+  void handleWebKeyboardEvent(KeySym keysym, Bool isKeyPress);
+
+  void handleMouseEvent(Display *, XEvent *);
+
+  void xtestInit(void);
+
+  void shmInit(void);
+
+  void randrInit(void);
+
+  void damageInit(void);
+
+  void handleRRScreenChangeNotify(XEvent *);
+
+  void handleDamageNotify(XEvent *);
+
+  void updateDamagedAreas(void);
+};
+
+int anyEventPredicate(Display *display, XEvent *event, XPointer parameter);
+
+#endif /* X11Poller_H */
diff --git a/nxcompshad/configure b/nxcompshad/configure
new file mode 100755
index 0000000..d5b4228
--- /dev/null
+++ b/nxcompshad/configure
@@ -0,0 +1,5778 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.59.
+#
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n &quot;${ZSH_VERSION+set}&quot; &amp;&amp; (emulate sh) &gt;/dev/null 2&gt;&amp;1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+&quot;$@&quot;}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+&quot;$@&quot;}'='&quot;$@&quot;'
+elif test -n &quot;${BASH_VERSION+set}&quot; &amp;&amp; (set -o posix) &gt;/dev/null 2&gt;&amp;1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) &gt;/dev/null 2&gt;&amp;1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='&gt; '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z &quot;`(eval $as_var=C; export $as_var) 2&gt;&amp;1`&quot;); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' &gt;/dev/null 2&gt;&amp;1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) &gt;/dev/null 2&gt;&amp;1 &amp;&amp; test &quot;X`basename / 2&gt;&amp;1`&quot; = &quot;X/&quot;; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename &quot;$0&quot; ||
+$as_expr X/&quot;$0&quot; : '.*/\([^/][^/]*\)/*$' \| \
+	 X&quot;$0&quot; : 'X\(//\)$' \| \
+	 X&quot;$0&quot; : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2&gt;/dev/null ||
+echo X/&quot;$0&quot; |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test &quot;${PATH_SEPARATOR+set}&quot; != set; then
+  echo &quot;#! /bin/sh&quot; &gt;conf$$.sh
+  echo  &quot;exit 0&quot;   &gt;&gt;conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH=&quot;/nonexistent;.&quot;; conf$$.sh) &gt;/dev/null 2&gt;&amp;1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2&gt;/dev/null`
+  test &quot;x$as_lineno_1&quot; != &quot;x$as_lineno_2&quot; &amp;&amp;
+  test &quot;x$as_lineno_3&quot;  = &quot;x$as_lineno_2&quot;  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  test -r &quot;$as_dir/$0&quot; &amp;&amp; as_myself=$as_dir/$0 &amp;&amp; break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test &quot;x$as_myself&quot; = x; then
+    as_myself=$0
+  fi
+  if test ! -f &quot;$as_myself&quot;; then
+    { echo &quot;$as_me: error: cannot find myself; rerun with an absolute path&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if (&quot;$as_dir/$as_base&quot; -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2&gt;/dev/null`
+  test &quot;x$as_lineno_1&quot; != &quot;x$as_lineno_2&quot; &amp;&amp;
+  test &quot;x$as_lineno_3&quot;  = &quot;x$as_lineno_2&quot; ') 2&gt;/dev/null; then
+	     $as_unset BASH_ENV || test &quot;${BASH_ENV+set}&quot; != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test &quot;${ENV+set}&quot; != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec &quot;$CONFIG_SHELL&quot; &quot;$0&quot; ${1+&quot;$@&quot;}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' &lt;$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' &gt;$as_me.lineno &amp;&amp;
+  chmod +x $as_me.lineno ||
+    { echo &quot;$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo &quot;testing\c&quot;; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' &gt;/dev/null 2&gt;&amp;1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo &gt;conf$$.file
+if ln -s conf$$.file conf$$ 2&gt;/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2&gt;/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2&gt;/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p &amp;&amp; rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p=&quot;test -f&quot;
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp=&quot;eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'&quot;
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh=&quot;eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'&quot;
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=&quot; 	$as_nl&quot;
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2&gt;/dev/null | sed 1q`
+
+exec 6&gt;&amp;1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file=&quot;Shadow.h&quot;
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS armcxx armcc CXX CXXFLAGS LDFLAGS CPPFLAGS ac_ct_CXX EXEEXT OBJEXT CC CFLAGS ac_ct_CC INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CXXCPP X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS LIBVERSION VERSION MAKEDEPEND LIBOBJS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can &quot;make install exec_prefix=/foo&quot;
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n &quot;$ac_prev&quot;; then
+    eval &quot;$ac_prev=\$ac_option&quot;
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr &quot;x$ac_option&quot; : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr &quot;x$ac_option&quot; : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr &quot;x$ac_feature&quot; : &quot;.*[^-_$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      { echo &quot;$as_me: error: invalid feature name: $ac_feature&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval &quot;enable_$ac_feature=no&quot; ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr &quot;x$ac_option&quot; : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr &quot;x$ac_feature&quot; : &quot;.*[^-_$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      { echo &quot;$as_me: error: invalid feature name: $ac_feature&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo &quot;$ac_optarg&quot; | sed &quot;s/'/'\\\\\\\\''/g&quot;`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval &quot;enable_$ac_feature='$ac_optarg'&quot; ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr &quot;x$ac_option&quot; : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr &quot;x$ac_package&quot; : &quot;.*[^-_$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      { echo &quot;$as_me: error: invalid package name: $ac_package&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo &quot;$ac_optarg&quot; | sed &quot;s/'/'\\\\\\\\''/g&quot;`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval &quot;with_$ac_package='$ac_optarg'&quot; ;;
+
+  -without-* | --without-*)
+    ac_package=`expr &quot;x$ac_option&quot; : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr &quot;x$ac_package&quot; : &quot;.*[^-_$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      { echo &quot;$as_me: error: invalid package name: $ac_package&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval &quot;with_$ac_package=no&quot; ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo &quot;$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information.&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr &quot;x$ac_option&quot; : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr &quot;x$ac_envvar&quot; : &quot;.*[^_$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      { echo &quot;$as_me: error: invalid variable name: $ac_envvar&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo &quot;$ac_optarg&quot; | sed &quot;s/'/'\\\\\\\\''/g&quot;`
+    eval &quot;$ac_envvar='$ac_optarg'&quot;
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo &quot;$as_me: WARNING: you should use --build, --host, --target&quot; &gt;&amp;2
+    expr &quot;x$ac_option&quot; : &quot;.*[^-._$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      echo &quot;$as_me: WARNING: invalid host type: $ac_option&quot; &gt;&amp;2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n &quot;$ac_prev&quot;; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo &quot;$as_me: error: missing argument to $ac_option&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo &quot;$as_me: error: expected an absolute directory name for --$ac_var: $ac_val&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo &quot;$as_me: error: expected an absolute directory name for --$ac_var: $ac_val&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test &quot;x$host_alias&quot; != x; then
+  if test &quot;x$build_alias&quot; = x; then
+    cross_compiling=maybe
+    echo &quot;$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used.&quot; &gt;&amp;2
+  elif test &quot;x$build_alias&quot; != &quot;x$host_alias&quot;; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n &quot;$host_alias&quot; &amp;&amp; ac_tool_prefix=$host_alias-
+
+test &quot;$silent&quot; = yes &amp;&amp; exec 6&gt;/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z &quot;$srcdir&quot;; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname &quot;$0&quot;) 2&gt;/dev/null ||
+$as_expr X&quot;$0&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X&quot;$0&quot; : 'X\(//\)[^/]' \| \
+	 X&quot;$0&quot; : 'X\(//\)$' \| \
+	 X&quot;$0&quot; : 'X\(/\)' \| \
+	 .     : '\(.\)' 2&gt;/dev/null ||
+echo X&quot;$0&quot; |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test &quot;$ac_srcdir_defaulted&quot; = yes; then
+    { echo &quot;$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or ..&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+  else
+    { echo &quot;$as_me: error: cannot find sources ($ac_unique_file) in $srcdir&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir &amp;&amp; test -r ./$ac_unique_file) 2&gt;/dev/null ||
+  { echo &quot;$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+srcdir=`echo &quot;$srcdir&quot; | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+ac_env_CXX_set=${CXX+set}
+ac_env_CXX_value=$CXX
+ac_cv_env_CXX_set=${CXX+set}
+ac_cv_env_CXX_value=$CXX
+ac_env_CXXFLAGS_set=${CXXFLAGS+set}
+ac_env_CXXFLAGS_value=$CXXFLAGS
+ac_cv_env_CXXFLAGS_set=${CXXFLAGS+set}
+ac_cv_env_CXXFLAGS_value=$CXXFLAGS
+ac_env_LDFLAGS_set=${LDFLAGS+set}
+ac_env_LDFLAGS_value=$LDFLAGS
+ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
+ac_cv_env_LDFLAGS_value=$LDFLAGS
+ac_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_env_CPPFLAGS_value=$CPPFLAGS
+ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_cv_env_CPPFLAGS_value=$CPPFLAGS
+ac_env_CC_set=${CC+set}
+ac_env_CC_value=$CC
+ac_cv_env_CC_set=${CC+set}
+ac_cv_env_CC_value=$CC
+ac_env_CFLAGS_set=${CFLAGS+set}
+ac_env_CFLAGS_value=$CFLAGS
+ac_cv_env_CFLAGS_set=${CFLAGS+set}
+ac_cv_env_CFLAGS_value=$CFLAGS
+ac_env_CXXCPP_set=${CXXCPP+set}
+ac_env_CXXCPP_value=$CXXCPP
+ac_cv_env_CXXCPP_set=${CXXCPP+set}
+ac_cv_env_CXXCPP_value=$CXXCPP
+
+#
+# Report the --help message.
+#
+if test &quot;$ac_init_help&quot; = &quot;long&quot;; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat &lt;&lt;_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat &lt;&lt;_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat &lt;&lt;\_ACEOF
+
+X features:
+  --x-includes=DIR    X include files are in DIR
+  --x-libraries=DIR   X library files are in DIR
+_ACEOF
+fi
+
+if test -n &quot;$ac_init_help&quot;; then
+
+  cat &lt;&lt;\_ACEOF
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-x                use the X Window System
+
+Some influential environment variables:
+  CXX         C++ compiler command
+  CXXFLAGS    C++ compiler flags
+  LDFLAGS     linker flags, e.g. -L&lt;lib dir&gt; if you have libraries in a
+              nonstandard directory &lt;lib dir&gt;
+  CPPFLAGS    C/C++ preprocessor flags, e.g. -I&lt;include dir&gt; if you have
+              headers in a nonstandard directory &lt;include dir&gt;
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  CXXCPP      C++ preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+_ACEOF
+fi
+
+if test &quot;$ac_init_help&quot; = &quot;recursive&quot;; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test &quot;x$ac_dir&quot; = x: &amp;&amp; continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test &quot;$ac_dir&quot; != .; then
+  ac_dir_suffix=/`echo &quot;$ac_dir&quot; | sed 's,^\.[\\/],,'`
+  # A &quot;../&quot; for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo &quot;$ac_dir_suffix&quot; | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z &quot;$ac_top_builddir&quot;; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo &amp;&amp; pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir=&quot;$ac_dir&quot;;;
+*)
+  case &quot;$ac_dir&quot; in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir=&quot;$ac_dir&quot;;;
+  *) ac_abs_builddir=`pwd`/&quot;$ac_dir&quot;;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo &quot;$as_me: WARNING: no configuration information is in $ac_dir&quot; &gt;&amp;2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n &quot;$ac_init_help&quot; &amp;&amp; exit 0
+if $ac_init_version; then
+  cat &lt;&lt;\_ACEOF
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5&gt;config.log
+cat &gt;&amp;5 &lt;&lt;_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat &lt;&lt;_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2&gt;/dev/null | sed 1q`
+uname -m = `(uname -m) 2&gt;/dev/null || echo unknown`
+uname -r = `(uname -r) 2&gt;/dev/null || echo unknown`
+uname -s = `(uname -s) 2&gt;/dev/null || echo unknown`
+uname -v = `(uname -v) 2&gt;/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2&gt;/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2&gt;/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2&gt;/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2&gt;/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2&gt;/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2&gt;/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2&gt;/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2&gt;/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2&gt;/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  echo &quot;PATH: $as_dir&quot;
+done
+
+} &gt;&amp;5
+
+cat &gt;&amp;5 &lt;&lt;_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *&quot; &quot;*|*&quot;	&quot;*|*[\[\]\~\#\$\^\&amp;\*\(\)\{\}\\\|\;\&lt;\&gt;\?\&quot;\']*)
+      ac_arg=`echo &quot;$ac_arg&quot; | sed &quot;s/'/'\\\\\\\\''/g&quot;` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0=&quot;$ac_configure_args0 '$ac_arg'&quot; ;;
+    2)
+      ac_configure_args1=&quot;$ac_configure_args1 '$ac_arg'&quot;
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case &quot;$ac_configure_args0 &quot; in
+	      &quot;$ac_configure_args1&quot;*&quot; '$ac_arg' &quot;* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args=&quot;$ac_configure_args$ac_sep'$ac_arg'&quot;
+      # Get rid of the leading space.
+      ac_sep=&quot; &quot;
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test &quot;${ac_configure_args0+set}&quot; != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test &quot;${ac_configure_args1+set}&quot; != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat &lt;&lt;\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2&gt;&amp;1 |
+    case `(ac_space='&quot;'&quot;' '&quot;'&quot;'; set | grep ac_space) 2&gt;&amp;1` in
+    *ac_space=\ *)
+      sed -n \
+	&quot;s/'&quot;'&quot;'/'&quot;'&quot;'\\\\'&quot;'&quot;''&quot;'&quot;'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='&quot;'&quot;'\\2'&quot;'&quot;'/p&quot;
+      ;;
+    *)
+      sed -n \
+	&quot;s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p&quot;
+      ;;
+    esac;
+}
+    echo
+
+    cat &lt;&lt;\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo &quot;$ac_var='&quot;'&quot;'$ac_val'&quot;'&quot;'&quot;
+    done | sort
+    echo
+
+    if test -n &quot;$ac_subst_files&quot;; then
+      cat &lt;&lt;\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+	echo &quot;$ac_var='&quot;'&quot;'$ac_val'&quot;'&quot;'&quot;
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat &lt;&lt;\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed &quot;/^$/d&quot; confdefs.h | sort
+      echo
+    fi
+    test &quot;$ac_signal&quot; != 0 &amp;&amp;
+      echo &quot;$as_me: caught signal $ac_signal&quot;
+    echo &quot;$as_me: exit $exit_status&quot;
+  } &gt;&amp;5
+  rm -f core *.core &amp;&amp;
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &amp;&amp;
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo &gt;confdefs.h
+
+# Predefined preprocessor variables.
+
+cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF
+#define PACKAGE_NAME &quot;$PACKAGE_NAME&quot;
+_ACEOF
+
+
+cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF
+#define PACKAGE_TARNAME &quot;$PACKAGE_TARNAME&quot;
+_ACEOF
+
+
+cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF
+#define PACKAGE_VERSION &quot;$PACKAGE_VERSION&quot;
+_ACEOF
+
+
+cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF
+#define PACKAGE_STRING &quot;$PACKAGE_STRING&quot;
+_ACEOF
+
+
+cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF
+#define PACKAGE_BUGREPORT &quot;$PACKAGE_BUGREPORT&quot;
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z &quot;$CONFIG_SITE&quot;; then
+  if test &quot;x$prefix&quot; != xNONE; then
+    CONFIG_SITE=&quot;$prefix/share/config.site $prefix/etc/config.site&quot;
+  else
+    CONFIG_SITE=&quot;$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site&quot;
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r &quot;$ac_site_file&quot;; then
+    { echo &quot;$as_me:$LINENO: loading site script $ac_site_file&quot; &gt;&amp;5
+echo &quot;$as_me: loading site script $ac_site_file&quot; &gt;&amp;6;}
+    sed 's/^/| /' &quot;$ac_site_file&quot; &gt;&amp;5
+    . &quot;$ac_site_file&quot;
+  fi
+done
+
+if test -r &quot;$cache_file&quot;; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f &quot;$cache_file&quot;; then
+    { echo &quot;$as_me:$LINENO: loading cache $cache_file&quot; &gt;&amp;5
+echo &quot;$as_me: loading cache $cache_file&quot; &gt;&amp;6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo &quot;$as_me:$LINENO: creating cache $cache_file&quot; &gt;&amp;5
+echo &quot;$as_me: creating cache $cache_file&quot; &gt;&amp;6;}
+  &gt;$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2&gt;&amp;1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=&quot;\$ac_cv_env_${ac_var}_value&quot;
+  eval ac_new_val=&quot;\$ac_env_${ac_var}_value&quot;
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo &quot;$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run&quot; &gt;&amp;5
+echo &quot;$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run&quot; &gt;&amp;2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo &quot;$as_me:$LINENO: error: \`$ac_var' was not set in the previous run&quot; &gt;&amp;5
+echo &quot;$as_me: error: \`$ac_var' was not set in the previous run&quot; &gt;&amp;2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test &quot;x$ac_old_val&quot; != &quot;x$ac_new_val&quot;; then
+	{ echo &quot;$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:&quot; &gt;&amp;5
+echo &quot;$as_me: error: \`$ac_var' has changed since the previous run:&quot; &gt;&amp;2;}
+	{ echo &quot;$as_me:$LINENO:   former value:  $ac_old_val&quot; &gt;&amp;5
+echo &quot;$as_me:   former value:  $ac_old_val&quot; &gt;&amp;2;}
+	{ echo &quot;$as_me:$LINENO:   current value: $ac_new_val&quot; &gt;&amp;5
+echo &quot;$as_me:   current value: $ac_new_val&quot; &gt;&amp;2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test &quot;$ac_new_set&quot; = set; then
+    case $ac_new_val in
+    *&quot; &quot;*|*&quot;	&quot;*|*[\[\]\~\#\$\^\&amp;\*\(\)\{\}\\\|\;\&lt;\&gt;\?\&quot;\']*)
+      ac_arg=$ac_var=`echo &quot;$ac_new_val&quot; | sed &quot;s/'/'\\\\\\\\''/g&quot;` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case &quot; $ac_configure_args &quot; in
+      *&quot; '$ac_arg' &quot;*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args=&quot;$ac_configure_args '$ac_arg'&quot; ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo &quot;$as_me:$LINENO: error: changes in the environment can compromise the build&quot; &gt;&amp;5
+echo &quot;$as_me: error: changes in the environment can compromise the build&quot; &gt;&amp;2;}
+  { { echo &quot;$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over&quot; &gt;&amp;5
+echo &quot;$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+CXXFLAGS=&quot;-O3&quot;
+CPPFLAGS=&quot;-O3&quot;
+
+
+LIBSTATIC=&quot;&quot;
+LIBSHARED=&quot;&quot;
+
+
+if test -d &quot;../nx-X11/exports/include&quot; ; then
+    CXXFLAGS=&quot;$CXXFLAGS -I../nx-X11/exports/include&quot;
+    LIBS=&quot;$LIBS -L../nx-X11/exports/lib&quot;
+fi
+
+
+if test &quot;${with_ipaq}&quot; = yes; then
+  echo -e &quot;enabling IPAQ configuration&quot;
+  CXX=&quot;arm-linux-c++&quot;
+  CC=&quot;arm-linux-gcc&quot;
+  unset ac_cv_prog_armcxx
+  unset ac_cv_prog_armcc
+  unset ac_cv_prog_CXXCPP
+  # Extract the first word of &quot;&quot;$CXX&quot;&quot;, so it can be a program name with args.
+set dummy &quot;$CXX&quot;; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_armcxx+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$armcxx&quot;; then
+  ac_cv_prog_armcxx=&quot;$armcxx&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_armcxx=&quot;yes&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+  test -z &quot;$ac_cv_prog_armcxx&quot; &amp;&amp; ac_cv_prog_armcxx=&quot;no&quot;
+fi
+fi
+armcxx=$ac_cv_prog_armcxx
+if test -n &quot;$armcxx&quot;; then
+  echo &quot;$as_me:$LINENO: result: $armcxx&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$armcxx&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  # Extract the first word of &quot;&quot;$CC&quot;&quot;, so it can be a program name with args.
+set dummy &quot;$CC&quot;; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_armcc+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$armcc&quot;; then
+  ac_cv_prog_armcc=&quot;$armcc&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_armcc=&quot;yes&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+  test -z &quot;$ac_cv_prog_armcc&quot; &amp;&amp; ac_cv_prog_armcc=&quot;no&quot;
+fi
+fi
+armcc=$ac_cv_prog_armcc
+if test -n &quot;$armcc&quot;; then
+  echo &quot;$as_me:$LINENO: result: $armcc&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$armcc&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  if test $armcxx = &quot;yes&quot; &amp;&amp; test $armcc = &quot;yes&quot; ; then
+    ac_cv_prog_CXX=&quot;$CXX&quot;
+    ac_cv_prog_CC=&quot;$CC&quot;
+  else
+    { { echo &quot;$as_me:$LINENO: error: installation or configuration problem: I cannot find compiler for arm-linux&quot; &gt;&amp;5
+echo &quot;$as_me: error: installation or configuration problem: I cannot find compiler for arm-linux&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+  fi
+else
+  unset ac_cv_prog_CXX
+  unset ac_cv_prog_CC
+  unset ac_cv_prog_CXXCPP
+fi
+
+
+ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -n &quot;$ac_tool_prefix&quot;; then
+  for ac_prog in $CCC g++ c++ gpp aCC CC cxx cc++ cl FCC KCC RCC xlC_r xlC
+  do
+    # Extract the first word of &quot;$ac_tool_prefix$ac_prog&quot;, so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_CXX+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$CXX&quot;; then
+  ac_cv_prog_CXX=&quot;$CXX&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_CXX=&quot;$ac_tool_prefix$ac_prog&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CXX=$ac_cv_prog_CXX
+if test -n &quot;$CXX&quot;; then
+  echo &quot;$as_me:$LINENO: result: $CXX&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CXX&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+    test -n &quot;$CXX&quot; &amp;&amp; break
+  done
+fi
+if test -z &quot;$CXX&quot;; then
+  ac_ct_CXX=$CXX
+  for ac_prog in $CCC g++ c++ gpp aCC CC cxx cc++ cl FCC KCC RCC xlC_r xlC
+do
+  # Extract the first word of &quot;$ac_prog&quot;, so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_ac_ct_CXX+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$ac_ct_CXX&quot;; then
+  ac_cv_prog_ac_ct_CXX=&quot;$ac_ct_CXX&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_ac_ct_CXX=&quot;$ac_prog&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
+if test -n &quot;$ac_ct_CXX&quot;; then
+  echo &quot;$as_me:$LINENO: result: $ac_ct_CXX&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_ct_CXX&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  test -n &quot;$ac_ct_CXX&quot; &amp;&amp; break
+done
+test -n &quot;$ac_ct_CXX&quot; || ac_ct_CXX=&quot;g++&quot;
+
+  CXX=$ac_ct_CXX
+fi
+
+
+# Provide some information about the compiler.
+echo &quot;$as_me:$LINENO:&quot; \
+     &quot;checking for C++ compiler version&quot; &gt;&amp;5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler --version &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler --version &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler -v &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler -v &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler -V &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler -V &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files=&quot;$ac_clean_files a.out a.exe b.out&quot;
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+echo &quot;$as_me:$LINENO: checking for C++ compiler default output file name&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for C++ compiler default output file name... $ECHO_C&quot; &gt;&amp;6
+ac_link_default=`echo &quot;$ac_link&quot; | sed 's/ -o *conftest[^ ]*//'`
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link_default\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link_default) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; then
+  # Find the output, starting from the most likely.  This scheme is
+# not robust to junk in `.', hence go to wildcards (a.*) only as a last
+# resort.
+
+# Be careful to initialize this variable, since it used to be cached.
+# Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
+ac_cv_exeext=
+# b.out is created by i960 compilers.
+for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
+do
+  test -f &quot;$ac_file&quot; || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
+	;;
+    conftest.$ac_ext )
+	# This is the source file.
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	ac_cv_exeext=`expr &quot;$ac_file&quot; : '[^.]*\(\..*\)'`
+	# FIXME: I believe we export ac_cv_exeext for Libtool,
+	# but it would be cool to find out if it's true.  Does anybody
+	# maintain Libtool? --akim.
+	export ac_cv_exeext
+	break;;
+    * )
+	break;;
+  esac
+done
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+{ { echo &quot;$as_me:$LINENO: error: C++ compiler cannot create executables
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: C++ compiler cannot create executables
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 77); exit 77; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+echo &quot;$as_me:$LINENO: result: $ac_file&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_file&quot; &gt;&amp;6
+
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo &quot;$as_me:$LINENO: checking whether the C++ compiler works&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether the C++ compiler works... $ECHO_C&quot; &gt;&amp;6
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test &quot;$cross_compiling&quot; != yes; then
+  if { ac_try='./$ac_file'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test &quot;$cross_compiling&quot; = maybe; then
+	cross_compiling=yes
+    else
+	{ { echo &quot;$as_me:$LINENO: error: cannot run C++ compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot run C++ compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+fi
+echo &quot;$as_me:$LINENO: result: yes&quot; &gt;&amp;5
+echo &quot;${ECHO_T}yes&quot; &gt;&amp;6
+
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo &quot;$as_me:$LINENO: checking whether we are cross compiling&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether we are cross compiling... $ECHO_C&quot; &gt;&amp;6
+echo &quot;$as_me:$LINENO: result: $cross_compiling&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$cross_compiling&quot; &gt;&amp;6
+
+echo &quot;$as_me:$LINENO: checking for suffix of executables&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for suffix of executables... $ECHO_C&quot; &gt;&amp;6
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f &quot;$ac_file&quot; || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr &quot;$ac_file&quot; : '[^.]*\(\..*\)'`
+	  export ac_cv_exeext
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { echo &quot;$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+echo &quot;$as_me:$LINENO: result: $ac_cv_exeext&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_exeext&quot; &gt;&amp;6
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+echo &quot;$as_me:$LINENO: checking for suffix of object files&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for suffix of object files... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_objext+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; then
+  for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2&gt;/dev/null`; do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
+    *) ac_cv_objext=`expr &quot;$ac_file&quot; : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+{ { echo &quot;$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_objext&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_objext&quot; &gt;&amp;6
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+echo &quot;$as_me:$LINENO: checking whether we are using the GNU C++ compiler&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether we are using the GNU C++ compiler... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_cxx_compiler_gnu+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_cxx_compiler_gnu&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_cxx_compiler_gnu&quot; &gt;&amp;6
+GXX=`test $ac_compiler_gnu = yes &amp;&amp; echo yes`
+ac_test_CXXFLAGS=${CXXFLAGS+set}
+ac_save_CXXFLAGS=$CXXFLAGS
+CXXFLAGS=&quot;-g&quot;
+echo &quot;$as_me:$LINENO: checking whether $CXX accepts -g&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether $CXX accepts -g... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_cxx_g+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cxx_g=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_prog_cxx_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_prog_cxx_g&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_prog_cxx_g&quot; &gt;&amp;6
+if test &quot;$ac_test_CXXFLAGS&quot; = set; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test &quot;$GXX&quot; = yes; then
+    CXXFLAGS=&quot;-g -O2&quot;
+  else
+    CXXFLAGS=&quot;-g&quot;
+  fi
+else
+  if test &quot;$GXX&quot; = yes; then
+    CXXFLAGS=&quot;-O2&quot;
+  else
+    CXXFLAGS=
+  fi
+fi
+for ac_declaration in \
+   '' \
+   'extern &quot;C&quot; void std::exit (int) throw (); using std::exit;' \
+   'extern &quot;C&quot; void std::exit (int); using std::exit;' \
+   'extern &quot;C&quot; void exit (int) throw ();' \
+   'extern &quot;C&quot; void exit (int);' \
+   'void exit (int);'
+do
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+#include &lt;stdlib.h&gt;
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n &quot;$ac_declaration&quot;; then
+  echo '#ifdef __cplusplus' &gt;&gt;confdefs.h
+  echo $ac_declaration      &gt;&gt;confdefs.h
+  echo '#endif'             &gt;&gt;confdefs.h
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n &quot;$ac_tool_prefix&quot;; then
+  # Extract the first word of &quot;${ac_tool_prefix}gcc&quot;, so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$CC&quot;; then
+  ac_cv_prog_CC=&quot;$CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_CC=&quot;${ac_tool_prefix}gcc&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n &quot;$CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+fi
+if test -z &quot;$ac_cv_prog_CC&quot;; then
+  ac_ct_CC=$CC
+  # Extract the first word of &quot;gcc&quot;, so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_ac_ct_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$ac_ct_CC&quot;; then
+  ac_cv_prog_ac_ct_CC=&quot;$ac_ct_CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_ac_ct_CC=&quot;gcc&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n &quot;$ac_ct_CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $ac_ct_CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_ct_CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC=&quot;$ac_cv_prog_CC&quot;
+fi
+
+if test -z &quot;$CC&quot;; then
+  if test -n &quot;$ac_tool_prefix&quot;; then
+  # Extract the first word of &quot;${ac_tool_prefix}cc&quot;, so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$CC&quot;; then
+  ac_cv_prog_CC=&quot;$CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_CC=&quot;${ac_tool_prefix}cc&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n &quot;$CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+fi
+if test -z &quot;$ac_cv_prog_CC&quot;; then
+  ac_ct_CC=$CC
+  # Extract the first word of &quot;cc&quot;, so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_ac_ct_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$ac_ct_CC&quot;; then
+  ac_cv_prog_ac_ct_CC=&quot;$ac_ct_CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_ac_ct_CC=&quot;cc&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n &quot;$ac_ct_CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $ac_ct_CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_ct_CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC=&quot;$ac_cv_prog_CC&quot;
+fi
+
+fi
+if test -z &quot;$CC&quot;; then
+  # Extract the first word of &quot;cc&quot;, so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$CC&quot;; then
+  ac_cv_prog_CC=&quot;$CC&quot; # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    if test &quot;$as_dir/$ac_word$ac_exec_ext&quot; = &quot;/usr/ucb/cc&quot;; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC=&quot;cc&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC=&quot;$as_dir/$ac_word${1+' '}$@&quot;
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n &quot;$CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+fi
+if test -z &quot;$CC&quot;; then
+  if test -n &quot;$ac_tool_prefix&quot;; then
+  for ac_prog in cl
+  do
+    # Extract the first word of &quot;$ac_tool_prefix$ac_prog&quot;, so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$CC&quot;; then
+  ac_cv_prog_CC=&quot;$CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_CC=&quot;$ac_tool_prefix$ac_prog&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n &quot;$CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+    test -n &quot;$CC&quot; &amp;&amp; break
+  done
+fi
+if test -z &quot;$CC&quot;; then
+  ac_ct_CC=$CC
+  for ac_prog in cl
+do
+  # Extract the first word of &quot;$ac_prog&quot;, so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_ac_ct_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$ac_ct_CC&quot;; then
+  ac_cv_prog_ac_ct_CC=&quot;$ac_ct_CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_ac_ct_CC=&quot;$ac_prog&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n &quot;$ac_ct_CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $ac_ct_CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_ct_CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  test -n &quot;$ac_ct_CC&quot; &amp;&amp; break
+done
+
+  CC=$ac_ct_CC
+fi
+
+fi
+
+
+test -z &quot;$CC&quot; &amp;&amp; { { echo &quot;$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+
+# Provide some information about the compiler.
+echo &quot;$as_me:$LINENO:&quot; \
+     &quot;checking for C compiler version&quot; &gt;&amp;5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler --version &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler --version &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler -v &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler -v &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler -V &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler -V &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+
+echo &quot;$as_me:$LINENO: checking whether we are using the GNU C compiler&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether we are using the GNU C compiler... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_c_compiler_gnu+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_c_compiler_gnu&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_c_compiler_gnu&quot; &gt;&amp;6
+GCC=`test $ac_compiler_gnu = yes &amp;&amp; echo yes`
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+CFLAGS=&quot;-g&quot;
+echo &quot;$as_me:$LINENO: checking whether $CC accepts -g&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether $CC accepts -g... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_cc_g+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_g=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_prog_cc_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_prog_cc_g&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_prog_cc_g&quot; &gt;&amp;6
+if test &quot;$ac_test_CFLAGS&quot; = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test &quot;$GCC&quot; = yes; then
+    CFLAGS=&quot;-g -O2&quot;
+  else
+    CFLAGS=&quot;-g&quot;
+  fi
+else
+  if test &quot;$GCC&quot; = yes; then
+    CFLAGS=&quot;-O2&quot;
+  else
+    CFLAGS=
+  fi
+fi
+echo &quot;$as_me:$LINENO: checking for $CC option to accept ANSI C&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $CC option to accept ANSI C... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_cc_stdc+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_cv_prog_cc_stdc=no
+ac_save_CC=$CC
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std1 is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std1.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in &quot;&quot; -qlanglvl=ansi -std1 -Ae &quot;-Aa -D_HPUX_SOURCE&quot; &quot;-Xc -D__EXTENSIONS__&quot;
+do
+  CC=&quot;$ac_save_CC $ac_arg&quot;
+  rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_stdc=$ac_arg
+break
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+fi
+rm -f conftest.err conftest.$ac_objext
+done
+rm -f conftest.$ac_ext conftest.$ac_objext
+CC=$ac_save_CC
+
+fi
+
+case &quot;x$ac_cv_prog_cc_stdc&quot; in
+  x|xno)
+    echo &quot;$as_me:$LINENO: result: none needed&quot; &gt;&amp;5
+echo &quot;${ECHO_T}none needed&quot; &gt;&amp;6 ;;
+  *)
+    echo &quot;$as_me:$LINENO: result: $ac_cv_prog_cc_stdc&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_prog_cc_stdc&quot; &gt;&amp;6
+    CC=&quot;$CC $ac_cv_prog_cc_stdc&quot; ;;
+esac
+
+# Some people use a C++ compiler to compile C.  Since we use `exit',
+# in C++ we need to declare it.  In case someone uses the same compiler
+# for both compiling C and C++ we need to have the C++ compiler decide
+# the declaration of exit, since it's the most demanding environment.
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+#ifndef __cplusplus
+  choke me
+#endif
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  for ac_declaration in \
+   '' \
+   'extern &quot;C&quot; void std::exit (int) throw (); using std::exit;' \
+   'extern &quot;C&quot; void std::exit (int); using std::exit;' \
+   'extern &quot;C&quot; void exit (int) throw ();' \
+   'extern &quot;C&quot; void exit (int);' \
+   'void exit (int);'
+do
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+#include &lt;stdlib.h&gt;
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n &quot;$ac_declaration&quot;; then
+  echo '#ifdef __cplusplus' &gt;&gt;confdefs.h
+  echo $ac_declaration      &gt;&gt;confdefs.h
+  echo '#endif'             &gt;&gt;confdefs.h
+fi
+
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+
+
+echo &quot;$as_me:$LINENO: checking whether compiler needs -Wno-deprecated&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether compiler needs -Wno-deprecated... $ECHO_C&quot; &gt;&amp;6
+gcc_version=`${CC} --version | grep 'gcc (GCC) [3-4].' | head -n 1`
+case &quot;${gcc_version}&quot; in
+     gcc*)
+        echo &quot;$as_me:$LINENO: result: yes&quot; &gt;&amp;5
+echo &quot;${ECHO_T}yes&quot; &gt;&amp;6
+        CXXFLAGS=&quot;$CXXFLAGS -Wno-deprecated&quot;
+        CPPFLAGS=&quot;$CPPFLAGS -Wno-deprecated&quot;
+        ;;
+
+     *)
+        echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+        ;;
+esac
+
+echo &quot;$as_me:$LINENO: checking whether compiler accepts -Wmissing-declarations and -Wnested-externs&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether compiler accepts -Wmissing-declarations and -Wnested-externs... $ECHO_C&quot; &gt;&amp;6
+gcc_version=`${CC} --version | grep 'gcc (GCC) [3-4].' | head -n 1`
+case &quot;${gcc_version}&quot; in
+     gcc*)
+        echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+        ;;
+
+     *)
+        echo &quot;$as_me:$LINENO: result: yes&quot; &gt;&amp;5
+echo &quot;${ECHO_T}yes&quot; &gt;&amp;6
+        CXXFLAGS=&quot;$CXXFLAGS -Wmissing-declarations -Wnested-externs&quot;
+        CPPFLAGS=&quot;$CPPFLAGS -Wmissing-declarations -Wnested-externs&quot;
+        ;;
+esac
+
+
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh=&quot;$ac_aux_dir/install-sh -c&quot;
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh=&quot;$ac_aux_dir/install.sh -c&quot;
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh=&quot;$ac_aux_dir/shtool install -c&quot;
+    break
+  fi
+done
+if test -z &quot;$ac_aux_dir&quot;; then
+  { { echo &quot;$as_me:$LINENO: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../..&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../..&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess=&quot;$SHELL $ac_aux_dir/config.guess&quot;
+ac_config_sub=&quot;$SHELL $ac_aux_dir/config.sub&quot;
+ac_configure=&quot;$SHELL $ac_aux_dir/configure&quot; # This should be Cygnus configure.
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group &quot;staff&quot;
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+echo &quot;$as_me:$LINENO: checking for a BSD-compatible install&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for a BSD-compatible install... $ECHO_C&quot; &gt;&amp;6
+if test -z &quot;$INSTALL&quot;; then
+if test &quot;${ac_cv_path_install+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if $as_executable_p &quot;$as_dir/$ac_prog$ac_exec_ext&quot;; then
+	  if test $ac_prog = install &amp;&amp;
+	    grep dspmsg &quot;$as_dir/$ac_prog$ac_exec_ext&quot; &gt;/dev/null 2&gt;&amp;1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &amp;&amp;
+	    grep pwplus &quot;$as_dir/$ac_prog$ac_exec_ext&quot; &gt;/dev/null 2&gt;&amp;1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install=&quot;$as_dir/$ac_prog$ac_exec_ext -c&quot;
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+
+
+fi
+  if test &quot;${ac_cv_path_install+set}&quot; = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL=$ac_install_sh
+  fi
+fi
+echo &quot;$as_me:$LINENO: result: $INSTALL&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$INSTALL&quot; &gt;&amp;6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z &quot;$INSTALL_PROGRAM&quot; &amp;&amp; INSTALL_PROGRAM='${INSTALL}'
+
+test -z &quot;$INSTALL_SCRIPT&quot; &amp;&amp; INSTALL_SCRIPT='${INSTALL}'
+
+test -z &quot;$INSTALL_DATA&quot; &amp;&amp; INSTALL_DATA='${INSTALL} -m 644'
+
+
+
+
+ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+echo &quot;$as_me:$LINENO: checking how to run the C++ preprocessor&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking how to run the C++ preprocessor... $ECHO_C&quot; &gt;&amp;6
+if test -z &quot;$CXXCPP&quot;; then
+  if test &quot;${ac_cv_prog_CXXCPP+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+      # Double quotes because CXXCPP needs to be expanded
+    for CXXCPP in &quot;$CXX -E&quot; &quot;/lib/cpp&quot;
+    do
+      ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+  # &lt;limits.h&gt; exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. &quot;Syntax error&quot; is here to catch this case.
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_cpp conftest.$ac_ext\&quot;&quot;) &gt;&amp;5
+  (eval $ac_cpp conftest.$ac_ext) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &gt;/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z &quot;$ac_cpp_err&quot;; then
+  :
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;ac_nonexistent.h&gt;
+_ACEOF
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_cpp conftest.$ac_ext\&quot;&quot;) &gt;&amp;5
+  (eval $ac_cpp conftest.$ac_ext) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &gt;/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z &quot;$ac_cpp_err&quot;; then
+  # Broken: success on invalid input.
+continue
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CXXCPP=$CXXCPP
+
+fi
+  CXXCPP=$ac_cv_prog_CXXCPP
+else
+  ac_cv_prog_CXXCPP=$CXXCPP
+fi
+echo &quot;$as_me:$LINENO: result: $CXXCPP&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CXXCPP&quot; &gt;&amp;6
+ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+  # &lt;limits.h&gt; exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. &quot;Syntax error&quot; is here to catch this case.
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_cpp conftest.$ac_ext\&quot;&quot;) &gt;&amp;5
+  (eval $ac_cpp conftest.$ac_ext) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &gt;/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z &quot;$ac_cpp_err&quot;; then
+  :
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;ac_nonexistent.h&gt;
+_ACEOF
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_cpp conftest.$ac_ext\&quot;&quot;) &gt;&amp;5
+  (eval $ac_cpp conftest.$ac_ext) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &gt;/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z &quot;$ac_cpp_err&quot;; then
+  # Broken: success on invalid input.
+continue
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo &quot;$as_me:$LINENO: error: C++ preprocessor \&quot;$CXXCPP\&quot; fails sanity check
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: C++ preprocessor \&quot;$CXXCPP\&quot; fails sanity check
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+
+echo &quot;$as_me:$LINENO: checking for X&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for X... $ECHO_C&quot; &gt;&amp;6
+
+
+# Check whether --with-x or --without-x was given.
+if test &quot;${with_x+set}&quot; = set; then
+  withval=&quot;$with_x&quot;
+
+fi;
+# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
+if test &quot;x$with_x&quot; = xno; then
+  # The user explicitly disabled X.
+  have_x=disabled
+else
+  if test &quot;x$x_includes&quot; != xNONE &amp;&amp; test &quot;x$x_libraries&quot; != xNONE; then
+    # Both variables are already set.
+    have_x=yes
+  else
+    if test &quot;${ac_cv_have_x+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  # One or both of the vars are not set, and there is no cached value.
+ac_x_includes=no ac_x_libraries=no
+rm -fr conftest.dir
+if mkdir conftest.dir; then
+  cd conftest.dir
+  # Make sure to not put &quot;make&quot; in the Imakefile rules, since we grep it out.
+  cat &gt;Imakefile &lt;&lt;'_ACEOF'
+acfindx:
+	@echo 'ac_im_incroot=&quot;${INCROOT}&quot;; ac_im_usrlibdir=&quot;${USRLIBDIR}&quot;; ac_im_libdir=&quot;${LIBDIR}&quot;'
+_ACEOF
+  if (xmkmf) &gt;/dev/null 2&gt;/dev/null &amp;&amp; test -f Makefile; then
+    # GNU make sometimes prints &quot;make[1]: Entering...&quot;, which would confuse us.
+    eval `${MAKE-make} acfindx 2&gt;/dev/null | grep -v make`
+    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
+    for ac_extension in a so sl; do
+      if test ! -f $ac_im_usrlibdir/libX11.$ac_extension &amp;&amp;
+	 test -f $ac_im_libdir/libX11.$ac_extension; then
+	ac_im_usrlibdir=$ac_im_libdir; break
+      fi
+    done
+    # Screen out bogus values from the imake configuration.  They are
+    # bogus both because they are the default anyway, and because
+    # using them would break gcc on systems where it needs fixed includes.
+    case $ac_im_incroot in
+	/usr/include) ;;
+	*) test -f &quot;$ac_im_incroot/X11/Xos.h&quot; &amp;&amp; ac_x_includes=$ac_im_incroot;;
+    esac
+    case $ac_im_usrlibdir in
+	/usr/lib | /lib) ;;
+	*) test -d &quot;$ac_im_usrlibdir&quot; &amp;&amp; ac_x_libraries=$ac_im_usrlibdir ;;
+    esac
+  fi
+  cd ..
+  rm -fr conftest.dir
+fi
+
+# Standard set of common directories for X headers.
+# Check X11 before X11Rn because it is often a symlink to the current release.
+ac_x_header_dirs='
+/usr/X11/include
+/usr/X11R6/include
+/usr/X11R5/include
+/usr/X11R4/include
+
+/usr/include/X11
+/usr/include/X11R6
+/usr/include/X11R5
+/usr/include/X11R4
+
+/usr/local/X11/include
+/usr/local/X11R6/include
+/usr/local/X11R5/include
+/usr/local/X11R4/include
+
+/usr/local/include/X11
+/usr/local/include/X11R6
+/usr/local/include/X11R5
+/usr/local/include/X11R4
+
+/usr/X386/include
+/usr/x386/include
+/usr/XFree86/include/X11
+
+/usr/include
+/usr/local/include
+/usr/unsupported/include
+/usr/athena/include
+/usr/local/x11r5/include
+/usr/lpp/Xamples/include
+
+/usr/openwin/include
+/usr/openwin/share/include'
+
+if test &quot;$ac_x_includes&quot; = no; then
+  # Guess where to find include files, by looking for Intrinsic.h.
+  # First, try using that file with no special directory specified.
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;X11/Intrinsic.h&gt;
+_ACEOF
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_cpp conftest.$ac_ext\&quot;&quot;) &gt;&amp;5
+  (eval $ac_cpp conftest.$ac_ext) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &gt;/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z &quot;$ac_cpp_err&quot;; then
+  # We can compile using X headers with no special include directory.
+ac_x_includes=
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+  for ac_dir in $ac_x_header_dirs; do
+  if test -r &quot;$ac_dir/X11/Intrinsic.h&quot;; then
+    ac_x_includes=$ac_dir
+    break
+  fi
+done
+fi
+rm -f conftest.err conftest.$ac_ext
+fi # $ac_x_includes = no
+
+if test &quot;$ac_x_libraries&quot; = no; then
+  # Check for the libraries.
+  # See if we find them without any special options.
+  # Don't add to $LIBS permanently.
+  ac_save_LIBS=$LIBS
+  LIBS=&quot;-lXt $LIBS&quot;
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;X11/Intrinsic.h&gt;
+int
+main ()
+{
+XtMalloc (0)
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  LIBS=$ac_save_LIBS
+# We can link X programs with no special library path.
+ac_x_libraries=
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+LIBS=$ac_save_LIBS
+for ac_dir in `echo &quot;$ac_x_includes $ac_x_header_dirs&quot; | sed s/include/lib/g`
+do
+  # Don't even attempt the hair of trying to link an X program!
+  for ac_extension in a so sl; do
+    if test -r $ac_dir/libXt.$ac_extension; then
+      ac_x_libraries=$ac_dir
+      break 2
+    fi
+  done
+done
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi # $ac_x_libraries = no
+
+if test &quot;$ac_x_includes&quot; = no || test &quot;$ac_x_libraries&quot; = no; then
+  # Didn't find X anywhere.  Cache the known absence of X.
+  ac_cv_have_x=&quot;have_x=no&quot;
+else
+  # Record where we found X for the cache.
+  ac_cv_have_x=&quot;have_x=yes \
+		ac_x_includes=$ac_x_includes ac_x_libraries=$ac_x_libraries&quot;
+fi
+fi
+
+  fi
+  eval &quot;$ac_cv_have_x&quot;
+fi # $with_x != no
+
+if test &quot;$have_x&quot; != yes; then
+  echo &quot;$as_me:$LINENO: result: $have_x&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$have_x&quot; &gt;&amp;6
+  no_x=yes
+else
+  # If each of the values was on the command line, it overrides each guess.
+  test &quot;x$x_includes&quot; = xNONE &amp;&amp; x_includes=$ac_x_includes
+  test &quot;x$x_libraries&quot; = xNONE &amp;&amp; x_libraries=$ac_x_libraries
+  # Update the cache value to reflect the command line values.
+  ac_cv_have_x=&quot;have_x=yes \
+		ac_x_includes=$x_includes ac_x_libraries=$x_libraries&quot;
+  echo &quot;$as_me:$LINENO: result: libraries $x_libraries, headers $x_includes&quot; &gt;&amp;5
+echo &quot;${ECHO_T}libraries $x_libraries, headers $x_includes&quot; &gt;&amp;6
+fi
+
+if test &quot;$no_x&quot; = yes; then
+  # Not all programs may use this symbol, but it does not hurt to define it.
+
+cat &gt;&gt;confdefs.h &lt;&lt;\_ACEOF
+#define X_DISPLAY_MISSING 1
+_ACEOF
+
+  X_CFLAGS= X_PRE_LIBS= X_LIBS= X_EXTRA_LIBS=
+else
+  if test -n &quot;$x_includes&quot;; then
+    X_CFLAGS=&quot;$X_CFLAGS -I$x_includes&quot;
+  fi
+
+  # It would also be nice to do this for all -L options, not just this one.
+  if test -n &quot;$x_libraries&quot;; then
+    X_LIBS=&quot;$X_LIBS -L$x_libraries&quot;
+    # For Solaris; some versions of Sun CC require a space after -R and
+    # others require no space.  Words are not sufficient . . . .
+    case `(uname -sr) 2&gt;/dev/null` in
+    &quot;SunOS 5&quot;*)
+      echo &quot;$as_me:$LINENO: checking whether -R must be followed by a space&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether -R must be followed by a space... $ECHO_C&quot; &gt;&amp;6
+      ac_xsave_LIBS=$LIBS; LIBS=&quot;$LIBS -R$x_libraries&quot;
+      cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_R_nospace=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_R_nospace=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+      if test $ac_R_nospace = yes; then
+	echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+	X_LIBS=&quot;$X_LIBS -R$x_libraries&quot;
+      else
+	LIBS=&quot;$ac_xsave_LIBS -R $x_libraries&quot;
+	cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_R_space=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_R_space=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	if test $ac_R_space = yes; then
+	  echo &quot;$as_me:$LINENO: result: yes&quot; &gt;&amp;5
+echo &quot;${ECHO_T}yes&quot; &gt;&amp;6
+	  X_LIBS=&quot;$X_LIBS -R $x_libraries&quot;
+	else
+	  echo &quot;$as_me:$LINENO: result: neither works&quot; &gt;&amp;5
+echo &quot;${ECHO_T}neither works&quot; &gt;&amp;6
+	fi
+      fi
+      LIBS=$ac_xsave_LIBS
+    esac
+  fi
+
+  # Check for system-dependent libraries X programs must link with.
+  # Do this before checking for the system-independent R6 libraries
+  # (-lICE), since we may need -lsocket or whatever for X linking.
+
+  if test &quot;$ISC&quot; = yes; then
+    X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -lnsl_s -linet&quot;
+  else
+    # Martyn Johnson says this is needed for Ultrix, if the X
+    # libraries were built with DECnet support.  And Karl Berry says
+    # the Alpha needs dnet_stub (dnet does not exist).
+    ac_xsave_LIBS=&quot;$LIBS&quot;; LIBS=&quot;$LIBS $X_LIBS -lX11&quot;
+    cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char XOpenDisplay ();
+int
+main ()
+{
+XOpenDisplay ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+echo &quot;$as_me:$LINENO: checking for dnet_ntoa in -ldnet&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for dnet_ntoa in -ldnet... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_dnet_dnet_ntoa+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-ldnet  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dnet_ntoa ();
+int
+main ()
+{
+dnet_ntoa ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dnet_dnet_ntoa=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_dnet_dnet_ntoa=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_dnet_dnet_ntoa&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_dnet_dnet_ntoa&quot; &gt;&amp;6
+if test $ac_cv_lib_dnet_dnet_ntoa = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -ldnet&quot;
+fi
+
+    if test $ac_cv_lib_dnet_dnet_ntoa = no; then
+      echo &quot;$as_me:$LINENO: checking for dnet_ntoa in -ldnet_stub&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for dnet_ntoa in -ldnet_stub... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_dnet_stub_dnet_ntoa+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-ldnet_stub  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dnet_ntoa ();
+int
+main ()
+{
+dnet_ntoa ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dnet_stub_dnet_ntoa=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_dnet_stub_dnet_ntoa=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_dnet_stub_dnet_ntoa&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_dnet_stub_dnet_ntoa&quot; &gt;&amp;6
+if test $ac_cv_lib_dnet_stub_dnet_ntoa = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -ldnet_stub&quot;
+fi
+
+    fi
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+    LIBS=&quot;$ac_xsave_LIBS&quot;
+
+    # <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">msh at cis.ufl.edu</A> says -lnsl (and -lsocket) are needed for his 386/AT,
+    # to get the SysV transport functions.
+    # Chad R. Larson says the Pyramis MIS-ES running DC/OSx (SVR4)
+    # needs -lnsl.
+    # The nsl library prevents programs from opening the X display
+    # on Irix 5.2, according to T.E. Dickey.
+    # The functions gethostbyname, getservbyname, and inet_addr are
+    # in -lbsd on LynxOS 3.0.1/i386, according to Lars Hecking.
+    echo &quot;$as_me:$LINENO: checking for gethostbyname&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for gethostbyname... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_func_gethostbyname+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+/* Define gethostbyname to an innocuous variant, in case &lt;limits.h&gt; declares gethostbyname.
+   For example, HP-UX 11i &lt;limits.h&gt; declares gettimeofday.  */
+#define gethostbyname innocuous_gethostbyname
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char gethostbyname (); below.
+    Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+    &lt;limits.h&gt; exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+
+#undef gethostbyname
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_gethostbyname) || defined (__stub___gethostbyname)
+choke me
+#else
+char (*f) () = gethostbyname;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != gethostbyname;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_func_gethostbyname=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_func_gethostbyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_func_gethostbyname&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_func_gethostbyname&quot; &gt;&amp;6
+
+    if test $ac_cv_func_gethostbyname = no; then
+      echo &quot;$as_me:$LINENO: checking for gethostbyname in -lnsl&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for gethostbyname in -lnsl... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_nsl_gethostbyname+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lnsl  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_nsl_gethostbyname&quot; &gt;&amp;6
+if test $ac_cv_lib_nsl_gethostbyname = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -lnsl&quot;
+fi
+
+      if test $ac_cv_lib_nsl_gethostbyname = no; then
+	echo &quot;$as_me:$LINENO: checking for gethostbyname in -lbsd&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for gethostbyname in -lbsd... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_bsd_gethostbyname+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lbsd  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_bsd_gethostbyname=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_bsd_gethostbyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_bsd_gethostbyname&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_bsd_gethostbyname&quot; &gt;&amp;6
+if test $ac_cv_lib_bsd_gethostbyname = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -lbsd&quot;
+fi
+
+      fi
+    fi
+
+    # <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">lieder at skyler.mavd.honeywell.com</A> says without -lsocket,
+    # socket/setsockopt and other routines are undefined under SCO ODT
+    # 2.0.  But -lsocket is broken on IRIX 5.2 (and is not necessary
+    # on later versions), says Simon Leinen: it contains gethostby*
+    # variants that don't use the name server (or something).  -lsocket
+    # must be given before -lnsl if both are needed.  We assume that
+    # if connect needs -lnsl, so does gethostbyname.
+    echo &quot;$as_me:$LINENO: checking for connect&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for connect... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_func_connect+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+/* Define connect to an innocuous variant, in case &lt;limits.h&gt; declares connect.
+   For example, HP-UX 11i &lt;limits.h&gt; declares gettimeofday.  */
+#define connect innocuous_connect
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char connect (); below.
+    Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+    &lt;limits.h&gt; exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+
+#undef connect
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char connect ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_connect) || defined (__stub___connect)
+choke me
+#else
+char (*f) () = connect;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != connect;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_func_connect=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_func_connect=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_func_connect&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_func_connect&quot; &gt;&amp;6
+
+    if test $ac_cv_func_connect = no; then
+      echo &quot;$as_me:$LINENO: checking for connect in -lsocket&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for connect in -lsocket... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_socket_connect+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lsocket $X_EXTRA_LIBS $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char connect ();
+int
+main ()
+{
+connect ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_socket_connect=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_socket_connect=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_socket_connect&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_socket_connect&quot; &gt;&amp;6
+if test $ac_cv_lib_socket_connect = yes; then
+  X_EXTRA_LIBS=&quot;-lsocket $X_EXTRA_LIBS&quot;
+fi
+
+    fi
+
+    # Guillermo Gomez says -lposix is necessary on A/UX.
+    echo &quot;$as_me:$LINENO: checking for remove&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for remove... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_func_remove+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+/* Define remove to an innocuous variant, in case &lt;limits.h&gt; declares remove.
+   For example, HP-UX 11i &lt;limits.h&gt; declares gettimeofday.  */
+#define remove innocuous_remove
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char remove (); below.
+    Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+    &lt;limits.h&gt; exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+
+#undef remove
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char remove ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_remove) || defined (__stub___remove)
+choke me
+#else
+char (*f) () = remove;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != remove;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_func_remove=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_func_remove=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_func_remove&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_func_remove&quot; &gt;&amp;6
+
+    if test $ac_cv_func_remove = no; then
+      echo &quot;$as_me:$LINENO: checking for remove in -lposix&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for remove in -lposix... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_posix_remove+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lposix  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char remove ();
+int
+main ()
+{
+remove ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_posix_remove=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_posix_remove=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_posix_remove&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_posix_remove&quot; &gt;&amp;6
+if test $ac_cv_lib_posix_remove = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -lposix&quot;
+fi
+
+    fi
+
+    # BSDI BSD/OS 2.1 needs -lipc for XOpenDisplay.
+    echo &quot;$as_me:$LINENO: checking for shmat&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for shmat... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_func_shmat+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+/* Define shmat to an innocuous variant, in case &lt;limits.h&gt; declares shmat.
+   For example, HP-UX 11i &lt;limits.h&gt; declares gettimeofday.  */
+#define shmat innocuous_shmat
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char shmat (); below.
+    Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+    &lt;limits.h&gt; exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+
+#undef shmat
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char shmat ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_shmat) || defined (__stub___shmat)
+choke me
+#else
+char (*f) () = shmat;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != shmat;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_func_shmat=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_func_shmat=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_func_shmat&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_func_shmat&quot; &gt;&amp;6
+
+    if test $ac_cv_func_shmat = no; then
+      echo &quot;$as_me:$LINENO: checking for shmat in -lipc&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for shmat in -lipc... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_ipc_shmat+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lipc  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char shmat ();
+int
+main ()
+{
+shmat ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_ipc_shmat=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_ipc_shmat=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_ipc_shmat&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_ipc_shmat&quot; &gt;&amp;6
+if test $ac_cv_lib_ipc_shmat = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -lipc&quot;
+fi
+
+    fi
+  fi
+
+  # Check for libraries that X11R6 Xt/Xaw programs need.
+  ac_save_LDFLAGS=$LDFLAGS
+  test -n &quot;$x_libraries&quot; &amp;&amp; LDFLAGS=&quot;$LDFLAGS -L$x_libraries&quot;
+  # SM needs ICE to (dynamically) link under SunOS 4.x (so we have to
+  # check for ICE first), but we must link in the order -lSM -lICE or
+  # we get undefined symbols.  So assume we have SM if we have ICE.
+  # These have to be linked with before -lX11, unlike the other
+  # libraries we check for below, so use a different variable.
+  # John Interrante, Karl Berry
+  echo &quot;$as_me:$LINENO: checking for IceConnectionNumber in -lICE&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for IceConnectionNumber in -lICE... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_ICE_IceConnectionNumber+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lICE $X_EXTRA_LIBS $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char IceConnectionNumber ();
+int
+main ()
+{
+IceConnectionNumber ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_ICE_IceConnectionNumber=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_ICE_IceConnectionNumber=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_ICE_IceConnectionNumber&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_ICE_IceConnectionNumber&quot; &gt;&amp;6
+if test $ac_cv_lib_ICE_IceConnectionNumber = yes; then
+  X_PRE_LIBS=&quot;$X_PRE_LIBS -lSM -lICE&quot;
+fi
+
+  LDFLAGS=$ac_save_LDFLAGS
+
+fi
+
+
+
+ac_help=&quot;$ac_help
+  --with-symbols          give -g flag to compiler to produce debug symbols
+  --with-info             define INFO at compile time to get basic log output
+  --with-valgrind         clean up allocated buffers to avoid valgrind warnings
+  --with-version          use this version for produced libraries
+
+  --with-static-jpeg      enable static linking of JPEG library
+  --with-static-z         enable static linking of Z library&quot;
+
+
+
+echo &quot;$as_me:$LINENO: checking for Cygwin32 environment&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for Cygwin32 environment... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${nxconf_cv_cygwin32+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+return __CYGWIN32__;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  nxconf_cv_cygwin32=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+nxconf_cv_cygwin32=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest*
+fi
+echo &quot;$as_me:$LINENO: result: $nxconf_cv_cygwin32&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxconf_cv_cygwin32&quot; &gt;&amp;6
+CYGWIN32=
+test &quot;$nxconf_cv_cygwin32&quot; = yes &amp;&amp; CYGWIN32=yes
+
+
+if test &quot;$CYGWIN32&quot; = yes; then
+    LIBS=&quot;$LIBS -lstdc++ -lcygipc -lgdi32&quot;
+fi
+
+
+
+echo &quot;$as_me:$LINENO: checking for Darwin environment&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for Darwin environment... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${nxconf_cv_darwin+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+return __APPLE__;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  nxconf_cv_darwin=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+nxconf_cv_darwin=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest*
+fi
+echo &quot;$as_me:$LINENO: result: $nxconf_cv_darwin&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxconf_cv_darwin&quot; &gt;&amp;6
+DARWIN=
+test &quot;$nxconf_cv_darwin&quot; = yes &amp;&amp; DARWIN=yes
+
+
+
+echo &quot;$as_me:$LINENO: checking for Solaris environment&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for Solaris environment... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${nxconf_cv_sun+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+return __sun;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  nxconf_cv_sun=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+nxconf_cv_sun=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest*
+fi
+echo &quot;$as_me:$LINENO: result: $nxconf_cv_sun&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxconf_cv_sun&quot; &gt;&amp;6
+SUN=
+test &quot;$nxconf_cv_sun&quot; = yes &amp;&amp; SUN=yes
+
+
+
+echo &quot;$as_me:$LINENO: checking for FreeBSD environment&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for FreeBSD environment... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${nxconf_cv_freebsd+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+return __FreeBSD__;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  nxconf_cv_freebsd=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+nxconf_cv_freebsd=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest*
+fi
+echo &quot;$as_me:$LINENO: result: $nxconf_cv_freebsd&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxconf_cv_freebsd&quot; &gt;&amp;6
+FreeBSD=
+test &quot;$nxconf_cv_freebsd&quot; = yes &amp;&amp; FreeBSD=yes
+
+
+if test &quot;$CYGWIN32&quot; != yes -a &quot;$DARWIN&quot; != yes; then
+  CXXFLAGS=&quot;$CXXFLAGS -fPIC&quot;
+  CFLAGS=&quot;$CFLAGS -fPIC&quot;
+fi
+
+
+if test &quot;$SUN&quot; = yes; then
+  LIBS=&quot;$LIBS  -L/usr/sfw/lib -lsocket &quot;
+  CXXFLAGS=&quot;$CXXFLAGS -I/usr/sfw/include&quot;
+fi
+
+
+if test &quot;$FreeBSD&quot; = yes; then
+  LIBS=&quot;$LIBS  -L/usr/local/lib&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -I/usr/local/include&quot;
+fi
+
+
+if test &quot;$DARWIN&quot; = yes; then
+  LDFLAGS=&quot;$LDFLAGS -bundle&quot;
+elif test &quot;$SUN&quot; = yes; then
+  LDFLAGS=&quot;$LDFLAGS -G -h \$(LIBLOAD)&quot;
+else
+  LDFLAGS=&quot;$LDFLAGS -Wl,-soname,\$(LIBLOAD)&quot;
+fi
+
+
+
+echo &quot;$as_me:$LINENO: checking for in_addr_t&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for in_addr_t... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${nxconf_cv_inaddrt+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;netinet/in.h&gt;
+int
+main ()
+{
+in_addr_t t; t = 1; return t;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  nxconf_cv_inaddrt=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+nxconf_cv_inaddrt=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest*
+fi
+echo &quot;$as_me:$LINENO: result: $nxconf_cv_inaddrt&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxconf_cv_inaddrt&quot; &gt;&amp;6
+INADDRT=
+test &quot;$nxconf_cv_inaddrt&quot; = yes &amp;&amp; INADDRT=yes
+
+
+if test &quot;$INADDRT&quot; != yes ; then
+  echo -e &quot;using unsigned int for type in_addr_t&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DIN_ADDR_T=unsigned&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DIN_ADDR_T=unsigned&quot;
+else
+  CXXFLAGS=&quot;$CXXFLAGS -DIN_ADDR_T=in_addr_t&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DIN_ADDR_T=in_addr_t&quot;
+fi
+
+
+
+
+if test &quot;${with_version}&quot; = yes; then
+  VERSION=${ac_option}
+else
+  VERSION=`cat VERSION`
+fi
+echo -e &quot;compiling version ${VERSION}&quot;
+
+LIBVERSION=`echo ${VERSION} | cut -d '.' -f 1`
+
+CXXFLAGS=&quot;$CXXFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+CPPFLAGS=&quot;$CPPFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+
+
+if test &quot;$DARWIN&quot; = yes ; then
+  LIBS=&quot;$LIBS $LIBSTATIC $LIBSHARED&quot;
+elif test &quot;$SUN&quot; = yes ; then
+  LIBS=&quot;$LIBS $LIBSTATIC $LIBSHARED&quot;
+else
+  LIBS=&quot;$LIBS $LIBSTATIC -shared $LIBSHARED&quot;
+fi
+
+
+if test &quot;${with_symbols}&quot; = yes; then
+  echo -e &quot;enabling production of debug symbols&quot;
+  CXXFLAGS=&quot;-g $CXXFLAGS&quot;
+  CPPFLAGS=&quot;-g $CPPFLAGS&quot;
+else
+  echo -e &quot;disabling production of debug symbols&quot;
+fi
+
+
+if test &quot;${with_info}&quot; = yes; then
+  echo -e &quot;enabling info output in the log file&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DINFO&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DINFO&quot;
+else
+  echo -e &quot;disabling info output in the log file&quot;
+fi
+
+
+if test &quot;${with_valgrind}&quot; = yes; then
+  echo -e &quot;enabling valgrind memory checker workarounds&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DVALGRIND&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DVALGRIND&quot;
+else
+  echo -e &quot;disabling valgrind memory checker workarounds&quot;
+fi
+
+
+
+
+if test -x &quot;../nx-X11/config/makedepend/makedepend&quot; ; then
+  MAKEDEPEND=../nx-X11/config/makedepend/makedepend
+else
+  if test -x &quot;/usr/X11R6/bin/makedepend&quot; ; then
+    MAKEDEPEND=/usr/X11R6/bin/makedepend
+  else
+    if test -x &quot;/usr/openwin/bin/makedepend&quot; ; then
+      MAKEDEPEND=/usr/openwin/bin/makedepend
+    else
+      MAKEDEPEND=makedepend
+    fi
+  fi
+fi
+
+          ac_config_files=&quot;$ac_config_files Makefile&quot;
+cat &gt;confcache &lt;&lt;\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2&gt;&amp;1 |
+    case `(ac_space=' '; set | grep ac_space) 2&gt;&amp;1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	&quot;s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p&quot;
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+	&quot;s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p&quot;
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test &quot;${\1+set}&quot; = set || &amp;/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' &gt;&gt;confcache
+if diff $cache_file confcache &gt;/dev/null 2&gt;&amp;1; then :; else
+  if test -w $cache_file; then
+    test &quot;x$cache_file&quot; != &quot;x/dev/null&quot; &amp;&amp; echo &quot;updating cache $cache_file&quot;
+    cat confcache &gt;$cache_file
+  else
+    echo &quot;not updating unwritable cache $cache_file&quot;
+  fi
+fi
+rm -f confcache
+
+test &quot;x$prefix&quot; = xNONE &amp;&amp; prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test &quot;x$exec_prefix&quot; = xNONE &amp;&amp; exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is &quot;.&quot;, strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test &quot;x$srcdir&quot; = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
+# Transform confdefs.h into DEFS.
+# Protect against shell expansion while executing Makefile rules.
+# Protect against Makefile macro expansion.
+#
+# If the first sed substitution is executed (which looks for macros that
+# take arguments), then we branch to the quote section.  Otherwise,
+# look for a macro that doesn't take arguments.
+cat &gt;confdef2opt.sed &lt;&lt;\_ACEOF
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+d
+: quote
+s,[	 `~#$^&amp;*(){}\\|;'&quot;&lt;&gt;?],\\&amp;,g
+s,\[,\\&amp;,g
+s,\],\\&amp;,g
+s,\$,$$,g
+p
+_ACEOF
+# We use echo to avoid assuming a particular line-breaking character.
+# The extra dot is to prevent the shell from consuming trailing
+# line-breaks from the sub-command output.  A line-break within
+# single-quotes doesn't work because, if this script is created in a
+# platform that uses two characters for line-breaks (e.g., DOS), tr
+# would break.
+ac_LF_and_DOT=`echo; echo .`
+DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr &quot;$ac_LF_and_DOT&quot; ' .'`
+rm -f confdef2opt.sed
+
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test &quot;x$ac_i&quot; = x: &amp;&amp; continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo &quot;$ac_i&quot; |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs=&quot;$ac_libobjs $ac_i\$U.$ac_objext&quot;
+  ac_ltlibobjs=&quot;$ac_ltlibobjs $ac_i&quot;'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files=&quot;$ac_clean_files $CONFIG_STATUS&quot;
+{ echo &quot;$as_me:$LINENO: creating $CONFIG_STATUS&quot; &gt;&amp;5
+echo &quot;$as_me: creating $CONFIG_STATUS&quot; &gt;&amp;6;}
+cat &gt;$CONFIG_STATUS &lt;&lt;_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n &quot;${ZSH_VERSION+set}&quot; &amp;&amp; (emulate sh) &gt;/dev/null 2&gt;&amp;1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+&quot;$@&quot;}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+&quot;$@&quot;}'='&quot;$@&quot;'
+elif test -n &quot;${BASH_VERSION+set}&quot; &amp;&amp; (set -o posix) &gt;/dev/null 2&gt;&amp;1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) &gt;/dev/null 2&gt;&amp;1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='&gt; '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z &quot;`(eval $as_var=C; export $as_var) 2&gt;&amp;1`&quot;); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' &gt;/dev/null 2&gt;&amp;1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) &gt;/dev/null 2&gt;&amp;1 &amp;&amp; test &quot;X`basename / 2&gt;&amp;1`&quot; = &quot;X/&quot;; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename &quot;$0&quot; ||
+$as_expr X/&quot;$0&quot; : '.*/\([^/][^/]*\)/*$' \| \
+	 X&quot;$0&quot; : 'X\(//\)$' \| \
+	 X&quot;$0&quot; : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2&gt;/dev/null ||
+echo X/&quot;$0&quot; |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test &quot;${PATH_SEPARATOR+set}&quot; != set; then
+  echo &quot;#! /bin/sh&quot; &gt;conf$$.sh
+  echo  &quot;exit 0&quot;   &gt;&gt;conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH=&quot;/nonexistent;.&quot;; conf$$.sh) &gt;/dev/null 2&gt;&amp;1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2&gt;/dev/null`
+  test &quot;x$as_lineno_1&quot; != &quot;x$as_lineno_2&quot; &amp;&amp;
+  test &quot;x$as_lineno_3&quot;  = &quot;x$as_lineno_2&quot;  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  test -r &quot;$as_dir/$0&quot; &amp;&amp; as_myself=$as_dir/$0 &amp;&amp; break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test &quot;x$as_myself&quot; = x; then
+    as_myself=$0
+  fi
+  if test ! -f &quot;$as_myself&quot;; then
+    { { echo &quot;$as_me:$LINENO: error: cannot find myself; rerun with an absolute path&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot find myself; rerun with an absolute path&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if (&quot;$as_dir/$as_base&quot; -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2&gt;/dev/null`
+  test &quot;x$as_lineno_1&quot; != &quot;x$as_lineno_2&quot; &amp;&amp;
+  test &quot;x$as_lineno_3&quot;  = &quot;x$as_lineno_2&quot; ') 2&gt;/dev/null; then
+	     $as_unset BASH_ENV || test &quot;${BASH_ENV+set}&quot; != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test &quot;${ENV+set}&quot; != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec &quot;$CONFIG_SHELL&quot; &quot;$0&quot; ${1+&quot;$@&quot;}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' &lt;$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' &gt;$as_me.lineno &amp;&amp;
+  chmod +x $as_me.lineno ||
+    { { echo &quot;$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo &quot;testing\c&quot;; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' &gt;/dev/null 2&gt;&amp;1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo &gt;conf$$.file
+if ln -s conf$$.file conf$$ 2&gt;/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2&gt;/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2&gt;/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p &amp;&amp; rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p=&quot;test -f&quot;
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp=&quot;eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'&quot;
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh=&quot;eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'&quot;
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=&quot; 	$as_nl&quot;
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6&gt;&amp;1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5&gt;&gt;config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' &lt;&lt;_ASBOX
+## Running $as_me. ##
+_ASBOX
+} &gt;&amp;5
+cat &gt;&amp;5 &lt;&lt;_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo &quot;on `(hostname || uname -n) 2&gt;/dev/null | sed 1q`&quot; &gt;&amp;5
+echo &gt;&amp;5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n &quot;$ac_config_files&quot;; then
+  echo &quot;config_files=\&quot;$ac_config_files\&quot;&quot; &gt;&gt;$CONFIG_STATUS
+fi
+
+if test -n &quot;$ac_config_headers&quot;; then
+  echo &quot;config_headers=\&quot;$ac_config_headers\&quot;&quot; &gt;&gt;$CONFIG_STATUS
+fi
+
+if test -n &quot;$ac_config_links&quot;; then
+  echo &quot;config_links=\&quot;$ac_config_links\&quot;&quot; &gt;&gt;$CONFIG_STATUS
+fi
+
+if test -n &quot;$ac_config_commands&quot;; then
+  echo &quot;config_commands=\&quot;$ac_config_commands\&quot;&quot; &gt;&gt;$CONFIG_STATUS
+fi
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+
+ac_cs_usage=&quot;\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Report bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">bug-autoconf at gnu.org</A>&gt;.&quot;
+_ACEOF
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;_ACEOF
+ac_cs_version=&quot;\\
+config.status
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\&quot;`echo &quot;$ac_configure_args&quot; | sed 's/[\\&quot;&quot;\`\$]/\\\\&amp;/g'`\\&quot;
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.&quot;
+srcdir=$srcdir
+INSTALL=&quot;$INSTALL&quot;
+_ACEOF
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr &quot;x$1&quot; : 'x\([^=]*\)='`
+    ac_optarg=`expr &quot;x$1&quot; : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo &quot;$ac_cs_version&quot;; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo &quot;$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information.&quot; &gt;&amp;5
+echo &quot;$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo &quot;$ac_cs_usage&quot;; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES=&quot;$CONFIG_FILES $ac_optarg&quot;
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS=&quot;$CONFIG_HEADERS $ac_optarg&quot;
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo &quot;$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information.&quot; &gt;&amp;5
+echo &quot;$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets=&quot;$ac_config_targets $1&quot; ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6&gt;/dev/null
+  ac_configure_extra_args=&quot;$ac_configure_extra_args --silent&quot;
+fi
+
+_ACEOF
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;_ACEOF
+if \$ac_cs_recheck; then
+  echo &quot;running $SHELL $0 &quot; $ac_configure_args \$ac_configure_extra_args &quot; --no-create --no-recursion&quot; &gt;&amp;6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case &quot;$ac_config_target&quot; in
+  # Handling of arguments.
+  &quot;Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES Makefile&quot; ;;
+  *) { { echo &quot;$as_me:$LINENO: error: invalid argument: $ac_config_target&quot; &gt;&amp;5
+echo &quot;$as_me: error: invalid argument: $ac_config_target&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test &quot;${CONFIG_FILES+set}&quot; = set || CONFIG_FILES=$config_files
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp &amp;&amp; exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 &amp;&amp; mktemp -d -q &quot;./confstatXXXXXX&quot;) 2&gt;/dev/null` &amp;&amp;
+  test -n &quot;$tmp&quot; &amp;&amp; test -d &quot;$tmp&quot;
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 &amp;&amp; mkdir $tmp)
+} ||
+{
+   echo &quot;$me: cannot create a temporary directory in .&quot; &gt;&amp;2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n &quot;\$CONFIG_FILES&quot;; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&amp;,]/\\\\&amp;/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' &gt;\$tmp/subs.sed &lt;&lt;\\CEOF
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at SHELL</A>@,$SHELL,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PATH_SEPARATOR</A>@,$PATH_SEPARATOR,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PACKAGE_NAME</A>@,$PACKAGE_NAME,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PACKAGE_TARNAME</A>@,$PACKAGE_TARNAME,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PACKAGE_VERSION</A>@,$PACKAGE_VERSION,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PACKAGE_STRING</A>@,$PACKAGE_STRING,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PACKAGE_BUGREPORT</A>@,$PACKAGE_BUGREPORT,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at exec_prefix</A>@,$exec_prefix,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at prefix</A>@,$prefix,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at program_transform_name</A>@,$program_transform_name,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at bindir</A>@,$bindir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at sbindir</A>@,$sbindir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at libexecdir</A>@,$libexecdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at datadir</A>@,$datadir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at sysconfdir</A>@,$sysconfdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at sharedstatedir</A>@,$sharedstatedir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at localstatedir</A>@,$localstatedir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at libdir</A>@,$libdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at includedir</A>@,$includedir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at oldincludedir</A>@,$oldincludedir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at infodir</A>@,$infodir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at mandir</A>@,$mandir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at build_alias</A>@,$build_alias,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at host_alias</A>@,$host_alias,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at target_alias</A>@,$target_alias,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at DEFS</A>@,$DEFS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at ECHO_C</A>@,$ECHO_C,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at ECHO_N</A>@,$ECHO_N,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at ECHO_T</A>@,$ECHO_T,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at LIBS</A>@,$LIBS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at armcxx</A>@,$armcxx,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at armcc</A>@,$armcc,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CXX</A>@,$CXX,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CXXFLAGS</A>@,$CXXFLAGS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at LDFLAGS</A>@,$LDFLAGS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CPPFLAGS</A>@,$CPPFLAGS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at ac_ct_CXX</A>@,$ac_ct_CXX,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at EXEEXT</A>@,$EXEEXT,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at OBJEXT</A>@,$OBJEXT,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CC</A>@,$CC,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CFLAGS</A>@,$CFLAGS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at ac_ct_CC</A>@,$ac_ct_CC,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at INSTALL_PROGRAM</A>@,$INSTALL_PROGRAM,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at INSTALL_SCRIPT</A>@,$INSTALL_SCRIPT,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at INSTALL_DATA</A>@,$INSTALL_DATA,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CXXCPP</A>@,$CXXCPP,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at X_CFLAGS</A>@,$X_CFLAGS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at X_PRE_LIBS</A>@,$X_PRE_LIBS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at X_LIBS</A>@,$X_LIBS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at X_EXTRA_LIBS</A>@,$X_EXTRA_LIBS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at LIBVERSION</A>@,$LIBVERSION,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at VERSION</A>@,$VERSION,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at MAKEDEPEND</A>@,$MAKEDEPEND,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at LIBOBJS</A>@,$LIBOBJS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at LTLIBOBJS</A>@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed &quot;1,${ac_beg}d; ${ac_end}q&quot; $tmp/subs.sed &gt;$tmp/subs.frag
+    else
+      sed &quot;${ac_end}q&quot; $tmp/subs.sed &gt;$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' &amp;&amp; cat $tmp/subs.frag) &gt;$tmp/subs-$ac_sed_frag.sed
+      if test -z &quot;$ac_sed_cmds&quot;; then
+	ac_sed_cmds=&quot;sed -f $tmp/subs-$ac_sed_frag.sed&quot;
+      else
+	ac_sed_cmds=&quot;$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed&quot;
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z &quot;$ac_sed_cmds&quot;; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n &quot;$CONFIG_FILES&quot;
+
+_ACEOF
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+for ac_file in : $CONFIG_FILES; do test &quot;x$ac_file&quot; = x: &amp;&amp; continue
+  # Support &quot;outfile[:infile[:infile...]]&quot;, defaulting infile=&quot;outfile.in&quot;.
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat &gt;$tmp/stdin
+	ac_file_in=`echo &quot;$ac_file&quot; | sed 's,[^:]*:,,'`
+	ac_file=`echo &quot;$ac_file&quot; | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo &quot;$ac_file&quot; | sed 's,[^:]*:,,'`
+	ac_file=`echo &quot;$ac_file&quot; | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname &quot;$ac_file&quot;) 2&gt;/dev/null ||
+$as_expr X&quot;$ac_file&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X&quot;$ac_file&quot; : 'X\(//\)[^/]' \| \
+	 X&quot;$ac_file&quot; : 'X\(//\)$' \| \
+	 X&quot;$ac_file&quot; : 'X\(/\)' \| \
+	 .     : '\(.\)' 2&gt;/dev/null ||
+echo X&quot;$ac_file&quot; |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p &quot;$ac_dir&quot;
+  else
+    as_dir=&quot;$ac_dir&quot;
+    as_dirs=
+    while test ! -d &quot;$as_dir&quot;; do
+      as_dirs=&quot;$as_dir $as_dirs&quot;
+      as_dir=`(dirname &quot;$as_dir&quot;) 2&gt;/dev/null ||
+$as_expr X&quot;$as_dir&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X&quot;$as_dir&quot; : 'X\(//\)[^/]' \| \
+	 X&quot;$as_dir&quot; : 'X\(//\)$' \| \
+	 X&quot;$as_dir&quot; : 'X\(/\)' \| \
+	 .     : '\(.\)' 2&gt;/dev/null ||
+echo X&quot;$as_dir&quot; |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n &quot;$as_dirs&quot; || mkdir $as_dirs
+  fi || { { echo &quot;$as_me:$LINENO: error: cannot create directory \&quot;$ac_dir\&quot;&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot create directory \&quot;$ac_dir\&quot;&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test &quot;$ac_dir&quot; != .; then
+  ac_dir_suffix=/`echo &quot;$ac_dir&quot; | sed 's,^\.[\\/],,'`
+  # A &quot;../&quot; for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo &quot;$ac_dir_suffix&quot; | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z &quot;$ac_top_builddir&quot;; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo &amp;&amp; pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir=&quot;$ac_dir&quot;;;
+*)
+  case &quot;$ac_dir&quot; in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir=&quot;$ac_dir&quot;;;
+  *) ac_abs_builddir=`pwd`/&quot;$ac_dir&quot;;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x&quot;$ac_file&quot; != x-; then
+    { echo &quot;$as_me:$LINENO: creating $ac_file&quot; &gt;&amp;5
+echo &quot;$as_me: creating $ac_file&quot; &gt;&amp;6;}
+    rm -f &quot;$ac_file&quot;
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x&quot;$ac_file&quot; = x-; then
+    configure_input=
+  else
+    configure_input=&quot;$ac_file.  &quot;
+  fi
+  configure_input=$configure_input&quot;Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure.&quot;
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f &quot;$f&quot; || { { echo &quot;$as_me:$LINENO: error: cannot find input file: $f&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot find input file: $f&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+	 echo &quot;$f&quot;;;
+      *) # Relative
+	 if test -f &quot;$f&quot;; then
+	   # Build tree
+	   echo &quot;$f&quot;
+	 elif test -f &quot;$srcdir/$f&quot;; then
+	   # Source tree
+	   echo &quot;$srcdir/$f&quot;
+	 else
+	   # /dev/null tree
+	   { { echo &quot;$as_me:$LINENO: error: cannot find input file: $f&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot find input file: $f&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;_ACEOF
+  sed &quot;$ac_vpsub
+$extrasub
+_ACEOF
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at configure_input</A>@,$configure_input,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at srcdir</A>@,$ac_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at abs_srcdir</A>@,$ac_abs_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at top_srcdir</A>@,$ac_top_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at abs_top_srcdir</A>@,$ac_abs_top_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at builddir</A>@,$ac_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at abs_builddir</A>@,$ac_abs_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at top_builddir</A>@,$ac_top_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at abs_top_builddir</A>@,$ac_abs_top_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at INSTALL</A>@,$ac_INSTALL,;t t
+&quot; $ac_file_inputs | (eval &quot;$ac_sed_cmds&quot;) &gt;$tmp/out
+  rm -f $tmp/stdin
+  if test x&quot;$ac_file&quot; != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test &quot;$no_create&quot; != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test &quot;$silent&quot; = yes &amp;&amp;
+    ac_config_status_args=&quot;$ac_config_status_args --quiet&quot;
+  exec 5&gt;/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5&gt;&gt;config.log
+  # Use ||, not &amp;&amp;, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
diff --git a/nxcompshad/configure.in b/nxcompshad/configure.in
new file mode 100644
index 0000000..3f16ee9
--- /dev/null
+++ b/nxcompshad/configure.in
@@ -0,0 +1,287 @@
+dnl Process this file with autoconf to produce a configure script.
+
+dnl Prolog
+
+AC_INIT(Shadow.h)
+AC_PREREQ(2.13)
+
+dnl Reset default compilation flags.
+
+CXXFLAGS=&quot;-O3&quot;
+CPPFLAGS=&quot;-O3&quot;
+
+dnl Reset default linking directives.
+
+LIBSTATIC=&quot;&quot;
+LIBSHARED=&quot;&quot;
+
+dnl Prefer headers and libraries from nx-X11, if present.
+
+if test -d &quot;../nx-X11/exports/include&quot; ; then
+    CXXFLAGS=&quot;$CXXFLAGS -I../nx-X11/exports/include&quot;
+    LIBS=&quot;$LIBS -L../nx-X11/exports/lib&quot;
+fi
+
+dnl Check whether --with-ipaq was given.
+
+if test &quot;${with_ipaq}&quot; = yes; then
+  echo -e &quot;enabling IPAQ configuration&quot;
+  CXX=&quot;arm-linux-c++&quot;
+  CC=&quot;arm-linux-gcc&quot;
+  unset ac_cv_prog_armcxx
+  unset ac_cv_prog_armcc
+  unset ac_cv_prog_CXXCPP
+  AC_CHECK_PROG([armcxx],[&quot;$CXX&quot;],[yes],[no],[$PATH])
+  AC_CHECK_PROG([armcc],[&quot;$CC&quot;],[yes],[no],[$PATH])
+  if test $armcxx = &quot;yes&quot; &amp;&amp; test $armcc = &quot;yes&quot; ; then
+    ac_cv_prog_CXX=&quot;$CXX&quot;
+    ac_cv_prog_CC=&quot;$CC&quot;
+  else
+    AC_MSG_ERROR(installation or configuration problem: I cannot find compiler for arm-linux)
+  fi
+else
+  unset ac_cv_prog_CXX
+  unset ac_cv_prog_CC
+  unset ac_cv_prog_CXXCPP
+fi  
+
+dnl Check for programs.
+
+AC_PROG_CXX
+AC_PROG_CC
+AC_LANG_CPLUSPLUS
+
+dnl Check whether option -Wno-deprecated
+dnl is needed by GCC compiler.
+
+AC_MSG_CHECKING([whether compiler needs -Wno-deprecated])
+gcc_version=`${CC} --version | grep 'gcc (GCC) [[3-4]].' | head -n 1`
+case &quot;${gcc_version}&quot; in
+     gcc*)
+        AC_MSG_RESULT([yes])
+        CXXFLAGS=&quot;$CXXFLAGS -Wno-deprecated&quot;
+        CPPFLAGS=&quot;$CPPFLAGS -Wno-deprecated&quot;
+        ;;
+
+     *)
+        AC_MSG_RESULT([no])
+        ;;
+esac
+
+AC_MSG_CHECKING([whether compiler accepts -Wmissing-declarations and -Wnested-externs])
+gcc_version=`${CC} --version | grep 'gcc (GCC) [[3-4]].' | head -n 1`
+case &quot;${gcc_version}&quot; in
+     gcc*)
+        AC_MSG_RESULT([no])
+        ;;
+
+     *)
+        AC_MSG_RESULT([yes])
+        CXXFLAGS=&quot;$CXXFLAGS -Wmissing-declarations -Wnested-externs&quot;
+        CPPFLAGS=&quot;$CPPFLAGS -Wmissing-declarations -Wnested-externs&quot;
+        ;;
+esac
+
+dnl Check for BSD compatible install.
+
+AC_PROG_INSTALL
+
+dnl Check for extra header files.
+
+AC_PATH_XTRA
+
+dnl Custom addition.
+
+ac_help=&quot;$ac_help
+  --with-symbols          give -g flag to compiler to produce debug symbols
+  --with-info             define INFO at compile time to get basic log output
+  --with-valgrind         clean up allocated buffers to avoid valgrind warnings
+  --with-version          use this version for produced libraries
+
+  --with-static-jpeg      enable static linking of JPEG library
+  --with-static-z         enable static linking of Z library&quot;
+
+dnl Check to see if we're running under Cygwin32.
+
+AC_DEFUN(nxconf_CYGWIN32,
+[AC_CACHE_CHECK(for Cygwin32 environment, nxconf_cv_cygwin32,
+[AC_TRY_COMPILE(,[return __CYGWIN32__;],
+nxconf_cv_cygwin32=yes, nxconf_cv_cygwin32=no)
+rm -f conftest*])
+CYGWIN32=
+test &quot;$nxconf_cv_cygwin32&quot; = yes &amp;&amp; CYGWIN32=yes])
+nxconf_CYGWIN32
+
+dnl Cygwin32 requires the stdc++ library explicitly linked.
+
+if test &quot;$CYGWIN32&quot; = yes; then
+    LIBS=&quot;$LIBS -lstdc++ -lcygipc -lgdi32&quot;
+fi
+
+dnl Check for Darwin environment.
+
+AC_DEFUN(nxconf_DARWIN,
+[AC_CACHE_CHECK(for Darwin environment, nxconf_cv_darwin,
+[AC_TRY_COMPILE(,[return __APPLE__;],
+nxconf_cv_darwin=yes, nxconf_cv_darwin=no)
+rm -f conftest*])
+DARWIN=
+test &quot;$nxconf_cv_darwin&quot; = yes &amp;&amp; DARWIN=yes])
+nxconf_DARWIN
+
+dnl Check to see if we're running under Solaris.
+
+AC_DEFUN(nxconf_SUN,
+[AC_CACHE_CHECK(for Solaris environment, nxconf_cv_sun,
+[AC_TRY_COMPILE(,[return __sun;],
+nxconf_cv_sun=yes, nxconf_cv_sun=no)
+rm -f conftest*])
+SUN=
+test &quot;$nxconf_cv_sun&quot; = yes &amp;&amp; SUN=yes])
+nxconf_SUN
+
+dnl Check to see if we're running under FreeBSD.
+
+AC_DEFUN(nxconf_FreeBSD,
+[AC_CACHE_CHECK(for FreeBSD environment, nxconf_cv_freebsd,
+[AC_TRY_COMPILE(,[return __FreeBSD__;],
+nxconf_cv_freebsd=yes, nxconf_cv_freebsd=no)
+rm -f conftest*])
+FreeBSD=
+test &quot;$nxconf_cv_freebsd&quot; = yes &amp;&amp; FreeBSD=yes])
+nxconf_FreeBSD
+
+dnl Build PIC libraries.
+
+if test &quot;$CYGWIN32&quot; != yes -a &quot;$DARWIN&quot; != yes; then
+  CXXFLAGS=&quot;$CXXFLAGS -fPIC&quot;
+  CFLAGS=&quot;$CFLAGS -fPIC&quot;
+fi
+
+dnl Solaris requires the socket and gcc_s libs explicitly linked.
+dnl Note also that headers from default /usr/openwin/include/X11
+dnl cause a warning due to pragma in Xmd.h.
+
+if test &quot;$SUN&quot; = yes; then
+  LIBS=&quot;$LIBS  -L/usr/sfw/lib -lsocket &quot;
+  CXXFLAGS=&quot;$CXXFLAGS -I/usr/sfw/include&quot;
+fi
+
+dnl On FreeBSD search libraries and includes under /usr/local.
+
+if test &quot;$FreeBSD&quot; = yes; then
+  LIBS=&quot;$LIBS  -L/usr/local/lib&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -I/usr/local/include&quot;
+fi
+
+dnl Under Darwin we don't have support for -soname option and
+dnl we need the -bundle flag. Under Solaris, instead, we need
+dnl the options -G -h.
+
+if test &quot;$DARWIN&quot; = yes; then
+  LDFLAGS=&quot;$LDFLAGS -bundle&quot;
+elif test &quot;$SUN&quot; = yes; then
+  LDFLAGS=&quot;$LDFLAGS -G -h \$(LIBLOAD)&quot;
+else
+  LDFLAGS=&quot;$LDFLAGS -Wl,-soname,\$(LIBLOAD)&quot;
+fi
+
+dnl Check to see if in_addr_t is defined.
+dnl Could use a specific configure test.
+
+AC_DEFUN(nxconf_INADDRT,
+[AC_CACHE_CHECK(for in_addr_t, nxconf_cv_inaddrt,
+[AC_TRY_COMPILE([#include &lt;netinet/in.h&gt;],[in_addr_t t; t = 1; return t;],
+nxconf_cv_inaddrt=yes, nxconf_cv_inaddrt=no)
+rm -f conftest*])
+INADDRT=
+test &quot;$nxconf_cv_inaddrt&quot; = yes &amp;&amp; INADDRT=yes])
+nxconf_INADDRT
+
+dnl If in_addr_t is not defined use unsigned int.
+
+if test &quot;$INADDRT&quot; != yes ; then
+  echo -e &quot;using unsigned int for type in_addr_t&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DIN_ADDR_T=unsigned&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DIN_ADDR_T=unsigned&quot;
+else
+  CXXFLAGS=&quot;$CXXFLAGS -DIN_ADDR_T=in_addr_t&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DIN_ADDR_T=in_addr_t&quot;
+fi
+
+dnl Check whether --with-version was given.
+
+AC_SUBST(LIBVERSION)
+AC_SUBST(VERSION)
+if test &quot;${with_version}&quot; = yes; then
+  VERSION=${ac_option}
+else
+  VERSION=`cat VERSION`
+fi
+echo -e &quot;compiling version ${VERSION}&quot;
+
+LIBVERSION=`echo ${VERSION} | cut -d '.' -f 1`
+
+CXXFLAGS=&quot;$CXXFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+CPPFLAGS=&quot;$CPPFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+
+dnl Finally compose the LIB variable.
+
+if test &quot;$DARWIN&quot; = yes ; then
+  LIBS=&quot;$LIBS $LIBSTATIC $LIBSHARED&quot;
+elif test &quot;$SUN&quot; = yes ; then
+  LIBS=&quot;$LIBS $LIBSTATIC $LIBSHARED&quot;
+else
+  LIBS=&quot;$LIBS $LIBSTATIC -shared $LIBSHARED&quot;
+fi
+
+dnl Check whether --with-symbols or --without-symbols was
+dnl given and set the required optimization level.
+
+if test &quot;${with_symbols}&quot; = yes; then
+  echo -e &quot;enabling production of debug symbols&quot;
+  CXXFLAGS=&quot;-g $CXXFLAGS&quot;
+  CPPFLAGS=&quot;-g $CPPFLAGS&quot;
+else
+  echo -e &quot;disabling production of debug symbols&quot;
+fi
+
+dnl Check whether --with-info or --without-info was given.
+
+if test &quot;${with_info}&quot; = yes; then
+  echo -e &quot;enabling info output in the log file&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DINFO&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DINFO&quot;
+else
+  echo -e &quot;disabling info output in the log file&quot;
+fi
+
+dnl Check whether --with-valgrind or --without-valgrind was given.
+
+if test &quot;${with_valgrind}&quot; = yes; then
+  echo -e &quot;enabling valgrind memory checker workarounds&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DVALGRIND&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DVALGRIND&quot;
+else
+  echo -e &quot;disabling valgrind memory checker workarounds&quot;
+fi
+
+dnl Find makedepend somewhere.
+
+AC_SUBST(MAKEDEPEND)
+
+if test -x &quot;../nx-X11/config/makedepend/makedepend&quot; ; then
+  MAKEDEPEND=../nx-X11/config/makedepend/makedepend
+else
+  if test -x &quot;/usr/X11R6/bin/makedepend&quot; ; then
+    MAKEDEPEND=/usr/X11R6/bin/makedepend
+  else
+    if test -x &quot;/usr/openwin/bin/makedepend&quot; ; then
+      MAKEDEPEND=/usr/openwin/bin/makedepend
+    else
+      MAKEDEPEND=makedepend
+    fi
+  fi
+fi
+
+AC_OUTPUT(Makefile)
diff --git a/nxcomp/install-sh b/nxcompshad/install-sh
similarity index 100%
copy from nxcomp/install-sh
copy to nxcompshad/install-sh


hooks/post-receive
-- 
nx-libs.git (NX (redistributed))

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;nx-libs.git&quot; (NX (redistributed)).

</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011771.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	redist-client/3.5.0.20-14-g2a41a2c
</A></li>
	<LI>Next message: <A HREF="011799.html">[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxproxy/3.5.0-1-78-g65f882e
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11779">[ date ]</a>
              <a href="thread.html#11779">[ thread ]</a>
              <a href="subject.html#11779">[ subject ]</a>
              <a href="author.html#11779">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2Go-commits
mailing list</a><br>
</body></html>
