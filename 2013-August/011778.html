<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxcompshad/3.1.0-2
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2013-August/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-baikal%20%28branch%29%20updated%3A%0A%09nxcompshad/3.1.0-2&In-Reply-To=%3C20130830142402.11F665DB24%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011737.html">
   <LINK REL="Next"  HREF="011699.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxcompshad/3.1.0-2</H1>
    <B>X2Go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-baikal%20%28branch%29%20updated%3A%0A%09nxcompshad/3.1.0-2&In-Reply-To=%3C20130830142402.11F665DB24%40ymir%3E"
       TITLE="[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxcompshad/3.1.0-2">git-admin at x2go.org
       </A><BR>
    <I>Fri Aug 30 16:24:01 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="011737.html">[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxcompext/3.3.0-2
</A></li>
        <LI>Next message: <A HREF="011699.html">[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxproxy/3.1.0-2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11778">[ date ]</a>
              <a href="thread.html#11778">[ thread ]</a>
              <a href="subject.html#11778">[ subject ]</a>
              <a href="author.html#11778">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, build-baikal has been updated
  discards  88dace9a99687840f3fb341f0316cd94399cae9e (commit)
  discards  9573b5669d4811862d24acde6a5db4db68e92b76 (commit)
  discards  9ea0691391b9dda7f205ec2cc5acf531d2b427d1 (commit)
  discards  f2f6dab87b8a2c066c5eb242ca73b85f2796a5c0 (commit)
  discards  abf03fd2c05cbbf24cd9c40e81684706c258ea63 (commit)
  discards  4ad13f4ef6bfd430432b928e72686e2ae995d175 (commit)
  discards  42e72ef5f513977227328efba9482225b643697a (commit)
       via  8fa612d1a931096ff57c9b90df0f13e6cd638da8 (commit)

This update added new revisions after undoing existing revisions.  That is
to say, the old revision is not a strict subset of the new revision.  This
situation occurs when you --force push a change and generate a repository
containing something like this:

 * -- * -- B -- O -- O -- O (88dace9a99687840f3fb341f0316cd94399cae9e)
            \
             N -- N -- N (8fa612d1a931096ff57c9b90df0f13e6cd638da8)

When this happens we assume that you've already had alert emails for all
of the O revisions, and so we here report only the revisions in the N
branch from the common base, B.

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
-----------------------------------------------------------------------

Summary of changes:
 nxcompext/Alpha.c                           |   42 -
 nxcompext/Alpha.h                           |   37 -
 nxcompext/Bitmap.c                          |  112 -
 nxcompext/Bitmap.h                          |   36 -
 nxcompext/CHANGELOG                         |  806 -----
 nxcompext/Clean.c                           |  341 --
 nxcompext/Colormap.c                        |   42 -
 nxcompext/Colormap.h                        |   37 -
 nxcompext/Jpeg.c                            |  472 ---
 nxcompext/Jpeg.h                            |   38 -
 nxcompext/Makefile.in                       |  162 -
 nxcompext/Mask.c                            |  794 -----
 nxcompext/Mask.h                            |   40 -
 nxcompext/NXlib.c                           | 4770 ---------------------------
 nxcompext/NXlib.h                           |  904 -----
 nxcompext/Pgn.c                             |  722 ----
 nxcompext/Pgn.h                             |   68 -
 nxcompext/README                            |   15 -
 nxcompext/Rgb.c                             |   43 -
 nxcompext/Rle.c                             |   43 -
 nxcompext/Rle.h                             |   36 -
 nxcompext/VERSION                           |    1 -
 nxcompext/Z.c                               |  301 --
 nxcompext/Z.h                               |   52 -
 nxcompext/configure.in                      |  249 --
 nxcompext/mkinstalldirs                     |   34 -
 nxcompshad/CHANGELOG                        |  329 ++
 {nxcompext =&gt; nxcompshad}/COPYING           |    0
 nxcompshad/Core.cpp                         |  598 ++++
 nxcompshad/Core.h                           |  200 ++
 nxcompshad/Input.cpp                        |  167 +
 nxcompshad/Input.h                          |   91 +
 {nxcompext =&gt; nxcompshad}/LICENSE           |    5 +-
 nxcompshad/Logger.cpp                       |  116 +
 nxcompshad/Logger.h                         |  159 +
 nxcompshad/Makefile.in                      |  192 ++
 nxcompshad/Manager.cpp                      |  252 ++
 nxcompshad/Manager.h                        |  115 +
 nxcompext/Rgb.h =&gt; nxcompshad/Misc.h        |   40 +-
 nxcompext/NXlibint.h =&gt; nxcompshad/Poller.h |   24 +-
 nxcompext/Clean.h =&gt; nxcompshad/Regions.h   |   35 +-
 nxcompshad/Shadow.cpp                       |  439 +++
 nxcompshad/Shadow.h                         |   95 +
 nxcompshad/Updater.cpp                      |  383 +++
 nxcompshad/Updater.h                        |   95 +
 nxcompshad/VERSION                          |    1 +
 nxcompshad/Win.cpp                          | 1130 +++++++
 nxcompshad/Win.h                            |  223 ++
 nxcompshad/X11.cpp                          |  720 ++++
 nxcompshad/X11.h                            |  101 +
 {nxcompext =&gt; nxcompshad}/configure         |  382 ++-
 nxcompshad/configure.in                     |  287 ++
 {nxcompext =&gt; nxcompshad}/install-sh        |    0
 53 files changed, 6018 insertions(+), 10358 deletions(-)
 delete mode 100644 nxcompext/Alpha.c
 delete mode 100644 nxcompext/Alpha.h
 delete mode 100644 nxcompext/Bitmap.c
 delete mode 100644 nxcompext/Bitmap.h
 delete mode 100644 nxcompext/CHANGELOG
 delete mode 100644 nxcompext/Clean.c
 delete mode 100644 nxcompext/Colormap.c
 delete mode 100644 nxcompext/Colormap.h
 delete mode 100644 nxcompext/Jpeg.c
 delete mode 100644 nxcompext/Jpeg.h
 delete mode 100644 nxcompext/Makefile.in
 delete mode 100644 nxcompext/Mask.c
 delete mode 100644 nxcompext/Mask.h
 delete mode 100644 nxcompext/NXlib.c
 delete mode 100644 nxcompext/NXlib.h
 delete mode 100644 nxcompext/Pgn.c
 delete mode 100644 nxcompext/Pgn.h
 delete mode 100644 nxcompext/README
 delete mode 100644 nxcompext/Rgb.c
 delete mode 100644 nxcompext/Rle.c
 delete mode 100644 nxcompext/Rle.h
 delete mode 100644 nxcompext/VERSION
 delete mode 100644 nxcompext/Z.c
 delete mode 100644 nxcompext/Z.h
 delete mode 100644 nxcompext/configure.in
 delete mode 100755 nxcompext/mkinstalldirs
 create mode 100644 nxcompshad/CHANGELOG
 rename {nxcompext =&gt; nxcompshad}/COPYING (100%)
 create mode 100644 nxcompshad/Core.cpp
 create mode 100644 nxcompshad/Core.h
 create mode 100644 nxcompshad/Input.cpp
 create mode 100644 nxcompshad/Input.h
 rename {nxcompext =&gt; nxcompshad}/LICENSE (85%)
 create mode 100644 nxcompshad/Logger.cpp
 create mode 100644 nxcompshad/Logger.h
 create mode 100755 nxcompshad/Makefile.in
 create mode 100644 nxcompshad/Manager.cpp
 create mode 100644 nxcompshad/Manager.h
 rename nxcompext/Rgb.h =&gt; nxcompshad/Misc.h (68%)
 rename nxcompext/NXlibint.h =&gt; nxcompshad/Poller.h (74%)
 rename nxcompext/Clean.h =&gt; nxcompshad/Regions.h (68%)
 create mode 100644 nxcompshad/Shadow.cpp
 create mode 100644 nxcompshad/Shadow.h
 create mode 100644 nxcompshad/Updater.cpp
 create mode 100644 nxcompshad/Updater.h
 create mode 100644 nxcompshad/VERSION
 create mode 100644 nxcompshad/Win.cpp
 create mode 100644 nxcompshad/Win.h
 create mode 100644 nxcompshad/X11.cpp
 create mode 100644 nxcompshad/X11.h
 rename {nxcompext =&gt; nxcompshad}/configure (95%)
 create mode 100644 nxcompshad/configure.in
 rename {nxcompext =&gt; nxcompshad}/install-sh (100%)

The diff of changes is:
diff --git a/nxcompext/Alpha.c b/nxcompext/Alpha.c
deleted file mode 100644
index bba191f..0000000
--- a/nxcompext/Alpha.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;zlib.h&gt;
-
-#include &quot;NXlib.h&quot;
-
-#include &quot;Alpha.h&quot;
-#include &quot;Z.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-#define ALPHA_COMPRESSION_LEVEL      1
-#define ALPHA_COMPRESSION_THRESHOLD  32
-#define ALPHA_COMPRESSION_STRATEGY   Z_RLE
-
-static int alphaCompressionLevel     = ALPHA_COMPRESSION_LEVEL;
-static int alphaCompressionThreshold = ALPHA_COMPRESSION_THRESHOLD;
-static int alphaCompressionStrategy  = ALPHA_COMPRESSION_STRATEGY;
-
-char *AlphaCompressData(const char *data, unsigned int size, unsigned int *compressed_size)
-{
-  return ZCompressData(data, size, alphaCompressionThreshold, alphaCompressionLevel,
-                           alphaCompressionStrategy, compressed_size);
-}
diff --git a/nxcompext/Alpha.h b/nxcompext/Alpha.h
deleted file mode 100644
index 6ae9aee..0000000
--- a/nxcompext/Alpha.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#ifndef Alpha_H
-#define Alpha_H
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-extern char *AlphaCompressData(
-#if NeedFunctionPrototypes
-    const char*       /* data */,
-    unsigned int      /* size */,
-    unsigned int*     /* compressed_size */
-#endif
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* Alpha_H */
diff --git a/nxcompext/Bitmap.c b/nxcompext/Bitmap.c
deleted file mode 100644
index 725eaac..0000000
--- a/nxcompext/Bitmap.c
+++ /dev/null
@@ -1,112 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-
-#include &quot;NXlib.h&quot;
-
-#include &quot;Bitmap.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-char *BitmapCompressData(XImage *image, unsigned int *size)
-{
-  if (image -&gt; bits_per_pixel != 32)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******BitmapCompressData: Nothing to do with image of [%d] bpp and size [%d].\n&quot;,
-                image -&gt; bits_per_pixel, image -&gt; bytes_per_line * image -&gt; height);
-    #endif
-
-    *size = image -&gt; bytes_per_line * image -&gt; height;
-
-    return image -&gt; data;
-  }
-  else
-  {
-    /*
-     * Remove the 4th byte from the bitmap.
-     */
-
-    char *data;
-
-    char *next_src;
-    char *next_dst;
-
-    #ifdef TEST
-
-    if (image -&gt; bytes_per_line != 4 * image -&gt; width)
-    {
-      fprintf(stderr, &quot;******BitmapCompressData: PANIC! Image as [%d] bytes per line with expected [%d].\n&quot;,
-                  image -&gt; bytes_per_line, 4 * image -&gt; width);
-
-      return NULL;
-    }
-
-    #endif
-
-    *size = image -&gt; width * image -&gt; height * 3;
-
-    data = Xmalloc(*size);
-
-    if (data == NULL)
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******BitmapCompressData: PANIC! Failed to allocate [%d] bytes for the destination.\n&quot;,
-                  *size);
-      #endif
-
-      *size = image -&gt; bytes_per_line * image -&gt; height;
-
-      return image -&gt; data;
-    }
-
-    next_src = image -&gt; data;
-    next_dst = data;
-
-    if (image -&gt; byte_order == LSBFirst)
-    {
-      while (next_src &lt; image -&gt; data +
-                 image -&gt; bytes_per_line * image -&gt; height)
-      {
-        *next_dst++ = *next_src++;
-        *next_dst++ = *next_src++;
-        *next_dst++ = *next_src++;
-
-        next_src++;
-      }
-    }
-    else
-    {
-      while (next_src &lt; image -&gt; data +
-                 image -&gt; bytes_per_line * image -&gt; height)
-      {
-        next_src++;
-
-        *next_dst++ = *next_src++;
-        *next_dst++ = *next_src++;
-        *next_dst++ = *next_src++;
-      }
-    }
-
-    return data;
-  }
-}
diff --git a/nxcompext/Bitmap.h b/nxcompext/Bitmap.h
deleted file mode 100644
index 974aa42..0000000
--- a/nxcompext/Bitmap.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#ifndef Bitmap_H
-#define Bitmap_H
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-extern char *BitmapCompressData(
-#if NeedFunctionPrototypes
-    XImage*                   /* image */,
-    unsigned int*             /* compressed_size */
-#endif
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* Bitmap_H */
diff --git a/nxcompext/CHANGELOG b/nxcompext/CHANGELOG
deleted file mode 100644
index 941e9b4..0000000
--- a/nxcompext/CHANGELOG
+++ /dev/null
@@ -1,806 +0,0 @@
-ChangeLog:
-
-nxcompext-3.5.0-1
-
-- Opened the 3.5.0 branch based on nxcompext-3.4.0-1.
-
-- Updated copyright to year 2011. 
-
-nxcompext-3.4.0-1
-
-- Opened the 3.4.0 branch based on nxcompext-3.3.0-4.
-
-- Updated version number.
-
-- Updated copyright to year 2009.
-
-nxcompext-3.3.0-4
-
-- Fixed TR03G02199. The color palette allocated for encoding an image
-  having 256 colors or less was not freed.
-
-nxcompext-3.3.0-3
-
-- Now setting the correct event serial number when sending collect
-  notifies back.
-
-nxcompext-3.3.0-2
-
-- Updated VERSION.
-
-nxcompext-3.3.0-1
-
-- Opened the 3.3.0 branch based on nxcompext-3.2.0-1.
-
-nxcompext-3.2.0-1
-
-- Opened the 3.2.0 branch based on nxcompext-3.1.0-2.
-
-nxcompext-3.1.0-2
-
-- Updated file VERSION to match the current release version.
-
-nxcompext-3.1.0-1
-
-- Opened the 3.1.0 branch based on nxcompext-3.0.0-18.
-
-nxcompext-3.0.0-18
-
-- Removed the remaining debug output.
-
-nxcompext-3.0.0-17
-
-- Changed the copyright notices at the beginning of the files that
-  were referring to NXPROXY to refer to NXCOMPEXT.
-
-nxcompext-3.0.0-16
-
-- Handle the reply failure in NXGetShmemParameters().
-
-nxcompext-3.0.0-15
-
-- Separated the functionalities made available by NXQueryDisplay()
-  in three distinct functions:
-
-  NXDisplayReadable()  Query the number of bytes readable from
-                       the display connection.
-
-  NXDisplayFlushable() Query the number of the outstanding bytes
-                       to flush to the display connection.
-
-  NXDisplayCongestion() Return a value between 0 and 9 indicating
-                        the congestion level of the NX transport.
-
-- Renamed NXQueryDisplayError() to NXDisplayError().
-
-nxcompext-3.0.0-14
-
-- Removed support for Rdp, Tight and Hextile packed images encod-
-  ing since they have been made obsolete by the new NX server.
-
-- Changed the copyright attribution from Medialogic to NoMachine.
-
-nxcompext-3.0.0-13
-
-- Allocate 1024 additional bytes for the Jpeg compression, instead
-  of 512, to avoid failures on very tiny images.
-
-- Removed support for the special *PNG_JPEG* pack method.
-
-nxcompext-3.0.0-12
-
-- Implemented the NXEncodeBitmap() method. This is a very simple
-  encoder removing the 4th byte in 32 bits-per-plane images. For
-  the other pixmap depths it simply returns a pointer to the orig-
-  inal image data, saving the copy. This encoding is intended to
-  better leverage the stream compression on low bandwidth links.
-
-- Removed the quality parameter from the RGB/RLE encoding function.
-
-nxcompext-3.0.0-11
-
-- Removed the additional parameter in the call to NXTransFlush().
-
-nxcompext-3.0.0-10
-
-- Moved the _NXRDPGlyph and _NXRDPText declarations from NXlib.h
-  to NXproto.h to force fields to be CARD32.
-
-- Fixed a typo in NXSetDisplayBuffer() that could cause a double
-  free.
-
-- Fixed a compilation error with old GCC versions.
-
-- Removed the warning issued on AMD64 when compiling with the logs
-  enabled.
-
-nxcompext-3.0.0-9
-
-- Added the NXDisplayCongestion query type to NXQueryDisplay(). It
-  returns a value between 0 and 9, with 9 meaning that the link is
-  congested and no further data can be sent.
-
-- Added the NXSetDisplayBuffer() function. It allows the caller to
-  set the display output buffer size at runtime.
-
-- Removed the congestion and synchronization callbacks.
-
-nxcompext-3.0.0-8
-
-- Removed the warnings issued when purging the collected data at
-  display reset.
-
-nxcompext-3.0.0-7
-
-- Added the NXSetDisplayWriteHandler() interface. The function
-  registers a callback that will be invoked every time more data
-  is written to the display socket.
-
-nxcompext-3.0.0-6
-
-- Made NXQueryDisplay() take into account the bytes in the display
-  buffer when queried for the bytes flushable.
-
-nxcompext-3.0.0-5
-
-- Added file COPYING.
-
-nxcompext-3.0.0-4
-
-- Updated copyright notices to the current year.
-
-nxcompext-3.0.0-3
-
-- Imported changes up to nxcompext-2.1.0-4.
-
-- Fixed TR12D01564. Changed configure script to build library with
-  -fPIC option.
-
-- Added 256 byte to the size of Jpeg destination buffer. 
-
-nxcompext-3.0.0-2
-
-- Updated the file VERSION.
-
-nxcompext-3.0.0-1
-
-- Opened the 3.0.0 branch based on nxcompext-2.0.0-33.
-
-nxcompext-2.0.0-33
-
-- Placed the inclusion of jpeglib.h after the X includes to fix a
-  possible compilation error.
-
-nxcompext-2.0.0-32
-
-- Avoid to copy the data to the scratch buffer and yield the task
-  of padding the output to _XSend() in the NXPutPackedImage(), NX-
-  SetUnpackAlpha() and NXSetUnpackColormap() requests.
-
-- Added support for the RLE pack method.
-
-nxcompext-2.0.0-31
-
-- The X_NXSetUnpackColormap and X_NXSetUnpackAlpha now carry their
-  data in compressed form. The alpha data is compressed using the
-  ZLIB RLE encoding, while the colormap data is compressed using
-  the default ZLIB deflate.
-
-- Created new message structures to handle the compatibility with
-  the old proxy versions. When connected to an old proxy version
-  the agent should use the NXSetUnpackColormapCompat() and NXSet-
-  UnpackAlpha() interfaces.
-
-nxcompext-2.0.0-30
-
-- Removed the unfriendly warning printed if a client tried to reset
-  the library multiple times.
-
-nxcompext-2.0.0-29
-
-- Made possible to compile even if makedepend is not found.
-
-nxcompext-2.0.0-28
-
-- Added the NXSetDisplaySynchronizationHandler() interface. The NX
-  transport will use the callback to report when the agent can use
-  the available bandwidth to synchronize the X objects that are
-  corrupted or incomplete.
-
-- Bytes from 14 to 24 in the NXGetControlParameters() reply report,
-  respectively, the frame timeout, the ping timeout, the preferred
-  image split mode and the split size threshold.
-
-nxcompext-2.0.0-27
-
-- Changed the image cleanup functions and the Png and Jpeg encoders
-  to be independent from the host endianess.
-
-- Enabled again the image cleanup on big endian machines.
-
-nxcompext-2.0.0-26
-
-- Added the NXAbortSplit() request.
-
-- Added information about the size of the shared memory segment used
-  by the remote proxy in the NXGetShmemParameters() reply.
-
-nxcompext-2.0.0-25
-
-- Renamed the NXGetSplitResource() and NXGetUnpackResource() utili-
-  ties to NXAllocSplit() and NXAllocUnpack(). They can be called
-  with a NXAnyResource parameter to get the first available id or
-  requre a specific resource. From this version the resource must
-  be explicitly reserved. NXFreeUnpack() and NXFreeSplit() check
-  if the resource was allocated and don't do anything if it is not
-  the case. NXAllocSplit() and NXAllocUnpack() return NXNoResource
-  if the resource can't be reserved.
-
-nxcompext-2.0.0-24
-
-- NXFlushDisplay() now verifies whether the XlibDisplayWriting flag
-  is set before flushing the display buffer. in this case, it only
-  flushes the NX link.
-
-nxcompext-2.0.0-23
-
-- Implemented a move-to-front strategy for the image cache, to mi-
-  nimize the number of lookups.
-
-- Fixed the problems imtroduced by the new cache implementation by
-  modifying the memory allocation routines in Jpeg.c and Pgn.c.
-
-- Temporarily fixed the cleanup problems on big-endian machines by
-  skipping the operation.
-
-- Added a NXSetDisplayStatisticsHandler() to let the agent include
-  arbitrary data in the transport statistics. The parameter is a
-  pointer to a pointer to a null terminated string. The pointer is
-  set at the time the handler is registered. The pointed string can
-  be filled by the agent with its statistics data.
-
-nxcompext-2.0.0-22
-
-- The NXCacheFindImage() returns a pointer to the checksum, if the
-  image is found.
-
-- The image cache uses the data passed to NXCacheAddImage() instead
-  of making a copy.
-
-- The Z stream used by the RGB encoder is allocated at initializat-
-  ion and freed at reset.
-
-nxcompext-2.0.0-21
-
-- Removed the reliance on the local byte order in the image cleanup
-  functions.
-
-nxcompext-2.0.0-20
-
-- Added the NXFinishSplit() request. It forces the proxy to comple-
-  tely transfer all the split messages for the given resource, and
-  then notify the agent.
-
-nxcompext-2.0.0-19
-
-- Enabled again the cleanup of images.
-
-- Updated to comply with the new NXTransFlush() interface.
-
-nxcompext-2.0.0-18
-
-- Moved all the declarations in Rgb.c at the beginning of the block
-  to avoid the possible compilation errors with old compilers.
-
-nxcompext-2.0.0-17
-
-- Added a new RGB image encoder. For now the encoder uses a static
-  Z stream to compress the image data in the destination buffer and
-  allows the agent to use the simplest encoding by still separating
-  the alpha channel from the image data. The new encoder can be the
-  the base for implementing color reduction by dithering or a color-
-  mapped translation of the image similar to PNG, but without the
-  PNG overhead and with the colormap being sent to the client using
-  the NXSetUnpackColormap() opcode.
-
-- Created a new NXCleanImage() function that takes a XImage pointer
-  and uses either the CleanXYImage() or the CleanZImage() routines
-  to cleanup the padding bits.
-
-nxcompext-2.0.0-16
-
-- Added a parameter to NXFlushDisplay() to specify what needs to be
-  flushed. The parameter can be one the following values, defined
-  in NXvars.h:
-
-  NXFlushBuffer   Only the Xlib buffer is to be flushed.
-
-  NXFlushLink     Flush both the Xlib buffer and any pending
-                  data encoded by the NX transport.
-
-  NXFlushIdle     Inform the NX transport that the agent is
-                  idle. This will let the NX transport encode
-                  more low-priority data, and then flush the
-                  link.
-
-- Ensured that the padding bytes are cleaned when creating a new
-  PNG image. It seems that some images are still missed. This is
-  to be investigated.
-
-nxcompext-2.0.0-15
-
-- Ensured that the packed image cache is recreated only on a size
-  change.
-
-nxcompext-2.0.0-14
-
-- Updated to get the karma delay field from the X_NXGetControlPara-
-  meters reply.
-
-nxcompext-2.0.0-13
-
-- Added the NXSetDisplayPolicy() and NXSetDisplayFlushHandler() in-
-  terfaces. The second function registers a callback that will be
-  invoked by the NX transport when the number of bytes encoded by
-  the proxy exceeds the threshold set for the scheduled write.
-
-- Added the NXFlushDisplay() and NXQueryDisplay() interfaces. They
-  are used to hide the corresponding NX transport functions to the
-  application. NXQueryDisplay() can be called with the NXDisplay-
-  Flushable or NXDisplayReadable parameters, to get, repectively,
-  the number of bytes that are queued to the NX transport and the
-  number of bytes that is possible to read.
-
-- Included the remote proxy version in the NXGetControlParameter()
-  reply.
-
-nxcompext-2.0.0-12
-
-- Added the NXGetSplitResource() and NXGetUnpackResource utilities.
-  These can be used by the client to find out the first unused id
-  available for a split or unpack operation.
-
-- Added the NXFreeSplit() request function. It makes the resource
-  available for the next operation and tells the proxy to destroy
-  all the storage associated to the split.
-
-- Renamed the NXNumberOfConnections constant to NXNumberOfResources.
-
-nxcompext-2.0.0-11
-
-- Changed NXForceDisplayError() to also shut down the NX transport
-  by calling NXTransClose().
-
-- Updated to comply with the new NX function prototypes introduced
-  in nxcomp-2.0.0-31.
-
-nxcompext-2.0.0-10
-
-- NXQueryDisplayError() now checks the predicate function only if
-  the I/O error was not encountered already.
-
-nxcompext-2.0.0-9
-
-- Added the NXSetDisplayErrorPredicate(), NXSetDisplayBlockHand-
-  ler(), NXSetDisplayCongestionHandler(), NXSetLostSequenceHand-
-  ler() interfaces to let the user set the values used internal-
-  ly. All functions return the previous handler. See ChangeLog
-  in nx-X11-2.0.0-16 and nx-X11-2.0.0-17.
-
-- Moved all the internal variables shared between Xlib, nxcompext
-  and the X server in nxcomp. Declarations and function prototypes
-  moved to NXvars.h.
-
-- Some name changes. In particular the NXContinueOnDisplayError()
-  function iss renamed NXHandleDisplayError() and NXDisplayError()
-  is now renamed NXQueryDisplayError(). To verify if the display
-  is valid, NXQueryDisplayError() will now call the _NXDisplayEr-
-  rorPredicate function, or, if the predicate function is not set,
-  will simply check the value of the XlibDisplayIOError flag.
-
-- Removed the NXGetCleanupParameters() and NXGetImageParameters()
-  interfaces and the remaining references to the unused display
-  buffer and image cleanup functions.
-
-- Updated the NoMachine copyright notice to year 2006.
-
-nxcompext-2.0.0-8
-
-- Removed the unused screen parameter from XSetUnpackGeometry().
-
-- NXSetUnpackGeometry() now fails if no visual is provided.
-
-nxcompext-2.0.0-7
-
-- Changed the LICENSE file to state that the software is only made
-  available under the version 2 of the GPL.
-
-- Removed the misplaced DXPC copyright notices from the license.
-  They were copied from NXCOMP but they don't apply in any way to
-  NXCOMPEXT.
-
-nxcompext-2.0.0-6
-
-- Added the NXSetCacheParameters() request. It tells to the local
-  proxy how to handle the X requests, namely if the next requests
-  have to be stored in the memory cache, split in smal data chunks,
-  and in the case of images, saved on disk in the persistent image
-  cache. The request will affect all X messages, including plain
-  and packed images. It can be used to tell the proxy to discard
-  images coming from some selected operations, like GLX or XVideo.
-
-nxcompext-2.0.0-5
-
-- Added the NXGetFontParameters() request and reply. If the proxy
-  has been configured accordingly, the request returns the X font
-  path that can be set by the agent to tunnel the font server con-
-  nections through the NX link.
-
-nxcompext-2.0.0-4
-
-- Initial work on font server tunneling.
-
-nxcompext-2.0.0-3
-
-- Renamed the NXSetExposeEvents request to NXSetExposeParameters.
-
-nxcompext-2.0.0-2
-
-- Modified the configure and the makefiles to support the Cygwin
-  environment.
-
-- Renamed Png.h to Pgn.h to avoid name clashes on Windows.
-
-- The distclean target now removes the autom4te.cache directory.
-
-nxcompext-2.0.0-1
-
-- Opened the 2.0.0 branch based on nxcompext-1.5.0-20.
-
-nxcompext-1.5.0-20
-
-- Removed the code installing a SIGSEGV handler before trying to
-  clean an image in NXCleanImageInPlace().
-
-nxcompext-1.5.0-19
-
-- Added the NXUnsetLibraryPath() function to specify the behaviour
-  of the Popen() in the X server. If the _NXUnsetLibraryPath flag
-  is set, the Popen() will remove the LD_LIBRARY_PATH variable from
-  the environment before running the child process. This will cause
-  the X server to run the process (for example the keyboard initia-
-  lization utilities) by using the native system libraries, instead
-  of the libraries shipped with the NX environment.
-
-nxcompext-1.5.0-18
-
-- Moved the declarations of _NXEnable* and related structures from
-  Xlibint.h to NXlibint.h.  
-
-- Use the include files from nx-X11 if the nx-X11/include directory
-  is found. The previous configure checked the presence of nx-X11/
-  exports/include, that might not be built at the time this library
-  is compiled.
-
-nxcompext-1.5.0-17
-
-- Added the -fPIC GCC flag when compiling on AMD64 architectures.
-
-- Removed all warnings when compiling with GCC4.
-
-- Small changes to configure.in to have specific CFLAGS.
-
-- Created a new configure using autoconf 2.59.
-
-nxcompext-1.5.0-16
-
-- Added the 'mode' field in the NXStartSplit() request. It determi-
-  nes the strategy that the proxy will adopt to handle the image.
-  If set to 'eager', the proxy will only split the messages whose
-  size exceeds the split threshold (the threshold can be found in
-  the NXGetControlParameters() reply). If mode is set to lazy, the
-  proxy will split any image that it is not able to find in its
-  cache.
-
-  The opcode and the two available modes are defined in NXproto.h,
-  currently:
-
-  #define NXSplitModeDefault  0
-  #define NXSplitModeEager    1
-  #define NXSplitModeLazy     2
-
-- All requests related to image streaming now carry a 'resource' id.
-  The id is currently ignored by the proxy in the case of NXCommit-
-  Split() requests.
-
-nxcompext-1.5.0-15
-
-- Removed the NXSync() and NXKarma() operations, not used anymore
-  by the NX agents.
-
-- Updated to comply with changes occurred in the numbering of the
-  notification events and in the interface to the image streaming
-  functions.
-
-nxcompext-1.5.0-14
-
-- Accounted for the missing xoffset field in clean-up of XYPixmaps.
-
-nxcompext-1.5.0-13
-
-- Added a 'commit' field in NXCommitSplit(). When zero, the remote
-  proxy will remove the message from the split store, without send-
-  ing the recomposed image to the X server.
-
-nxcompext-1.5.0-12
-
-- Added the NXContinueOnDisplayError() function to specify the be-
-  haviour of the Xlib I/O error handler. If the flag is set to true,
-  Xlib will simply return, instead of quitting the program. This
-  leaves to the application the responsibility of checking the sta-
-  te of the XlibDisplayIOError flag.
-
-- Changed NXDisplayIsValid() to NXDisplayError() and inverted the
-  logic. Now the function returns true if the display pointer is
-  NULL or the XlibDisplayIOError flag is set.
-
-- Added the NXForceDisplayError() function, to shutdown the display
-  descriptor and force Xlib to set the I/O error flag.
-
-nxcompext-1.5.0-11
-
-- Added -I../nx-X11/exports/include to CCINCLUDES in Makefile.in.
-
-nxcompext-1.5.0-10
-
-- Added FindLSB() to replace ffs() that may be not present on some
-  systems.
-
-- Some cosmetic changes.
-
-nxcompext-1.5.0-9
-
-- Fixed a printf() that prevented the code to compile if TEST was
-  enabled.
-
-nxcompext-1.5.0-8
-
-- Implemented the NXLib interface for asynchronous handling of the
-  XGetInputFocus requests and replies.
-
-nxcompext-1.5.0-7
-
-- Removed the _NXFlushSize parameter. New agents run the NX trans-
-  port in-process, so we don't get any benefit from increasing the
-  display buffer size.
-
-nxcompext-1.5.0-6
-
-- Added a NXDisplayIsValid() to check that the display is not NULL
-  and that the descriptor was not shut down after an IOError. The
-  reason a function is needed for this is that the flags field is
-  only in Xlibint and it is not visible to Xlib applications.
-
-nxcompext-1.5.0-5
-
-- Added the NXGetCollect*Resource utility functions, returning the
-  first available small integer resource id that can be used in a
-  subsequent collect request.
-
-nxcompext-1.5.0-4
-
-- Added the NXNumberOfConnections constant.
-
-nxcompext-1.5.0-3
-
-- Implemented the NXLib interface for the asynchronous handling of
-  the XGrabPointer requests and replies.
-
-- Solved an error in image cleaning that prevented the 8 bits-per-
-  pixel images to be completely cleaned. Due to the bug, only half
-  of the total lines were cleaned.
-
-- Removed a bug that prevented the cleaning of XYPixmaps images of
-  bitmap unit 32 and byte order LSB.
-
-- Renamed the NXImageCache variables to show they are global. They
-  are currently used in the nxagent code.
-
-nxcompext-1.5.0-2
-
-- Changed VERSION file.
-
-nxcompext-1.5.0-1
-
-- Opened the 1.5.0 branch.
-
-nxcompext-1.4.1-1
-
-- Removed the configure option --with-static. There are two options
-  now, --with-static-png and --with-static-jpeg, to offer a greater
-  degree of control on the resulting library.
-
-- This version differs from the 1.4.0-3-KRY1 in the way that the con-
-  figure script is generated by GNU Autoconf 2.57, the same version
-  used for nxcomp.
-
-- Opened the 1.4.1 branch.
-
-nxcompext-1.4.0-3
-
-- Updated the VERSION file to reflect the 1.4.0 status.
-
-nxcompext-1.4.0-2
-
-- Imported changes from the latest 1.3.2 development branch.
-
-- The 1.4.0 branch already had a 1.4.0-1 version. The changes from
-  the 1.4.0-1 were up to date with the 1.3.2-2 version.
-
-nxcompext-1.3.2-6
-
-- Fixed problem with icons in KDE and Mozilla on SPARC Solaris. The
-  problem was related to cleaning of one-bit XYPixmaps on big-endian
-  hosts, where shift of the cleaning mask executed in the wrong di-
-  rection.
-
-nxcompext-1.3.2-5
-
-- Changes in Clean.c to compile on Solaris.
-
-nxcompext-1.3.2-4
-
-- Fixed a bug in clean image procedures for 1bit XYPixmaps. The bug
-  caused Mozilla to trash some transparent icons in web pages and
-  the toolbar.
-
-- Added cleaning of the padding bytes at the end of the data chunk
-  inside XImage structure
-
-- Implemented handling of SIGSEGV during cleanup in case of static
-  data.
-
-- Moved image cleanup and masking code in new Clean.c and Mask.c
-  sources.
-
-- Corrected few typos in NXCollectImage code.
-
-nxcompext-1.3.2-2
-
-- Imported 1.4.0-1 changes from the 1.4.0 development branch.
-
-- Modified NXAllocColors to handle errors generated allocating
-  each requested color. A per-color result code is now returned 
-  to the caller.
-
-- Code cleanup in Png.h and Png.c.
-
-nxcompext-1.3.2-1
-
-- Opened the 1.3.2 branch.
-
-nxcompext-1.3.1-2
-
-- Removed the underline characters and added a colon in the
-  title of this ChangeLog to fully comply with format used in
-  the release notices.
-
-nxcompext-1.3.1-1
-
-- Opened the 1.3.1 branch.
-
-nxcompext-1.3.0-18
-
-- Added the _NXLostSequenceHandler function to let NX agents
-  suppress the error message and modify the default Xlib
-  behaviour when out-of-order sequence numbers are received.
-  Pointer to function is assigned to _NXLostSequenceFunction
-  in XlibInt.c.
-
-- Original output buffer size in stock XFree86 is 2048. We try
-  to reduce context switches and help stream compression by
-  increasing the maximum size of the buffer 8192. _NXFlushSize
-  determines when the display buffer is actually flushed. It is
-  set by default to 4096 in XlibInt.c and set to 0 to use the
-  maximum available size at the time NXGetControlParameters()
-  is called.
-
-nxcompext-1.3.0-17
-
-- In handling of asynchronous GetProperty replies a warning
-  message was printed in session log when a null property was
-  stored in the state structure. This message is now printed
-  only if TEST is defined.
-
-nxcompext-1.3.0-16
-
-- Added asynchronous handling of GetProperty request and reply
-  by means of the NXCollectProperty and NXGetCollectedProperty
-  requests and the NXCollectPropertyNotify event.
-
-nxcompext-1.3.0-15
-
-- Added 4 new fields to the X_NXGetControlParameters reply.
-
-nxcompext-1.3.0-14
-
-- Added request X_NXFreeUnpack to free the resources allocated
-  by the remote proxy to unpack images for the given agent's
-  client
-
-nxcompext-1.3.0-13
-
-- Modified the following requests to carry the id of the
-  agent's client in the field resource:
-
-  - X_NXSetUnpackGeometry
-  - X_NXSetUnpackColormap
-  - X_NXSetUnpackAlpha
-  - X_NXPutPackedImage
-
-nxcompext-1.3.0-11
-
-- Modified the MIT-SHM initialization procedure to always send
-  all the 3 protocol requests also in the case of early failures.
-
-nxcompext-1.3.0-10
-
-- Added handling of X_NXSetUnpackAlpha request.
-
-- It has been made possible to send both X_NXSetUnpackColormap
-  and X_NXSetUnpackAlpha messages with 0 entries to temporarily
-  disable use of the colormap or the alpha channel and free the
-  resources allocated by the remote proxy.
-
-nxcompext-1.3.0-9
-
-- Solved a compatibility problem when mixing proxy versions
-  1.2.2 and 1.3.0 due to the missing X_NXGetShmemParameters
-  request.
-
-nxcompext-1.3.0-7
-
-- Reduced the number of requests needed to setup the shared
-  segment at X server proxy from 4 to 3.
-
-- Small changes to the shared memory interface to support
-  path X agent to X client proxy.
-
-nxcompext-1.3.0-6
-
-- Implemented initial support for MIT-SHM extension in the
-  network path between the X server proxy and the real X
-  server.
-
-- Configure script now checks for the FreeBSD environment.
-
-- New configure script generated using autoconf-2.57-3.
-
-- Removed the XFree86 CCDEFINES from Makefile.in.
-
-nxcompext-1.3.0-5
-
-- Cosmetic changes.
-
-- Started to convert configure.in to the new layout adopted
-  for nxcomp.
-
-- Created file CHANGELOG.
-
-nxcompext-1.3.0-4
-
-- More fixes in image clean-up.
-
-nxcompext-1.3.0-3
-
-- Many fixes in image clean-up functions to handle differences
-  in endianess between client and X server.
-
-nxcompext-1.3.0-2
-
-- Modified configure.in to compile under Solaris.
-
-nxcompext-1.3.0-1
-
-- First 1.3.0 version based on nxcompext-1.2.2-12.
-
diff --git a/nxcompext/Clean.c b/nxcompext/Clean.c
deleted file mode 100644
index cc02200..0000000
--- a/nxcompext/Clean.c
+++ /dev/null
@@ -1,341 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;signal.h&gt;
-
-#include &quot;os.h&quot;
-
-#include &quot;NXlib.h&quot;
-
-#include &quot;Clean.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-int CleanXYImage(XImage *image)
-{
-  int i, j, k, plane;
-
-  int bitsToClean = (image -&gt; bytes_per_line &lt;&lt; 3) - image -&gt; width - image -&gt; xoffset;
-
-  unsigned int bytesToClean = bitsToClean &gt;&gt; 3;
-
-  bitsToClean &amp;= 7;
-
-  for (k = 0; k &lt; image -&gt; depth; k++)
-  {
-    plane = k * (image -&gt; bytes_per_line * image -&gt; height);
-
-    for (i = 1; i &lt;= image -&gt; height; i++)
-    {
-      if (image -&gt; byte_order == image -&gt; bitmap_bit_order)
-      {
-        for (j = 1; j &lt;= bytesToClean; j++)
-        {
-          image -&gt; data[plane + i * (image -&gt; bytes_per_line) - j] = 0x00;
-        }
-      }
-      else
-      {
-        for (j = bytesToClean; j &gt;= 1; j--)
-        {
-          image -&gt; data[plane + i * (image -&gt; bytes_per_line) - j] = 0x00;
-        }
-      }
-
-      if (image -&gt; bitmap_bit_order == MSBFirst)
-      {
-        image -&gt; data[plane + i * (image -&gt; bytes_per_line) - j] &amp;= 0xff &lt;&lt; bitsToClean;
-      }
-      else
-      {
-        image -&gt; data[plane + i * (image -&gt; bytes_per_line) - j] &amp;= 0xff &gt;&gt; bitsToClean;
-      }
-    }
-  }
-
-  return 1;
-}
-
-int CleanZImage(XImage *image)
-{
-  unsigned int bytesToClean;
-  unsigned int j;
-  unsigned int imageLength;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;*****CleanZImage: Going to clean image of [%d] bits per pixel.\n&quot;,
-              image -&gt; bits_per_pixel);
-  #endif
-
-  switch (image -&gt; bits_per_pixel)
-  {
-    case 32:
-    {
-      /*
-       * The caller should pay attention at extracting
-       * the alpha channel prior to cleaning the image.
-       * Cleaning an image which is carrying the alpha
-       * channel will result in the image being treated
-       * as fully transparent.
-       */
-
-      register int i;
-
-      bytesToClean = image -&gt; bytes_per_line * image -&gt; height;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;*****CleanZImage: Cleaning [%d] bytes with bits per pixel [%d] &quot;
-                  &quot;width [%d] bytes per line [%d] height [%d].\n&quot;, bytesToClean,
-                      image -&gt; bits_per_pixel, image -&gt; width, image -&gt;
-                          bytes_per_line, image -&gt; height);
-      #endif
-
-      if (image -&gt; byte_order == LSBFirst)
-      {
-        for (i = 3; i &lt; bytesToClean; i += 4)
-        {
-          ((unsigned char *) image -&gt; data)[i] = 0x00;
-        }
-      }
-      else
-      {
-        for (i = 0; i &lt; bytesToClean; i += 4)
-        {
-          ((unsigned char *) image -&gt; data)[i] = 0x00;
-        }
-      }
-
-      break;
-    }
-    case 24:
-    case 15:
-    case 16:
-    case 8:
-    {
-      register int i, j;
-
-      bytesToClean = image -&gt; bytes_per_line -
-                           ((image -&gt; width * image -&gt; bits_per_pixel) &gt;&gt; 3);
-
-      for (i = 1; i &lt;= image -&gt; height; i++)
-      {
-        for (j = bytesToClean; j &gt; 0; j--)
-        {
-          ((unsigned char *) image -&gt; data)[(i * image -&gt; bytes_per_line) - j] = 0x00;
-        }
-      }
-
-      break;
-    }
-    default:
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;*****CleanZImage: PANIC! Cannot clean image with [%d] bits per pixel.\n&quot;,
-                  image -&gt; bits_per_pixel);
-      #endif
-    }
-  }
-
-  /* 
-   * Clean the padding bytes at the real
-   * end of the buffer.
-   */
-
-  imageLength = image -&gt; bytes_per_line * image -&gt; height;
-
-  bytesToClean = imageLength % 4;
-
-  for (j = 0; j &lt; bytesToClean; j++)
-  {
-    ((unsigned char *)image -&gt; data)[(imageLength + j)] = 0x00;
-  }
-
-  return 1;
-}
-
-/*
- * Copy a clean version of src_image into dst_image.
- * This code is not taking care of the image format.
- * The agent doesn't use it and you have to consider
- * it unsupported.
- */
-
-int CopyAndCleanImage(XImage *src_image, XImage *dst_image)
-{
-  register long data_size;
-  register int i;
-
-  data_size = (src_image -&gt; bytes_per_line * src_image -&gt; height) &gt;&gt; 2;
-
-  #ifdef WARNING
-  fprintf(stderr, &quot;******CleanImage: WARNING! Function called with image of [%d] bits per pixel.\n&quot;,
-              src_image -&gt; bits_per_pixel);
-  #endif
-
-  switch (src_image -&gt; bits_per_pixel)
-  {
-    case 32:
-    {
-      unsigned int mask;
-
-      if (src_image -&gt; byte_order == MSBFirst)
-      {
-        mask = 0xffffff00;
-      }
-      else
-      {
-        mask = 0x00ffffff;
-      }
-      for (i = 0; i &lt; data_size; i++)
-      {
-        ((unsigned int *)dst_image -&gt; data)[i] = ((unsigned int *)src_image -&gt; data)[i] &amp; mask;
-      }
-
-      break;
-    }
-
-    case 24:
-    {
-      unsigned int bytes_to_clean;
-
-      for (i = 0; i &lt; data_size; i++)
-      {
-        ((unsigned int *)dst_image -&gt; data)[i] = ((unsigned int *)src_image -&gt; data)[i];
-      }
-
-      bytes_to_clean = dst_image -&gt; bytes_per_line - ((dst_image -&gt; width *
-                           dst_image -&gt; bits_per_pixel) &gt;&gt; 3);
-
-      if (bytes_to_clean)
-      {
-        register unsigned int mask = 0xffffffff;
-        register int line_size;
-        register int i;
-                
-        line_size = dst_image -&gt; bytes_per_line &gt;&gt; 2;
-
-        if (dst_image -&gt; byte_order == MSBFirst)
-        {
-          mask = mask &lt;&lt; (bytes_to_clean &lt;&lt; 3);
-        }
-        else
-        {
-          mask = mask &gt;&gt; (bytes_to_clean &lt;&lt; 3);
-        }
-
-        for (i = 0; i &lt; dst_image -&gt; height;)
-        {
-          ((unsigned char *)dst_image -&gt; data)[(++i * line_size) -1] &amp;= mask;
-        }
-      }
-
-      break;
-    }
-
-    case 15:
-    case 16:
-    {
-      for (i = 0; i &lt; data_size; i++)
-      {
-        ((unsigned int *) dst_image -&gt; data)[i] = ((unsigned int *) src_image -&gt; data)[i];
-      }
-
-      if (src_image -&gt; width &amp; 0x00000001)
-      {
-        int card32_per_line = dst_image -&gt; bytes_per_line &gt;&gt; 2;
-
-        for (i = 0; i &lt; dst_image -&gt; height;)
-        {
-          ((unsigned int *) dst_image -&gt; data)[(++i * card32_per_line) -1] &amp;= 0x0000ffff;
-        }
-      }
-
-      break;
-    }
-
-    case 8:
-    {
-      unsigned int mask = 0x00000000;
-
-      switch (dst_image -&gt; width % 4)
-      {
-        case 3:
-        {
-          mask = 0x00ffffff;
-
-          break;
-        }
-        case 2:
-        {
-          mask = 0x0000ffff;
-
-          break;
-        }
-        case 1:
-        {
-          mask = 0x000000ff;
-
-          break;
-        }
-        default:
-        {
-          /*
-           * Nothing to clean.
-           */
-
-          break;
-        }
-      }
-
-      for (i = 0; i &lt; data_size; i++)
-      {
-        ((unsigned int *) dst_image -&gt; data)[i] = ((unsigned int *) src_image -&gt; data)[i];
-      }
-
-      if (mask)
-      {
-        int card32_per_line;
-        int i;
-
-        card32_per_line = dst_image -&gt; bytes_per_line &gt;&gt; 2;
-
-        for (i = 0; i &lt; dst_image -&gt; height; i++)
-        {
-          ((unsigned int *) dst_image -&gt; data)[(++i * card32_per_line) -1] &amp;= mask;
-        }
-      }
-
-      break;
-    }
-
-    default:
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******CleanImage: PANIC! Cannot clean image of [%d] bits per pixel.\n&quot;,
-                  src_image -&gt; bits_per_pixel);
-      #endif
-
-      return 0;
-    }
-  }
-
-  return 1;
-}
diff --git a/nxcompext/Colormap.c b/nxcompext/Colormap.c
deleted file mode 100644
index 2e169ed..0000000
--- a/nxcompext/Colormap.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;zlib.h&gt;
-
-#include &quot;NXlib.h&quot;
-
-#include &quot;Colormap.h&quot;
-#include &quot;Z.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-#define COLORMAP_COMPRESSION_LEVEL      4
-#define COLORMAP_COMPRESSION_THRESHOLD  32
-#define COLORMAP_COMPRESSION_STRATEGY   Z_DEFAULT_STRATEGY
-
-static int colormapCompressionLevel     = COLORMAP_COMPRESSION_LEVEL;
-static int colormapCompressionThreshold = COLORMAP_COMPRESSION_THRESHOLD;
-static int colormapCompressionStrategy  = COLORMAP_COMPRESSION_STRATEGY;
-
-char *ColormapCompressData(const char *data, unsigned int size, unsigned int *compressed_size)
-{
-  return ZCompressData(data, size, colormapCompressionThreshold, colormapCompressionLevel,
-                           colormapCompressionStrategy, compressed_size);
-}
diff --git a/nxcompext/Colormap.h b/nxcompext/Colormap.h
deleted file mode 100644
index 42eff34..0000000
--- a/nxcompext/Colormap.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#ifndef Colormap_H
-#define Colormap_H
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-extern char *ColormapCompressData(
-#if NeedFunctionPrototypes
-    const char*       /* data */,
-    unsigned int      /* size */,
-    unsigned int*     /* compressed_size */
-#endif
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* Colormap_H */
diff --git a/nxcompext/Jpeg.c b/nxcompext/Jpeg.c
deleted file mode 100644
index cb854bc..0000000
--- a/nxcompext/Jpeg.c
+++ /dev/null
@@ -1,472 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &quot;X11/X.h&quot;
-#include &quot;X11/Xlib.h&quot;
-#include &quot;X11/Xmd.h&quot;
-
-#include &lt;jpeglib.h&gt;
-
-#include &quot;NXlib.h&quot;
-
-#include &quot;Mask.h&quot;
-#include &quot;Jpeg.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-#define JPEG_DEST_SIZE(width, height) ((width) * 3 * (height) + 1024)
-
-/*
- * Local function prototypes.
- */
-
-static void PrepareRowForJpeg(CARD8 *dst, int y, int count);
-static void PrepareRowForJpeg24(CARD8 *dst, int y, int count);
-static void PrepareRowForJpeg16(CARD8 *dst, int y, int count);
-static void PrepareRowForJpeg32(CARD8 *dst, int y, int count);
-
-static int JpegEmptyOutputBuffer(j_compress_ptr cinfo);
-
-static void JpegInitDestination(j_compress_ptr cinfo);
-static void JpegTermDestination(j_compress_ptr cinfo);
-static void JpegSetDstManager(j_compress_ptr cinfo);
-
-/*
- * Quality levels.
- */
-
-static int jpegQuality[10] = {20, 30, 40, 50, 55, 60, 65, 70, 75, 80};
-
-/*
- * Image characteristics.
- */
-
-static int bytesPerLine;
-
-static CARD8 bitsPerPixel;
-static CARD16 redMax, greenMax, blueMax;
-static CARD8  redShift, greenShift, blueShift;
-static int byteOrder;
-
-/*
- * Other variables used for the Jpeg
- * encoding.
- */
-
-static char *jpegBeforeBuf = NULL;
-static char *jpegCompBuf;
-static int  jpegCompBufSize;
-static int  jpegError;
-static int  jpegDstDataLen;
-
-static struct jpeg_destination_mgr jpegDstManager;
-
-/*
- * Just for debugging purpose.
- */
-
-#ifdef DEBUG
-
-static int  jpegId;
-static char jpegName[10];
-static FILE *jpegFile;
-
-#endif
-
-/*
- * Function declarations
- */
-
-char *JpegCompressData(XImage *image, int level, int *compressed_size)
-{
-  struct jpeg_compress_struct cinfo;
-  struct jpeg_error_mgr jerr;
-
-  CARD8 *srcBuf;
-  JSAMPROW rowPointer[1];
-
-  int dy, w, h;
-
-  *compressed_size = 0;
-
-  /*
-   * Initialize the image stuff
-   */
-
-  bitsPerPixel = image -&gt; bits_per_pixel;
-  bytesPerLine = image -&gt; bytes_per_line;
-  byteOrder = image -&gt; byte_order;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******JpegCompressData: Image byte order [%d] bitmap bit order [%d].\n&quot;,
-              image -&gt; byte_order, image -&gt; bitmap_bit_order);
-
-  fprintf(stderr, &quot;******JpegCompressData: Bits per pixel [%d] bytes per line [%d].\n&quot;,
-              bitsPerPixel, bytesPerLine);
-  #endif
-
-  redShift   = FindLSB(image -&gt; red_mask)   - 1;
-  greenShift = FindLSB(image -&gt; green_mask) - 1;
-  blueShift  = FindLSB(image -&gt; blue_mask)  - 1;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******JpegCompressData: Red mask [0x%lx] green mask [0x%lx] blue mask [0x%lx].\n&quot;,
-              image -&gt; red_mask, image -&gt; green_mask, image -&gt; blue_mask);
-
-  fprintf(stderr, &quot;******JpegCompressData: Red shift [%d] green shift [%d] blue shift [%d].\n&quot;,
-              redShift, greenShift, blueShift);
-  #endif
-
-  redMax   = image -&gt; red_mask   &gt;&gt; redShift;
-  greenMax = image -&gt; green_mask &gt;&gt; greenShift;
-  blueMax  = image -&gt; blue_mask  &gt;&gt; blueShift;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******JpegCompressData: Red max [0x%x] green max [0x%x] blue max [0x%x].\n&quot;,
-              redMax, greenMax, blueMax);
-  #endif
-
-  w = image -&gt; width;
-  h = image -&gt; height;
-
-  jpegBeforeBuf = image -&gt; data;
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******JpegCompressData: Width [%d] height [%d] level [%d].\n&quot;,
-              w, h, level);
-  #endif
-
-  if (bitsPerPixel == 1 ||
-          bitsPerPixel == 8)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******JpegCompressData: PANIC! Invalid bits per pixel [%d].\n&quot;,
-                bitsPerPixel);
-    #endif
-
-    return NULL;
-  }
-
-  /*
-   * Allocate space for one line of the
-   * resulting image, 3 bytes per pixel.
-   */
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******JpegCompressData: Allocating [%d] bytes for the scanline.\n&quot;,
-              w * 3);
-  #endif
-
-  srcBuf = (CARD8 *) malloc(w * 3);
-
-  if (srcBuf == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******JpegCompressData: PANIC! Cannot allocate [%d] bytes.\n&quot;,
-                w * 3);
-    #endif
-
-    return NULL;
-  }
-
-  rowPointer[0] = srcBuf;
-
-  cinfo.err = jpeg_std_error(&amp;jerr);
-
-  jpeg_create_compress(&amp;cinfo);
-
-  cinfo.image_width = w;
-  cinfo.image_height = h;
-  cinfo.input_components = 3;
-  cinfo.in_color_space = JCS_RGB;
-
-  jpeg_set_defaults(&amp;cinfo);
-  jpeg_set_quality(&amp;cinfo, jpegQuality[level], 1);
-
-  /*
-   * Allocate memory for the destination
-   * buffer.
-   */
-
-  jpegCompBufSize = JPEG_DEST_SIZE(w, h);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******JpegCompressData: Allocating [%d] bytes for the destination data.\n&quot;,
-              jpegCompBufSize);
-  #endif
-
-  jpegCompBuf = malloc(jpegCompBufSize);
-
-  if (jpegCompBuf == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******JpegCompressData: PANIC! Error allocating [%d] bytes for the Jpeg data.\n&quot;,
-                jpegCompBufSize);
-    #endif
-
-    return NULL;
-  }
-
-  JpegSetDstManager(&amp;cinfo);
-
-  jpeg_start_compress(&amp;cinfo, 1);
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******JpegCompressedData: Initialization finished.\n&quot;);
-  #endif
-
-  for (dy = 0; dy &lt; h; dy++)
-  {
-    PrepareRowForJpeg(srcBuf, dy, w);
-
-    jpeg_write_scanlines(&amp;cinfo, rowPointer, 1);
-
-    if (jpegError != 0)
-    {
-      break;
-    }
-  }
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******JpegCompressedData: Compression finished. Lines handled [%d,%d]. Error is [%d].\n&quot;,
-              dy, h, jpegError);
-  #endif
-
-  if (jpegError == 0)
-  {
-    jpeg_finish_compress(&amp;cinfo);
-  }
-
-  jpeg_destroy_compress(&amp;cinfo);
-
-  free((char *) srcBuf);
-
-  if (jpegError != 0)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******JpegCompressedData: PANIC! Compression failed. Error is [%d].\n&quot;,
-                jpegError);
-    #endif
-
-    free(jpegCompBuf);
-
-    return NULL;
-  }
-
-  /*
-   * Check the size of the resulting data.
-   */
-
-  if (jpegDstDataLen &gt; 0)
-  {
-    /*
-     * Save the image on disk to help with
-     * the debug.
-     */
-
-    #ifdef DEBUG
-
-    int i = 0;
-
-    fprintf(stderr, &quot;******JpegCompressedData: Compressed size [%d].\n&quot;,
-                jpegDstDataLen);
-
-    jpegId++;
-
-    sprintf(jpegName, &quot;jpeg%d&quot;, jpegId);
-
-    jpegFile = fopen(jpegName, &quot;w&quot;);
-
-    for (i = 0; i &lt; jpegDstDataLen; i++)
-    {
-      fprintf(jpegFile, &quot;%c&quot;, *(jpegCompBuf + i));
-    }
-
-    fclose(jpegFile);
-
-    #endif
-
-    *compressed_size = jpegDstDataLen;
-
-    return jpegCompBuf;
-  }
-  else
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******JpegCompressedData: PANIC! Invalid size of the compressed data [%d].\n&quot;,
-                jpegDstDataLen);
-    #endif
-
-    free(jpegCompBuf);
-
-    return NULL;
-  }
-}
-
-void PrepareRowForJpeg(CARD8 *dst, int y, int count)
-{
-  if (bitsPerPixel == 32)
-  {
-    if (redMax == 0xff &amp;&amp;
-            greenMax == 0xff &amp;&amp;
-                blueMax == 0xff)
-    {
-      PrepareRowForJpeg24(dst, y, count);
-    }
-    else
-    {
-      PrepareRowForJpeg32(dst, y, count);
-    }
-  }
-  else if (bitsPerPixel == 24)
-  {
-    memcpy(dst, jpegBeforeBuf + y * bytesPerLine, count * 3);
-  }
-  else
-  {
-    /*
-     * 16 bpp assumed.
-     */
-
-    PrepareRowForJpeg16(dst, y, count);
-  }
-}
-
-void PrepareRowForJpeg24(CARD8 *dst, int y, int count)
-{
-  CARD8 *fbptr;
-  CARD32 pix;
-
-  fbptr = (CARD8 *) (jpegBeforeBuf + y * bytesPerLine);
-
-  while (count--)
-  {
-    if (byteOrder == LSBFirst)
-    {
-      pix = (CARD32) *(fbptr + 2);
-      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr+1);
-      pix = (pix &lt;&lt; 8) | (CARD32) *fbptr;
-    }
-    else
-    {
-      pix = (CARD32) *(fbptr + 1);
-      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + 2);
-      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + 3);
-    }
-
-    *dst++ = (CARD8)(pix &gt;&gt; redShift);
-    *dst++ = (CARD8)(pix &gt;&gt; greenShift);
-    *dst++ = (CARD8)(pix &gt;&gt; blueShift);
-
-    fbptr+=4;
-  }
-}
-
-#define DEFINE_JPEG_GET_ROW_FUNCTION(bpp)                                   \
-                                                                            \
-void PrepareRowForJpeg##bpp(CARD8 *dst, int y, int count)                   \
-{                                                                           \
-  CARD8 *fbptr;                                                             \
-  CARD##bpp pix;                                                            \
-  int inRed, inGreen, inBlue;                                               \
-  int i;                                                                    \
-                                                                            \
-  fbptr = (CARD8 *) (jpegBeforeBuf + y * bytesPerLine);                     \
-                                                                            \
-  while (count--)                                                           \
-  {                                                                         \
-    pix = 0;                                                                \
-                                                                            \
-    if (byteOrder == LSBFirst)                                              \
-    {                                                                       \
-      for (i = (bpp &gt;&gt; 3) - 1; i &gt;= 0; i--)                                 \
-      {                                                                     \
-        pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + i);                           \
-      }                                                                     \
-    }                                                                       \
-    else                                                                    \
-    {                                                                       \
-      for (i = 0; i &lt; (bpp &gt;&gt; 3); i++)                                      \
-      {                                                                     \
-        pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + i);                           \
-      }                                                                     \
-    }                                                                       \
-                                                                            \
-    fbptr += bpp &gt;&gt; 3;                                                      \
-                                                                            \
-    inRed = (int)                                                           \
-            (pix &gt;&gt; redShift   &amp; redMax);                                   \
-    inGreen = (int)                                                         \
-            (pix &gt;&gt; greenShift &amp; greenMax);                                 \
-    inBlue  = (int)                                                         \
-            (pix &gt;&gt; blueShift  &amp; blueMax);                                  \
-                                                                            \
-    *dst++ = (CARD8)((inRed   * 255 + redMax / 2) /                         \
-                         redMax);                                           \
-    *dst++ = (CARD8)((inGreen * 255 + greenMax / 2) /                       \
-                         greenMax);                                         \
-    *dst++ = (CARD8)((inBlue  * 255 + blueMax / 2) /                        \
-                         blueMax);                                          \
-  }                                                                         \
-}
-
-DEFINE_JPEG_GET_ROW_FUNCTION(16)
-DEFINE_JPEG_GET_ROW_FUNCTION(32)
-
-/*
- * Destination manager implementation for JPEG library.
- */
-
-void JpegInitDestination(j_compress_ptr cinfo)
-{
-  jpegError = 0;
-
-  jpegDstManager.next_output_byte = (JOCTET *) jpegCompBuf;
-  jpegDstManager.free_in_buffer = (size_t) jpegCompBufSize;
-}
-
-int JpegEmptyOutputBuffer(j_compress_ptr cinfo)
-{
-  jpegError = 1;
-
-  jpegDstManager.next_output_byte = (JOCTET *) jpegCompBuf;
-  jpegDstManager.free_in_buffer = (size_t) jpegCompBufSize;
-
-  return 1;
-}
-
-void JpegTermDestination(j_compress_ptr cinfo)
-{
-  jpegDstDataLen = jpegCompBufSize - jpegDstManager.free_in_buffer;
-}
-
-void JpegSetDstManager(j_compress_ptr cinfo)
-{
-  jpegDstManager.init_destination = JpegInitDestination;
-  jpegDstManager.empty_output_buffer = JpegEmptyOutputBuffer;
-  jpegDstManager.term_destination = JpegTermDestination;
-
-  cinfo -&gt; dest = &jpegDstManager;
-}
-
diff --git a/nxcompext/Jpeg.h b/nxcompext/Jpeg.h
deleted file mode 100644
index 87740df..0000000
--- a/nxcompext/Jpeg.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#ifndef Jpeg_H
-#define Jpeg_H
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-extern char *JpegCompressData(
-#if NeedFunctionPrototypes
-    XImage*                   /* image */,
-    int                       /* level */,
-    int*                      /* compressed_size */
-#endif
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* Jpeg_H */
-
diff --git a/nxcompext/Makefile.in b/nxcompext/Makefile.in
deleted file mode 100644
index cdf0b1c..0000000
--- a/nxcompext/Makefile.in
+++ /dev/null
@@ -1,162 +0,0 @@
-############################################################################
-#                                                                          #
-#  Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com.">http://www.nomachine.com.</A>           #
-#                                                                          #
-#  NXCOMPEXT, NX protocol compression and NX extensions to this software   #
-#  are copyright of NoMachine. Redistribution and use of the present       #
-#  software is allowed according to terms specified in the file LICENSE    #
-#  which comes in the source distribution.                                 #
-#                                                                          #
-#  Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.        #
-#                                                                          #
-#  NX and NoMachine are trademarks of NoMachine S.r.l.                     #
-#                                                                          #
-#  All rights reserved.                                                    #
-#                                                                          #
-############################################################################
-
-#
-# Get values from configure script.
-#
-
-VERSION=@VERSION@
-LIBVERSION=@LIBVERSION@
-
-#
-# We want to enable really all warnings. -Wredundant-decls,
-# though, gives a warning caused by pthread.h and unistd.h.
-#
-
-CXX         = @CXX@
-CXXFLAGS    = @CXXFLAGS@ @X_CFLAGS@ @DEFS@ \
-              -Wall -Wpointer-arith -Wstrict-prototypes -Wmissing-prototypes \
-              -Wmissing-declarations -Wnested-externs
-CXXINCLUDES = -I. -I../nxcomp
-CXXDEFINES  =
-
-CC          = @CC@
-CCFLAGS     = @CFLAGS@ @X_CFLAGS@ @DEFS@ \
-              -Wall -Wpointer-arith -Wstrict-prototypes -Wmissing-prototypes \
-              -Wmissing-declarations -Wnested-externs
-CCINCLUDES  = -I. -I../nxcomp
-CCDEFINES   =
-
-LDFLAGS     = @LDFLAGS@ -L../nxcomp
-LIBS        = @LIBS@ -lz -lX11 -lXcomp
-
-#
-# Only if THREADS is defined
-#
-# LIBS = @LIBS@ -lz -ljpeg -lpthread -lX11 -lXcomp
-#
-
-srcdir      = @srcdir@
-prefix      = @prefix@
-exec_prefix = @exec_prefix@
-bindir      = @bindir@
-man1dir     = @mandir@/man1
-VPATH       = @srcdir@
-
-INSTALL         = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA    = @INSTALL_DATA@
-
-#
-# This should be autodetected.
-#
-
-MAKEDEPEND     = @MAKEDEPEND@
-DEPENDINCLUDES =  -I/usr/include/c++ -I/usr/include/g++ -I/usr/include/g++-3 
-
-.SUFFIXES: .cpp.c
-
-.cpp.o:
-	$(CXX) -c $(CXXFLAGS) $(CXXINCLUDES) $&lt;
-.c.o:
-	$(CC) -c $(CCFLAGS) $(CCINCLUDES) $&lt;
-
-LIBRARY = Xcompext
-
-LIBNAME    = lib$(LIBRARY)
-LIBFULL    = lib$(LIBRARY).so.$(VERSION)
-LIBLOAD    = lib$(LIBRARY).so.$(LIBVERSION)
-LIBSHARED  = lib$(LIBRARY).so
-LIBARCHIVE = lib$(LIBRARY).a
-
-LIBCYGSHARED  = cyg$(LIBRARY).dll
-LIBCYGARCHIVE = lib$(LIBRARY).dll.a
-
-all: depend @ALL@
-
-MSRC=
-
-CSRC=	NXlib.c		\
-	Clean.c		\
-	Mask.c		\
-	Colormap.c	\
-	Alpha.c		\
-	Jpeg.c		\
-	Pgn.c		\
-	Bitmap.c	\
-	Rgb.c		\
-	Rle.c		\
-        Z.c
-
-CXXSRC=
-
-MOBJ   = $(MSRC:.c=.o)
-COBJ   = $(CSRC:.c=.o)
-CXXOBJ = $(CXXSRC:.cpp=.o)
-
-$(LIBFULL):	 $(CXXOBJ) $(COBJ)
-		 $(CXX) -o $@ $(LDFLAGS) $(CXXOBJ) $(COBJ) $(LIBS)
-
-$(LIBLOAD):	 $(LIBFULL)
-		 rm -f $(LIBLOAD)
-		 ln -s $(LIBFULL) $(LIBLOAD)
-
-$(LIBSHARED):	 $(LIBFULL)
-		 rm -f $(LIBSHARED)
-		 ln -s $(LIBFULL) $(LIBSHARED)
-
-$(LIBARCHIVE):	 $(CXXOBJ) $(COBJ)
-		 rm -f  $(LIBARCHIVE)
-		 ar clq $(LIBARCHIVE) $(CXXOBJ) $(COBJ)
-		 ranlib $(LIBARCHIVE)
-
-$(LIBCYGSHARED): $(LIBARCHIVE)
-		 $(CC) -shared -o $(LIBCYGSHARED) \
-		 -Wl,--out-implib=$(LIBCYGARCHIVE) \
-		 -Wl,--export-all-symbols \
-		 -Wl,--enable-auto-import \
-		 -Wl,--whole-archive $(LIBARCHIVE) \
-		 -Wl,--no-whole-archive $(LIBS) \
-		 $(LDFLAGS)
-
-$(LIBCYGARCHIVE): $(LIBCYGSHARED)
-
-depends:	depend.status
-
-depend:		depend.status
-
-depend.status:	
-		if [ -x $(MAKEDEPEND) ] ; then \
-			$(MAKEDEPEND) $(CXXINCLUDES) $(CCINCLUDES) \
-                        $(DEPENDINCLUDES) -f Makefile $(MSRC) $(CSRC) \
-			$(CXXSRC) 2&gt;/dev/null; \
-		fi
-		touch depend.status
-
-install:	install.bin install.man
-
-install.bin:
-
-install.man:
-
-clean:
-		-rm -f *~ *.o *.bak *.orig *.rej st?????? core core.* *.out.* \
-		@ALL@
-
-distclean:	clean
-		-rm -rf autom4te.cache config.status config.log \
-		config.cache depend.status Makefile tags
diff --git a/nxcompext/Mask.c b/nxcompext/Mask.c
deleted file mode 100644
index b04989d..0000000
--- a/nxcompext/Mask.c
+++ /dev/null
@@ -1,794 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;stdio.h&gt;
-
-#include &quot;Xlib.h&quot;
-
-#include &quot;NXpack.h&quot;
-
-#include &quot;Mask.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-/*
- * Try first to reduce to a white or black
- * pixel. If not possible, apply the mask.
- * Note that correction is applied at the
- * time pixel is unpacked.
- */
-
-#define MaskPixel(red, green, blue, mask) \
-\
-if (red &gt; mask -&gt; white_threshold &amp;&amp; \
-        green &gt; mask -&gt; white_threshold &amp;&amp; \
-            blue &gt; mask -&gt; white_threshold) \
-{ \
-    red = green = blue = 0xff; \
-} \
-else if (red &lt; mask -&gt; black_threshold &amp;&amp; \
-             green &lt; mask -&gt; black_threshold &amp;&amp; \
-                 blue &lt; mask -&gt; black_threshold) \
-{ \
-    red = green = blue = 0x00; \
-} \
-else \
-{ \
-    red   = red   &amp; mask -&gt; color_mask; \
-    green = green &amp; mask -&gt; color_mask; \
-    blue  = blue  &amp; mask -&gt; color_mask; \
-}
-
-int MaskImage(const ColorMask *mask, XImage *src_image, XImage *dst_image)
-{
-  unsigned long pixel;
-
-  register unsigned int red;
-  register unsigned int green;
-  register unsigned int blue;
-
-  register unsigned long data_size;
-
-  register unsigned int i;
-
-  data_size = (src_image -&gt; bytes_per_line * src_image -&gt; height) &gt;&gt; 2;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******MaskImage: Going to mask image with [%d] bits per pixel.\n&quot;,
-              src_image -&gt; bits_per_pixel);
-  #endif
-
-  if (src_image -&gt; bits_per_pixel == 24 || src_image -&gt; bits_per_pixel == 32)
-  {
-    register unsigned char *pixel_addr;
-
-    for (i = 0; i &lt; data_size; i++)
-    {
-      pixel = ((unsigned long *) src_image -&gt; data)[i];
-
-      pixel_addr = (unsigned char *) &pixel;
-
-      red   = pixel_addr[2];
-      green = pixel_addr[1];
-      blue  = pixel_addr[0];
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskImage: 24/32 bits original R [%d] G [%d] B [%d] A [%d].\n&quot;,
-              red, green, blue, pixel_addr[3]);
-      #endif
-
-      MaskPixel(red, green, blue, mask);
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskImage: 24/32 bits masked R [%d] G [%d] B [%d] A [%d].\n&quot;,
-                  red, green, blue, pixel_addr[3]);
-      #endif
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskImage: 24/32 bits pixel 0x%lx&quot;, pixel);
-      #endif
-
-      pixel_addr[2] = red;
-      pixel_addr[1] = green;
-      pixel_addr[0] = blue;
-
-      ((unsigned long*)dst_image -&gt; data)[i] = pixel;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot; -&gt; 0x%lx\n&quot;, pixel);
-      #endif
-    }
-
-    return 1;
-  }
-  else if (src_image -&gt; bits_per_pixel == 16)
-  {
-    /* 
-     * FIXME: Masking doesn't work in 16 bpp.
-     *
-
-    unsigned long src_addr, *dst_addr;
-    unsigned short *src_pixels_addr, *dst_pixels_addr;
-
-    for (i = 0; i &lt; data_size; i++)
-    {
-      src_addr = ((unsigned long *)src_image -&gt; data)[i];
-      dst_addr = (unsigned long *)((unsigned long *)dst_image -&gt; data + i);
-
-      src_pixels_addr = ((unsigned short *) &amp;src_addr);
-      dst_pixels_addr = ((unsigned short *) dst_addr);
-
-      red   = (src_pixels_addr[0] &amp; src_image -&gt; red_mask)   &gt;&gt; 8;
-      green = (src_pixels_addr[0] &amp; src_image -&gt; green_mask) &gt;&gt; 3;
-      blue  = (src_pixels_addr[0] &amp; src_image -&gt; blue_mask)  &lt;&lt; 3;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskImage: 16 bits original R [%d] G [%d] B [%d].\n&quot;,
-              red, green, blue);
-      #endif
-
-      MaskPixel(red, green, blue, mask);
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskImage: 16 bits masked R [%d] G [%d] B [%d].\n&quot;,
-              red, green, blue);
-      #endif
-
-      dst_pixels_addr[0] = ((red &lt;&lt; 8)   &amp; src_image -&gt; red_mask)   |
-                           ((green &lt;&lt; 3) &amp; src_image -&gt; green_mask) |
-                           ((blue &gt;&gt; 3)  &amp; src_image -&gt; blue_mask);
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskImage: 16 bits pixel 0x%x&quot;, dst_pixels_addr[0]);
-      #endif
-
-      red   = (src_pixels_addr[1] &amp; src_image -&gt; red_mask)   &gt;&gt; 8;
-      green = (src_pixels_addr[1] &amp; src_image -&gt; green_mask) &gt;&gt; 3;
-      blue  = (src_pixels_addr[1] &amp; src_image -&gt; blue_mask)  &lt;&lt; 3;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskImage: 16 bits original R [%d] G [%d] B [%d].\n&quot;,
-              red, green, blue);
-      #endif
-
-      MaskPixel(red, green, blue, mask);
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskImage: 16 bits masked R [%d] G [%d] B [%d].\n&quot;,
-              red, green, blue);
-      #endif
-
-      dst_pixels_addr[1] = ((red &lt;&lt; 8)   &amp; src_image -&gt; red_mask)   |
-                           ((green &lt;&lt; 3) &amp; src_image -&gt; green_mask) |
-                           ((blue &gt;&gt; 3)  &amp; src_image -&gt; blue_mask);
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskImage: 16 bits pixel 0x%x&quot;, dst_pixels_addr[0]);
-      #endif
-    }
-
-    if (dst_image -&gt; width &amp; 0x00000001)
-    {
-      int card32_per_line;
-      int i;
-
-      card32_per_line = dst_image -&gt; bytes_per_line &gt;&gt; 2;
-
-      for (i = 0; i &lt; dst_image -&gt; height;)
-      {
-        ((CARD32 *) dst_image -&gt; data)[(++i * card32_per_line) - 1] &amp;= 0x0000ffff;
-      }
-    }
-
-    *
-    * End of FIXME.
-    */
-  }
-  else
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******MaskImage: PANIC! Cannot apply mask with [%d] bits per pixel.\n&quot;,
-                src_image -&gt; bits_per_pixel);
-    #endif
-
-    return 0;
-  }
-
-  return 1;
-}
-
-int MaskInPlaceImage(const ColorMask *mask, XImage *image)
-{
-  unsigned long pixel;
-
-  register unsigned int red;
-  register unsigned int green;
-  register unsigned int blue;
-
-  register unsigned int i;
-
-  register unsigned long data_size;
-
-  data_size = (image -&gt; bytes_per_line * image -&gt; height)&gt;&gt;2;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******MaskInPlaceImage: Going to mask image with [%d] bits per pixel.\n&quot;,
-              image -&gt; bits_per_pixel);
-  #endif
-
-  if (image -&gt; bits_per_pixel == 24 || image -&gt; bits_per_pixel == 32)
-  {
-    register unsigned char *pixel_addr;
-
-    for (i = 0; i &lt; data_size; i++)
-    {
-      pixel = ((unsigned long *) image -&gt; data)[i];
-
-      pixel_addr = (unsigned char *) &pixel;
-
-      red   = pixel_addr[2];
-      green = pixel_addr[1];
-      blue  = pixel_addr[0];
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskInPlaceImage: 24/32 bits original R [%d] G [%d] B [%d] A [%d].\n&quot;,
-                  red, green, blue, pixel_addr[3]);
-      #endif
-
-      MaskPixel(red, green, blue, mask);
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskInPlaceImage: 24/32 bits masked R [%d] G [%d] B [%d] A [%d].\n&quot;,
-                  red, green, blue, pixel_addr[3]);
-      #endif
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskInPlaceImage: 24/32 bits pixel 0x%lx&quot;, pixel);
-      #endif
-
-      pixel_addr[2] = red;
-      pixel_addr[1] = green;
-      pixel_addr[0] = blue;
-
-      ((unsigned long *) image -&gt; data)[i] = pixel;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot; -&gt; 0x%lx\n&quot;, pixel);
-      #endif
-    }
-
-    return 1;
-  }
-  else if (image -&gt; bits_per_pixel == 16)
-  {
-    /*
-     * FIXME: Mask doesn't still work for 16 bits.
-     *
-
-    unsigned long addr;
-    register unsigned short *pixels_addr;
-
-    for (i = 0; i &lt; data_size; i++)
-    {
-      addr = ((unsigned long *) image -&gt; data)[i];
-
-      pixels_addr = ((unsigned short *) &amp;addr);
-
-      red   = (pixels_addr[0] &amp; image -&gt; red_mask)   &gt;&gt; 8;
-      green = (pixels_addr[0] &amp; image -&gt; green_mask) &gt;&gt; 3;
-      blue  = (pixels_addr[0] &amp; image -&gt; blue_mask)  &lt;&lt; 3;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits original R [%d] G [%d] B [%d].\n&quot;,
-                  red, green, blue);
-      #endif
-
-      MaskPixel(red, green, blue, mask);
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits masked R [%d] G [%d] B [%d].\n&quot;,
-                  red, green, blue);
-      #endif
-
-      pixels_addr[0] = ((red &lt;&lt; 8)   &amp; image -&gt; red_mask) |
-                           ((green &lt;&lt; 3) &amp; image -&gt; green_mask) |
-                               ((blue &gt;&gt; 3)  &amp; image -&gt; blue_mask);
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits pixel 0x%x&quot;, pixels_addr[0]);
-      #endif
-
-      red   = (pixels_addr[1] &amp; image -&gt; red_mask)   &gt;&gt; 8;
-      green = (pixels_addr[1] &amp; image -&gt; green_mask) &gt;&gt; 3;
-      blue  = (pixels_addr[1] &amp; image -&gt; blue_mask)  &lt;&lt; 3;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits original R [%d] G [%d] B [%d].\n&quot;,
-                  red, green, blue);
-      #endif
-
-      MaskPixel(red, green, blue, mask);
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits masked R [%d] G [%d] B [%d].\n&quot;,
-                  red, green, blue);
-      #endif
-
-      pixels_addr[1] = ((red &lt;&lt; 8)   &amp; image -&gt; red_mask) |
-                           ((green &lt;&lt; 3) &amp; image -&gt; green_mask) |
-                               ((blue &gt;&gt; 3)  &amp; image -&gt; blue_mask);
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits pixel 0x%x&quot;, pixels_addr[1]);
-      #endif
-    }
-
-    if (image -&gt; width &amp; 0x00000001)
-    {
-      int card32_per_line;
-      int i;
-
-      card32_per_line = image -&gt; bytes_per_line &gt;&gt; 2;
-
-      for (i = 0; i &lt; image -&gt; height;)
-      {
-        ((CARD32 *) image -&gt; data)[(++i * card32_per_line) - 1] &amp;= 0x0000ffff;
-      }
-    }
-
-    *
-    * End of FIXME.
-    */
-  }
-  else
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******MaskImage: PANIC! Cannot apply mask with [%d] bits per pixel.\n&quot;,
-                image -&gt; bits_per_pixel);
-    #endif
-
-    return 0;
-  }
-
-  return 1;
-}
-
-static int Pack16To8(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
-{
-  unsigned short *src_pixel = (unsigned short *) src_image -&gt; data;
-  unsigned char  *dst_pixel = (unsigned char *)  dst_image -&gt; data;
-
-  #ifdef DEBUG
-  unsigned int counter = 0;
-  #endif
-
-  while (src_pixel &lt; ((unsigned short *) (src_image -&gt; data + src_data_size)))
-  {
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
-                counter, *src_pixel, (*src_pixel &amp; 0xc000) &gt;&gt; 8,
-                    ((*src_pixel &amp; 0x600) &gt;&gt; 3), (*src_pixel &amp; 0x18) &lt;&lt; 3);
-    #endif
-
-    if (*src_pixel == 0x0)
-    {
-      *dst_pixel = 0x0;
-    }
-    else if (*src_pixel == 0xffff)
-    {
-      *dst_pixel = 0xff;
-    }
-    else
-    {
-      *dst_pixel = ((*src_pixel &amp; 0xc000) &gt;&gt; 10) |
-                        ((*src_pixel &amp; 0x600) &gt;&gt; 7) |
-                             ((*src_pixel &amp; 0x18) &gt;&gt; 3);
-    }
-
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x].\n&quot;,
-                counter++, *dst_pixel);
-    #endif
-
-    src_pixel++;
-    dst_pixel++;
-  }
-
-  return 1;
-}
-
-static int Pack24To8(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
-{
-  unsigned char *src_pixel = (unsigned char *) src_image -&gt; data;
-  unsigned char *dst_pixel = (unsigned char *) dst_image -&gt; data;
-
-  int i;
-
-  unsigned int bytes_per_line = src_image -&gt; bytes_per_line;
-
-  unsigned char *end_of_line = (unsigned char *) (src_pixel + bytes_per_line);
-
-
-  #ifdef DEBUG
-  unsigned int counter = 0;
-  #endif
-
-  for (i = 0; i &lt; src_image -&gt; height; i++ )
-  {
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x%x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
-                counter, src_pixel[0], src_pixel[1], src_pixel[2], src_pixel[0] &amp; 0xc0,
-                    src_pixel[1] &amp; 0xc0, src_pixel[2] &amp; 0xc0);
-    #endif
-
-    while(src_pixel &lt; end_of_line - 2)
-    {
-      if (src_pixel[0] == 0x00 &amp;&amp;
-              src_pixel[1] == 0x00 &amp;&amp;
-                  src_pixel[2] == 0x00)
-      {
-        *dst_pixel = 0x0;
-      }
-      else if (src_pixel[0] == 0xff &amp;&amp;
-                   src_pixel[1] == 0xff &amp;&amp;
-                       src_pixel[2] == 0xff)
-      {
-        *dst_pixel = 0xff;
-      }
-      else
-      {
-        /*
-         * Pixel layout:
-         *
-         * 24 bit RRRRR000 GGGGG000 BBBBB000 -&gt; 8 bit 00RRGGBB
-         */
-
-        *dst_pixel = (src_pixel[0] &amp; 0xc0) &gt;&gt; 2 |
-                         ((src_pixel[1] &amp; 0xc0) &gt;&gt; 4) |
-                              ((src_pixel[2] &amp; 0xc0) &gt;&gt; 6);
-      }
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x].\n&quot;,
-                  counter++, *dst_pixel);
-      #endif
-
-      src_pixel += 3;
-      dst_pixel += 1;
-    }
-
-    src_pixel = end_of_line;
-    end_of_line += bytes_per_line;
-  }
-  
-  return 1;
-}
-
-static int Pack24To16(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
-{
-  unsigned char  *src_pixel = (unsigned char  *) src_image -&gt; data;
-  unsigned short *dst_pixel = (unsigned short *) dst_image -&gt; data;
-
-  int i;
-
-  unsigned int bytes_per_line = src_image -&gt; bytes_per_line;
-
-  unsigned char *end_of_line = (unsigned char *) (src_pixel + bytes_per_line);
-
-  #ifdef DEBUG
-  unsigned int counter = 0;
-  #endif
-
-  for (i = 0; i &lt; src_image -&gt; height; i++ )
-  {
-    while(src_pixel &lt; end_of_line - 2)
-    {
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x%x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
-                  counter, src_pixel[0], src_pixel[1], src_pixel[2], src_pixel[0] &amp; 0xf8,
-                      src_pixel[1] &amp; 0xf8, src_pixel[2] &amp; 0xf8);
-      #endif
-
-      if (src_pixel[0] == 0x00 &amp;&amp;
-              src_pixel[1] == 0x00 &amp;&amp;
-                  src_pixel[2] == 0x00)
-      {
-        *dst_pixel = 0x0;
-      }
-      else if (src_pixel[0] == 0xff &amp;&amp;
-                   src_pixel[1] == 0xff &amp;&amp;
-                       src_pixel[2] == 0xff)
-      {
-        *dst_pixel = 0xffff;
-      }
-      else
-      {
-        /*
-         * Pixel layout:
-         *
-         * 24 bit RRRRR000 GGGGG000 BBBBB000 -&gt; 16 bit 0RRRRRGG GGGBBBBB
-         */
-
-        *dst_pixel = ((src_pixel[0] &amp; 0xf8) &lt;&lt; 7) |
-                         ((src_pixel[1] &amp; 0xf8) &lt;&lt; 2) |
-                             ((src_pixel[2] &amp; 0xf8) &gt;&gt; 3);
-      }
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x].\n&quot;,
-                  counter++, *dst_pixel);
-      #endif
-
-      src_pixel += 3;
-      dst_pixel += 1;
-    }
-
-    src_pixel = end_of_line;
-    end_of_line += bytes_per_line;
-  }
-
-  return 1;
-}
-
-static int Pack32To8(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
-{
-  unsigned int  *src_pixel = (unsigned int  *) src_image -&gt; data;
-  unsigned char *dst_pixel = (unsigned char *) dst_image -&gt; data;
-
-  #ifdef DEBUG
-  unsigned int counter = 0;
-  #endif
-
-  while (src_pixel &lt; ((unsigned int  *) (src_image -&gt; data + src_data_size)))
-  {
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
-                counter, *src_pixel, (*src_pixel &amp; 0xc00000),
-                    (*src_pixel &amp; 0xc000), (*src_pixel &amp; 0xc0));
-    #endif
-
-    if (*src_pixel == 0x0)
-    {
-      *dst_pixel = 0x0;
-    }
-    else if (*src_pixel == 0xffffff)
-    {
-      *dst_pixel = 0xff;
-    }
-    else
-    {
-      *dst_pixel = ((*src_pixel &amp; 0xc00000) &gt;&gt; 18) |
-                        ((*src_pixel &amp; 0xc000) &gt;&gt; 12) |
-                             ((*src_pixel &amp; 0xc0) &gt;&gt; 6);
-    }
-
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x].\n&quot;,
-                counter++, *dst_pixel);
-    #endif
-
-    src_pixel++;
-    dst_pixel++;
-  }
-
-  return 1;
-}
-
-static int Pack32To16(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
-{
-  unsigned int   *src_pixel = (unsigned int  *)  src_image -&gt; data;
-  unsigned short *dst_pixel = (unsigned short *) dst_image -&gt; data;
-
-  #ifdef DEBUG
-  unsigned int counter = 0;
-  #endif
-
-  while (src_pixel &lt; ((unsigned int  *) (src_image -&gt; data + src_data_size)))
-  {
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
-                counter, *src_pixel, (*src_pixel &amp; 0xf80000),
-                    (*src_pixel &amp; 0xf800), (*src_pixel &amp; 0xf8));
-    #endif
-
-    if (*src_pixel == 0x0)
-    {
-      *dst_pixel = 0x0;
-    }
-    else if (*src_pixel == 0xffffff)
-    {
-      *dst_pixel = 0xffff;
-    }
-    else
-    {
-      *dst_pixel = ((*src_pixel &amp; 0xf80000) &gt;&gt; 9) |
-                        ((*src_pixel &amp; 0xf800) &gt;&gt; 6) |
-                             ((*src_pixel &amp; 0xf8) &gt;&gt; 3);
-    }
-
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x].\n&quot;,
-                counter++, *dst_pixel);
-    #endif
-
-    src_pixel++;
-    dst_pixel++;
-  }
-
-  return 1;
-}
-
-static int Pack32To24(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
-{
-  unsigned int  *src_pixel = (unsigned int  *) src_image -&gt; data;
-  unsigned char *dst_pixel = (unsigned char *) dst_image -&gt; data;
-
-  #ifdef DEBUG
-  unsigned int counter = 0;
-  #endif
-
-  while (src_pixel &lt; ((unsigned int  *) (src_image -&gt; data + src_data_size)))
-  {
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
-                counter, *src_pixel, ((*src_pixel &amp; 0xff0000) &gt;&gt; 16),
-                    ((*src_pixel &amp; 0x00ff00) &gt;&gt; 8), (*src_pixel &amp; 0xff));
-    #endif
-
-    if (*src_pixel == 0x0)
-    {
-      dst_pixel[0] = dst_pixel[1] = dst_pixel[2] = 0x0;
-    }
-    else if (*src_pixel == 0xffffff)
-    {
-      dst_pixel[0] = dst_pixel[1] = dst_pixel[2] = 0xff;
-    }
-    else
-    {
-      dst_pixel[0] = (*src_pixel &amp; 0xff0000) &gt;&gt; 16;
-      dst_pixel[1] = (*src_pixel &amp; 0x00ff00) &gt;&gt; 8;
-      dst_pixel[2] = (*src_pixel &amp; 0x0000ff);
-    }
-
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x], [0x%x], [0x%x].\n&quot;,
-                counter++, dst_pixel[0], dst_pixel[1], dst_pixel[2]);
-    #endif
-
-    src_pixel += 1;
-    dst_pixel += 3;
-  }
-
-  return 1;
-}
-
-int PackImage(unsigned int method, unsigned int src_data_size, XImage *src_image,
-                  unsigned int dst_data_size, XImage *dst_image)
-{
-  unsigned int src_bits_per_pixel;
-  unsigned int dst_bits_per_pixel;
-
-  src_bits_per_pixel = src_image -&gt; bits_per_pixel;
-  dst_bits_per_pixel = MethodBitsPerPixel(method);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******PackImage: Source bits per pixel [%d], destination bits per pixel [%d].\n&quot;,
-              src_bits_per_pixel, dst_bits_per_pixel);
-
-  fprintf(stderr, &quot;******PackImage: Source data size [%d], destination data size [%d].\n&quot;,
-              src_data_size, dst_data_size);
-  #endif
-
-  if (dst_bits_per_pixel &gt;= src_bits_per_pixel)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******PackImage: PANIC! Cannot pack image from [%d] to [%d] bytes per pixel.\n&quot;,
-                src_bits_per_pixel, dst_bits_per_pixel);
-    #endif
-
-    return 0;
-  }
-
-  switch (src_bits_per_pixel)
-  {
-    case 16:
-    {
-      switch (dst_bits_per_pixel)
-      {
-        case 8:
-        {
-          return Pack16To8(src_data_size, src_image, dst_image);
-        }
-        default:
-        {
-          return 0;
-        }
-      }
-    }
-    case 24:
-    {
-      switch (dst_bits_per_pixel)
-      {
-        case 8:
-        {
-          return Pack24To8(src_data_size, src_image, dst_image);
-        }
-        case 16:
-        {
-          return Pack24To16(src_data_size, src_image, dst_image);
-        }
-        default:
-        {
-          return 0;
-        }
-      }
-    }
-    case 32:
-    {
-      switch (dst_bits_per_pixel)
-      {
-        case 8:
-        {
-          return Pack32To8(src_data_size, src_image, dst_image);
-        }
-        case 16:
-        {
-          return Pack32To16(src_data_size, src_image, dst_image);
-        }
-        case 24:
-        {
-          return Pack32To24(src_data_size, src_image, dst_image);
-        }
-        default:
-        {
-          return 0;
-        }
-      }
-    }
-    default:
-    {
-      return 0;
-    }
-  }
-}
-
-/*
- * Replace the ffs() call that may be not
- * present on some systems.
- */
-
-int FindLSB(int word)
-{
-  int t = word;
-
-  int m = 1;
-  int i = 0;
-
-  for (; i &lt; sizeof(word) &lt;&lt; 3; i++, m &lt;&lt;= 1)
-  {
-    if (t &amp; m)
-    {
-      return i + 1;
-    }
-  }
-
-  return 0;
-}
-
diff --git a/nxcompext/Mask.h b/nxcompext/Mask.h
deleted file mode 100644
index 5d6024f..0000000
--- a/nxcompext/Mask.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#ifndef Mask_H
-#define Mask_H
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-#include &quot;Xlib.h&quot;
-
-extern int MaskImage(const ColorMask *mask, XImage *src_image, XImage *dst_image);
-
-extern int MaskInPlaceImage(const ColorMask *mask, XImage *image);
-
-extern int PackImage(unsigned int method, unsigned int src_data_size, XImage *src_image,
-                         unsigned int dst_data_size, XImage *dst_image);
-
-int FindLSB(int word);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* Mask_H */
diff --git a/nxcompext/NXlib.c b/nxcompext/NXlib.c
deleted file mode 100644
index 452213b..0000000
--- a/nxcompext/NXlib.c
+++ /dev/null
@@ -1,4770 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;sys/socket.h&gt;
-
-#ifndef __sun
-#include &lt;strings.h&gt;
-#endif
-
-#include &quot;NX.h&quot;
-
-#include &quot;dix.h&quot;
-#include &quot;os.h&quot;
-
-#define NEED_REPLIES
-
-/*
- * Needed to enable definition of the callback
- * functions.
- */
-
-#define NX_TRANS_SOCKET
-
-#include &quot;Xlib.h&quot;
-#include &quot;Xutil.h&quot;
-#include &quot;Xlibint.h&quot;
-
-#include &quot;NXlib.h&quot;
-#include &quot;NXproto.h&quot;
-#include &quot;NXpack.h&quot;
-
-#include &quot;Clean.h&quot;
-#include &quot;Mask.h&quot;
-#include &quot;Colormap.h&quot;
-#include &quot;Alpha.h&quot;
-#include &quot;Bitmap.h&quot;
-#include &quot;Jpeg.h&quot;
-#include &quot;Pgn.h&quot;
-#include &quot;Rgb.h&quot;
-#include &quot;Rle.h&quot;
-#include &quot;Z.h&quot;
-
-#include &quot;MD5.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-#undef  DUMP
-
-/*
- * Maximum number of colors allowed in
- * Png encoding.
- */
-
-#define NB_COLOR_MAX          256
-
-/*
- * Dummy error handlers used internally to catch
- * Xlib failures in replies.
- */
-
-static int _NXInternalReplyErrorFunction(Display *dpy, XErrorEvent *error);
-
-static void _NXInternalLostSequenceFunction(Display *dpy, unsigned long newseq,
-                                                unsigned long lastseq, unsigned int type);
-
-/*
- * Resource ids that can be requested by
- * the client for use in split or unpack
- * operations.
- */
-
-static unsigned char _NXSplitResources[NXNumberOfResources];
-static unsigned char _NXUnpackResources[NXNumberOfResources];
-
-static Display *_NXDisplayInitialized = NULL;
-
-/*
- * Used in asynchronous handling of
- * GetImage replies.
- */
-
-typedef struct
-{
-  unsigned long  sequence;
-  unsigned int   resource;
-  unsigned long  mask;
-  int            format;
-  int            width;
-  int            height;
-  _XAsyncHandler *handler;
-  XImage         *image;
-} _NXCollectImageState;
-
-static _NXCollectImageState *_NXCollectedImages[NXNumberOfResources];
-
-/*
- * Used in asynchronous handling of
- * GetProperty replies.
- */
-
-typedef struct
-{
-  unsigned long  sequence;
-  unsigned int   resource;
-  Window         window;
-  Atom           property;
-  Atom           type;
-  int            format;
-  unsigned long  items;
-  unsigned long  after;
-  _XAsyncHandler *handler;
-  char           *data;
-} _NXCollectPropertyState;
-
-static _NXCollectPropertyState *_NXCollectedProperties[NXNumberOfResources];
-
-/*
- * Used in asynchronous handling of
- * GrabPointer replies.
- */
-
-typedef struct
-{
-  unsigned long  sequence;
-  unsigned int   resource;
-  int            status;
-  _XAsyncHandler *handler;
-} _NXCollectGrabPointerState;
-
-static _NXCollectGrabPointerState *_NXCollectedGrabPointers[NXNumberOfResources];
-
-/*
- * Used in asynchronous handling of
- * GetInputFocus replies.
- */
-
-typedef struct
-{
-  unsigned long  sequence;
-  unsigned int   resource;
-  Window         focus;
-  int            revert_to;
-  _XAsyncHandler *handler;
-} _NXCollectInputFocusState;
-
-static _NXCollectInputFocusState *_NXCollectedInputFocuses[NXNumberOfResources];
-
-/*
- * Used by functions handling cache of
- * packed images.
- */
-
-#define MD5_LENGTH            16
-
-typedef struct
-{
-  md5_byte_t   *md5;
-  XImage       *image;
-  unsigned int method;
-} _NXImageCacheEntry;
-
-int NXImageCacheSize = 0;
-int NXImageCacheHits = 0;
-int NXImageCacheOps  = 0;
-
-_NXImageCacheEntry *NXImageCache = NULL;
-
-#ifdef DUMP
-
-void _NXCacheDump(const char *label);
-
-void _NXDumpData(const unsigned char *buffer, unsigned int size);
-
-#endif
-
-/*
- * From X11/PutImage.c.
- *
- * Cancel a GetReq operation, before doing
- * _XSend or Data.
- */
-
-#if (defined(__STDC__) &amp;&amp; !defined(UNIXCPP)) || defined(ANSICPP)
-#define UnGetReq(name)\
-    dpy-&gt;bufptr -= SIZEOF(x##name##Req);\
-    dpy-&gt;request--
-#else
-#define UnGetReq(name)\
-    dpy-&gt;bufptr -= SIZEOF(x/**/name/**/Req);\
-    dpy-&gt;request--
-#endif
-
-#if (defined(__STDC__) &amp;&amp; !defined(UNIXCPP)) || defined(ANSICPP)
-#define UnGetEmptyReq()\
-    dpy-&gt;bufptr -= 4;\
-    dpy-&gt;request--
-#else
-#define UnGetEmptyReq(name)\
-    dpy-&gt;bufptr -= 4;\
-    dpy-&gt;request--
-#endif
-
-/*
- * From X11/ImUtil.c.
- */
-
-extern int _XGetBitsPerPixel(Display *dpy, int depth);
-extern int _XGetScanlinePad(Display *dpy, int depth);
-
-#define ROUNDUP(nbytes, pad) (((nbytes) + ((pad) - 1)) &amp; \
-                                  ~(long)((pad) - 1))
-
-static unsigned int DepthOnes(unsigned long mask)
-{
-  register unsigned long y;
-
-  y = (mask &gt;&gt; 1) &amp;033333333333;
-  y = mask - y - ((y &gt;&gt;1) &amp; 033333333333);
-  return ((unsigned int) (((y + (y &gt;&gt; 3)) &amp;
-              030707070707) % 077));
-}
-
-#define CanMaskImage(image, mask) \
-\
-(image -&gt; format == ZPixmap &amp;&amp; mask != NULL &amp;&amp; \
-    (image -&gt; depth == 32 || image -&gt; depth == 24 || \
-        (image -&gt; depth == 16 &amp;&amp; (image -&gt; red_mask == 0xf800 &amp;&amp; \
-            image -&gt; green_mask == 0x7e0 &amp;&amp; image -&gt; blue_mask == 0x1f))))
-
-#define ShouldMaskImage(image, mask) (mask -&gt; color_mask != 0xff)
-
-/*
- * Initialize and reset the internal structures.
- */
-
-extern int _NXInternalInitResources(Display *dpy);
-extern int _NXInternalResetResources(Display *dpy);
-extern int _NXInternalInitEncoders(Display *dpy);
-extern int _NXInternalResetEncoders(Display *dpy);
-
-int NXInitDisplay(Display *dpy)
-{
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXInitDisplay: Called for display at [%p].\n&quot;, (void *) dpy);
-  #endif
-
-  if (_NXDisplayInitialized == NULL)
-  {
-    _NXInternalInitResources(dpy);
-
-    _NXInternalInitEncoders(dpy);
-
-    _NXDisplayInitialized = dpy;
-
-    return 1;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXInitDisplay: WARNING! Internal structures already initialized.\n&quot;);
-  #endif
-
-  return 0;
-}
-
-int NXResetDisplay(Display *dpy)
-{
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXResetDisplay: Called for display at [%p].\n&quot;, (void *) dpy);
-  #endif
-
-  if (_NXDisplayInitialized != NULL)
-  {
-    _NXInternalResetResources(dpy);
-
-    _NXInternalResetEncoders(dpy);
-
-    _NXDisplayInitialized = NULL;
-
-    return 1;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXResetDisplay: WARNING! Internal structures already reset.\n&quot;);
-  #endif
-
-  return 0;
-}
-
-int _NXInternalInitResources(Display *dpy)
-{
-  return _NXInternalResetResources(dpy);
-}
-
-int _NXInternalResetResources(Display *dpy)
-{
-  int i;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXInternalResetResources: Clearing all the internal structures.\n&quot;);
-  #endif
-
-  for (i = 0; i &lt; NXNumberOfResources; i++)
-  {
-    _NXSplitResources[i]  = 0;
-    _NXUnpackResources[i] = 0;
-
-    if (_NXCollectedImages[i] != NULL)
-    {
-      #ifdef TEST
-      fprintf(stderr, &quot;******_NXInternalResetResources: WARNING! Clearing collect image data &quot;
-                  &quot;for resource [%d].\n&quot;, i);
-      #endif
-
-      if (_NXCollectedImages[i] -&gt; handler != NULL)
-      {
-        DeqAsyncHandler(dpy, _NXCollectedImages[i] -&gt; handler);
-
-        Xfree(_NXCollectedImages[i] -&gt; handler);
-      }
-
-      if (_NXCollectedImages[i] -&gt; image != NULL)
-      {
-        XDestroyImage(_NXCollectedImages[i] -&gt; image);
-      }
-
-      Xfree(_NXCollectedImages[i]);
-
-      _NXCollectedImages[i] = NULL;
-    }
-
-    if (_NXCollectedProperties[i] != NULL)
-    {
-      #ifdef TEST
-      fprintf(stderr, &quot;******_NXInternalResetResources: WARNING! Clearing collect property data &quot;
-                  &quot;for resource [%d].\n&quot;, i);
-      #endif
-
-      if (_NXCollectedProperties[i] -&gt; handler != NULL)
-      {
-        DeqAsyncHandler(dpy, _NXCollectedProperties[i] -&gt; handler);
-
-        Xfree(_NXCollectedProperties[i] -&gt; handler);
-      }
-
-      if (_NXCollectedProperties[i] -&gt; data != NULL)
-      {
-        Xfree(_NXCollectedProperties[i] -&gt; data);
-      }
-
-      Xfree(_NXCollectedProperties[i]);
-
-      _NXCollectedProperties[i] = NULL;
-    }
-
-    if (_NXCollectedGrabPointers[i] != NULL)
-    {
-      #ifdef TEST
-      fprintf(stderr, &quot;******_NXInternalResetResources: WARNING! Clearing grab pointer data &quot;
-                  &quot;for resource [%d].\n&quot;, i);
-      #endif
-
-      if (_NXCollectedGrabPointers[i] -&gt; handler != NULL)
-      {
-        DeqAsyncHandler(dpy, _NXCollectedGrabPointers[i] -&gt; handler);
-
-        Xfree(_NXCollectedGrabPointers[i] -&gt; handler);
-      }
-
-      Xfree(_NXCollectedGrabPointers[i]);
-
-      _NXCollectedGrabPointers[i] = NULL;
-    }
-
-    if (_NXCollectedInputFocuses[i] != NULL)
-    {
-      #ifdef TEST
-      fprintf(stderr, &quot;******_NXInternalResetResources: WARNING! Clearing collect input focus data &quot;
-                  &quot;for resource [%d].\n&quot;, i);
-      #endif
-
-      if (_NXCollectedInputFocuses[i] -&gt; handler != NULL)
-      {
-        DeqAsyncHandler(dpy, _NXCollectedInputFocuses[i] -&gt; handler);
-
-        Xfree(_NXCollectedInputFocuses[i] -&gt; handler);
-      }
-
-      Xfree(_NXCollectedInputFocuses[i]);
-
-      _NXCollectedInputFocuses[i] = NULL;
-    }
-  }
-
-  return 1;
-}
-
-int _NXInternalInitEncoders(Display *dpy)
-{
-  ZInitEncoder();
-
-  return 1;
-}
-
-int _NXInternalResetEncoders(Display *dpy)
-{
-  ZResetEncoder();
-
-  return 1;
-}
-
-int NXSetDisplayPolicy(Display *dpy, int policy)
-{
-  if (policy == NXPolicyImmediate)
-  {
-    return NXTransPolicy(NX_FD_ANY, NX_POLICY_IMMEDIATE);
-  }
-  else
-  {
-    return NXTransPolicy(NX_FD_ANY, NX_POLICY_DEFERRED);
-  }
-}
-
-int NXSetDisplayBuffer(Display *dpy, int size)
-{
-  /*
-   * This is not multi-thread safe, so,
-   * if you have threads, be sure that
-   * they are stopped.
-   */
-
-  char *buffer;
-
-  XFlush(dpy);
-
-  if (dpy -&gt; bufmax - size == dpy -&gt; buffer)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXSetDisplayBuffer: Nothing to do with buffer size matching.\n&quot;);
-    #endif
-
-    return 1;
-  }
-  else if (dpy -&gt; bufptr != dpy -&gt; buffer)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXSetDisplayBuffer: PANIC! The display buffer is not empty.\n&quot;);
-    #endif
-
-    return -1;
-  }
-  else if ((buffer = Xcalloc(1, size)) == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXSetDisplayBuffer: PANIC! Can't allocate [%d] bytes for the buffer.\n&quot;,
-                size);
-    #endif
-
-    return -1;
-  }
-
-  if (dpy -&gt; buffer != NULL)
-  {
-    Xfree(dpy -&gt; buffer);
-  }
-
-  dpy -&gt; buffer = buffer;
-  dpy -&gt; bufptr = dpy -&gt; buffer;
-  dpy -&gt; bufmax = dpy -&gt; bufptr + size;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetDisplayBuffer: Set the display output buffer size to [%d].\n&quot;,
-              size);
-  #endif
-
-  return 1;
-}
-
-/*
- * If set, the Popen() function in the X server
- * wil remove the LD_LIBRARY_PATH variable from
- * the environment before calling the execl()
- * function on the child process.
- */
-
-int NXUnsetLibraryPath(int value)
-{
-  int previous = _NXUnsetLibraryPath;
-
-  _NXUnsetLibraryPath = value;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXUnsetLibraryPath: Set the flag to [%d] with previous value [%d].\n&quot;,
-              value, previous);
-  #endif
-
-  return previous;
-}
-
-/*
- * If set, the Xlib I/O error handler will simply
- * return, instead of quitting the program. This
- * leaves to the application the responsibility
- * of checking the state of the XlibDisplayIOEr-
- * ror flag.
- */
-
-int NXHandleDisplayError(int value)
-{
-  int previous = _NXHandleDisplayError;
-
-  _NXHandleDisplayError = value;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXHandleDisplayError: Set the flag to [%d] with previous value [%d].\n&quot;,
-              value, previous);
-  #endif
-
-  return previous;
-}
-
-/*
- * Shutdown the display descriptor and force Xlib
- * to set the I/O error flag.
- */
-
-Bool NXForceDisplayError(Display *dpy)
-{
-  if (dpy != NULL)
-  {
-    NXTransClose(dpy -&gt; fd);
-
-    if (!(dpy -&gt; flags &amp; XlibDisplayIOError))
-    {
-      shutdown(dpy -&gt; fd, SHUT_RDWR);
-
-      _XIOError(dpy);
-    }
-
-    return 1;
-  }
-
-  return 0;
-}
-
-/*
- * Check if the display has become invalid. Similarly
- * to the modified Xlib, we call the predicate funct-
- * ion with the value of the XlibDisplayIOError flag
- * only if the I/O error was not encountered already.
- * The application can use this function to query the
- * XlibDisplayIOError flag because Xlib doesn't expose
- * the internals of the display structure to the appli-
- * cation.
- */
-
-int NXDisplayError(Display *dpy)
-{
-  if (dpy != NULL)
-  {
-    return (_XGetIOError(dpy) ||
-                (_NXDisplayErrorFunction != NULL &amp;&amp;
-                    (*_NXDisplayErrorFunction)(dpy, _XGetIOError(dpy))));
-  }
-
-  return 1;
-}
-
-/*
- * Various queries related to the state of the
- * display connection.
- */
-
-int NXDisplayReadable(Display *dpy)
-{
-  int result;
-  int readable;
-
-  result = NXTransReadable(dpy -&gt; fd, &amp;readable);
-
-  if (result == 0)
-  {
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******NXDisplayReadable: Returning [%d] bytes readable from fd [%d].\n&quot;,
-                readable, dpy -&gt; fd);
-    #endif
-
-    return readable;
-  }
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******NXDisplayReadable: WARNING! Error detected on display fd [%d].\n&quot;,
-              dpy -&gt; fd);
-  #endif
-
-  return -1;
-}
-
-int NXDisplayFlushable(Display *dpy)
-{
-  #ifdef DEBUG
-
-  int flushable;
-
-  flushable = NXTransFlushable(dpy -&gt; fd) +
-                  (dpy -&gt; bufptr - dpy -&gt; buffer);
-
-  fprintf(stderr, &quot;******NXDisplayFlushable: Returning [%d+%d=%d] bytes flushable &quot;
-              &quot;to fd [%d].\n&quot;, (int) (dpy -&gt; bufptr - dpy -&gt; buffer),
-                  (int) (flushable - (dpy -&gt; bufptr - dpy -&gt; buffer)),
-                      flushable, dpy -&gt; fd);
-
-  return flushable;
-
-  #else
-
-  return NXTransFlushable(dpy -&gt; fd) + (dpy -&gt; bufptr - dpy -&gt; buffer);
-
-  #endif
-}
-
-int NXDisplayCongestion(Display *dpy)
-{
-  #ifdef DEBUG
-
-  int congestion = NXTransCongestion(dpy -&gt; fd);
-
-  fprintf(stderr, &quot;******NXDisplayCongestion: Returning [%d] as congestion level for fd [%d].\n&quot;,
-              congestion, dpy -&gt; fd);
-
-  return congestion;
-
-  #else
-
-  return NXTransCongestion(dpy -&gt; fd);
-
-  #endif
-}
-
-int NXFlushDisplay(Display *dpy, int what)
-{
-  if (!(dpy -&gt; flags &amp; XlibDisplayWriting) &amp;&amp;
-          dpy -&gt; bufptr - dpy -&gt; buffer &gt; 0)
-  {
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******NXFlushDisplay: Writing with [%d] bytes in the buffer.\n&quot;,
-            (int) (dpy -&gt; bufptr - dpy -&gt; buffer));
-    #endif
-
-    XFlush(dpy);
-  }
-
-  if (what == NXFlushBuffer)
-  {
-    return 0;
-  }
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******NXFlushDisplay: Flushing with [%d] bytes in the NX transport.\n&quot;,
-              NXDisplayFlushable(dpy));
-  #endif
-
-  return NXTransFlush(dpy -&gt; fd);
-}
-
-NXDisplayErrorPredicate NXSetDisplayErrorPredicate(NXDisplayErrorPredicate predicate)
-{
-  NXDisplayErrorPredicate previous = _NXDisplayErrorFunction;
-
-  _NXDisplayErrorFunction = predicate;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetDisplayErrorPredicate: Set the predicate to [%p] with previous value [%p].\n&quot;,
-              predicate, previous);
-  #endif
-
-  return previous;
-}
-
-NXDisplayBlockHandler NXSetDisplayBlockHandler(NXDisplayBlockHandler handler)
-{
-  NXDisplayBlockHandler previous = _NXDisplayBlockFunction;
-
-  _NXDisplayBlockFunction = handler;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetDisplayBlockHandler: Set the handler to [%p] with previous value [%p].\n&quot;,
-              handler, previous);
-  #endif
-
-  return previous;
-}
-
-NXDisplayWriteHandler NXSetDisplayWriteHandler(NXDisplayWriteHandler handler)
-{
-  NXDisplayWriteHandler previous = _NXDisplayWriteFunction;
-
-  _NXDisplayWriteFunction = handler;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetDisplayWriteHandler: Set the handler to [%p] with previous value [%p].\n&quot;,
-              handler, previous);
-  #endif
-
-  return previous;
-}
-
-NXDisplayFlushHandler NXSetDisplayFlushHandler(NXDisplayFlushHandler handler, Display *display)
-{
-  NXDisplayFlushHandler previous = _NXDisplayFlushFunction;
-
-  _NXDisplayFlushFunction = handler;
-
-  NXTransHandler(NX_FD_ANY, NX_HANDLER_FLUSH,
-                     (void (*)(void *, int)) handler, (void *) display);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetDisplayFlushHandler: Set the handler to [%p] with display [%p] &quot;
-              &quot;and previous value [%p].\n&quot;, handler, display, previous);
-  #endif
-
-  return previous;
-}
-
-NXDisplayStatisticsHandler NXSetDisplayStatisticsHandler(NXDisplayStatisticsHandler handler, char **buffer)
-{
-  NXDisplayStatisticsHandler previous = _NXDisplayStatisticsFunction;
-
-  _NXDisplayStatisticsFunction = handler;
-
-  /*
-   * Propagate the handler.
-   */
-
-  NXTransHandler(NX_FD_ANY, NX_HANDLER_STATISTICS,
-                     (void (*)(void *, int)) handler, (void *) buffer);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetDisplayStatisticsHandler: Set the handler to [%p] with buffer pointer [%p] &quot;
-              &quot;and previous value [%p].\n&quot;, handler, buffer, previous);
-  #endif
-
-  return previous;
-}
-
-NXLostSequenceHandler NXSetLostSequenceHandler(NXLostSequenceHandler handler)
-{
-  NXLostSequenceHandler previous = _NXLostSequenceFunction;
-
-  _NXLostSequenceFunction = handler;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetLostSequenceHandler: Set the handler to [%p] with previous value [%p].\n&quot;,
-              handler, previous);
-  #endif
-
-  return previous;
-}
-
-int _NXInternalReplyErrorFunction(Display *dpy, XErrorEvent *error)
-{
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXInternalReplyErrorFunction: Internal error handler called.\n&quot;);
-  #endif
-
-  return 0;
-}
-
-void _NXInternalLostSequenceFunction(Display *dpy, unsigned long newseq,
-                                         unsigned long lastseq, unsigned int type)
-{
-  #ifdef TEST
-
-  fprintf(stderr, &quot;******_NXInternalLostSequenceFunction: WARNING! Sequence lost with new &quot;
-              &quot;sequence %ld last request %ld.\n&quot;, newseq, dpy -&gt; request);
-
-  /*
-   * TODO: Reply or event info must be implemented.
-   *
-   * fprintf(stderr, &quot;******_NXInternalLostSequenceFunction: WARNING! Expected event or reply &quot;
-   *             &quot;was %ld with sequence %ld.\n&quot;, (long) rep -&gt; type, (long) rep -&gt; sequenceNumber);
-   */
-
-  fprintf(stderr, &quot;******_NXInternalLostSequenceFunction: WARNING! Last sequence read &quot;
-              &quot;was %ld display request is %ld.\n&quot;, lastseq &amp; 0xffff, dpy -&gt; request &amp; 0xffff);
-
-  #endif
-}
-
-Status NXGetControlParameters(Display *dpy, unsigned int *link_type, unsigned int *local_major,
-                                  unsigned int *local_minor, unsigned int *local_patch,
-                                      unsigned int *remote_major, unsigned int *remote_minor,
-                                          unsigned int *remote_patch, int *split_timeout, int *motion_timeout,
-                                              int *split_mode, int *split_size, unsigned int *pack_method,
-                                                  unsigned int *pack_quality, int *data_level, int *stream_level,
-                                                      int *delta_level, unsigned int *load_cache,
-                                                          unsigned int *save_cache, unsigned int *startup_cache)
-{
-  xNXGetControlParametersReply rep;
-
-  register xReq *req;
-
-  LockDisplay(dpy);
-
-  GetEmptyReq(NXGetControlParameters, req);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXGetControlParameters: Sending message opcode [%d].\n&quot;,
-              X_NXGetControlParameters);
-  #endif
-
-  if (_XReply(dpy, (xReply *) &amp;rep, 0, xTrue) == xFalse)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXGetControlParameters: Error receiving reply.\n&quot;);
-    #endif
-
-    UnlockDisplay(dpy);
-
-    SyncHandle();
-
-    return 0;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXGetControlParameters: Got reply with link type [%u].\n&quot;, rep.linkType);
-
-  fprintf(stderr, &quot;******NXGetControlParameters: Local protocol major [%u] minor [%u] patch [%u].\n&quot;,
-              rep.localMajor, rep.localMinor, rep.localPatch);
-
-  fprintf(stderr, &quot;******NXGetControlParameters: Remote protocol major [%u] minor [%u] patch [%u].\n&quot;,
-              rep.remoteMajor, rep.remoteMinor, rep.remotePatch);
-
-  fprintf(stderr, &quot;******NXGetControlParameters: Split timeout [%d] motion timeout [%d].\n&quot;,
-              (int) rep.splitTimeout, (int) rep.motionTimeout);
-
-  fprintf(stderr, &quot;******NXGetControlParameters: Split mode [%d] split size [%d].\n&quot;,
-              (int) rep.splitMode, (int) rep.splitSize);
-
-  fprintf(stderr, &quot;******NXGetControlParameters: Preferred pack method [%d] pack quality [%d].\n&quot;,
-              (int) rep.packMethod, (int) rep.packQuality);
-
-  fprintf(stderr, &quot;******NXGetControlParameters: Data level [%d] stream level [%d] delta level [%d].\n&quot;,
-              rep.dataLevel, rep.streamLevel, rep.deltaLevel);
-  #endif
-
-  *link_type = rep.linkType;
-
-  *local_major = rep.localMajor;
-  *local_minor = rep.localMinor;
-  *local_patch = rep.localPatch;
-
-  *remote_major = rep.remoteMajor;
-  *remote_minor = rep.remoteMinor;
-  *remote_patch = rep.remotePatch;
-
-  *split_timeout  = rep.splitTimeout;
-  *motion_timeout = rep.motionTimeout;
-
-  *split_mode = rep.splitMode;
-  *split_size = rep.splitSize;
-
-  *pack_method  = rep.packMethod;
-  *pack_quality = rep.packQuality;
-
-  *data_level   = rep.dataLevel;
-  *stream_level = rep.streamLevel;
-  *delta_level  = rep.deltaLevel;
-
-  *load_cache    = rep.loadCache;
-  *save_cache    = rep.saveCache;
-  *startup_cache = rep.startupCache;
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  /*
-   * Install our internal out-of-sync handler.
-   */
-
-  _NXLostSequenceFunction = _NXInternalLostSequenceFunction;
-
-  return 1;
-}
-
-/*
- * Which unpack methods are supported by the
- * remote proxy?
- */
-
-Status NXGetUnpackParameters(Display *dpy, unsigned int *entries, unsigned char supported_methods[])
-{
-  register xNXGetUnpackParametersReq *req;
-
-  xNXGetUnpackParametersReply rep;
-
-  register unsigned n;
-
-  #ifdef TEST
-  register unsigned i;
-  #endif
-
-  if (*entries &lt; NXNumberOfPackMethods)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXGetUnpackParameters: Requested only [%d] entries while they should be [%d].\n&quot;,
-                *entries, NXNumberOfPackMethods);
-    #endif
-
-    return 0;
-  }
-
-  LockDisplay(dpy);
-
-  GetReq(NXGetUnpackParameters, req);
-
-  req -&gt; entries = *entries;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXGetUnpackParameters: Sending message opcode [%d] with [%d] requested entries.\n&quot;,
-              X_NXGetUnpackParameters, *entries);
-  #endif
-
-  if (_XReply(dpy, (xReply *) &amp;rep, 0, xFalse) == xFalse || rep.length == 0)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXGetUnpackParameters: Error receiving reply.\n&quot;);
-    #endif
-
-    UnlockDisplay(dpy);
-
-    SyncHandle();
-
-    return 0;
-  }
-
-  if ((n = rep.length &lt;&lt; 2) &gt; *entries)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXGetUnpackParameters: Got [%d] bytes of reply data while they should be [%d].\n&quot;,
-                n, *entries);
-    #endif
-
-    _XEatData(dpy, (unsigned long) n);
-
-    UnlockDisplay(dpy);
-
-    SyncHandle();
-
-    return 0;
-  }
-
-  *entries = n;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXGetUnpackParameters: Reading [%d] bytes of reply data.\n&quot;, n);
-  #endif
-
-  _XReadPad(dpy, (char *) supported_methods, n);
-
-  #ifdef TEST
-
-  fprintf(stderr, &quot;******NXGetUnpackParameters: Got reply with methods: &quot;);
-
-  for (i = 0; i &lt; n; i++)
-  {
-    if (supported_methods[i] != 0)
-    {
-      fprintf(stderr, &quot;[%d]&quot;, i);
-    }
-  }
-  
-  fprintf(stderr, &quot;.\n&quot;);
-
-  #endif
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-/*
- * Query and enable the MIT-SHM support between the
- * proxy and the X server. The 'enable' flags must be
- * true if shared memory PutImages and PutPackedImages
- * are desired. On return the flags will say if support
- * has been successfully enabled.
- *
- * Note that the the client part is not useful and not
- * implemented. The size of the segment is chosen by
- * the proxy. The main purpose of the message is to
- * reserve the XID that will be used by the remote.
- */
-
-Status NXGetShmemParameters(Display *dpy, unsigned int *enable_client,
-                                unsigned int *enable_server, unsigned int *client_segment,
-                                    unsigned int *server_segment, unsigned int *client_size,
-                                        unsigned int *server_size)
-{
-  register xNXGetShmemParametersReq *req;
-
-  register int stage;
-
-  xNXGetShmemParametersReply rep;
-
-  /*
-   * Save the previous handler.
-   */
-
-  int (*handler)(Display *, XErrorEvent *) = _XErrorFunction;
-
-  *client_segment = 0;
-  *server_segment = 0;
-
-  if (*enable_client)
-  {
-    *client_segment = XAllocID(dpy);
-  }
-
-  if (*enable_server)
-  {
-    *server_segment = XAllocID(dpy);
-  }
-
-  LockDisplay(dpy);
-
-  _XErrorFunction = _NXInternalReplyErrorFunction;
-
-  for (stage = 0; stage &lt; 3; stage++)
-  {
-    GetReq(NXGetShmemParameters, req);
-
-    req -&gt; stage = stage;
-
-    req -&gt; enableClient = (*enable_client != 0 ? 1 : 0);
-    req -&gt; enableServer = (*enable_server != 0 ? 1 : 0);
-
-    req -&gt; clientSegment = *client_segment;
-    req -&gt; serverSegment = *server_segment;
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXGetShmemParameters: Sending message opcode [%d] at stage [%d].\n&quot;,
-                X_NXGetShmemParameters, stage);
-    #endif
-
-    #ifdef TEST
-
-    if (stage == 0)
-    {
-      fprintf(stderr, &quot;******NXGetShmemParameters: Enable client is [%u] enable server is [%u].\n&quot;,
-                  *enable_client, *enable_server);
-
-      fprintf(stderr, &quot;******NXGetShmemParameters: Client segment is [%u] server segment is [%u].\n&quot;,
-                  *client_segment, *server_segment);
-    }
-
-    #endif
-
-    /*
-     * There isn't X server reply in the second stage.
-     * The procedure followed at X server side is:
-     *
-     * Stage 0: Send X_QueryExtension and masquerade
-     *          the reply.
-     *
-     * Stage 1: Allocate the shared memory and send
-     *          X_ShmAttach to the X server.
-     *
-     * Stage 2: Send X_GetInputFocus and masquerade
-     *          the reply.
-     *
-     * The last message is used to force a reply and
-     * collect any X error caused by a failure in the
-     * shared memory initialization.
-     */
-
-    if (stage != 1)
-    {
-      /*
-       * We are only interested in the final reply.
-       */
-
-      if (_XReply(dpy, (xReply *) &amp;rep, 0, xTrue) == xFalse)
-      {
-        #ifdef TEST
-        fprintf(stderr, &quot;******NXGetShmemParameters: Error receiving reply.\n&quot;);
-        #endif
-
-        _XErrorFunction = handler;
-
-        UnlockDisplay(dpy);
-
-        SyncHandle();
-
-        return 0;
-      }
-    }
-  }
-
-  /*
-   * Return the settings to client.
-   */
-
-  *enable_client = rep.clientEnabled;
-  *enable_server = rep.serverEnabled;
-
-  *client_size = rep.clientSize;
-  *server_size = rep.serverSize;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXGetShmemParameters: Got final reply with enabled client [%u] and server [%u].\n&quot;,
-              *enable_client, *enable_server);
-
-  fprintf(stderr, &quot;******NXGetShmemParameters: Client segment size [%u] server segment size [%u].\n&quot;,
-              *client_size, *server_size);
-  #endif
-
-  _XErrorFunction = handler;
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-/*
- * Get the path to the font server that can be used by the X
- * server to tunnel the font connections across the NX link.
- * The path actually represents the TCP port where the proxy
- * on the NX client side is listening. The agent can tempora-
- * rily enable the tunneling when it needs a font that is not
- * available on the client, for example when the session is
- * migrated from a different X server.
- *
- * Note that it is not advisable to use the font server chan-
- * nel for other purposes than restoring a font that is found
- * missing at the time the session is migrated to a different
- * display. This is because the agent implements a caching of
- * the list of fonts supported by the client as it needs to
- * advertise only the fonts that can be opened at both sides.
- */
-
-Status NXGetFontParameters(Display *dpy, unsigned int path_length, char path_data[])
-{
-  register xNXGetFontParametersReq *req;
-
-  xNXGetFontParametersReply rep;
-
-  register unsigned n;
-
-  #ifdef TEST
-  register unsigned i;
-  #endif
-
-  if (path_length &lt; 1)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXGetFontParameters: No room to store the reply.\n&quot;);
-    #endif
-
-    return 0;
-  }
-
-  *path_data = '\0';
-
-  LockDisplay(dpy);
-
-  GetReq(NXGetFontParameters, req);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXGetFontParameters: Sending message opcode [%d].\n&quot;,
-              X_NXGetFontParameters);
-  #endif
-
-  if (_XReply(dpy, (xReply *) &amp;rep, 0, xFalse) == xFalse || rep.length == 0)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXGetFontParameters: Error receiving reply.\n&quot;);
-    #endif
-
-    UnlockDisplay(dpy);
-
-    SyncHandle();
-
-    return 0;
-  }
-
-  if ((n = rep.length &lt;&lt; 2) &gt; path_length)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXGetFontParameters: Got [%d] bytes of reply data with only room for [%d].\n&quot;,
-                n, path_length);
-    #endif
-
-    _XEatData(dpy, (unsigned long) n);
-
-    UnlockDisplay(dpy);
-
-    SyncHandle();
-
-    return 0;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXGetFontParameters: Reading [%d] bytes of reply data.\n&quot;, n);
-  #endif
-
-  _XReadPad(dpy, (char *) path_data, n);
-
-  /*
-   * Check if the string can be fully
-   * contained by the buffer.
-   */
-
-  if (*path_data &gt; path_length - 1)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXGetFontParameters: Inconsistent length in the returned string.\n&quot;);
-    #endif
-
-    UnlockDisplay(dpy);
-
-    SyncHandle();
-
-    return 0;
-  }
-
-  #ifdef TEST
-
-  fprintf(stderr, &quot;******NXGetFontParameters: Got font path of [%d] bytes and value [&quot;,
-              (int) *path_data);
-
-  for (i = 0; i &lt; *path_data; i++)
-  {
-    fprintf(stderr, &quot;%c&quot;, *(path_data + i + 1));
-  }
-  
-  fprintf(stderr, &quot;].\n&quot;);
-
-  #endif
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-unsigned int NXAllocSplit(Display *dpy, unsigned int resource)
-{
-  if (resource == NXAnyResource)
-  {
-    for (resource = 0; resource &lt; NXNumberOfResources; resource++)
-    {
-      if (_NXSplitResources[resource] == 0)
-      {
-        _NXSplitResources[resource] = 1;
-
-        #ifdef TEST
-        fprintf(stderr, &quot;******NXAllocSplit: Reserved resource [%u].\n&quot;,
-                    resource);
-        #endif
-    
-        return resource;
-      }
-    }
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXAllocSplit: WARNING! Resource limit exausted.\n&quot;);
-    #endif
-
-    return NXNoResource;
-  }
-  else if (resource &gt;= 0 &amp;&amp; resource &lt; NXNumberOfResources)
-  {
-    #ifdef TEST
-
-    if (_NXSplitResources[resource] == 0)
-    {
-      fprintf(stderr, &quot;******NXAllocSplit: Reserved requested resource [%u].\n&quot;,
-                  resource);
-    }
-    else
-    {
-      fprintf(stderr, &quot;******NXAllocSplit: Requested resource [%u] already reserved.\n&quot;,
-                  resource);
-    }
-
-    #endif
-    
-    _NXSplitResources[resource] = 1;
-  }
-
-  #ifdef PANIC
-  fprintf(stderr, &quot;******NXAllocSplit: PANIC! Can't reserve requested resource [%u].\n&quot;,
-              resource);
-  #endif
-
-  return NXNoResource;
-}
-
-/*
- * Tell the proxy to split the next messages.
- */
-
-int NXStartSplit(Display *dpy, unsigned int resource, unsigned int mode)
-{
-  register xNXStartSplitReq *req;
-
-  LockDisplay(dpy);
-
-  GetReq(NXStartSplit, req);
-
-  req -&gt; resource = resource;
-  req -&gt; mode     = mode;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXStartSplit: Sending opcode [%d] with resource [%d] mode [%d].\n&quot;,
-              X_NXStartSplit, resource, mode);
-  #endif
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-/*
- * Send the closure of the split sequence and
- * tell the proxy to send the results.
- */
-
-int NXEndSplit(Display *dpy, unsigned int resource)
-{
-  register xNXEndSplitReq *req;
-
-  LockDisplay(dpy);
-
-  GetReq(NXEndSplit, req);
-
-  req -&gt; resource = resource;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXEndSplit: Sending opcode [%d] with resource [%d].\n&quot;,
-              X_NXStartSplit, resource);
-  #endif
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-/*
- * This message must be sent whenever the proxy notifies
- * the client of the completion of a split. If the 'pro-
- * pagate' field is 0, the proxy will not send the ori-
- * ginal request to the X server, but will only free the
- * internal state.
- */
-
-int NXCommitSplit(Display *dpy, unsigned int resource, unsigned int propagate,
-                      unsigned char request, unsigned int position)
-{
-  register xNXCommitSplitReq *req;
-
-  LockDisplay(dpy);
-
-  GetReq(NXCommitSplit, req);
-
-  req -&gt; resource  = resource;
-  req -&gt; propagate = propagate;
-  req -&gt; request   = request;
-  req -&gt; position  = position;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXCommitSplit: Sending opcode [%d] with resource [%d] propagate [%d] &quot;
-              &quot;request [%d] position [%d].\n&quot;, X_NXCommitSplit, resource,
-                  propagate, request, position);
-  #endif
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-int NXAbortSplit(Display *dpy, unsigned int resource)
-{
-  register xNXAbortSplitReq *req;
-
-  LockDisplay(dpy);
-
-  GetReq(NXAbortSplit, req);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXAbortSplit: Sending message opcode [%d] with resource [%u].\n&quot;,
-              X_NXAbortSplit, resource);
-  #endif
-
-  req -&gt; resource = resource;
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-int NXFinishSplit(Display *dpy, unsigned int resource)
-{
-  register xNXFinishSplitReq *req;
-
-  LockDisplay(dpy);
-
-  GetReq(NXFinishSplit, req);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXFinishSplit: Sending message opcode [%d] with resource [%u].\n&quot;,
-              X_NXFinishSplit, resource);
-  #endif
-
-  req -&gt; resource = resource;
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-int NXFreeSplit(Display *dpy, unsigned int resource)
-{
-  register xNXFreeSplitReq *req;
-
-  if (_NXSplitResources[resource] != 0)
-  {
-    LockDisplay(dpy);
-
-    GetReq(NXFreeSplit, req);
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXFreeSplit: Sending message opcode [%d] with resource [%u].\n&quot;,
-                X_NXFreeSplit, resource);
-    #endif
-
-    req -&gt; resource = resource;
-
-    UnlockDisplay(dpy);
-
-    SyncHandle();
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXFreeSplit: Making the resource [%u] newly available.\n&quot;,
-                resource);
-    #endif
-
-    _NXSplitResources[resource] = 0;
-  }
-  #ifdef TEST
-  else
-  {
-    fprintf(stderr, &quot;******NXFreeSplit: Nothing to do for resource [%u].\n&quot;,
-                resource);
-  }
-  #endif
-
-  return 1;
-}
-
-/*
- * Tell to remote proxy to discard expose events
- * of one or more types.
- */
-
-int NXSetExposeParameters(Display *dpy, int expose, int graphics_expose, int no_expose)
-{
-  register xNXSetExposeParametersReq *req;
-
-  LockDisplay(dpy);
-
-  GetReq(NXSetExposeParameters, req);
-
-  req -&gt; expose         = expose;
-  req -&gt; graphicsExpose = graphics_expose;
-  req -&gt; noExpose       = no_expose;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetExposeParameters: Sending message opcode [%d] with flags [%d][%d][%d].\n&quot;,
-              X_NXSetExposeParameters, req -&gt; expose, req -&gt; graphicsExpose, req -&gt; noExpose);
-  #endif
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-/*
- * Tell to the local proxy how to handle the next requests.
- */
-
-int NXSetCacheParameters(Display *dpy, int enable_cache, int enable_split,
-                             int enable_save, int enable_load)
-{
-  register xNXSetCacheParametersReq *req;
-
-  LockDisplay(dpy);
-
-  GetReq(NXSetCacheParameters, req);
-
-  req -&gt; enableCache = enable_cache;
-  req -&gt; enableSplit = enable_split;
-  req -&gt; enableSave  = enable_save;
-  req -&gt; enableLoad  = enable_load;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetCacheParameters: Sending message opcode [%d] with &quot;
-              &quot;flags [%d][%d][%d][%d].\n&quot;, X_NXSetCacheParameters, req -&gt; enableCache,
-                  req -&gt; enableSplit, req -&gt; enableSave, req -&gt; enableLoad);
-  #endif
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-unsigned int NXAllocUnpack(Display *dpy, unsigned int resource)
-{
-  if (resource == NXAnyResource)
-  {
-    for (resource = 0; resource &lt; NXNumberOfResources; resource++)
-    {
-      if (_NXUnpackResources[resource] == 0)
-      {
-        _NXUnpackResources[resource] = 1;
-
-        #ifdef TEST
-        fprintf(stderr, &quot;******NXAllocUnpack: Reserved resource [%u].\n&quot;,
-                    resource);
-        #endif
-    
-        return resource;
-      }
-    }
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXAllocUnpack: WARNING! Resource limit exausted.\n&quot;);
-    #endif
-
-    return NXNoResource;
-  }
-  else if (resource &gt;= 0 &amp;&amp; resource &lt; NXNumberOfResources)
-  {
-    #ifdef TEST
-
-    if (_NXUnpackResources[resource] == 0)
-    {
-      fprintf(stderr, &quot;******NXAllocUnpack: Reserved requested resource [%u].\n&quot;,
-                  resource);
-    }
-    else
-    {
-      fprintf(stderr, &quot;******NXAllocUnpack: Requested resource [%u] already reserved.\n&quot;,
-                  resource);
-    }
-
-    #endif
-    
-    _NXUnpackResources[resource] = 1;
-  }
-
-  #ifdef PANIC
-  fprintf(stderr, &quot;******NXAllocUnpack: PANIC! Can't reserve requested resource [%u].\n&quot;,
-              resource);
-  #endif
-
-  return NXNoResource;
-}
-
-int NXSetUnpackGeometry(Display *dpy, unsigned int resource, Visual *visual)
-{
-  register xNXSetUnpackGeometryReq *req;
-
-  LockDisplay(dpy);
-
-  GetReq(NXSetUnpackGeometry, req);
-
-  req -&gt; resource = resource;
-
-  req -&gt; depth1Bpp  = _XGetBitsPerPixel(dpy, 1);
-  req -&gt; depth4Bpp  = _XGetBitsPerPixel(dpy, 4);
-  req -&gt; depth8Bpp  = _XGetBitsPerPixel(dpy, 8);
-  req -&gt; depth16Bpp = _XGetBitsPerPixel(dpy, 16);
-  req -&gt; depth24Bpp = _XGetBitsPerPixel(dpy, 24);
-  req -&gt; depth32Bpp = _XGetBitsPerPixel(dpy, 32);
-
-  if (visual != NULL)
-  {
-    req -&gt; redMask   = visual -&gt; red_mask;
-    req -&gt; greenMask = visual -&gt; green_mask;
-    req -&gt; blueMask  = visual -&gt; blue_mask;
-  }
-  else
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXSetUnpackGeometry: PANIC! Can't set the geometry without a visual.\n&quot;);
-    #endif
-
-    UnGetReq(NXSetUnpackGeometry);
-
-    UnlockDisplay(dpy);
-
-    return -1;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetUnpackGeometry: Resource [%u] Depth/Bpp [1/%d][4/%d][8/%d]&quot;
-              &quot;[16/%d][24/%d][32/%d].\n&quot;, resource, req -&gt; depth1Bpp, req -&gt; depth4Bpp,
-                  req -&gt; depth8Bpp, req -&gt; depth16Bpp, req -&gt; depth24Bpp, req -&gt; depth32Bpp);
-
-  fprintf(stderr, &quot;******NXSetUnpackGeometry: red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
-               (unsigned) req -&gt; redMask, (unsigned) req -&gt; greenMask, (unsigned) req -&gt; blueMask);
-  #endif
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-/*
- * Store a colormap table on the remote side.
- * The colormap can then be used to unpack
- * an image.
- */
-
-int NXSetUnpackColormap(Display *dpy, unsigned int resource, unsigned int method,
-                            unsigned int entries, const char *data, unsigned int data_length)
-{
-  register xNXSetUnpackColormapReq *req;
-
-  register int dst_data_length;
-
-  LockDisplay(dpy);
-
-  GetReq(NXSetUnpackColormap, req);
-
-  req -&gt; resource  = resource;
-  req -&gt; method    = method;
-
-  req -&gt; srcLength = data_length;
-  req -&gt; dstLength = entries &lt;&lt; 2;
-
-  dst_data_length = ROUNDUP(data_length, 4);
-
-  req -&gt; length += (dst_data_length &gt;&gt; 2);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetUnpackColormap: Resource [%u] data size [%u] destination &quot;
-              &quot;data size [%u].\n&quot;, resource, data_length, dst_data_length);
-  #endif
-
-  if (data_length &gt; 0)
-  {
-    if (dpy -&gt; bufptr + dst_data_length &lt;= dpy -&gt; bufmax)
-    {
-      /*
-       * Clean the padding bytes in the request.
-       */
-
-      *((int *) (dpy -&gt; bufptr + dst_data_length - 4)) = 0x0;
-
-      memcpy(dpy -&gt; bufptr, data, data_length);
-
-      dpy -&gt; bufptr += dst_data_length;
-    }
-    else
-    {
-      /*
-       * The _XSend() will pad the request for us.
-       */
-
-      _XSend(dpy, data, data_length);
-    }
-  }
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-/*
- * Store data of the alpha blending channel
- * that will be combined with the next image
- * to be unpacked.
- */
-
-int NXSetUnpackAlpha(Display *dpy, unsigned int resource, unsigned int method,
-                         unsigned int entries, const char *data, unsigned int data_length)
-{
-  register xNXSetUnpackAlphaReq *req;
-
-  register unsigned int dst_data_length;
-
-  LockDisplay(dpy);
-
-  GetReq(NXSetUnpackAlpha, req);
-
-  req -&gt; resource  = resource;
-  req -&gt; method    = method;
-
-  req -&gt; srcLength = data_length;
-  req -&gt; dstLength = entries;
-
-  dst_data_length = ROUNDUP(data_length, 4);
-
-  req -&gt; length += (dst_data_length &gt;&gt; 2);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetUnpackAlpha: Resource [%u] data size [%u] destination data size [%u].\n&quot;,
-              resource, data_length, dst_data_length);
-  #endif
-
-  if (data_length &gt; 0)
-  {
-    if (dpy -&gt; bufptr + dst_data_length &lt;= dpy -&gt; bufmax)
-    {
-      /*
-       * Clean the padding bytes in the request.
-       */
-
-      *((int *) (dpy -&gt; bufptr + dst_data_length - 4)) = 0x0;
-
-      memcpy(dpy -&gt; bufptr, data, data_length);
-
-      dpy -&gt; bufptr += dst_data_length;
-    }
-    else
-    {
-      /*
-       * The _XSend() will pad the request for us.
-       */
-
-      _XSend(dpy, data, data_length);
-    }
-  }
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-/*
- * Compatibility versions to be used when
- * connected to a 1.X.X proxy.
- */
-
-/*
- * These are for compatibility with the 1.X.X
- * versions.
- */
-
-#define sz_xNXSetUnpackColormapCompatReq        8
-
-typedef struct _NXSetUnpackColormapCompatReq {
-    CARD8  reqType;
-    CARD8  resource;
-    CARD16 length B16;
-    CARD32 entries B32;
-} xNXSetUnpackColormapCompatReq;
-
-#define X_NXSetUnpackColormapCompat  X_NXSetUnpackColormap
-
-int NXSetUnpackColormapCompat(Display *dpy, unsigned int resource,
-                                  unsigned int entries, const char *data)
-{
-  register xNXSetUnpackColormapCompatReq *req;
-
-  register char *dst_data;
-
-  register int dst_data_length;
-
-  #ifdef DUMP
-
-  int i;
-
-  #endif
-
-  LockDisplay(dpy);
-
-  GetReq(NXSetUnpackColormapCompat, req);
-
-  req -&gt; resource = resource;
-  req -&gt; entries  = entries;
-
-  dst_data_length = entries &lt;&lt; 2;
-
-  req -&gt; length += (dst_data_length &gt;&gt; 2);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetUnpackColormapCompat: Resource [%u] number of entries [%u] &quot;
-              &quot;destination data size [%u].\n&quot;, resource, entries, dst_data_length);
-  #endif
-
-  if (entries &gt; 0)
-  {
-    if ((dpy -&gt; bufptr + dst_data_length) &lt;= dpy -&gt; bufmax)
-    {
-      dst_data = dpy -&gt; bufptr;
-    }
-    else
-    {
-      if ((dst_data = _XAllocScratch(dpy, dst_data_length)) == NULL)
-      {
-        #ifdef PANIC
-        fprintf(stderr, &quot;******NXSetUnpackColormapCompat: PANIC! Cannot allocate memory.\n&quot;);
-        #endif
-
-        UnGetReq(NXSetUnpackColormapCompat);
-
-        UnlockDisplay(dpy);
-
-        return -1;
-      }
-    }
-
-    memcpy(dst_data, data, entries &lt;&lt; 2);
-
-    #ifdef DUMP
-
-    fprintf(stderr, &quot;******NXSetUnpackColormapCompat: Dumping colormap entries:\n&quot;);
-
-    for (i = 0; i &lt; entries; i++)
-    {
-      fprintf(stderr, &quot;******NXSetUnpackColormapCompat: [%d] -&gt; [0x%x].\n&quot;,
-                  i, *((int *) (dst_data + (i * 4))));
-    }
-
-    #endif
-
-    if (dst_data == dpy -&gt; bufptr)
-    {
-      dpy -&gt; bufptr += dst_data_length;
-    }
-    else
-    {
-      _XSend(dpy, dst_data, dst_data_length);
-    }
-  }
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-#define sz_xNXSetUnpackAlphaCompatReq  8
-
-typedef struct _NXSetUnpackAlphaCompatReq {
-    CARD8  reqType;
-    CARD8  resource;
-    CARD16 length B16;
-    CARD32 entries B32;
-} xNXSetUnpackAlphaCompatReq;
-
-#define X_NXSetUnpackAlphaCompat  X_NXSetUnpackAlpha
-
-int NXSetUnpackAlphaCompat(Display *dpy, unsigned int resource,
-                               unsigned int entries, const char *data)
-{
-  register xNXSetUnpackAlphaCompatReq *req;
-
-  register char *dst_data;
-
-  register unsigned int dst_data_length;
-
-  #ifdef DUMP
-
-  int i;
-
-  #endif
-
-  LockDisplay(dpy);
-
-  GetReq(NXSetUnpackAlphaCompat, req);
-
-  req -&gt; resource = resource;
-  req -&gt; entries  = entries;
-
-  dst_data_length = ROUNDUP(entries, 4);
-
-  req -&gt; length += (dst_data_length &gt;&gt; 2);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXSetUnpackAlphaCompat: Resource [%u] number of entries [%u] &quot;
-              &quot;destination data size [%u].\n&quot;, resource, entries, dst_data_length);
-  #endif
-
-  if (entries &gt; 0)
-  {
-    if ((dpy -&gt; bufptr + dst_data_length) &lt;= dpy -&gt; bufmax)
-    {
-      dst_data = dpy -&gt; bufptr;
-    }
-    else
-    {
-      if ((dst_data = _XAllocScratch(dpy, dst_data_length)) == NULL)
-      {
-        #ifdef PANIC
-        fprintf(stderr, &quot;******NXSetUnpackAlphaCompat: PANIC! Cannot allocate memory.\n&quot;);
-        #endif
-
-        UnGetReq(NXSetUnpackAlphaCompat);
-
-        UnlockDisplay(dpy);
-
-        return -1;
-      }
-    }
-
-    memcpy(dst_data, data, entries);
-
-    if (dst_data_length != entries)
-    {
-      memset(dst_data + entries, 0, dst_data_length - entries);
-    }
-
-    #ifdef DUMP
-
-    fprintf(stderr, &quot;******NXSetUnpackAlphaCompat: Dumping alpha channel data:\n&quot;);
-
-    for (i = 0; i &lt; dst_data_length; i++)
-    {
-      fprintf(stderr, &quot;******NXSetUnpackAlphaCompat: [%d] -&gt; [0x%02x].\n&quot;,
-                  i, ((unsigned int) *(dst_data + i)) &amp; 0xff);
-    }
-
-    #endif
-
-    if (dst_data == dpy -&gt; bufptr)
-    {
-      dpy -&gt; bufptr += dst_data_length;
-    }
-    else
-    {
-      _XSend(dpy, dst_data, dst_data_length);
-    }
-  }
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-/*
- * Free any geometry, colormap and alpha channel
- * data stored by the remote proxy to unpack the
- * image. Resource, as usual, must be a value
- * between 0 and 255.
- */
-
-int NXFreeUnpack(Display *dpy, unsigned int resource)
-{
-  register xNXFreeUnpackReq *req;
-
-  if (_NXUnpackResources[resource] != 0)
-  {
-    LockDisplay(dpy);
-
-    GetReq(NXFreeUnpack, req);
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXFreeUnpack: Sending message opcode [%d] with resource [%u].\n&quot;,
-                X_NXFreeUnpack, resource);
-    #endif
-
-    req -&gt; resource = resource;
-
-    UnlockDisplay(dpy);
-
-    SyncHandle();
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXFreeUnpack: Making the resource [%u] newly available.\n&quot;,
-                resource);
-    #endif
-
-    _NXUnpackResources[resource] = 0;
-  }
-  #ifdef TEST
-  else
-  {
-    fprintf(stderr, &quot;******NXFreeUnpack: Nothing to do for resource [%u].\n&quot;,
-                resource);
-  }
-  #endif
-
-  return 1;
-}
-
-/*
- * Wrapper of XCreateImage(). Note that we use offset
- * field of XImage to store size of source image in
- * packed format. Note also that method is currently
- * not stored in the NXignored.
- */
-
-NXPackedImage *NXCreatePackedImage(Display *dpy, Visual *visual, unsigned int method,
-                                       unsigned int depth, int format, char *data,
-                                           int data_length, unsigned int width,
-                                               unsigned int height, int bitmap_pad,
-                                                   int bytes_per_line)
-{
-  XImage* image;
-
-  image = XCreateImage(dpy, visual, depth, format, 0, data,
-                           width, height, bitmap_pad, bytes_per_line);
-
-  if (image != NULL)
-  {
-    image -&gt; xoffset = data_length;
-  }
-
-  return (NXPackedImage *) image;
-}
-
-/*
- * Wrapper of XDestroyImage().
- */
-
-int NXDestroyPackedImage(NXPackedImage *image)
-{
-  return XDestroyImage((XImage *) image);
-}
-
-/*
- * Clean the image data directly in the current buffer.
- */
-
-int NXCleanImage(XImage *image)
-{
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXCleanImage: Cleaning image with format [%d] depth [%d] &quot;
-              &quot;bits per pixel [%d].\n&quot;, image -&gt; format, image -&gt; depth,
-                  image -&gt; bits_per_pixel);
-  #endif
-
-  if (image -&gt; format == ZPixmap)
-  {
-    if (image -&gt; depth == 1)
-    {
-      return CleanXYImage(image);
-    }
-    else
-    {
-      return CleanZImage(image);
-    }
-  }
-  else
-  {
-    return CleanXYImage(image);
-  }
-}
-
-NXPackedImage *NXPackImage(Display *dpy, XImage *src_image, unsigned int method)
-{
-  XImage *dst_image;
-
-  const ColorMask *mask;
-
-  unsigned int dst_data_size;
-  unsigned int dst_packed_data_size;
-
-  unsigned int dst_bits_per_pixel;
-  unsigned int dst_packed_bits_per_pixel;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXPackImage: Going to pack a new image with method [%d].\n&quot;,
-              method);
-  #endif
-
-  /*
-   * Get the mask out of the method and 
-   * check if the visual is supported by
-   * the color reduction algorithm.
-   */
-
-  mask = MethodColorMask(method);
-
-  if (mask == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXPackImage: WARNING! No mask to apply for pack method [%d].\n&quot;,
-                method);
-    #endif
-
-    return NULL;
-  }
-  else if (CanMaskImage(src_image, mask) == 0)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXPackImage: PANIC! Invalid source with format [%d] depth [%d] bits per pixel [%d].\n&quot;,
-                src_image -&gt; format, src_image -&gt; depth, src_image -&gt; bits_per_pixel);
-
-    fprintf(stderr, &quot;******NXPackImage: PANIC! Visual colormask is red 0x%lx green 0x%lx blue 0x%lx.\n&quot;,
-                src_image -&gt; red_mask, src_image -&gt; green_mask, src_image -&gt; blue_mask);
-    #endif
-
-    return NULL;
-  }
-
-  /*
-   * Create a destination image from
-   * source and apply the color mask.
-   */
-
-  if ((dst_image = (XImage *) Xmalloc(sizeof(XImage))) == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXPackImage: PANIC! Cannot allocate [%d] bytes for the image.\n&quot;,
-                (int) sizeof(XImage));
-    #endif
-
-    return NULL;
-  }
-
-  *dst_image = *src_image;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXPackImage: Source width [%d], bytes per line [%d] with depth [%d].\n&quot;,
-              src_image -&gt; width, src_image -&gt; bytes_per_line, src_image -&gt; depth);
-  #endif
-
-  dst_data_size = src_image -&gt; bytes_per_line * src_image -&gt; height;
-
-  dst_image -&gt; data = Xmalloc(dst_data_size);
-
-  if (dst_image -&gt; data == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXPackImage: PANIC! Cannot allocate [%d] bytes for masked image data.\n&quot;,
-                dst_data_size);
-    #endif
-
-    Xfree(dst_image);
-
-    return NULL;
-  }
-
-  /*
-   * If the pixel resulting from the mask
-   * needs more bits than available, then
-   * just clean the padding bits in the
-   * image.
-   */
-
-  dst_bits_per_pixel = dst_image -&gt; bits_per_pixel;
-  dst_packed_bits_per_pixel = MethodBitsPerPixel(method);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXPackImage: Destination depth [%d], bits per pixel [%d], packed bits per pixel [%d].\n&quot;,
-             dst_image -&gt; depth, dst_bits_per_pixel, dst_packed_bits_per_pixel);
-  #endif
-
-  if (dst_packed_bits_per_pixel &gt; dst_bits_per_pixel ||
-          ShouldMaskImage(src_image, mask) == 0)
-  {
-    /*
-     * Should use the same data for source
-     * and destination to avoid the memcpy.
-     */
-
-    if (CopyAndCleanImage(src_image, dst_image) &lt;= 0)
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******NXPackImage: PANIC! Failed to clean the image.\n&quot;);
-      #endif
-
-      Xfree(dst_image -&gt; data);
-
-      Xfree(dst_image);
-
-      return NULL;
-    }
-  }
-  else if (MaskImage(mask, src_image, dst_image) &lt;= 0)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXPackImage: PANIC! Failed to apply the color mask.\n&quot;);
-    #endif
-
-    Xfree(dst_image -&gt; data);
-
-    Xfree(dst_image);
-
-    return NULL;
-  }
-
-  /*
-   * Let's pack the same pixels in fewer bytes.
-   * Note that we save a new memory allocation
-   * by using the same image as source and des-
-   * tination. This means that PackImage() must
-   * be able to handle ovelapping areas.
-   */
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXPackImage: Plain bits per pixel [%d], data size [%d].\n&quot;,
-              dst_bits_per_pixel, dst_data_size);
-  #endif
-
-  dst_packed_data_size = dst_data_size * dst_packed_bits_per_pixel /
-                              dst_bits_per_pixel;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXPackImage: Packed bits per pixel [%d], data size [%d].\n&quot;,
-              dst_packed_bits_per_pixel, dst_packed_data_size);
-  #endif
-
-  if (PackImage(method, dst_data_size, dst_image,
-                    dst_packed_data_size, dst_image) &lt;= 0)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXPackImage: PANIC! Failed to pack image from [%d] to [%d] bits per pixel.\n&quot;,
-                dst_bits_per_pixel, dst_packed_bits_per_pixel);
-    #endif
-
-    Xfree(dst_image -&gt; data);
-
-    Xfree(dst_image);
-
-    return NULL;
-  }
-
-  /*
-   * Save data size in xoffset field
-   * to comply with NX packed images.
-   */
-
-  dst_image -&gt; xoffset = dst_packed_data_size;
-
-  return dst_image;
-}
-
-/*
- * NXInPlacePackImage creates a NXPackedImage
- * from a XImage, sharing the same data buffer.
- * Is up to the caller to free the data buffer
- * only once.
- */
-
-XImage *NXInPlacePackImage(Display *dpy, XImage *src_image, unsigned int method)
-{
-  XImage *dst_image;
-
-  const ColorMask *mask;
-
-  unsigned int dst_data_size;
-  unsigned int dst_packed_data_size;
-
-  unsigned int dst_bits_per_pixel;
-  unsigned int dst_packed_bits_per_pixel;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXInPlacePackImage: Going to pack a new image with method [%d].\n&quot;,
-              method);
-  #endif
-
-  /*
-   * Get mask out of method and check if
-   * visual is supported by current color
-   * reduction algorithm.
-   */
-
-  mask = MethodColorMask(method);
-
-  if (mask == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXInPlacePackImage: WARNING! No mask to apply for pack method [%d].\n&quot;,
-                method);
-    #endif
-
-    return NULL;
-  }
-  else if (CanMaskImage(src_image, mask) == 0)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXInPlacePackImage: PANIC! Invalid source with format [%d] depth [%d] bits per pixel [%d].\n&quot;,
-                src_image -&gt; format, src_image -&gt; depth, src_image -&gt; bits_per_pixel);
-
-    fprintf(stderr, &quot;******NXInPlacePackImage: PANIC! Visual colormask is red 0x%lx green 0x%lx blue 0x%lx.\n&quot;,
-                src_image -&gt; red_mask, src_image -&gt; green_mask, src_image -&gt; blue_mask);
-    #endif
-    return NULL;
-  }
-
-  /*
-   * Create a destination image from
-   * source and apply the color mask.
-   */
-
-  if ((dst_image = (XImage *) Xmalloc(sizeof(XImage))) == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXInPlacePackImage: PANIC! Cannot allocate [%d] bytes for the image.\n&quot;,
-                (int) sizeof(XImage));
-    #endif
-
-    return NULL;
-  }
-
-  *dst_image = *src_image;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXInPlacePackImage: Source width [%d], bytes per line [%d] with depth [%d].\n&quot;,
-              src_image -&gt; width, src_image -&gt; bytes_per_line, src_image -&gt; depth);
-  #endif
-
-  dst_data_size = src_image -&gt; bytes_per_line * src_image -&gt; height;
-
-  dst_image -&gt; data = src_image -&gt; data;
-
-  /*
-   * If pixel resulting from mask needs
-   * more bits than available, then just
-   * clean the pad bits in image.
-   */
-
-  dst_bits_per_pixel = dst_image -&gt; bits_per_pixel;
-  dst_packed_bits_per_pixel = MethodBitsPerPixel(method);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXInPlacePackImage: Destination depth [%d], bits per pixel [%d], packed bits per pixel [%d].\n&quot;,
-              dst_image -&gt; depth, dst_bits_per_pixel, dst_packed_bits_per_pixel);
-  #endif
-
-  if (dst_packed_bits_per_pixel &gt; dst_bits_per_pixel ||
-          ShouldMaskImage(src_image, mask) == 0)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXInPlacePackImage: Just clean image packed_bits_per_pixel[%d], bits_per_pixel[%d].\n&quot;,
-                dst_packed_bits_per_pixel, dst_bits_per_pixel);
-    #endif
-
-    if (NXCleanImage(dst_image) &lt;= 0)
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******NXInPlacePackImage: PANIC! Failed to clean the image.\n&quot;);
-      #endif
-
-      Xfree(dst_image);
-
-      return NULL;
-    }
-  }
-  else if (MaskInPlaceImage(mask, dst_image) &lt;= 0)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXInPlacePackImage: PANIC! Failed to apply the color mask.\n&quot;);
-    #endif
-
-    Xfree(dst_image);
-
-    return NULL;
-  }
-
-  /*
-   * Let's pack the same pixels in fewer bytes.
-   * Note that we save a new memory allocation
-   * by using the same image as source and des-
-   * tination. This means that PackImage() must
-   * be able to handle ovelapping areas.
-   */
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXInPlacePackImage: Plain bits per pixel [%d], data size [%d].\n&quot;,
-             dst_bits_per_pixel, dst_data_size);
-  #endif
-
-  dst_packed_data_size = dst_data_size * dst_packed_bits_per_pixel /
-    dst_bits_per_pixel;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXInPlacePackImage: Packed bits per pixel [%d], data size [%d].\n&quot;,
-             dst_packed_bits_per_pixel, dst_packed_data_size);
-  #endif
-
-  /*
-   * Save data size in xoffset field
-   * to comply with NX packed images.
-   */
-
-  dst_image -&gt; xoffset = dst_packed_data_size;
-
-  return dst_image;
-}
-
-int NXPutPackedImage(Display *dpy, unsigned int resource, Drawable drawable,
-                         void *gc, NXPackedImage *image, unsigned int method,
-                             unsigned int depth, int src_x, int src_y, int dst_x,
-                                 int dst_y, unsigned int width, unsigned int height)
-{
-  register xNXPutPackedImageReq *req;
-
-  register unsigned int src_data_length;
-  register unsigned int dst_data_length;
-
-  LockDisplay(dpy);
-
-  FlushGC(dpy, (GC) gc);
-
-  GetReq(NXPutPackedImage, req);
-
-  req -&gt; resource = resource;
-  req -&gt; drawable = drawable;
-  req -&gt; gc = ((GC) gc) -&gt; gid;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXPutPackedImage: Image resource [%d] drawable [%d] gc [%d].\n&quot;,
-              req -&gt; resource, (int) req -&gt; drawable, (int) req -&gt; gc);
-  #endif
-
-  /*
-   * There is no leftPad field in request. We only
-   * support a leftPad of 0. Anyway, X imposes a
-   * leftPad of 0 in case of ZPixmap format.
-   */
-
-  req -&gt; format = image -&gt; format;
-
-  /*
-   * Source depth, as well as width and height,
-   * are taken from the image structure.
-   */
-
-  req -&gt; srcDepth = image -&gt; depth;
-
-  req -&gt; srcX = src_x;
-  req -&gt; srcY = src_y;
-
-  req -&gt; srcWidth  = image -&gt; width;
-  req -&gt; srcHeight = image -&gt; height;
-
-  /*
-   * The destination depth is provided
-   * by the caller.
-   */
-
-  req -&gt; dstDepth = depth;
-
-  req -&gt; dstX = dst_x;
-  req -&gt; dstY = dst_y;
-
-  req -&gt; dstWidth  = width;
-  req -&gt; dstHeight = height;
-
-  req -&gt; method = method;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXPutPackedImage: Source image depth [%d] destination depth [%d] &quot;
-              &quot;method [%d].\n&quot;, req -&gt; srcDepth, req -&gt; dstDepth, req -&gt; method);
-  #endif
-
-  /*
-   * Source data length is the size of image in packed format,
-   * as stored in xoffset field of XImage. Destination data
-   * size is calculated according to bytes per line of target
-   * image, so the caller must provide the right depth at the
-   * time XImage structure is created.
-   */
-
-  req -&gt; srcLength = image -&gt; xoffset;
-
-  if (image -&gt; width == (int) width &amp;&amp;
-          image -&gt; height == (int) height)
-  {
-    req -&gt; dstLength = image -&gt; bytes_per_line * image -&gt; height;
-  }
-  else if (image -&gt; format == ZPixmap)
-  {
-    req -&gt; dstLength = ROUNDUP((image -&gt; bits_per_pixel * width),
-                                    image -&gt; bitmap_pad) * height &gt;&gt; 3;
-  }
-  else
-  {
-    req -&gt; dstLength = ROUNDUP(width, image -&gt; bitmap_pad) * height &gt;&gt; 3;
-  }
-
-  src_data_length = image -&gt; xoffset;
-
-  dst_data_length = ROUNDUP(src_data_length, 4);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXPutPackedImage: Source data length [%d] request data length [%d].\n&quot;,
-              src_data_length, dst_data_length);
-  #endif
-
-  req -&gt; length += (dst_data_length &gt;&gt; 2);
-
-  if (src_data_length &gt; 0)
-  {
-    if (dpy -&gt; bufptr + dst_data_length &lt;= dpy -&gt; bufmax)
-    {
-      /*
-       * Clean the padding bytes in the request.
-       */
-
-      *((int *) (dpy -&gt; bufptr + dst_data_length - 4)) = 0x0;
-
-      memcpy(dpy -&gt; bufptr, image -&gt; data, src_data_length);
-
-      dpy -&gt; bufptr += dst_data_length;
-    }
-    else
-    {
-      /*
-       * The _XSend() will pad the request for us.
-       */
-
-      _XSend(dpy, image -&gt; data, src_data_length);
-    }
-  }
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-int NXAllocColors(Display *dpy, Colormap colormap, unsigned int entries,
-                      XColor screens_in_out[], Bool results_in_out[])
-{
-  Status result = 0;
-  xAllocColorReply rep;
-  register xAllocColorReq *req;
-
-  Bool alloc_error = False;
-
-  register unsigned int i;
-
-  LockDisplay(dpy);
-
-  for (i = 0; i &lt; entries; i++)
-  {
-    GetReq(AllocColor, req);
-
-    req -&gt; cmap  = colormap;
-
-    req -&gt; red   = screens_in_out[i].red;
-    req -&gt; green = screens_in_out[i].green;
-    req -&gt; blue  = screens_in_out[i].blue;
-  }
-
-  for (i = 0; i &lt; entries; i++)
-  {
-    result = _XReply(dpy, (xReply *) &amp;rep, 0, xTrue);
-
-    if (result)
-    {
-      screens_in_out[i].pixel = rep.pixel;
-
-      screens_in_out[i].red   = rep.red;
-      screens_in_out[i].green = rep.green;
-      screens_in_out[i].blue  = rep.blue;
-      
-      results_in_out[i] = True;
-    } 
-    else 
-    {
-      results_in_out[i] = False;
-
-      alloc_error = True;
-    }
-  }
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return (alloc_error == False);
-}
-
-char *NXEncodeColormap(const char *src_data, unsigned int src_size, unsigned int *dst_size)
-{
-  return ColormapCompressData(src_data, src_size, dst_size);
-}
-
-char *NXEncodeAlpha(const char *src_data, unsigned int src_size, unsigned int *dst_size)
-{
-  return AlphaCompressData(src_data, src_size, dst_size);
-}
-
-NXPackedImage *NXEncodeRgb(XImage *src_image, unsigned int method, unsigned int quality)
-{
-  NXPackedImage *dst_image = NULL;
-
-  unsigned int dst_size;
-
-  /*
-   * Create a new image structure as a copy
-   * of the source.
-   */
-
-  if ((dst_image = (NXPackedImage *) Xmalloc(sizeof(NXPackedImage))) == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodeRgb: PANIC! Cannot allocate [%d] bytes for the image.\n&quot;,
-                (int) sizeof(XImage));
-    #endif
-
-    return NULL;
-  }
-
-  *dst_image = *src_image;
-
-  dst_image -&gt; data = RgbCompressData(src_image, &amp;dst_size);
-
-  if (dst_image -&gt; data == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodeRgb: PANIC! Rgb compression failed.\n&quot;);
-    #endif
-
-    Xfree(dst_image);
-
-    return NULL;
-  }
-
-  /*
-   * Store the Rgb size in the xoffset field.
-   */
-
-  dst_image -&gt; xoffset = dst_size;
-
-  return dst_image;
-}
-
-NXPackedImage *NXEncodeRle(XImage *src_image, unsigned int method, unsigned int quality)
-{
-  NXPackedImage *dst_image = NULL;
-
-  unsigned int dst_size;
-
-  /*
-   * Create a new image structure as a copy
-   * of the source.
-   */
-
-  if ((dst_image = (NXPackedImage *) Xmalloc(sizeof(NXPackedImage))) == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodeRle: PANIC! Cannot allocate [%d] bytes for the image.\n&quot;,
-                (int) sizeof(XImage));
-    #endif
-
-    return NULL;
-  }
-
-  *dst_image = *src_image;
-
-  dst_image -&gt; data = RleCompressData(src_image, &amp;dst_size);
-
-  if (dst_image -&gt; data == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodeRle: PANIC! Rle compression failed.\n&quot;);
-    #endif
-
-    Xfree(dst_image);
-
-    return NULL;
-  }
-
-  /*
-   * Store the Rle size in the xoffset field.
-   */
-
-  dst_image -&gt; xoffset = dst_size;
-
-  return dst_image;
-}
-
-NXPackedImage *NXEncodeBitmap(XImage *src_image, unsigned int method, unsigned int quality)
-{
-  NXPackedImage *dst_image = NULL;
-
-  unsigned int dst_size;
-
-  /*
-   * Create a new image structure as a copy
-   * of the source.
-   */
-
-  if ((dst_image = (NXPackedImage *) Xmalloc(sizeof(NXPackedImage))) == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodeBitmap: PANIC! Cannot allocate [%d] bytes for the image.\n&quot;,
-                (int) sizeof(XImage));
-    #endif
-
-    return NULL;
-  }
-
-  *dst_image = *src_image;
-
-  dst_image -&gt; data = BitmapCompressData(src_image, &amp;dst_size);
-
-  if (dst_image -&gt; data == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodeBitmap: PANIC! Bitmap compression failed.\n&quot;);
-    #endif
-
-    Xfree(dst_image);
-
-    return NULL;
-  }
-
-  /*
-   * Store the bitmap size in the xoffset field.
-   */
-
-  dst_image -&gt; xoffset = dst_size;
-
-  return dst_image;
-}
-
-NXPackedImage *NXEncodeJpeg(XImage *src_image, unsigned int method, unsigned int quality)
-{
-  NXPackedImage *dst_image = NULL;
-
-  int size;
-
-  /*
-   * Check if the bpp of the image is valid
-   * for the Jpeg compression.
-   */
-
-  if (src_image -&gt; bits_per_pixel &lt; 15)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodeJpeg: PANIC! Invalid bpp for Jpeg compression [%d]\n.&quot;,
-                src_image -&gt; bits_per_pixel);
-    #endif
-
-    return NULL;
-  }
-
-  /*
-   * Create the destination image as a copy
-   * of the source.
-   */
-
-  if ((dst_image = (NXPackedImage *) Xmalloc(sizeof(NXPackedImage))) == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodeJpeg: PANIC! Cannot allocate [%d] bytes for the Jpeg image.\n&quot;,
-                (int) sizeof(NXPackedImage));
-    #endif
-
-    return NULL;
-  }
-
-  *dst_image = *src_image;
-
-  dst_image -&gt; data = JpegCompressData(src_image, quality, &amp;size);
-
-  if (dst_image -&gt; data == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodeJpeg: PANIC! Jpeg compression failed.\n&quot;);
-    #endif
-
-    Xfree(dst_image);
-
-    return NULL;
-  }
-
-  /*
-   * Store the Jpeg size in the xoffset field.
-   */
-
-  dst_image -&gt; xoffset = size;
-
-  return dst_image;
-}
-
-NXPackedImage *NXEncodePng(XImage *src_image, unsigned int method, unsigned int quality)
-{
-  NXPackedImage *dst_image = NULL;
-
-  int size;
-
-  /*
-   * Check if the bpp of the image is valid
-   * for png compression.
-   */
-
-  if (src_image -&gt; bits_per_pixel &lt; 15)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodePng: PANIC! Invalid bpp for Png compression [%d].\n&quot;,
-                src_image -&gt; bits_per_pixel);
-    #endif
-
-    return NULL;
-  }
-
-  if ((dst_image = (NXPackedImage *) Xmalloc(sizeof(NXPackedImage))) == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodePng: PANIC! Cannot allocate [%d] bytes for the Png image.\n&quot;,
-                (int) sizeof(NXPackedImage));
-    #endif
-
-    return NULL;
-  }
-
-  *dst_image = *src_image;
-
-  dst_image -&gt; data = PngCompressData(dst_image, &amp;size);
-
-  if (dst_image -&gt; data == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXEncodePng: PANIC! Png compression failed.\n&quot;);
-    #endif
-
-    Xfree(dst_image);
-
-    return NULL;
-  }
-
-  /*
-   * Store the Png size in the xoffset field.
-   */
-
-  dst_image -&gt; xoffset = size;
-
-  return dst_image;
-}
-
-int NXEncodeColors(XImage *src_image, NXColorTable *color_table, int nb_max)
-{
-  int x, y, t, p;
-
-  long pixel;
-
-  /*
-   * We need a smarter way to extract
-   * the colors from the image and
-   * create a color table.
-   */
-
-  memset(color_table, 0, nb_max * sizeof(NXColorTable));
-
-  for (x = 0, p = 0; x &lt; src_image -&gt; width; x++)
-  {
-    for (y = 0; y &lt; src_image -&gt; height; y++)
-    {
-      pixel  = XGetPixel(src_image, x, y);
-
-      for (t = 0; t &lt; nb_max; t++)
-      {
-        if ( color_table[t].found == 0)
-        {
-          color_table[t].pixel =  pixel;
-          color_table[t].found =  1;
-
-          p++;
-
-          break;
-        }
-        else if ((color_table[t].pixel) == pixel)
-        {
-          break;
-        }
-      }
-
-      if (p == nb_max)
-      {
-        return nb_max + 1;
-      }
-    }
-  }
-
-  return p;
-}
-
-void NXMaskImage(XImage *image, unsigned int method)
-{
-  unsigned int maskMethod;
-
-  const ColorMask *mask;
-
-  /*
-   * Choose the correct mask method
-   */
-
-  switch(method)
-  {
-    case PACK_JPEG_8_COLORS:
-    case PACK_PNG_8_COLORS:
-    {
-      maskMethod = MASK_8_COLORS;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_8_COLORS\n&quot;);
-      #endif
-
-      break;
-    }
-    case PACK_JPEG_64_COLORS:
-    case PACK_PNG_64_COLORS:
-    {
-      maskMethod = MASK_64_COLORS;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_64K_COLORS\n&quot;);
-      #endif
-
-      break;
-    }
-    case PACK_JPEG_256_COLORS:
-    case PACK_PNG_256_COLORS:
-    {
-      maskMethod = MASK_256_COLORS;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_256_COLORS\n&quot;);
-      #endif
-
-      break;
-    }
-    case PACK_JPEG_512_COLORS:
-    case PACK_PNG_512_COLORS:
-    {
-      maskMethod = MASK_512_COLORS;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_512K_COLORS\n&quot;);
-      #endif
-
-      break;
-    }
-    case PACK_JPEG_4K_COLORS:
-    case PACK_PNG_4K_COLORS:
-    {
-      maskMethod = MASK_4K_COLORS;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_4K_COLORS\n&quot;);
-      #endif
-
-      break;
-    }
-    case PACK_JPEG_32K_COLORS:
-    case PACK_PNG_32K_COLORS:
-    {
-      maskMethod = MASK_32K_COLORS;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_32K_COLORS\n&quot;);
-      #endif
-
-      break;
-    }
-    case PACK_JPEG_64K_COLORS:
-    case PACK_PNG_64K_COLORS:
-    {
-      maskMethod = MASK_64K_COLORS;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_64K_COLORS\n&quot;);
-      #endif
-
-      break;
-    }
-    case PACK_JPEG_256K_COLORS:
-    case PACK_PNG_256K_COLORS:
-    {
-      maskMethod = MASK_256K_COLORS;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_256K_COLORS\n&quot;);
-      #endif
-
-      break;
-    }
-    case PACK_JPEG_2M_COLORS:
-    case PACK_PNG_2M_COLORS:
-    {
-      maskMethod = MASK_2M_COLORS;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_2M_COLORS\n&quot;);
-      #endif
-
-      break;
-    }
-    case PACK_JPEG_16M_COLORS:
-    case PACK_PNG_16M_COLORS:
-    {
-      maskMethod = MASK_16M_COLORS;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_16M_COLORS\n&quot;);
-      #endif
-
-      break;
-    }
-    default:
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******NXMaskImage: PANIC! Cannot find mask method for pack method [%d]\n&quot;,
-                  method);
-      #endif
-
-      return;
-    }
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXMaskImage: packMethod[%d] =&gt; maskMethod[%d]\n&quot;,
-              method, maskMethod);
-  #endif
-
-  /*
-   * Get mask out of method and check if
-   * visual is supported by current color
-   * reduction algorithm.
-   */
-
-  mask = MethodColorMask(maskMethod);
-
-  if (mask == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXMaskImage: PANIC! No mask to apply for pack method [%d].\n&quot;,
-                method);
-    #endif
-
-    return;
-  }
-  else if (CanMaskImage(image, mask) == 0)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXMaskImage: PANIC! Invalid source with format [%d] depth [%d] bits per pixel [%d].\n&quot;,
-                image -&gt; format, image -&gt; depth, image -&gt; bits_per_pixel);
-
-    fprintf(stderr, &quot;******NXMaskImage: PANIC! Visual colormask is red 0x%lx green 0x%lx blue 0x%lx.\n&quot;,
-                image -&gt; red_mask, image -&gt; green_mask, image -&gt; blue_mask);
-    #endif
-
-    return;
-  }
-
-  /*
-   * Calling ShouldMaskImage you get 0 in the case
-   * of MASK_256_COLORS and MASK_64K_COLORS, which
-   * means that the image should not be masked.
-   */
-
-  if (ShouldMaskImage(image, mask) == 0)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******NXMaskImage: the image will not be masked\n&quot;);
-    #endif
-  }
-  else
-  {
-    if (MaskInPlaceImage(mask, image) &lt;= 0)
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******NXMaskImage: PANIC! Failed to apply the color mask in place.\n&quot;);
-      #endif
-    }
-  }
-}
-
-/*
- * The display parameter is ignored.
- */
-
-void NXInitCache(Display *dpy, int entries)
-{
-  if (NXImageCache != NULL &amp;&amp; NXImageCacheSize == entries)
-  {
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******NXInitCache: Nothing to do with image cache at [%p] and [%d] entries.\n&quot;,
-                NXImageCache,  NXImageCacheSize);
-    #endif
-
-    return;
-  }
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******NXInitCache: Initializing the cache with [%d] entries.\n&quot;,
-              entries);
-  #endif
-
-  NXImageCacheSize = 0;
-
-  if (NXImageCache != NULL)
-  {
-    Xfree(NXImageCache);
-
-    NXImageCache = NULL;
-  }
-
-  if (entries &gt; 0)
-  {
-    NXImageCache = Xmalloc(entries * sizeof(_NXImageCacheEntry));
-
-    if (NXImageCache != NULL)
-    {
-      memset(NXImageCache, 0, entries * sizeof(_NXImageCacheEntry));
-
-      NXImageCacheSize = entries;
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******NXInitCache: Image cache initialized with [%d] entries.\n&quot;, entries);
-      #endif
-    }
-  }
-}
-
-#ifdef DUMP
-
-void _NXCacheDump(const char *label)
-{
-  char s[MD5_LENGTH * 2 + 1];
-
-  int i;
-  int j;
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;%s: Dumping the content of image cache:\n&quot;, label);
-  #endif
-
-  for (i = 0; i &lt; NXImageCacheSize; i++)
-  {
-    if (NXImageCache[i].image == NULL)
-    {
-      break;
-    }
-
-    for (j = 0; j &lt; MD5_LENGTH; j++)
-    {
-      sprintf(s + (j * 2), &quot;%02X&quot;, ((unsigned char *) NXImageCache[i].md5)[j]);
-    }
-
-    #ifdef DEBUG
-    fprintf(stderr, &quot;%s: [%d][%s].\n&quot;, label, i, s);
-    #endif
-  }
-}
-
-#endif
-
-XImage *NXCacheFindImage(NXPackedImage *src_image, unsigned int *method, unsigned char **md5)
-{
-  md5_state_t  new_state;
-  md5_byte_t   *new_md5;
-  unsigned int data_size, i;
-
-  if (NXImageCache == NULL)
-  {
-    return NULL;
-  }
-
-  /*
-   * Will return the allocated checksum
-   * if the image is not found.
-   */
-
-  *md5 = NULL;
-
-  if ((new_md5 = Xmalloc(MD5_LENGTH)) == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCacheFindImage: Can't allocate memory for the checksum.\n&quot;);
-    #endif
-
-    return NULL;
-  }
-
-  data_size = (src_image -&gt; bytes_per_line * src_image -&gt; height);
-
-  md5_init(&amp;new_state);
-
-  md5_append(&amp;new_state, (unsigned char *) &amp;src_image -&gt; width,  sizeof(int));
-  md5_append(&amp;new_state, (unsigned char *) &amp;src_image -&gt; height, sizeof(int));
-
-  md5_append(&amp;new_state, (unsigned char *) src_image -&gt; data, data_size);
-
-  md5_finish(&amp;new_state, new_md5);
-
-  for (i = 0; i &lt; NXImageCacheSize; i++)
-  {
-    if (NXImageCache[i].image != NULL)
-    {
-      if (memcmp(NXImageCache[i].md5, new_md5, MD5_LENGTH) == 0)
-      {
-        _NXImageCacheEntry found;
-
-        found.image  = NXImageCache[i].image;
-        found.method = NXImageCache[i].method;
-        found.md5    = NXImageCache[i].md5;
-
-        *method = found.method;
-
-        NXImageCacheHits++;
-
-        #ifdef DEBUG
-        fprintf(stderr, &quot;******NXCacheFindImage: Found at position [%d] with hits [%d] and [%d] packs.\n&quot;,
-                    i, NXImageCacheHits, NXImageCacheOps);
-        #endif
-
-        Xfree(new_md5);
-
-        /*
-         * Move the images down one slot, from
-         * the head of the list, and place the
-         * image just found at top.
-         */
-
-        if (i &gt; 16)
-        {
-          #ifdef DEBUG
-          fprintf(stderr, &quot;******NXCacheFindImage: Moving the image at the head of the list.\n&quot;);
-          #endif
-
-          memmove(&amp;NXImageCache[1], &amp;NXImageCache[0], (i * sizeof(_NXImageCacheEntry)));
-
-          NXImageCache[0].image  = found.image;
-          NXImageCache[0].method = found.method;
-          NXImageCache[0].md5    = found.md5;
-
-          #ifdef DUMP
-
-          _NXCacheDump(&quot;******NXCacheFindImage&quot;);
-
-          #endif
-        }
-
-        /*
-         * Return the checksum and image
-         * structure allocated in cache.
-         */
-
-        *md5 = found.md5;
-
-        return found.image;
-      }
-    }
-    else
-    {
-      break;
-    }
-  }
-
-  *md5 = new_md5;
-
-  return NULL;
-}
-
-/*
- * Add a packed image to the cache. A new image
- * structure is allocated and copied, data and
- * checksum are inherited from the passed image.
- */
-
-int NXCacheAddImage(NXPackedImage *image, unsigned int method, unsigned char *md5)
-{
-  unsigned int i;
-
-  if (image == NULL || image -&gt; data == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCacheAddImage: PANIC! Invalid image passed to function.\n&quot;);
-    #endif
-
-    return -1;
-  }
-
-  i = (NXImageCacheOps &lt; NXImageCacheSize) ? NXImageCacheOps : NXImageCacheSize;
-
-  if (NXImageCacheOps &gt;= NXImageCacheSize)
-  {
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******NXCacheAddImage: Freeing up the oldest entry.\n&quot;);
-    #endif
-
-    i--;
-
-    Xfree(NXImageCache[NXImageCacheSize - 1].image -&gt; data);
-    Xfree(NXImageCache[NXImageCacheSize - 1].image);
-    Xfree(NXImageCache[NXImageCacheSize - 1].md5);
-  }
-
-  if (i &gt; 0)
-  {
-    memmove(&amp;NXImageCache[1], &amp;NXImageCache[0], i * sizeof(_NXImageCacheEntry));
-  }
-
-  NXImageCacheOps++;
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******NXCacheAddImage: Going to add new image with data size [%d].\n&quot;,
-              image -&gt; xoffset);
-  #endif
-
-  NXImageCache[0].image  = image;
-  NXImageCache[0].method = method;
-  NXImageCache[0].md5    = md5;
-
-  #ifdef DUMP
-
-  _NXCacheDump(&quot;******NXCacheAddImage&quot;);
-
-  #endif
-
-  return 1;
-}
-
-/*
- * The display parameter is ignored.
- */
-
-void NXFreeCache(Display *dpy)
-{
-  int i;
-
-  if (NXImageCache == NULL)
-  {
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******NXFreeCache: Nothing to do with a null image cache.\n&quot;);
-    #endif
-
-    return;
-  }
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******NXFreeCache: Freeing the cache with [%d] entries.\n&quot;,
-              NXImageCacheSize);
-  #endif
-
-  for (i = 0; i &lt; NXImageCacheSize; i++)
-  {
-    if (NXImageCache[i].image != NULL)
-    {
-      if (NXImageCache[i].image -&gt; data != NULL)
-      {
-        Xfree(NXImageCache[i].image -&gt; data);
-      }
-
-      Xfree(NXImageCache[i].image);
-
-      NXImageCache[i].image = NULL;
-    }
-
-    if (NXImageCache[i].md5 != NULL)
-    {
-      Xfree(NXImageCache[i].md5);
-
-      NXImageCache[i].md5 = NULL;
-    }
-  }
-
-  Xfree(NXImageCache);
-
-  NXImageCache = NULL;
-
-  NXImageCacheSize = 0;
-  NXImageCacheHits = 0;
-  NXImageCacheOps  = 0;
-}
-
-static void _NXNotifyImage(Display *dpy, int resource, Bool success)
-{
-  XEvent async_event;
-
-  /*
-   * Enqueue an event to tell client
-   * the result of GetImage.
-   */
-
-  async_event.type = ClientMessage;
-
-  async_event.xclient.serial = _NXCollectedImages[resource] -&gt; sequence;
-
-  async_event.xclient.window       = 0;
-  async_event.xclient.message_type = 0;
-  async_event.xclient.format       = 32;
-
-  async_event.xclient.data.l[0] = NXCollectImageNotify;
-  async_event.xclient.data.l[1] = resource;
-  async_event.xclient.data.l[2] = success;
-
-  XPutBackEvent(dpy, &amp;async_event);
-}
-
-static Bool _NXCollectImageHandler(Display *dpy, xReply *rep, char *buf,
-                                       int len, XPointer data)
-{
-  register _NXCollectImageState *state;
-
-  register xGetImageReply *async_rep;
-
-  char *async_head;
-  char *async_data;
-
-  int async_size;
-
-  state = (_NXCollectImageState *) data;
-
-  if ((rep -&gt; generic.sequenceNumber % 65536) !=
-          ((int)(state -&gt; sequence) % 65536))
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectImageHandler: Unmatched sequence [%d] for opcode [%d] &quot;
-                &quot;with length [%d].\n&quot;, rep -&gt; generic.sequenceNumber, rep -&gt; generic.type,
-                    (int) rep -&gt; generic.length &lt;&lt; 2);
-    #endif
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectImageHandler: Going to handle asynchronous GetImage reply.\n&quot;);
-  #endif
-
-  /*
-   * As even reply data is managed asynchronously,
-   * we can use state to get to vector and vector
-   * to get to handler. In this way, we can safely
-   * dequeue and free the handler itself.
-   */
-
-  DeqAsyncHandler(dpy, state -&gt; handler);
-
-  Xfree(state -&gt; handler);
-
-  state -&gt; handler = NULL;
-
-  if (rep -&gt; generic.type == X_Error)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectImageHandler: Error received from X server for resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyImage(dpy, state -&gt; resource, False);
-
-    _NXCollectedImages[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectImageHandler: Matched request with sequence [%ld].\n&quot;,
-              state -&gt; sequence);
-  #endif
-
-  async_size = SIZEOF(xGetImageReply);
-
-  async_head = Xmalloc(async_size);
-
-  if (async_head == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******_NXCollectImageHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyImage(dpy, state -&gt; resource, False);
-
-    _NXCollectedImages[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectImageHandler: Going to get reply with size [%d].\n&quot;,
-              (int) rep -&gt; generic.length &lt;&lt; 2);
-  #endif
-
-  async_rep = (xGetImageReply *) _XGetAsyncReply(dpy, async_head, rep, buf, len, 0, False);
-
-  if (async_rep == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******_NXCollectImageHandler: PANIC! Failed to get reply with resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyImage(dpy, state -&gt; resource, False);
-
-    _NXCollectedImages[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    Xfree(async_head);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectImageHandler: Got reply with depth [%d] visual [%d] size [%d].\n&quot;,
-              async_rep -&gt; depth, (int) async_rep -&gt; visual, (int) async_rep -&gt; length &lt;&lt; 2);
-  #endif
-
-  async_size = async_rep -&gt; length &lt;&lt; 2;
-
-  if (async_size &gt; 0)
-  {
-    async_data = Xmalloc(async_size);
-
-    if (async_data == NULL)
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******_NXCollectImageHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
-                  state -&gt; resource);
-      #endif
-
-      _NXNotifyImage(dpy, state -&gt; resource, False);
-
-      _NXCollectedImages[state -&gt; resource] = NULL;
-
-      Xfree(state);
-
-      Xfree(async_head);
-
-      return False;
-    }
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectImageHandler: Going to get data with size [%d].\n&quot;,
-                async_size);
-    #endif
-
-    _XGetAsyncData(dpy, async_data, buf, len, SIZEOF(xGetImageReply), async_size, async_size);
-
-    /*
-     * From now on we can return True, as all
-     * data has been consumed from buffer.
-     */
-
-    if (state -&gt; format == XYPixmap)
-    {
-      unsigned long depth = DepthOnes(state -&gt; mask &amp; (((unsigned long)0xFFFFFFFF) &gt;&gt;
-                                          (32 - async_rep -&gt; depth)));
-
-      state -&gt; image = XCreateImage(dpy, _XVIDtoVisual(dpy, async_rep -&gt; visual),
-                                        depth, XYPixmap, 0, async_data, state -&gt; width,
-                                            state -&gt; height, dpy -&gt; bitmap_pad, 0);
-    }
-    else
-    {
-      state -&gt; image = XCreateImage(dpy, _XVIDtoVisual(dpy, async_rep -&gt; visual),
-                                        async_rep -&gt; depth, ZPixmap, 0, async_data, state -&gt; width,
-                                            state -&gt; height, _XGetScanlinePad(dpy, async_rep -&gt; depth), 0);
-    }
-
-    if (state -&gt; image == NULL)
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******_NXCollectImageHandler: PANIC! Failed to create image for resource [%d].\n&quot;,
-                  state -&gt; resource);
-      #endif
-
-      _NXNotifyImage(dpy, state -&gt; resource, False);
-
-      _NXCollectedImages[state -&gt; resource] = NULL;
-
-      Xfree(state);
-
-      Xfree(async_head);
-      Xfree(async_data);
-
-      return True;
-    }
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectImageHandler: Successfully stored image data for resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-  }
-  #ifdef WARNING
-  else
-  {
-    fprintf(stderr, &quot;******_NXCollectImageHandler: WARNING! Null image data stored for resource [%d].\n&quot;,
-                state -&gt; resource);
-  }
-  #endif
-
-  _NXNotifyImage(dpy, state -&gt; resource, True);
-
-  Xfree(async_head);
-
-  return True;
-}
-
-int NXGetCollectImageResource(Display *dpy)
-{
-  int i;
-
-  for (i = 0; i &lt; NXNumberOfResources; i++)
-  {
-    if (_NXCollectedImages[i] == NULL)
-    {
-      return i;
-    }
-  }
-
-  return -1;
-}
-
-int NXCollectImage(Display *dpy, unsigned int resource, Drawable drawable,
-                       int src_x, int src_y, unsigned int width, unsigned int height,
-                           unsigned long plane_mask, int format)
-{
-  register xGetImageReq *req;
-
-  _NXCollectImageState *state;
-  _XAsyncHandler *handler;
-
-  if (resource &gt;= NXNumberOfResources)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectImage: PANIC! Provided resource [%u] is out of range.\n&quot;,
-                resource);
-    #endif
-
-    return -1;
-  }
-
-  state = _NXCollectedImages[resource];
-
-  if (state != NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectImage: PANIC! Having to remove previous state for resource [%u].\n&quot;,
-                resource);
-    #endif
-
-    if (state -&gt; handler != NULL)
-    {
-      DeqAsyncHandler(dpy, state -&gt; handler);
-
-      Xfree(state -&gt; handler);
-    }
-
-    if (state -&gt; image != NULL)
-    {
-      XDestroyImage(state -&gt; image);
-    }
-
-    Xfree(state);
-
-    _NXCollectedImages[resource] = NULL;
-  }
-
-  LockDisplay(dpy);
-
-  GetReq(GetImage, req);
-
-  req -&gt; format    = format;
-  req -&gt; drawable  = drawable;
-  req -&gt; x         = src_x;
-  req -&gt; y         = src_y;
-  req -&gt; width     = width;
-  req -&gt; height    = height;
-  req -&gt; planeMask = plane_mask;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXCollectImage: Sending message opcode [%d] sequence [%ld] for resource [%d].\n&quot;,
-              X_GetImage, dpy -&gt; request, resource);
-
-  fprintf(stderr, &quot;******NXCollectImage: Format [%d] drawable [%d] src_x [%d] src_y [%d].\n&quot;,
-              req -&gt; format, (int) req -&gt; drawable, req -&gt; x, req -&gt; y);
-
-  fprintf(stderr, &quot;******NXCollectImage: Width [%d] height [%d] plane_mask [%x].\n&quot;,
-              req -&gt; width, req -&gt; height, (int) req -&gt; planeMask);
-  #endif
-
-  state   = Xmalloc(sizeof(_NXCollectImageState));
-  handler = Xmalloc(sizeof(_XAsyncHandler));
-
-  if (state == NULL || handler == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectImage: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
-                resource);
-    #endif
-
-    UnGetReq(GetImage);
-
-    if (state != NULL)
-    {
-      Xfree(state);
-    }
-
-    if (handler != NULL)
-    {
-      Xfree(handler);
-    }
-
-    UnlockDisplay(dpy);
-
-    return -1;
-  }
-
-  state -&gt; sequence = dpy -&gt; request;
-  state -&gt; resource = resource;
-  state -&gt; mask     = plane_mask;
-  state -&gt; format   = format;
-  state -&gt; width    = width;
-  state -&gt; height   = height;
-  state -&gt; image    = NULL;
-
-  state -&gt; handler = handler;
-
-  handler -&gt; next = dpy -&gt; async_handlers;
-  handler -&gt; handler = _NXCollectImageHandler;
-  handler -&gt; data = (XPointer) state;
-  dpy -&gt; async_handlers = handler;
-
-  _NXCollectedImages[resource] = state;
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return 1;
-}
-
-int NXGetCollectedImage(Display *dpy, unsigned int resource, XImage **image)
-{
-  register _NXCollectImageState *state;
-
-  state = _NXCollectedImages[resource];
-
-  if (state == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXGetCollectedImage: PANIC! No image collected for resource [%u].\n&quot;,
-                resource);
-    #endif
-
-    return 0;
-  }
-
-  _NXCollectedImages[resource] = NULL;
-
-  *image = state -&gt; image;
-
-  Xfree(state);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXGetCollectedImage: Returning GetImage data for resource [%u].\n&quot;,
-              resource);
-  #endif
-
-  return 1;
-}
-
-static void _NXNotifyProperty(Display *dpy, int resource, Bool success)
-{
-  XEvent async_event;
-
-  /*
-   * Enqueue an event to tell client
-   * the result of GetProperty.
-   */
-
-  async_event.type = ClientMessage;
-
-  async_event.xclient.serial = _NXCollectedProperties[resource] -&gt; sequence;
-
-  async_event.xclient.window       = 0;
-  async_event.xclient.message_type = 0;
-  async_event.xclient.format       = 32;
-
-  async_event.xclient.data.l[0] = NXCollectPropertyNotify;
-  async_event.xclient.data.l[1] = resource;
-  async_event.xclient.data.l[2] = success;
-
-  XPutBackEvent(dpy, &amp;async_event);
-}
-
-static Bool _NXCollectPropertyHandler(Display *dpy, xReply *rep, char *buf,
-                                          int len, XPointer data)
-{
-  register _NXCollectPropertyState *state;
-
-  register xGetPropertyReply *async_rep;
-
-  char *async_head;
-  char *async_data;
-
-  int async_size;
-
-  state = (_NXCollectPropertyState *) data;
-
-  if ((rep -&gt; generic.sequenceNumber % 65536) !=
-          ((int)(state -&gt; sequence) % 65536))
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectPropertyHandler: Unmatched sequence [%d] for opcode [%d] &quot;
-                &quot;with length [%d].\n&quot;, rep -&gt; generic.sequenceNumber, rep -&gt; generic.type,
-                    (int) rep -&gt; generic.length &lt;&lt; 2);
-    #endif
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectPropertyHandler: Going to handle asynchronous GetProperty reply.\n&quot;);
-  #endif
-
-  /*
-   * Reply data is managed asynchronously. We can
-   * use state to get to vector and vector to get
-   * to handler. In this way, we can dequeue and
-   * free the handler itself.
-   */
-
-  DeqAsyncHandler(dpy, state -&gt; handler);
-
-  Xfree(state -&gt; handler);
-
-  state -&gt; handler = NULL;
-
-  if (rep -&gt; generic.type == X_Error)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectPropertyHandler: Error received from X server for resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyProperty(dpy, state -&gt; resource, False);
-
-    _NXCollectedProperties[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectPropertyHandler: Matched request with sequence [%ld].\n&quot;,
-              state -&gt; sequence);
-  #endif
-
-  async_size = SIZEOF(xGetPropertyReply);
-
-  async_head = Xmalloc(async_size);
-
-  if (async_head == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******_NXCollectPropertyHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyProperty(dpy, state -&gt; resource, False);
-
-    _NXCollectedProperties[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectPropertyHandler: Going to get reply with size [%d].\n&quot;,
-              (int) rep -&gt; generic.length &lt;&lt; 2);
-  #endif
-
-  async_rep = (xGetPropertyReply *) _XGetAsyncReply(dpy, async_head, rep, buf, len, 0, False);
-
-  if (async_rep == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******_NXCollectPropertyHandler: PANIC! Failed to get reply with resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyProperty(dpy, state -&gt; resource, False);
-
-    _NXCollectedProperties[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    Xfree(async_head);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectPropertyHandler: Got reply with format [%d] type [%d] size [%d].\n&quot;,
-              async_rep -&gt; format, (int) async_rep -&gt; propertyType, (int) async_rep -&gt; length &lt;&lt; 2);
-
-  fprintf(stderr, &quot;******_NXCollectPropertyHandler: Bytes after [%d] number of items [%d].\n&quot;,
-              (int) async_rep -&gt; bytesAfter, (int) async_rep -&gt; nItems);
-  #endif
-
-  state -&gt; format = async_rep -&gt; format;
-  state -&gt; type   = async_rep -&gt; propertyType;
-  state -&gt; items  = async_rep -&gt; nItems;
-  state -&gt; after  = async_rep -&gt; bytesAfter;
-
-  async_size = async_rep -&gt; length &lt;&lt; 2;
-
-  if (async_size &gt; 0)
-  {
-    async_data = Xmalloc(async_size);
-
-    if (async_data == NULL)
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******_NXCollectPropertyHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
-                  state -&gt; resource);
-      #endif
-
-      _NXNotifyProperty(dpy, state -&gt; resource, False);
-
-      _NXCollectedProperties[state -&gt; resource] = NULL;
-
-      Xfree(state);
-
-      Xfree(async_head);
-
-      return False;
-    }
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectPropertyHandler: Going to get data with size [%d].\n&quot;,
-                async_size);
-    #endif
-
-    _XGetAsyncData(dpy, async_data, buf, len, SIZEOF(xGetPropertyReply), async_size, async_size);
-
-    /*
-     * From now on we can return True, as all
-     * data has been consumed from buffer.
-     */
-
-    state -&gt; data = async_data;
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectPropertyHandler: Successfully stored property data for resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-  }
-  #ifdef TEST
-  else
-  {
-    fprintf(stderr, &quot;******_NXCollectPropertyHandler: WARNING! Null property data stored for resource [%d].\n&quot;,
-                state -&gt; resource);
-  }
-  #endif
-
-  _NXNotifyProperty(dpy, state -&gt; resource, True);
-
-  Xfree(async_head);
-
-  return True;
-}
-
-int NXGetCollectPropertyResource(Display *dpy)
-{
-  int i;
-
-  for (i = 0; i &lt; NXNumberOfResources; i++)
-  {
-    if (_NXCollectedProperties[i] == NULL)
-    {
-      return i;
-    }
-  }
-
-  return -1;
-}
-
-int NXCollectProperty(Display *dpy, unsigned int resource, Window window, Atom property,
-                          long long_offset, long long_length, Bool delete, Atom req_type)
-{
-  register xGetPropertyReq *req;
-
-  _NXCollectPropertyState *state;
-  _XAsyncHandler *handler;
-
-  if (resource &gt;= NXNumberOfResources)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectProperty: PANIC! Provided resource [%u] is out of range.\n&quot;,
-                resource);
-    #endif
-
-    return -1;
-  }
-
-  state = _NXCollectedProperties[resource];
-
-  if (state != NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectProperty: PANIC! Having to remove previous state for resource [%u].\n&quot;,
-                resource);
-    #endif
-
-    if (state -&gt; handler != NULL)
-    {
-      DeqAsyncHandler(dpy, state -&gt; handler);
-
-      Xfree(state -&gt; handler);
-    }
-
-    if (state -&gt; data != NULL)
-    {
-      Xfree(state -&gt; data);
-    }
-
-    Xfree(state);
-
-    _NXCollectedProperties[resource] = NULL;
-  }
-
-  LockDisplay(dpy);
-
-  GetReq(GetProperty, req);
-
-  req -&gt; delete     = delete;
-  req -&gt; window     = window;
-  req -&gt; property   = property;
-  req -&gt; type       = req_type;
-  req -&gt; longOffset = long_offset;
-  req -&gt; longLength = long_length;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXCollectProperty: Sending message opcode [%d] sequence [%ld] for resource [%d].\n&quot;,
-              X_GetProperty, dpy -&gt; request, resource);
-
-  fprintf(stderr, &quot;******NXCollectProperty: Delete [%u] window [%d] property [%d] type [%d].\n&quot;,
-              req -&gt; delete, (int) req -&gt; window, (int) req -&gt; property, (int) req -&gt; type);
-
-  fprintf(stderr, &quot;******NXCollectProperty: Long offset [%d] long length [%d].\n&quot;,
-              (int) req -&gt; longOffset, (int) req -&gt; longLength);
-  #endif
-
-  state   = Xmalloc(sizeof(_NXCollectPropertyState));
-  handler = Xmalloc(sizeof(_XAsyncHandler));
-
-  if (state == NULL || handler == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectProperty: Failed to allocate memory with resource [%d].\n&quot;,
-                resource);
-    #endif
-
-    if (state != NULL)
-    {
-      Xfree(state);
-    }
-
-    if (handler != NULL)
-    {
-      Xfree(handler);
-    }
-
-    UnGetReq(GetProperty);
-
-    UnlockDisplay(dpy);
-
-    return -1;
-  }
-
-  state -&gt; sequence = dpy -&gt; request;
-  state -&gt; resource = resource;
-  state -&gt; window   = window;
-  state -&gt; property = property;
-  state -&gt; type     = 0;
-  state -&gt; format   = 0;
-  state -&gt; items    = 0;
-  state -&gt; after    = 0;
-  state -&gt; data     = NULL;
-
-  state -&gt; handler = handler;
-
-  handler -&gt; next = dpy -&gt; async_handlers;
-  handler -&gt; handler = _NXCollectPropertyHandler;
-  handler -&gt; data = (XPointer) state;
-  dpy -&gt; async_handlers = handler;
-
-  _NXCollectedProperties[resource] = state;
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return True;
-}
-
-int NXGetCollectedProperty(Display *dpy, unsigned int resource, Atom *actual_type_return,
-                               int *actual_format_return, unsigned long *nitems_return,
-                                   unsigned long *bytes_after_return, unsigned char **data)
-{
-  register _NXCollectPropertyState *state;
-
-  state = _NXCollectedProperties[resource];
-
-  if (state == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXGetCollectedProperty: PANIC! No data collected for resource [%u].\n&quot;,
-                resource);
-    #endif
-
-    return 0;
-  }
-
-  *actual_type_return   = state -&gt; type;
-  *actual_format_return = state -&gt; format;
-  *nitems_return        = state -&gt; items;
-  *bytes_after_return   = state -&gt; after;
-
-  *data = (unsigned char *) _NXCollectedProperties[resource] -&gt; data;
-
-  Xfree(state);
-
-  _NXCollectedProperties[resource] = NULL;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXGetCollectedProperty: Returning GetProperty data for resource [%u].\n&quot;,
-              resource);
-  #endif
-
-  return True;
-}
-
-static void _NXNotifyGrabPointer(Display *dpy, int resource, Bool success)
-{
-  XEvent async_event;
-
-  async_event.type = ClientMessage;
-
-  async_event.xclient.serial = _NXCollectedGrabPointers[resource] -&gt; sequence;
-
-  async_event.xclient.window       = 0;
-  async_event.xclient.message_type = 0;
-  async_event.xclient.format       = 32;
-
-  async_event.xclient.data.l[0] = NXCollectGrabPointerNotify;
-  async_event.xclient.data.l[1] = resource;
-  async_event.xclient.data.l[2] = success;
-
-  XPutBackEvent(dpy, &amp;async_event);
-}
-
-static Bool _NXCollectGrabPointerHandler(Display *dpy, xReply *rep, char *buf,
-                                             int len, XPointer data)
-{
-  register _NXCollectGrabPointerState *state;
-
-  register xGrabPointerReply *async_rep;
-
-  char *async_head;
-
-  int async_size;
-
-  state = (_NXCollectGrabPointerState *) data;
-
-  if ((rep -&gt; generic.sequenceNumber % 65536) !=
-          ((int)(state -&gt; sequence) % 65536))
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Unmatched sequence [%d] for opcode [%d] &quot;
-                &quot;with length [%d].\n&quot;, rep -&gt; generic.sequenceNumber, rep -&gt; generic.type,
-                    (int) rep -&gt; generic.length &lt;&lt; 2);
-    #endif
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Going to handle asynchronous GrabPointer reply.\n&quot;);
-  #endif
-
-  DeqAsyncHandler(dpy, state -&gt; handler);
-
-  Xfree(state -&gt; handler);
-
-  state -&gt; handler = NULL;
-
-  if (rep -&gt; generic.type == X_Error)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Error received from X server for resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyGrabPointer(dpy, state -&gt; resource, False);
-
-    _NXCollectedGrabPointers[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Matched request with sequence [%ld].\n&quot;,
-              state -&gt; sequence);
-  #endif
-
-  async_size = SIZEOF(xGrabPointerReply);
-
-  async_head = Xmalloc(async_size);
-
-  if (async_head == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyGrabPointer(dpy, state -&gt; resource, False);
-
-    _NXCollectedGrabPointers[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Going to get reply with size [%d].\n&quot;,
-              (int) rep -&gt; generic.length &lt;&lt; 2);
-  #endif
-
-  async_rep = (xGrabPointerReply *) _XGetAsyncReply(dpy, async_head, rep, buf, len, 0, False);
-
-  if (async_rep == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: PANIC! Failed to get reply with resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyGrabPointer(dpy, state -&gt; resource, False);
-
-    _NXCollectedGrabPointers[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    Xfree(async_head);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Got reply with status [%d] size [%d].\n&quot;,
-              async_rep -&gt; status, (int) async_rep -&gt; length &lt;&lt; 2);
-  #endif
-
-  state -&gt; status = async_rep -&gt; status;
-
-  _NXNotifyGrabPointer(dpy, state -&gt; resource, True);
-
-  Xfree(async_head);
-
-  return True;
-}
-
-int NXGetCollectGrabPointerResource(Display *dpy)
-{
-  int i;
-
-  for (i = 0; i &lt; NXNumberOfResources; i++)
-  {
-    if (_NXCollectedGrabPointers[i] == NULL)
-    {
-      return i;
-    }
-  }
-
-  return -1;
-}
-
-int NXCollectGrabPointer(Display *dpy, unsigned int resource, Window grab_window, Bool owner_events,
-                             unsigned int event_mask, int pointer_mode, int keyboard_mode,
-                                 Window confine_to, Cursor cursor, Time time)
-{
-  register xGrabPointerReq *req;
-
-  _NXCollectGrabPointerState *state;
-  _XAsyncHandler *handler;
-
-  if (resource &gt;= NXNumberOfResources)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectGrabPointer: PANIC! Provided resource [%u] is out of range.\n&quot;,
-                resource);
-    #endif
-
-    return -1;
-  }
-
-  state = _NXCollectedGrabPointers[resource];
-
-  if (state != NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectGrabPointer: PANIC! Having to remove previous state for resource [%u].\n&quot;,
-                resource);
-    #endif
-
-    if (state -&gt; handler != NULL)
-    {
-      DeqAsyncHandler(dpy, state -&gt; handler);
-
-      Xfree(state -&gt; handler);
-    }
-
-    Xfree(state);
-
-    _NXCollectedGrabPointers[resource] = NULL;
-  }
-
-  LockDisplay(dpy);
-
-  GetReq(GrabPointer, req);
-
-  req -&gt; grabWindow   = grab_window;
-  req -&gt; ownerEvents  = owner_events;
-  req -&gt; eventMask    = event_mask;
-  req -&gt; pointerMode  = pointer_mode;
-  req -&gt; keyboardMode = keyboard_mode;
-  req -&gt; confineTo    = confine_to;
-  req -&gt; cursor       = cursor;
-  req -&gt; time         = time;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXCollectGrabPointer: Sending message opcode [%d] sequence [%ld] &quot;
-              &quot;for resource [%d].\n&quot;, X_GrabPointer, dpy -&gt; request, resource);
-  #endif
-
-  state   = Xmalloc(sizeof(_NXCollectGrabPointerState));
-  handler = Xmalloc(sizeof(_XAsyncHandler));
-
-  if (state == NULL || handler == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectGrabPointer: Failed to allocate memory with resource [%d].\n&quot;,
-                resource);
-    #endif
-
-    if (state != NULL)
-    {
-      Xfree(state);
-    }
-
-    if (handler != NULL)
-    {
-      Xfree(handler);
-    }
-
-    UnGetReq(GrabPointer);
-
-    UnlockDisplay(dpy);
-
-    return -1;
-  }
-
-  state -&gt; sequence = dpy -&gt; request;
-  state -&gt; resource = resource;
-  state -&gt; status   = 0;
-
-  state -&gt; handler = handler;
-
-  handler -&gt; next = dpy -&gt; async_handlers;
-  handler -&gt; handler = _NXCollectGrabPointerHandler;
-  handler -&gt; data = (XPointer) state;
-  dpy -&gt; async_handlers = handler;
-
-  _NXCollectedGrabPointers[resource] = state;
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return True;
-}
-
-int NXGetCollectedGrabPointer(Display *dpy, unsigned int resource, int *status)
-{
-  register _NXCollectGrabPointerState *state;
-
-  state = _NXCollectedGrabPointers[resource];
-
-  if (state == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXGetCollectedGrabPointer: PANIC! No data collected for resource [%u].\n&quot;,
-                resource);
-    #endif
-
-    return 0;
-  }
-
-  *status = state -&gt; status;
-
-  Xfree(state);
-
-  _NXCollectedGrabPointers[resource] = NULL;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXGetCollectedGrabPointer: Returning GrabPointer data for resource [%u].\n&quot;,
-              resource);
-  #endif
-
-  return True;
-}
-
-static void _NXNotifyInputFocus(Display *dpy, int resource, Bool success)
-{
-  XEvent async_event;
-
-  async_event.type = ClientMessage;
-
-  async_event.xclient.serial = _NXCollectedInputFocuses[resource] -&gt; sequence;
-
-  async_event.xclient.window       = 0;
-  async_event.xclient.message_type = 0;
-  async_event.xclient.format       = 32;
-
-  async_event.xclient.data.l[0] = NXCollectInputFocusNotify;
-  async_event.xclient.data.l[1] = resource;
-  async_event.xclient.data.l[2] = success;
-
-  XPutBackEvent(dpy, &amp;async_event);
-}
-
-static Bool _NXCollectInputFocusHandler(Display *dpy, xReply *rep, char *buf,
-                                            int len, XPointer data)
-{
-  register _NXCollectInputFocusState *state;
-
-  register xGetInputFocusReply *async_rep;
-
-  char *async_head;
-
-  int async_size;
-
-  state = (_NXCollectInputFocusState *) data;
-
-  if ((rep -&gt; generic.sequenceNumber % 65536) !=
-          ((int)(state -&gt; sequence) % 65536))
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Unmatched sequence [%d] for opcode [%d] &quot;
-                &quot;with length [%d].\n&quot;, rep -&gt; generic.sequenceNumber, rep -&gt; generic.type,
-                    (int) rep -&gt; generic.length &lt;&lt; 2);
-    #endif
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Going to handle asynchronous GetInputFocus reply.\n&quot;);
-  #endif
-
-  DeqAsyncHandler(dpy, state -&gt; handler);
-
-  Xfree(state -&gt; handler);
-
-  state -&gt; handler = NULL;
-
-  if (rep -&gt; generic.type == X_Error)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Error received from X server for resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyInputFocus(dpy, state -&gt; resource, False);
-
-    _NXCollectedInputFocuses[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Matched request with sequence [%ld].\n&quot;,
-              state -&gt; sequence);
-  #endif
-
-  async_size = SIZEOF(xGetInputFocusReply);
-
-  async_head = Xmalloc(async_size);
-
-  if (async_head == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******_NXCollectInputFocusHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyInputFocus(dpy, state -&gt; resource, False);
-
-    _NXCollectedInputFocuses[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Going to get reply with size [%d].\n&quot;,
-              (int) rep -&gt; generic.length &lt;&lt; 2);
-  #endif
-
-  async_rep = (xGetInputFocusReply *) _XGetAsyncReply(dpy, async_head, rep, buf, len, 0, False);
-
-  if (async_rep == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******_NXCollectInputFocusHandler: PANIC! Failed to get reply with resource [%d].\n&quot;,
-                state -&gt; resource);
-    #endif
-
-    _NXNotifyInputFocus(dpy, state -&gt; resource, False);
-
-    _NXCollectedInputFocuses[state -&gt; resource] = NULL;
-
-    Xfree(state);
-
-    Xfree(async_head);
-
-    return False;
-  }
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Got reply with focus [%d] revert to [%d] &quot;
-              &quot;size [%d].\n&quot;, (int) async_rep -&gt; focus, (int) async_rep -&gt; revertTo,
-                  (int) async_rep -&gt; length &lt;&lt; 2);
-  #endif
-
-  state -&gt; focus     = async_rep -&gt; focus;
-  state -&gt; revert_to = async_rep -&gt; revertTo;
-
-  _NXNotifyInputFocus(dpy, state -&gt; resource, True);
-
-  Xfree(async_head);
-
-  return True;
-}
-
-int NXGetCollectInputFocusResource(Display *dpy)
-{
-  int i;
-
-  for (i = 0; i &lt; NXNumberOfResources; i++)
-  {
-    if (_NXCollectedInputFocuses[i] == NULL)
-    {
-      return i;
-    }
-  }
-
-  return -1;
-}
-
-int NXCollectInputFocus(Display *dpy, unsigned int resource)
-{
-  register xReq *req;
-
-  _NXCollectInputFocusState *state;
-  _XAsyncHandler *handler;
-
-  if (resource &gt;= NXNumberOfResources)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectInputFocus: PANIC! Provided resource [%u] is out of range.\n&quot;,
-                resource);
-    #endif
-
-    return -1;
-  }
-
-  state = _NXCollectedInputFocuses[resource];
-
-  if (state != NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectInputFocus: PANIC! Having to remove previous state for resource [%u].\n&quot;,
-                resource);
-    #endif
-
-    if (state -&gt; handler != NULL)
-    {
-      DeqAsyncHandler(dpy, state -&gt; handler);
-
-      Xfree(state -&gt; handler);
-    }
-
-    Xfree(state);
-
-    _NXCollectedInputFocuses[resource] = NULL;
-  }
-
-  LockDisplay(dpy);
-
-  GetEmptyReq(GetInputFocus, req);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXCollectInputFocus: Sending message opcode [%d] sequence [%ld] for resource [%d].\n&quot;,
-              X_GetInputFocus, dpy -&gt; request, resource);
-  #endif
-
-  state   = Xmalloc(sizeof(_NXCollectInputFocusState));
-  handler = Xmalloc(sizeof(_XAsyncHandler));
-
-  if (state == NULL || handler == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXCollectInputFocus: Failed to allocate memory with resource [%d].\n&quot;,
-                resource);
-    #endif
-
-    if (state != NULL)
-    {
-      Xfree(state);
-    }
-
-    if (handler != NULL)
-    {
-      Xfree(handler);
-    }
-
-    UnGetEmptyReq();
-
-    UnlockDisplay(dpy);
-
-    return -1;
-  }
-
-  state -&gt; sequence  = dpy -&gt; request;
-  state -&gt; resource  = resource;
-  state -&gt; focus     = 0;
-  state -&gt; revert_to = 0;
-
-  state -&gt; handler = handler;
-
-  handler -&gt; next = dpy -&gt; async_handlers;
-  handler -&gt; handler = _NXCollectInputFocusHandler;
-  handler -&gt; data = (XPointer) state;
-  dpy -&gt; async_handlers = handler;
-
-  _NXCollectedInputFocuses[resource] = state;
-
-  UnlockDisplay(dpy);
-
-  SyncHandle();
-
-  return True;
-}
-
-int NXGetCollectedInputFocus(Display *dpy, unsigned int resource,
-                                 Window *focus_return, int *revert_to_return)
-{
-  register _NXCollectInputFocusState *state;
-
-  state = _NXCollectedInputFocuses[resource];
-
-  if (state == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******NXGetCollectedInputFocus: PANIC! No data collected for resource [%u].\n&quot;,
-                resource);
-    #endif
-
-    return 0;
-  }
-
-  *focus_return     = state -&gt; focus;
-  *revert_to_return = state -&gt; revert_to;
-
-  Xfree(state);
-
-  _NXCollectedInputFocuses[resource] = NULL;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******NXGetCollectedInputFocus: Returning GetInputFocus data for resource [%u].\n&quot;,
-              resource);
-  #endif
-
-  return True;
-}
-
-#ifdef DUMP
-
-void _NXDumpData(const unsigned char *buffer, unsigned int size)
-{
-  if (buffer != NULL)
-  {
-    unsigned int i = 0;
-
-    unsigned int ii;
-
-    while (i &lt; size)
-    {
-      fprintf(stderr, &quot;[%d]\t&quot;, i);
-
-      for (ii = 0; i &lt; size &amp;&amp; ii &lt; 8; i++, ii++)
-      {
-        fprintf(stderr, &quot;%d\t&quot;, (unsigned int) (buffer[i]));
-      }
-
-      fprintf(stderr, &quot;\n&quot;);
-    }
-  }
-}
-
-#endif
diff --git a/nxcompext/NXlib.h b/nxcompext/NXlib.h
deleted file mode 100644
index d77ff60..0000000
--- a/nxcompext/NXlib.h
+++ /dev/null
@@ -1,904 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#ifndef NXlib_H
-#define NXlib_H
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-#include &lt;X11/X.h&gt;
-#include &lt;X11/Xlib.h&gt;
-
-#include &quot;NX.h&quot;
-#include &quot;NXpack.h&quot;
-#include &quot;NXproto.h&quot;
-#include &quot;NXvars.h&quot;
-
-/*
- * All the NX code should use these.
- */
-
-#define Xmalloc(size) malloc((size))
-#define Xfree(ptr)    free((ptr))
- 
-/*
- * Maximum number of supported pack methods.
- */
-
-#define NXNumberOfPackMethods  128
-
-/*
- * Assume this as the limit of resources that
- * can be provided to the split and unpack
- * requests.
- */
-
-#define NXNumberOfResources    256
-
-#define NXNoResource           256 + 1
-#define NXAnyResource          256 + 2
-
-/*
- * Initialize the internal structures used by
- * the library. Should be executed again after
- * having reopened the display.
- */
-
-extern int NXInitDisplay(
-#if NeedFunctionPrototypes
-    Display*            /* display */
-#endif
-);
-
-/*
- * Reset all the internal structures. Should be
- * executed after closing the display.
- */
-
-extern int NXResetDisplay(
-#if NeedFunctionPrototypes
-    Display*            /* display */
-#endif
-);
-
-/*
- * Set the NX display flush policy. The policy can
- * be either NXFlushDeferred or NXFlushImmediate.
- */
-
-extern int NXSetDisplayPolicy(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    int                 /* policy */
-#endif
-);
-
-/*
- * Set the display output buffer size.
- */
-
-extern int NXSetDisplayBuffer(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    int                 /* size */
-#endif
-);
-
-/*
- * If set, the Popen() function in the X server
- * wil remove the LD_LIBRARY_PATH variable from
- * the environment before calling the execl()
- * function on the child process. The function
- * returns the previous value.
- */
-
-extern int NXUnsetLibraryPath(
-#if NeedFunctionPrototypes
-    int                 /* value */
-#endif
-);
-
-/*
- * If the parameter is true, the Xlib I/O error
- * handler will return, instead of quitting the
- * program. The function returns the previous
- * value.
- */
-
-extern int NXHandleDisplayError(
-#if NeedFunctionPrototypes
-    int                 /* value */
-#endif
-);
-
-/*
- * Shutdown the display descriptor and force Xlib
- * to set the I/O error flag.
- */
-
-extern Bool NXForceDisplayError(
-#if NeedFunctionPrototypes
-    Display*            /* display */
-#endif
-);
-
-/*
- * Check the value of the XlibDisplayIOError flag.
- * If not set, try to call the display error hand-
- * ler to give to the application a chance to see
- * whether it needs to close the connection.
- */
-
-extern int NXDisplayError(
-#if NeedFunctionPrototypes
-    Display*            /* display */
-#endif
-);
-
-/*
- * Query the number of bytes readable from the
- * display connection.
- */
-
-extern int NXDisplayReadable(
-#if NeedFunctionPrototypes
-    Display*            /* display */
-#endif
-);
-
-/*
- * Query the number of the outstanding bytes to
- * flush to the display connection.
- */
-
-extern int NXDisplayFlushable(
-#if NeedFunctionPrototypes
-    Display*            /* display */
-#endif
-);
-
-/*
- * Return a value between 0 and 9 indicating the
- * congestion level of the NX transport based on
- * the tokens remaining. A value of 9 means that
- * the link is congested and no further data can
- * be sent.
- */
-
-extern int NXDisplayCongestion(
-#if NeedFunctionPrototypes
-    Display*            /* display */
-#endif
-);
-
-/*
- * Flush the Xlib display buffer and/or the
- * outstanding data accumulated by the NX
- * transport.
- */
-
-extern int NXFlushDisplay(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    int                 /* what */
-#endif
-);
-
-/*
- * Public interfaces used to set the handlers.
- * They all return the previous handler.
- */
-
-extern NXDisplayErrorPredicate NXSetDisplayErrorPredicate(
-#if NeedFunctionPrototypes
-    NXDisplayErrorPredicate /* predicate */
-#endif
-);
-
-/*
- * Called when the display blocks waiting to read or
- * write more data.
- */
-
-extern NXDisplayBlockHandler NXSetDisplayBlockHandler(
-#if NeedFunctionPrototypes
-    NXDisplayBlockHandler /* handler */
-#endif
-);
-
-/*
- * Called after more data is written to the display.
- * When the NX transport is running, data may be queued
- * until an explicit flush.
- */
-
-extern NXDisplayWriteHandler NXSetDisplayWriteHandler(
-#if NeedFunctionPrototypes
-    NXDisplayWriteHandler /* handler */
-#endif
-);
-
-/*
- * Called after more data is sent to the remote proxy.
- *
- * Here the display pointer is passed as the second
- * parameter to make clear that the function does not
- * tie the callback to the display, but, similarly to
- * all the Xlib error handlers, to a global variable
- * shared by all the Xlib functions. The display
- * pointer will be passed back by nxcomp at the time
- * it will call the handler. This is because nxcomp
- * doesn't have access to the display structure.
- */
-
-extern NXDisplayFlushHandler NXSetDisplayFlushHandler(
-#if NeedFunctionPrototypes
-    NXDisplayFlushHandler      /* handler */,
-    Display*                   /* display */
-#endif
-);
-
-/*
- * Get an arbitrary null terminated buffer to be added
- * to the NX statistics.
- */
-
-extern NXDisplayStatisticsHandler NXSetDisplayStatisticsHandler(
-#if NeedFunctionPrototypes
-    NXDisplayStatisticsHandler /* handler */,
-    char **                    /* buffer */
-#endif
-);
-
-/*
- * Redefine the function called by Xlib in the case of
- * an out-of-order sequence number received in the X
- * protocol stream.
- */
- 
-extern NXLostSequenceHandler NXSetLostSequenceHandler(
-#if NeedFunctionPrototypes
-    NXLostSequenceHandler /* handler */
-#endif
-);
-
-/*
- * The agent should get the NX parameters at startup, just after
- * having opened the display. If the agent is not able to satisfy
- * the pack method set by user (because a method is not applica-
- * ble, it is not supported by the remote or it simply requires a
- * screen depth greater than the depth available), it should fall
- * back to the nearest method of the same type.
- */
-
-extern Status NXGetControlParameters(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int*       /* link_type */,
-    unsigned int*       /* local_major */,
-    unsigned int*       /* local_minor */,
-    unsigned int*       /* local_patch */,
-    unsigned int*       /* remote_major */,
-    unsigned int*       /* remote_minor */,
-    unsigned int*       /* remote_patch */,
-    int*                /* frame_timeout */,
-    int*                /* ping_timeout */,
-    int*                /* split_mode */,
-    int*                /* split_size */,
-    unsigned int*       /* pack_method */,
-    unsigned int*       /* pack_quality */,
-    int*                /* data_level */,
-    int*                /* stream_level */,
-    int*                /* delta_level */,
-    unsigned int*       /* load_cache */,
-    unsigned int*       /* save_cache */,
-    unsigned int*       /* startup_cache */
-#endif
-);
-
-/*
- * Which unpack methods are supported by the remote proxy?
- */
-
-extern Status NXGetUnpackParameters(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int*       /* entries */,
-    unsigned char[]     /* supported_methods */
-#endif
-);
-
-/*
- * Query and enable shared memory support on path agent to X
- * client proxy and X server proxy to real X server. At the
- * moment only the path proxy to real X server is implemented.
- * On return flags will say if support has been successfully
- * activated. Segments will contain the XID associated to the
- * shared memory blocks. A MIT-SHM compliant protocol is used
- * between proxy and the real server, while a simplified
- * version is used between the agent and the client proxy to
- * accomodate both packed images and plain X bitmaps.
- */
-
-extern Status NXGetShmemParameters(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int*       /* enable_client  */,
-    unsigned int*       /* enable_server */,
-    unsigned int*       /* client_segment */,
-    unsigned int*       /* server_segment */,
-    unsigned int*       /* client_size */,
-    unsigned int*       /* server_size */
-#endif
-);
-
-/*
- * Get the path to the font server that can be used by the X
- * server to tunnel the font connections across the NX link.
- * The path actually represents the TCP port where the proxy
- * on the NX client side is listening. The agent can tempora-
- * rily enable the tunneling when it needs a font that is not
- * available on the client, for example when the session is
- * migrated from a different X server.
- */
-
-extern Status NXGetFontParameters(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* path_length */,
-    char[]              /* path_data */
-#endif
-);
-
-/*
- * This set of functions is used to leverage the image stream-
- * ing capabilities built in nxcomp. An image can be streamed
- * by sending a start-split message, followed by the X messages
- * that will have to be split by the proxy, followed by an end-
- * split closure. Usually, in the middle of a start-split/end-
- * split sequence there will be a single PutImage() or PutPack-
- * edImage(), that, in turn, can generate multiple partial
- * requests, like a SetUnpackColormap() and SetUnpackAlpha()
- * that will be later used to decompress the image to its ori-
- * ginal form. Multiple requests may be also generated because
- * of the maximum size of a X request being exceeded, so that
- * Xlib has to divide the single image in multiple sub-image re-
- * quests. The agent doesn't need to take care of these details
- * but will rather have to track the result of the split opera-
- * tion. By monitoring the notify events sent by the proxy, the
- * agent will have to implement its own strategy to deal with
- * the resources. For example, it will be able to:
- *
- * - Mark a drawable as dirty, if the image was not sent
- *   synchronously, in the main X oputput stream.
- *
- * - Choose to commit or discard the original image, at the
- *   time it will be recomposed at the remote side. This may
- *   include all the messages that were part of the split
- *   (the colormap, the alpha channel, etc.)
- *
- * - Mark the drawable as clean again, if the image was
- *   committed and the drawable didn't change in the mean-
- *   while.
- *
- * At the time the proxy receives the end-split, it reports the
- * result of the operation to the agent. The agent will be able
- * to identify the original split operation (the one referenced
- * in the start-split/end-split sequence) by the small integer
- * number (0-255) named 'resource' sent in the events.
- *
- * One of the following cases may be encountered:
- *
- *
- * NXNoSplitNotify      All messages were sent in the main out-
- *                      put stream, so that no split actually
- *                      took place.
- *
- * NXStartSplitNotify   One or more messages were split, so,
- *                      at discrection of the agent, the client
- *                      may be suspended until the transferral
- *                      is completed.
- *
- * NXCommitSplitNotify  One of the requests that made up the
- *                      split was recomposed. The agent should
- *                      either commit the given request or tell
- *                      the proxy to discard it.
- *
- * NXEndSplitNotify     The split was duly completed. The agent
- *                      can restart the client.
- *
- * NXEmptySplitNotify   No more split operation are pending.
- *                      The agent can use this information to
- *                      implement specific strategies requiring
- *                      that all messages have been recomposed
- *                      at the remote end, like updating the
- *                      drawables that were not synchronized
- *                      because of the lazy encoding.
- *
- * The 'mode' field that is sent by the agent in the start-split
- * request, determines the strategy that the proxy will adopt to
- * deal with the image. If set to 'eager', the proxy will only
- * split the messages whose size exceeds the split threshold (the
- * current threshold can be found in the NXGetControlParameters()
- * reply). If the mode is set to lazy, the proxy will split any
- * image that would have generated an actual transfer of the data
- * part (in practice all images that are not found in the cache).
- * This second strategy can be leveraged by an agent to further
- * reduce the bandwidth requirements. For example, by setting the
- * mode to lazy and by monitoring the result, an agent can easi-
- * ly verify if the drawable was successfully updated, mark the
- * drawable if not, and synchronize it at later time.
- *
- * See NXproto.h for the definition of the available modes.
- */
-
-extern unsigned int NXAllocSplit(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */
-#endif
-);
-
-extern int NXStartSplit(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    unsigned int        /* mode */
-#endif
-);
-
-extern int NXEndSplit(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */
-#endif
-);
-
-extern int NXCommitSplit(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    unsigned int        /* propagate */,
-    unsigned char       /* request */,
-    unsigned int        /* position */
-#endif
-);
-
-extern int NXAbortSplit(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */
-#endif
-);
-
-extern int NXFinishSplit(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */
-#endif
-);
-
-extern int NXFreeSplit(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */
-#endif
-);
-
-extern int NXSetExposeParameters(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    int                 /* expose */,
-    int                 /* graphics_expose */,
-    int                 /* no_expose */
-#endif
-);
-
-extern int NXSetCacheParameters(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    int                 /* enable_cache */,
-    int                 /* enable_split */,
-    int                 /* enable_save */,
-    int                 /* enable_load */
-#endif
-);
-
-extern unsigned int NXAllocUnpack(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */
-#endif
-);
-
-extern int NXSetUnpackGeometry(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    Visual*             /* visual */
-#endif
-);
-
-extern int NXSetUnpackColormap(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    unsigned int        /* method */,
-    unsigned int        /* entries */,
-    const char*         /* data */,
-    unsigned int        /* data_length */
-#endif
-);
-
-extern int NXSetUnpackAlpha(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    unsigned int        /* method */,
-    unsigned int        /* entries */,
-    const char*         /* data */,
-    unsigned int        /* data_length */
-#endif
-);
-
-extern int NXSetUnpackColormapCompat(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    unsigned int        /* entries */,
-    const char*         /* data */
-#endif
-);
-
-extern int NXSetUnpackAlphaCompat(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    unsigned int        /* entries */,
-    const char*         /* data */
-#endif
-);
-
-extern int NXFreeUnpack(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */
-#endif
-);
-
-/*
- * A packed image is a XImage but with
- * offset field containing total amount
- * of packed image data.
- */
-
-typedef XImage NXPackedImage;
-
-NXPackedImage *NXCreatePackedImage(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    Visual*             /* visual */,
-    unsigned int        /* method */,
-    unsigned int        /* depth */,
-    int                 /* format */,
-    char*               /* data */,
-    int                 /* data_length */,
-    unsigned int        /* width */,
-    unsigned int        /* height */,
-    int                 /* bitmap_pad */,
-    int                 /* bytes_per_line */
-#endif
-);
-
-extern int NXDestroyPackedImage(
-#if NeedFunctionPrototypes
-    NXPackedImage*      /* image */
-#endif
-);
-
-NXPackedImage *NXPackImage(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    XImage*             /* src_image */,
-    unsigned int        /* method */
-#endif
-);
-
-NXPackedImage *NXInPlacePackImage(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    XImage*             /* src_image */,
-    unsigned int        /* method */
-#endif
-);
-
-/*
- * GC is declared void * to get rid of mess
- * with different GC definitions in some X
- * server code (like in nxagent).
- */
-
-extern int NXPutPackedImage(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    Drawable            /* drawable */,
-    void*               /* gc */,
-    NXPackedImage*      /* image */,
-    unsigned int        /* method */,
-    unsigned int        /* depth */,
-    int                 /* src_x */,
-    int                 /* src_y */,
-    int                 /* dst_x */,
-    int                 /* dst_y */,
-    unsigned int        /* width */,
-    unsigned int        /* height */
-#endif
-);
-
-/*
- * Get multiple colors with a single call by
- * pipelining X_AllocColor requests/replies.
- */
-
-extern int NXAllocColors(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    Colormap            /* colormap */,
-    unsigned int        /* entries */,
-    XColor[]            /* screens_in_out */,
-    Bool []             /* flags allocation errors */
-#endif
-);
-
-/*
- * Encode the data in the given format.
- */
-
-extern char *NXEncodeColormap(
-#if NeedFunctionPrototypes
-    const char*         /* src_data */,
-    unsigned int        /* src_size */,
-    unsigned int*       /* dst_size */
-#endif
-);
-
-extern char *NXEncodeAlpha(
-#if NeedFunctionPrototypes
-    const char*         /* src_data */,
-    unsigned int        /* src_size */,
-    unsigned int*       /* dst_size */
-#endif
-);
-
-extern NXPackedImage *NXEncodeRgb(
-#if NeedFunctionPrototypes
-    XImage*             /* src_image */,
-    unsigned int        /* method */,
-    unsigned int        /* quality */
-#endif
-);
-
-extern NXPackedImage *NXEncodeRle(
-#if NeedFunctionPrototypes
-    XImage*             /* src_image */,
-    unsigned int        /* method */,
-    unsigned int        /* quality */
-#endif
-);
-
-extern NXPackedImage *NXEncodeJpeg(
-#if NeedFunctionPrototypes
-    XImage*             /* src_image */,
-    unsigned int        /* method */,
-    unsigned int        /* quality */
-#endif
-);
-
-typedef struct
-{
-  long pixel;
-  int found;
-
-} NXColorTable;
-
-extern int NXEncodeColors(
-#if NeedFunctionPrototypes
-  XImage*                 /* src_image */,
-  NXColorTable*           /* color_table */,
-  int                     /* nb_max */
-#endif
-);
-
-extern NXPackedImage *NXEncodePng(
-#if NeedFunctionPrototypes
-    XImage*             /* src_image */,
-    unsigned int        /* method */,
-    unsigned int        /* quality */
-#endif
-);
-
-extern NXPackedImage *NXEncodeBitmap(
-#if NeedFunctionPrototypes
-    XImage*             /* src_image */,
-    unsigned int        /* method */,
-    unsigned int        /* quality */
-#endif
-);
-
-extern int NXCleanImage(
-#if NeedFunctionPrototypes
-    XImage*
-#endif
-);
-
-extern void NXMaskImage(
-#if NeedFunctionPrototypes
-    XImage*              /* pointer to image to mask */ ,
-    unsigned int         /* method */
-#endif
-);
-
-extern int NXImageCacheSize;
-
-extern void NXInitCache(
-#if NeedFunctionPrototypes
-    Display*             /* display */,
-    int                  /* entries in image cache */
-#endif
-);
-
-extern void NXFreeCache(
-#if NeedFunctionPrototypes
-    Display*             /* display */
-#endif
-);
-
-extern XImage *NXCacheFindImage(
-#if NeedFunctionPrototypes
-    NXPackedImage*       /* packed image to find */,
-    unsigned int*        /* pointer to the pack method if found */,
-    unsigned char**      /* pointer to the calculated MD5 if found */
-#endif
-);
-
-extern int NXCacheAddImage(
-#if NeedFunctionPrototypes
-    NXPackedImage*       /* packed image to be added to the cache */,
-    unsigned int         /* pack method of the image to add */,
-    unsigned char*       /* pointer to MD5 of the original unpacked image */
-#endif
-);
-
-
-extern int NXGetCollectImageResource(
-#if NeedFunctionPrototypes
-    Display*            /* display */
-#endif
-);
-
-extern int NXCollectImage(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    Drawable            /* drawable */,
-    int                 /* src_x */,
-    int                 /* src_y */,
-    unsigned int        /* width */,
-    unsigned int        /* height */,
-    unsigned long       /* plane_mask */,
-    int                 /* format */
-#endif
-);
-
-extern int NXGetCollectedImage(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    XImage**            /* image */
-#endif
-);
-
-extern int NXGetCollectPropertyResource(
-#if NeedFunctionPrototypes
-    Display*            /* display */
-#endif
-);
-
-extern int NXCollectProperty(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    Window              /* window */,
-    Atom                /* property */,
-    long                /* long_offset */,
-    long                /* long_length */,
-    Bool                /* delete */,
-    Atom                /* req_type */
-#endif
-);
-
-extern int NXGetCollectedProperty(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    Atom*               /* actual_type_return */,
-    int*                /* actual_format_return */,
-    unsigned long*      /* nitems_return */,
-    unsigned long*      /* bytes_after_return */,
-    unsigned char**     /* data */
-#endif
-);
-
-extern int NXGetCollectGrabPointerResource(
-#if NeedFunctionPrototypes
-    Display*            /* display */
-#endif
-);
-
-extern int NXCollectGrabPointer(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    Window              /* grab_window */,
-    Bool                /* owner_events */,
-    unsigned int        /* event_mask */,
-    int                 /* pointer_mode */,
-    int                 /* keyboard_mode */,
-    Window              /* confine_to */,
-    Cursor              /* cursor */,
-    Time                /* time */
-#endif
-);
-
-extern int NXGetCollectedGrabPointer(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    int*                /* status */
-#endif
-);
-
-extern int NXGetCollectInputFocusResource(
-#if NeedFunctionPrototypes
-    Display*            /* display */
-#endif
-);
-
-extern int NXCollectInputFocus(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */
-#endif
-);
-
-extern int NXGetCollectedInputFocus(
-#if NeedFunctionPrototypes
-    Display*            /* display */,
-    unsigned int        /* resource */,
-    Window*             /* focus_return */,
-    int*                /* revert_to_return */
-#endif
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* NXlib_H */
diff --git a/nxcompext/Pgn.c b/nxcompext/Pgn.c
deleted file mode 100644
index d8fa919..0000000
--- a/nxcompext/Pgn.c
+++ /dev/null
@@ -1,722 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &quot;Xutil.h&quot;
-
-#include &quot;NXlib.h&quot;
-
-#include &quot;Mask.h&quot;
-#include &quot;Pgn.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-/*
- * Selected ZLIB compression level.
- */
-
-#define PNG_Z_LEVEL   4
-
-/*
- * Local function prototypes.
- */
-
-static void PrepareRowForPng(CARD8 *dst, int y, int count);
-static void PrepareRowForPng24(CARD8 *dst, int y, int count);
-static void PrepareRowForPng16(CARD8 *dst, int y, int count);
-static void PrepareRowForPng32(CARD8 *dst, int y, int count);
-
-static void PngWriteData(png_structp png_ptr, png_bytep data, png_size_t length);
-static void PngFlushData(png_structp png_ptr);
-
-/*
- * Image characteristics.
- */
-
-static int bytesPerLine;
-static int byteOrder;
-
-static CARD8 bitsPerPixel;
-static CARD16 redMax, greenMax, blueMax;
-static CARD8 redShift, greenShift, blueShift;
-
-/*
- * Other variables used for the Png
- * encoding.
- */
-
-png_byte    color_type;
-png_structp png_ptr;
-png_infop   info_ptr;
-png_colorp  palette;
-static char *pngCompBuf;
-static int  pngDataLen;
-static char *pngBeforeBuf = NULL;
-
-/*
- * Allocate data for the compressed image.
- * We need to ensure that there is enough
- * space to include the palette and the
- * header.
- */
-
-#define PNG_DEST_SIZE(width, height) ((width) * 3 * (height) + 1024 + 256)
-
-/*
- * Just for debug purposes.
- */
-
-#ifdef DEBUG
-
-static int  pngId;
-static char pngName[10];
-static FILE *pngFile;
-
-#endif
-
-int PngCompareColorTable(NXColorTable *c1, NXColorTable *c2)
-{
-  return (c1 -&gt; pixel - c2 -&gt; pixel);
-}
-
-#define NB_COLOR_MAX 256
-
-int NXCreatePalette32(XImage *src_image, NXColorTable *color_table, CARD8 *image_index, int nb_max)
-{
-  int    x, y, t, p;
-  CARD8 *fbptr;
-  CARD32 pixel;
-
-  fbptr = (CARD8 *) (src_image -&gt; data);
-
-  /*
-   * TODO: Find a more intelligent way to
-   * estimate the number of colors.
-   */
-
-  memset(color_table, 0, nb_max * sizeof(NXColorTable));
-
-  for (x = 0, p = 0; x &lt; src_image -&gt; height; x++)
-  {
-    for (y = 0; y &lt; src_image -&gt; width; y++)
-    {
-      if (byteOrder == LSBFirst)
-      {
-        pixel = (CARD32) *(fbptr + 3);
-        pixel = (pixel &lt;&lt; 8) | (CARD32) *(fbptr + 2);
-        pixel = (pixel &lt;&lt; 8) | (CARD32) *(fbptr + 1);
-        pixel = (pixel &lt;&lt; 8) | (CARD32) *fbptr;
-      }
-      else
-      {
-        pixel = (CARD32) *fbptr;
-        pixel = (pixel &lt;&lt; 8) | (CARD32) *(fbptr + 1);
-        pixel = (pixel &lt;&lt; 8) | (CARD32) *(fbptr + 2);
-        pixel = (pixel &lt;&lt; 8) | (CARD32) *(fbptr + 3);
-      }
-
-      fbptr += 4;
-
-      for (t = 0; t &lt; nb_max; t++)
-      {
-        if (color_table[t].found == 0)
-        {
-          color_table[t].pixel =  pixel;
-          color_table[t].found =  1;
-          p++;
-          image_index[((x * src_image -&gt; width) + y)] = t;
-
-          break;
-        }
-        else if ((CARD32)(color_table[t].pixel) == pixel)
-        {
-          image_index[((x * src_image -&gt; width) + y)] = t;
-
-          break;
-        }
-      }
-
-      if (p == nb_max)
-      {
-        return nb_max + 1;
-      }
-    }
-  }
-  return p;
-}
-
-int NXCreatePalette16(XImage *src_image, NXColorTable *color_table, CARD8 *image_index, int nb_max)
-{
-  int    x, y, t, p;
-  CARD8 *fbptr;
-  CARD16 pixel;
-
-  fbptr = (CARD8 *) (src_image -&gt; data);
-
-  /*
-   * TODO: Find a more intelligent way to
-   * estimate the number of colors.
-   */
-
-  memset(color_table, 0, nb_max * sizeof(NXColorTable));
-
-  for (x = 0, p = 0; x &lt; src_image -&gt; height; x++)
-  {
-    for (y = 0; y &lt; src_image -&gt; width; y++)
-    {
-      if (byteOrder == LSBFirst)
-      {
-        pixel = (CARD16) *(fbptr + 1);
-        pixel = (pixel &lt;&lt; 8) | (CARD16) *fbptr;
-      }
-      else
-      {
-        pixel = (CARD16) *fbptr;
-        pixel = (pixel &lt;&lt; 8) | (CARD16) *(fbptr + 1);
-      }
-
-      fbptr += 2;
-
-      for (t = 0; t &lt; nb_max; t++)
-      {
-        if (color_table[t].found == 0)
-        {
-          color_table[t].pixel =  pixel;
-          color_table[t].found =  1;
-          p++;
-          image_index[((x * src_image -&gt; width) + y)] = t;
-
-          break;
-        }
-        else if ((color_table[t].pixel) == pixel)
-        {
-          image_index[((x * src_image -&gt; width) + y)] = t;
-
-          break;
-        }
-      }
-
-      /*
-       * In case the number of 16bit words is not even
-       * we have 2 padding bytes that we have to skip.
-       */
-
-      if ((y == src_image -&gt; width - 1) &amp;&amp; (src_image -&gt; width % 2 == 1)) fbptr += 2;
-
-      if (p == nb_max)
-      {
-        return nb_max + 1;
-      }
-    }
-  }
-
-  return p;
-}
-
-char *PngCompressData(XImage *image, int *compressed_size)
-{
-  unsigned int num = 0;
-  CARD8        *srcBuf;
-
-  int dy, w, h;
-
-  int nb_colors;
-
-  NXColorTable color_table[NB_COLOR_MAX];
-  CARD8       *image_index;
-
-  image_index = (CARD8 *) malloc((image -&gt; height) * (image -&gt; width) * sizeof(CARD8));
-
-  /*
-   * TODO: Be sure the padded bytes are cleaned.
-   * It would be better to set to zero the bytes
-   * that are not alligned to the word boundary
-   * at the end of the procedure.
-   */
-
-  memset(image_index, 0, (image -&gt; height) * (image -&gt; width) * sizeof(CARD8));
-
-  *compressed_size = 0;
-
-  pngDataLen = 0;
-
-  /*
-   * Initialize the image stuff.
-   */
-
-  bitsPerPixel = image -&gt; bits_per_pixel;
-  bytesPerLine = image -&gt; bytes_per_line;
-  byteOrder = image -&gt; byte_order;
-
-  if (bitsPerPixel &lt; 15)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******PngCompressData: PANIC! Can't compress images with [%d] bits per pixel.\n&quot;,
-                bitsPerPixel);
-    #endif
-
-    return NULL;
-  }
-
-  redShift   = FindLSB(image -&gt; red_mask)   - 1;
-  greenShift = FindLSB(image -&gt; green_mask) - 1;
-  blueShift  = FindLSB(image -&gt; blue_mask)  - 1;
-
-  redMax   = image -&gt; red_mask   &gt;&gt; redShift;
-  greenMax = image -&gt; green_mask &gt;&gt; greenShift;
-  blueMax  = image -&gt; blue_mask  &gt;&gt; blueShift;
-
-  w             = image -&gt; width;
-  h             = image -&gt; height;
-  pngBeforeBuf  = image -&gt; data;
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******PngCompressData: Compressing image with width [%d] height [%d].\n&quot;,
-              w, h );
-  #endif
-
-  /*
-   * Initialize the PNG stuff.
-   */
-
-  png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-
-  if (png_ptr == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******PngCompressData: PANIC! Failed creating the png_create_write_struct.\n&quot;);
-    #endif
-
-    return NULL;
-  }
-
-  info_ptr = png_create_info_struct(png_ptr);
-
-  if (info_ptr == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******PngCompressData: PANIC! Failed creating the png_create_info_struct.\n&quot;);
-    #endif
-
-    png_destroy_write_struct(&amp;png_ptr, NULL);
-
-    return NULL;
-  }
-
-  if (setjmp(png_jmpbuf(png_ptr)))
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******PngCompressData: PANIC! Error during compression initialization.\n&quot;);
-    #endif
-
-    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
-
-    return NULL;
-  }
-
-  /*
-   * Be sure we allocate enough data.
-   */
-
-  #ifdef TEST
-  fprintf(stderr, &quot;******PngCompressData: Allocating [%d] bytes for the destination data.\n&quot;,
-              PNG_DEST_SIZE(w, h));
-  #endif
-
-  pngCompBuf = malloc(PNG_DEST_SIZE(w, h));
-
-  if (pngCompBuf == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******PngCompressData: PANIC! Error allocating [%d] bytes for the Png data.\n&quot;,
-                PNG_DEST_SIZE(w, h));
-    #endif
-
-    return NULL;
-  }
-
-  png_set_write_fn(png_ptr, (void *) pngCompBuf, PngWriteData, PngFlushData);
-
-  if (setjmp(png_jmpbuf(png_ptr)))
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******PngCompressData: PANIC! Error writing the header.\n&quot;);
-    #endif
-
-    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
-
-    free(pngCompBuf);
-
-    return NULL;
-  }
-
-  png_set_compression_level(png_ptr, PNG_Z_LEVEL);
-
-  if (bitsPerPixel == 16)
-  {
-    nb_colors = NXCreatePalette16(image, color_table, image_index, NB_COLOR_MAX);
-  }
-  else
-  {
-    nb_colors = NXCreatePalette32(image, color_table, image_index, NB_COLOR_MAX);
-  }
-
-  if (nb_colors &lt;= NB_COLOR_MAX)
-  {
-    color_type = PNG_COLOR_TYPE_PALETTE;
-  }
-  else
-  {
-    color_type = PNG_COLOR_TYPE_RGB;
-  }
-
-  png_set_IHDR(png_ptr, info_ptr, w, h,
-                   8, color_type, PNG_INTERLACE_NONE,
-                       PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-
-  if (color_type == PNG_COLOR_TYPE_PALETTE)
-  {
-    palette = png_malloc(png_ptr, sizeof(*palette) * 256);
-
-    /*
-     * TODO: Do we need to clean these bytes?
-     *
-     * memset(palette, 0, sizeof(*palette) * 256);
-     */
-
-    for (num = 0; num &lt; 256 &amp;&amp; color_table[num].found != 0; num++)
-    {
-      if (bitsPerPixel == 24)
-      {
-        palette[num].red = (color_table[num].pixel &gt;&gt; redShift) &amp; redMax;
-        palette[num].green = (color_table[num].pixel &gt;&gt; greenShift) &amp; greenMax;
-        palette[num].blue = color_table[num].pixel &gt;&gt; blueShift &amp; blueMax;
-      }
-      else
-      {
-        int inRed, inGreen, inBlue;
-
-        inRed = (color_table[num].pixel &gt;&gt; redShift) &amp; redMax;
-        inGreen = (color_table[num].pixel &gt;&gt; greenShift) &amp; greenMax;
-        inBlue = color_table[num].pixel &gt;&gt; blueShift &amp; blueMax;
-
-        palette[num].red = (CARD8)((inRed * 255 + redMax / 2) / redMax);
-        palette[num].green = (CARD8)((inGreen * 255 + greenMax / 2) / greenMax);
-        palette[num].blue = (CARD8)((inBlue * 255 + blueMax / 2) / blueMax);
-      }
-
-      #ifdef DEBUG
-      fprintf(stderr, &quot;******PngCompressData: pixel[%d] r[%d] g[%d] b[%d].\n&quot;,
-                  (int) color_table[num].pixel,palette[num].red,palette[num].green,palette[num].blue);
-      #endif
-    }
-
-    png_set_PLTE(png_ptr, info_ptr, palette, num);
-
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******PngCompressedData: Setting palette.\n&quot;);
-    #endif
-  }
-
-  /*
-   * End of palette.
-   */
-
-  png_write_info(png_ptr, info_ptr);
-
-  /*
-   * Allocate space for one line of
-   * the image, 3 bytes per pixel.
-   */
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******PngCompressedData: Initialization finished.\n&quot;);
-  #endif
-
-  if (setjmp(png_jmpbuf(png_ptr)))
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******PngCompressData: PANIC! Error while writing the image rows.\n&quot;);
-    #endif
-
-    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
-
-    free(pngCompBuf);
-
-    return NULL;
-  }
-
-  if (color_type == PNG_COLOR_TYPE_PALETTE)
-  {
-    srcBuf = (CARD8 *) malloc(w * sizeof(CARD8));
-
-    if (srcBuf == NULL)
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******PngCompressData: PANIC! Cannot allocate [%d] bytes.\n&quot;,
-                  (int) (w * sizeof(CARD8)));
-      #endif
-
-      return NULL;
-    }
-
-    /*
-     * TODO: Be sure the padded bytes are cleaned.
-     * It would be better to set to zero the bytes
-     * that are not alligned to the word boundary
-     * at the end of the procedure.
-     */
-
-    memset(srcBuf, 0, w * sizeof(CARD8));
-  }
-  else
-  {
-    srcBuf = (CARD8 *) malloc(w * 3 * sizeof(CARD8));
-
-    /*
-     * TODO: See above.
-     */
-
-    memset(srcBuf, 0, w * 3 * sizeof(CARD8));
-  }
-
-  if (srcBuf == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******PngCompressData: PANIC! Cannot allocate [%d] bytes.\n&quot;,
-                w * 3);
-    #endif
-
-    free(pngCompBuf);
-
-    return NULL;
-  }
-
-  for (dy = 0; dy &lt; h; dy++)
-  {
-    if (color_type == PNG_COLOR_TYPE_RGB)
-    {
-      PrepareRowForPng(srcBuf, dy, w);
-    }
-    else
-    {
-      memcpy(srcBuf, image_index + (dy * w), w);
-    }
-
-    png_write_row(png_ptr, srcBuf);
-  }
-
-  #ifdef DEBUG
-  fprintf(stderr, &quot;******PngCompressedData: Compression finished. Lines handled [%d,%d].\n&quot;,
-              dy, h);
-  #endif
-
-  free(srcBuf);
-  free(image_index);
-
-  if (setjmp(png_jmpbuf(png_ptr)))
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******PngCompressData: PANIC! error during end of write.\n&quot;);
-    #endif
-
-    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
-
-    free(pngCompBuf);
-
-    return NULL;
-  }
-
-  png_write_end(png_ptr, NULL);
-
-  if (color_type == PNG_COLOR_TYPE_PALETTE)
-  {
-    png_free(png_ptr, palette);
-  }
-
-  png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
-
-  /*
-   * Check the size of the resulting data.
-   */
-
-  if (pngDataLen &gt; 0)
-  {
-    #ifdef DEBUG
-
-    int i = 0;
-
-    fprintf(stderr, &quot;******PngCompressedData: Compressed size [%d].\n&quot;,
-                pngDataLen);
-
-    pngId++;
-    sprintf(pngName, &quot;png%d&quot;, pngId);
-    pngFile = fopen(pngName, &quot;w&quot;);
-
-    for (i = 0; i &lt; pngDataLen; i++)
-    {
-      fprintf(pngFile, &quot;%c&quot;, *(pngCompBuf + i));
-    }
-
-    fclose(pngFile);
-
-    #endif
-
-    *compressed_size = pngDataLen;
-
-    return pngCompBuf;
-  }
-  else
-  {
-    #ifdef DEBUG
-    fprintf(stderr, &quot;******PngCompressedData: PANIC! Invalid size of the compressed data [%d].\n&quot;,
-                pngDataLen);
-    #endif
-
-    free(pngCompBuf);
-
-    return NULL;
-  }
-}
-
-static void PngWriteData(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-  memcpy(((char *) png_get_io_ptr(png_ptr) + pngDataLen), data, length);
-
-  pngDataLen += length;
-}
-
-static void PngFlushData(png_structp png_ptr)
-{
-}
-
-void PrepareRowForPng(CARD8 *dst, int y, int count)
-{
-  if (bitsPerPixel == 32)
-  {
-    if (redMax == 0xff &amp;&amp;
-           greenMax == 0xff &amp;&amp;
-               blueMax == 0xff)
-    {
-      PrepareRowForPng24(dst, y, count);
-    }
-    else
-    {
-      PrepareRowForPng32(dst, y, count);
-    }
-  }
-  else if (bitsPerPixel == 24)
-  {
-    memcpy(dst, pngBeforeBuf + y * bytesPerLine, count * 3);
-  }
-  else
-  {
-    /*
-     * 16 bpp assumed.
-     */
-
-    PrepareRowForPng16(dst, y, count);
-  }
-}
-
-
-
-void PrepareRowForPng24(CARD8 *dst, int y, int count)
-{
-  CARD8 *fbptr;
-  CARD32 pix;
-
-  fbptr = (CARD8 *) (pngBeforeBuf + y * bytesPerLine);
-
-  while (count--)
-  {
-    if (byteOrder == LSBFirst)
-    {
-      pix = (CARD32) *(fbptr + 2);
-      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr+1);
-      pix = (pix &lt;&lt; 8) | (CARD32) *fbptr;
-    }
-    else
-    {
-      pix = (CARD32) *(fbptr + 1);
-      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + 2);
-      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + 3);
-    }
-
-    *dst++ = (CARD8)(pix &gt;&gt; redShift);
-    *dst++ = (CARD8)(pix &gt;&gt; greenShift);
-    *dst++ = (CARD8)(pix &gt;&gt; blueShift);
-
-    fbptr+=4;
-  }
-}
-
-#define DEFINE_PNG_GET_ROW_FUNCTION(bpp)                                    \
-                                                                            \
-void PrepareRowForPng##bpp(CARD8 *dst, int y, int count)                    \
-{                                                                           \
-  CARD8 *fbptr;                                                             \
-  CARD##bpp pix;                                                            \
-  int inRed, inGreen, inBlue;                                               \
-  int i;                                                                    \
-                                                                            \
-  fbptr = (CARD8 *) (pngBeforeBuf + y * bytesPerLine);                      \
-                                                                            \
-  while (count--)                                                           \
-  {                                                                         \
-    pix = 0;                                                                \
-                                                                            \
-    if (byteOrder == LSBFirst)                                              \
-    {                                                                       \
-      for (i = (bpp &gt;&gt; 3) - 1; i &gt;= 0; i--)                                 \
-      {                                                                     \
-        pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + i);                           \
-      }                                                                     \
-    }                                                                       \
-    else                                                                    \
-    {                                                                       \
-      for (i = 0; i &lt; (bpp &gt;&gt; 3); i++)                                      \
-      {                                                                     \
-        pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + i);                           \
-      }                                                                     \
-    }                                                                       \
-                                                                            \
-    fbptr += (bpp &gt;&gt; 3);                                                    \
-                                                                            \
-    inRed = (int)                                                           \
-            (pix &gt;&gt; redShift   &amp; redMax);                                   \
-    inGreen = (int)                                                         \
-            (pix &gt;&gt; greenShift &amp; greenMax);                                 \
-    inBlue  = (int)                                                         \
-            (pix &gt;&gt; blueShift  &amp; blueMax);                                  \
-    *dst++ = (CARD8)((inRed   * 255 + redMax / 2) /                         \
-                         redMax);                                           \
-    *dst++ = (CARD8)((inGreen * 255 + greenMax / 2) /                       \
-                         greenMax);                                         \
-    *dst++ = (CARD8)((inBlue  * 255 + blueMax / 2) /                        \
-                         blueMax);                                          \
-  }                                                                         \
-}
-
-DEFINE_PNG_GET_ROW_FUNCTION(16)
-DEFINE_PNG_GET_ROW_FUNCTION(32)
diff --git a/nxcompext/Pgn.h b/nxcompext/Pgn.h
deleted file mode 100644
index 999e8ea..0000000
--- a/nxcompext/Pgn.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#ifndef Pgn_H
-#define Pgn_H
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-#include &quot;X11/X.h&quot;
-#include &quot;X11/Xlib.h&quot;
-#include &quot;X11/Xmd.h&quot;
-
-#include &lt;png.h&gt; 
-
-extern int PngCompareColorTable(
-#if NeedFunctionPrototypes
-  NXColorTable*     /* color_table_1 */,
-  NXColorTable*     /* color_table_2 */
-#endif
-);
-
-extern char *PngCompressData(
-#if NeedFunctionPrototypes
-    XImage*          /* image */,
-    int*             /* compressed_size */
-#endif
-);
-
-int NXCreatePalette16(
-#if NeedFunctionPrototypes
-    XImage*          /* src_image */,
-    NXColorTable*    /* color_table */,
-    CARD8*           /* image_index */,
-    int              /* nb_max */
-#endif
-);
-
-int NXCreatePalette32(
-#if NeedFunctionPrototypes
-    XImage*          /* src_image */,
-    NXColorTable*    /* color_table */,
-    CARD8*           /* image_index */,
-    int              /* nb_max */
-#endif
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* Pgn_H */
-
diff --git a/nxcompext/README b/nxcompext/README
deleted file mode 100644
index 39648e7..0000000
--- a/nxcompext/README
+++ /dev/null
@@ -1,15 +0,0 @@
-README
-------
-
-1. To compile:
-
-   &gt; tar zxvf nxcompext-X.Y.Z-N.tar.gz
-   &gt; cd nxcompext
-   &gt; ./configure
-   &gt; make
-
-   You'll have to run gmake under Solaris.
-
-2. The 'make install' target is not currently supported
-   in the Makefile, but it should be simple to fix.
-
diff --git a/nxcompext/Rgb.c b/nxcompext/Rgb.c
deleted file mode 100644
index d6cecb4..0000000
--- a/nxcompext/Rgb.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;zlib.h&gt;
-
-#include &quot;NXlib.h&quot;
-
-#include &quot;Rgb.h&quot;
-#include &quot;Z.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-#define RGB_COMPRESSION_LEVEL      4
-#define RGB_COMPRESSION_THRESHOLD  32
-#define RGB_COMPRESSION_STRATEGY   Z_DEFAULT_STRATEGY
-
-static int rgbCompressionLevel     = RGB_COMPRESSION_LEVEL;
-static int rgbCompressionThreshold = RGB_COMPRESSION_THRESHOLD;
-static int rgbCompressionStrategy  = RGB_COMPRESSION_STRATEGY;
-
-char *RgbCompressData(XImage *image, unsigned int *size)
-{
-  return ZCompressData(image -&gt; data, image -&gt; bytes_per_line * image -&gt; height,
-                           rgbCompressionThreshold, rgbCompressionLevel,
-                               rgbCompressionStrategy, size);
-}
diff --git a/nxcompext/Rle.c b/nxcompext/Rle.c
deleted file mode 100644
index b647dbb..0000000
--- a/nxcompext/Rle.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;zlib.h&gt;
-
-#include &quot;NXlib.h&quot;
-
-#include &quot;Rle.h&quot;
-#include &quot;Z.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-#define RLE_COMPRESSION_LEVEL      1
-#define RLE_COMPRESSION_THRESHOLD  32
-#define RLE_COMPRESSION_STRATEGY   Z_RLE
-
-static int rleCompressionLevel     = RLE_COMPRESSION_LEVEL;
-static int rleCompressionThreshold = RLE_COMPRESSION_THRESHOLD;
-static int rleCompressionStrategy  = RLE_COMPRESSION_STRATEGY;
-
-char *RleCompressData(XImage *image, unsigned int *size)
-{
-  return ZCompressData(image -&gt; data, image -&gt; bytes_per_line * image -&gt; height,
-                           rleCompressionThreshold, rleCompressionLevel,
-                               rleCompressionStrategy, size);
-}
diff --git a/nxcompext/Rle.h b/nxcompext/Rle.h
deleted file mode 100644
index 7125d2f..0000000
--- a/nxcompext/Rle.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#ifndef Rle_H
-#define Rle_H
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-extern char *RleCompressData(
-#if NeedFunctionPrototypes
-    XImage*                   /* image */,
-    unsigned int*             /* compressed_size */
-#endif
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* Rle_H */
diff --git a/nxcompext/VERSION b/nxcompext/VERSION
deleted file mode 100644
index 1545d96..0000000
--- a/nxcompext/VERSION
+++ /dev/null
@@ -1 +0,0 @@
-3.5.0
diff --git a/nxcompext/Z.c b/nxcompext/Z.c
deleted file mode 100644
index d6ed3d1..0000000
--- a/nxcompext/Z.c
+++ /dev/null
@@ -1,301 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &lt;zlib.h&gt;
-
-#include &quot;NXlib.h&quot;
-
-#include &quot;Z.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-#define Z_COMPRESSION_LEVEL      4
-#define Z_COMPRESSION_THRESHOLD  32
-#define Z_COMPRESSION_STRATEGY   Z_DEFAULT_STRATEGY
-
-static int zCompressionLevel    = Z_COMPRESSION_LEVEL;
-static int zCompressionStrategy = Z_COMPRESSION_STRATEGY;
-
-static z_stream *zStream;
-
-static int zInitialized;
-
-static int ZConfigure(int level, int strategy);
-
-static int ZDeflate(char *dest, unsigned int *destLen,
-                        const char *source, unsigned int sourceLen);
-
-char *ZCompressData(const char *plainData, unsigned int plainSize, int threshold,
-                        int level, int strategy, unsigned int *compressedSize)
-{
-  char *compressedData;
-
-  /*
-   * Determine the size of the source image
-   * data and make sure there is enough
-   * space in the destination buffer.
-   */
-
-  *compressedSize = plainSize + (plainSize / 1000) + 12 + 1;
-
-  compressedData = Xmalloc(*compressedSize);
-
-  if (compressedData == NULL)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******ZCompressData: PANIC! Failed to allocate [%d] bytes for the destination.\n&quot;,
-                *compressedSize);
-    #endif
-
-    *compressedSize = 0;
-
-    return NULL;
-  }
-
-  if (level == Z_NO_COMPRESSION || plainSize &lt; threshold)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******ZCompressData: Not compressing [%d] bytes with level [%d] and &quot;
-	    &quot;threshold [%d].\n&quot;, plainSize, level, threshold);
-    #endif
-
-    /*
-     * Tell in the first byte of the buffer
-     * if the remaining data is compressed
-     * or not. This same byte can be used
-     * in future to store some other flag.
-     */
-
-    *compressedData = 0;
-
-    memcpy(compressedData + 1, plainData, plainSize);
-
-    *compressedSize = plainSize + 1;
-
-    return compressedData;
-  }
-  else
-  {
-    int result;
-
-    /*
-     * Reconfigure the stream if needed.
-     */
-
-    if (zCompressionLevel != level ||
-            zCompressionStrategy != strategy)
-    {
-      ZConfigure(level, strategy);
-
-      zCompressionLevel    = level;
-      zCompressionStrategy = strategy;
-    }
-
-    result = ZDeflate(compressedData + 1, compressedSize, plainData, plainSize);
-
-    if (result != Z_OK)
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******ZCompressData: PANIC! Failed to compress [%d] bytes with error [%s].\n&quot;,
-                  plainSize, zError(result));
-      #endif
-
-      Xfree(compressedData);
-
-      *compressedSize = 0;
-
-      return NULL;
-    }
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******ZCompressData: Source data of [%d] bytes compressed to [%d].\n&quot;,
-                plainSize, *compressedSize);
-    #endif
-
-    *compressedData = 1;
-
-    *compressedSize = *compressedSize + 1;
-
-    return compressedData;
-  }
-}
-
-int ZConfigure(int level, int strategy)
-{
-  /*
-   * ZLIB wants the avail_out to be
-   * non zero, even if the stream was
-   * already flushed.
-   */
-
-  unsigned char dest[1];
-
-  zStream -&gt; next_out  = dest;
-  zStream -&gt; avail_out = 1;
-
-  if (deflateParams(zStream, level, strategy) != Z_OK)
-  {
-    #ifdef PANIC
-    fprintf(stderr, &quot;******ZConfigure: PANIC! Failed to set level to [%d] and strategy to [%d].\n&quot;,
-                level, strategy);
-    #endif
-
-    return -1;
-  }
-  #ifdef TEST
-  else
-  {
-    fprintf(stderr, &quot;******ZConfigure: Reconfigured the stream with level [%d] and strategy [%d].\n&quot;,
-                level, strategy);
-  }
-  #endif
-
-  return 1;
-}
-
-int ZDeflate(char *dest, unsigned int *destLen, const char *source, unsigned int sourceLen)
-{
-  int saveOut;
-  int result;
-
-  /*
-   * Deal with the possible overflow.
-   */
-
-  if (zStream -&gt; total_out &amp; 0x80000000)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;******ZDeflate: Reset Z stream counters with total in [%ld] total out [%ld].\n&quot;,
-                zStream -&gt; total_in, zStream -&gt; total_out);
-    #endif
-
-    zStream -&gt; total_in  = 0;
-    zStream -&gt; total_out = 0;
-  }
-
-  saveOut = zStream -&gt; total_out;
-
-  zStream -&gt; next_in  = (Bytef *) source;
-  zStream -&gt; avail_in = (uInt) sourceLen;
-
-  #ifdef MAXSEG_64K
-
-  /*
-   * Check if the source is greater
-   * than 64K on a 16-bit machine.
-   */
-
-  if ((uLong) zStream -&gt; avail_in != sourceLen) return Z_BUF_ERROR;
-
-  #endif
-
-  zStream -&gt; next_out  = (unsigned char *) dest;
-  zStream -&gt; avail_out = (uInt) *destLen;
-
-  if ((uLong) zStream -&gt; avail_out != *destLen) return Z_BUF_ERROR;
-
-  result = deflate(zStream, Z_FINISH);
-
-  if (result != Z_STREAM_END)
-  {
-    deflateReset(zStream);
-
-    return (result == Z_OK ? Z_BUF_ERROR : result);
-  }
-
-  *destLen = zStream -&gt; total_out - saveOut;
-
-  result = deflateReset(zStream);
-
-  return result;
-}
-
-int ZInitEncoder()
-{
-  if (zInitialized == 0)
-  {
-    int result;
-
-    zStream = Xmalloc(sizeof(z_stream));
-
-    if (zStream == NULL)
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******ZInitEncoder: PANIC! Failed to allocate memory for the stream.\n&quot;);
-      #endif
-
-      return -1;
-    }
-
-    zStream -&gt; zalloc = (alloc_func) 0;
-    zStream -&gt; zfree  = (free_func) 0;
-    zStream -&gt; opaque = (voidpf) 0;
-
-    #ifdef TEST
-    fprintf(stderr, &quot;******ZInitEncoder: Initializing compressor with level [%d] and startegy [%d].\n&quot;,
-                zCompressionLevel, zCompressionStrategy);
-    #endif
-
-    result = deflateInit2(zStream, zCompressionLevel, Z_DEFLATED,
-                              15, 9, zCompressionStrategy);
-
-    if (result != Z_OK)
-    {
-      #ifdef PANIC
-      fprintf(stderr, &quot;******ZInitEncoder: Failed to initialize the compressor with error [%s].\n&quot;,
-                  zError(result));
-      #endif
-
-      return -1;
-    }
-
-    zInitialized = 1;
-  }
-
-  return zInitialized;
-}
-
-int ZResetEncoder()
-{
-  int result;
-
-  if (zInitialized == 1)
-  {
-    result = deflateEnd(zStream);
-
-    if (result != Z_OK)
-    {
-      #ifdef WARNING
-      fprintf(stderr, &quot;******ZResetEncoder: WARNING! Failed to deinitialize the compressor with error [%s].\n&quot;,
-                  zError(result));
-      #endif
-    }
-
-    Xfree(zStream);
-  }
-
-  zInitialized = 0;
-
-  return 1;
-}
diff --git a/nxcompext/Z.h b/nxcompext/Z.h
deleted file mode 100644
index b6733c6..0000000
--- a/nxcompext/Z.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rigths reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#ifndef Z_H
-#define Z_H
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-int ZInitEncoder(
-#if NeedFunctionPrototypes
-void
-#endif
-);
-
-int ZResetEncoder(
-#if NeedFunctionPrototypes
-void
-#endif
-);
-
-extern char *ZCompressData(
-#if NeedFunctionPrototypes
-    const char*     /* data */,
-    unsigned int    /* size */,
-    int             /* threshold */,
-    int             /* level */,
-    int             /* strategy */,
-    unsigned int*   /* compressed_size */
-#endif
-);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* Z_H */
diff --git a/nxcompext/configure.in b/nxcompext/configure.in
deleted file mode 100644
index fe5abf7..0000000
--- a/nxcompext/configure.in
+++ /dev/null
@@ -1,249 +0,0 @@
-dnl Process this file with autoconf to produce a configure script.
-
-dnl Prolog
-
-AC_INIT(NXlib.h)
-AC_PREREQ(2.13)
-
-dnl Reset default compilation flags.
-
-CXXFLAGS=&quot;-O3&quot;
-CFLAGS=&quot;-O3&quot;
-
-dnl Reset default linking directives.
-
-LIBSTATIC=&quot;&quot;
-LIBSHARED=&quot;&quot;
-
-dnl Prefer headers and libraries from nx-X11, if present.
-
-if test -d &quot;../nx-X11/include&quot; ; then
-    CXXFLAGS=&quot;$CXXFLAGS -I../nx-X11/exports/include -I../nx-X11/lib/X11 \
-                        -I../nx-X11/include -I../nx-X11/programs/Xserver/include&quot;
-    CFLAGS=&quot;$CFLAGS -I../nx-X11/exports/include -I../nx-X11/lib/X11 \
-                    -I../nx-X11/include -I../nx-X11/programs/Xserver/include&quot;
-    LDFLAGS=&quot;$LDFLAGS -L../nx-X11/exports/lib&quot;
-fi
-
-dnl Check for programs.
-
-AC_PROG_CXX
-AC_PROG_CC
-AC_LANG_CPLUSPLUS
-
-dnl Check for BSD compatible install.
-
-AC_PROG_INSTALL
-
-dnl Check for extra header files.
-
-AC_PATH_XTRA
-
-dnl Custom addition.
-ac_help=&quot;$ac_help
-  --with-symbols          add the -g flag to produce the debug symbols
-  --with-info             enable basic log output to trace the program
-  --with-valgrind         clean up allocated buffers to avoid valgrind warnings
-  --with-version          use this version for produced libraries
-
-  --with-static-png       enable static linking of PNG library
-  --with-static-jpeg      enable static linking of JPEG library&quot;
-
-dnl Check to see if we're running under Cygwin32.
-
-AC_DEFUN(nxproxy_CYGWIN32,
-[AC_CACHE_CHECK(for Cygwin32 environment, nxproxy_cv_cygwin32,
-[AC_TRY_COMPILE(,[return __CYGWIN32__;],
-nxproxy_cv_cygwin32=yes, nxproxy_cv_cygwin32=no)
-rm -f conftest*])
-CYGWIN32=
-test &quot;$nxproxy_cv_cygwin32&quot; = yes &amp;&amp; CYGWIN32=yes])
-
-dnl CygWin32 requires the stdc++ library explicitly linked.
-
-nxproxy_CYGWIN32
-if test &quot;$CYGWIN32&quot; = yes; then
-    LIBS=&quot;$LIBS -mwindows -lstdc++&quot;
-fi
-
-dnl Check whether we're building on a AMD64.
-
-AC_DEFUN(nxconf_AMD64,
-[AC_CACHE_CHECK(for Amd64 environment, nxconf_cv_amd64,
-[AC_TRY_COMPILE(,[return (__amd64__ || __x86_64__);],
-nxconf_cv_amd64=yes, nxconf_cv_amd64=no)
-rm -f conftest*])
-AMD64=
-test &quot;$nxconf_cv_amd64&quot; = yes &amp;&amp; AMD64=yes])
-nxconf_AMD64
-
-dnl Check to see if we're running under Solaris.
-
-AC_DEFUN(nxconf_SUN,
-[AC_CACHE_CHECK(for SunOS environment, nxconf_cv_sun,
-[AC_TRY_COMPILE(,[return __sun;],
-nxconf_cv_sun=yes, nxconf_cv_sun=no)
-rm -f conftest*])
-SUN=
-test &quot;$nxconf_cv_sun&quot; = yes &amp;&amp; SUN=yes])
-nxconf_SUN
-
-if test &quot;$SUN&quot; = yes; then
-  CFLAGS=&quot;$CFLAGS -I/usr/sfw/include&quot;
-fi
-
-if test &quot;$SUN&quot; = yes; then
-  LDFLAGS=&quot;$LDFLAGS -G -h \$(LIBLOAD) -L/usr/sfw/lib&quot; 
-else
-  LDFLAGS=&quot;$LDFLAGS -shared -Wl,-soname,\$(LIBLOAD)&quot;
-fi
-
-dnl Check to see if we're running under FreeBSD.
-
-AC_DEFUN(nxconf_FreeBSD,
-[AC_CACHE_CHECK(for FreeBSD environment, nxconf_cv_freebsd,
-[AC_TRY_COMPILE(,[return __FreeBSD__;],
-nxconf_cv_freebsd=yes, nxconf_cv_freebsd=no)
-rm -f conftest*])
-FreeBSD=
-test &quot;$nxconf_cv_freebsd&quot; = yes &amp;&amp; FreeBSD=yes])
-nxconf_FreeBSD
-
-dnl Build PIC libraries.
-
-if test &quot;$CYGWIN32&quot; != yes -a &quot;$DARWIN&quot; != yes; then
-  CXXFLAGS=&quot;$CXXFLAGS -fPIC&quot;
-  CFLAGS=&quot;$CFLAGS -fPIC&quot;
-fi
-
-dnl On FreeBSD search libraries and includes under /usr/local.
-
-if test &quot;$FreeBSD&quot; = yes; then
-  LIBS=&quot;$LIBS  -L/usr/local/lib&quot;
-  CXXFLAGS=&quot;$CXXFLAGS -I/usr/local/include&quot;
-  CFLAGS=&quot;$CFLAGS -I/usr/local/include&quot;
-fi
-
-dnl Check whether --with-static-png  was
-dnl given and add -lpng or libpng.a to linking.
-
-if test &quot;${with_static_png}&quot; = yes; then
-  echo -e &quot;enabling static linking of PNG library&quot;
-  if test &quot;$CYGWIN32&quot; = yes; then
-    LIBS=&quot;$LIBSTATIC -static -lpng&quot;
-  else
-    if test -f &quot;/usr/lib/libpng.a&quot; ; then
-      LIBS=&quot;/usr/lib/libpng.a $LIBS&quot;
-    else
-      if test -f &quot;/usr/local/lib/libpng.a&quot; ; then
-        echo -e &quot;assuming libpng.a in /usr/local/lib&quot;
-        LIBS=&quot;/usr/local/lib/libpng.a $LIBS&quot;
-      else
-        echo -e &quot;assuming libpng.a in default linker path&quot;
-        LIBS=&quot;libpng.a $LIBS&quot;
-      fi
-    fi
-  fi
-else
-  echo -e &quot;enabling dynamic linking of PNG library&quot;
-  LIBS=&quot;-lpng $LIBS&quot;
-fi
-
-dnl Check whether --with-static-jpeg  was
-dnl given and add -ljpeg or libjpeg.a to linking.
-if test &quot;${with_static_jpeg}&quot; = yes; then
-  echo -e &quot;enabling static linking of JPEG library&quot;
-  if test &quot;$CYGWIN32&quot; = yes; then
-    LIBSTATIC=&quot;$LIBS -static -ljpeg&quot;
-  else
-    if test -f &quot;/usr/lib/libjpeg.a&quot; ; then
-      LIBS=&quot;/usr/lib/libjpeg.a $LIBS&quot;
-    else
-      if test -f &quot;/usr/local/lib/libjpeg.a&quot; ; then
-        echo -e &quot;assuming libjpeg.a in /usr/local/lib&quot;
-        LIBS=&quot;/usr/local/lib/libjpeg.a $LIBS&quot;
-      else
-        echo -e &quot;assuming libjpeg.a in default linker path&quot;
-        LIBS=&quot;libjpeg.a $LIBS&quot;
-      fi
-    fi
-  fi
-else
-  echo -e &quot;enabling dynamic linking of JPEG library&quot;
-  LIBS=&quot;-ljpeg $LIBS&quot;
-fi
-
-dnl Check whether --with-symbols or --without-symbols was
-dnl given and set the required optimization level.
-if test &quot;${with_symbols}&quot; = yes; then
-  echo -e &quot;enabling production of debug symbols&quot;
-  CXXFLAGS=&quot;-g $CXXFLAGS&quot;
-  CFLAGS=&quot;-g $CFLAGS&quot;
-else
-  echo -e &quot;disabling production of debug symbols&quot;
-fi
-
-dnl Check whether --with-info or --without-info was given.
-if test &quot;${with_info}&quot; = yes; then
-  echo -e &quot;enabling info output in the log file&quot;
-  CXXFLAGS=&quot;$CXXFLAGS -DINFO&quot;
-  CFLAGS=&quot;$CFLAGS -DINFO&quot;
-else
-  echo -e &quot;disabling info output in the log file&quot;
-fi
-
-dnl Check whether --with-valgrind or --without-valgrind was given.
-if test &quot;${with_valgrind}&quot; = yes; then
-  echo -e &quot;enabling valgrind memory checker workarounds&quot;
-  CXXFLAGS=&quot;$CXXFLAGS -DVALGRIND&quot;
-  CFLAGS=&quot;$CFLAGS -DVALGRIND&quot;
-else
-  echo -e &quot;disabling valgrind memory checker workarounds&quot;
-fi
-
-dnl Check whether --with-version was given.
-AC_SUBST(LIBVERSION)
-AC_SUBST(VERSION)
-if test &quot;${with_version}&quot; = yes; then
-  VERSION=${ac_option}
-else
-  VERSION=`cat VERSION`
-fi
-echo -e &quot;compiling version ${VERSION}&quot;
-
-LIBVERSION=`echo ${VERSION} | cut -d '.' -f 1`
-
-CXXFLAGS=&quot;$CXXFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
-CFLAGS=&quot;$CFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
-
-dnl Find makedepend somewhere.
-
-AC_SUBST(MAKEDEPEND)
-
-if test -x &quot;../nx-X11/config/makedepend/makedepend&quot; ; then
-  MAKEDEPEND=../nx-X11/config/makedepend/makedepend
-else
-  if test -x &quot;/usr/X11R6/bin/makedepend&quot; ; then
-    MAKEDEPEND=/usr/X11R6/bin/makedepend
-  else
-    if test -x &quot;/usr/openwin/bin/makedepend&quot; ; then
-      MAKEDEPEND=/usr/openwin/bin/makedepend
-    else
-      MAKEDEPEND=/usr/bin/makedepend
-    fi
-  fi
-fi
-
-dnl Determine what to build based on the platform.
-dnl Override the LIBS settings on Cygwin32 so that
-dnl we always link with the exact set of libraries.
-
-AC_SUBST(ALL)
-
-if test &quot;$CYGWIN32&quot; = yes; then
-    ALL=&quot;\$(LIBCYGARCHIVE) \$(LIBCYGSHARED) \$(LIBARCHIVE)&quot;
-else
-    ALL=&quot;\$(LIBFULL) \$(LIBLOAD) \$(LIBSHARED) \$(LIBARCHIVE)&quot;
-fi
-
-AC_OUTPUT(Makefile)
diff --git a/nxcompext/mkinstalldirs b/nxcompext/mkinstalldirs
deleted file mode 100755
index 936cf34..0000000
--- a/nxcompext/mkinstalldirs
+++ /dev/null
@@ -1,34 +0,0 @@
-#! /bin/sh
-# mkinstalldirs --- make directory hierarchy
-# Author: Noah Friedman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">friedman at prep.ai.mit.edu</A>&gt;
-# Created: 1993-05-16
-# Last modified: 1995-03-05
-# Public domain
-
-errstatus=0
-
-for file in ${1+&quot;$@&quot;} ; do
-   set fnord `echo &quot;:$file&quot; | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
-   shift
-
-   pathcomp=
-   for d in ${1+&quot;$@&quot;} ; do
-     pathcomp=&quot;$pathcomp$d&quot;
-     case &quot;$pathcomp&quot; in
-       -* ) pathcomp=./$pathcomp ;;
-     esac
-
-     if test ! -d &quot;$pathcomp&quot;; then
-        echo &quot;mkdir $pathcomp&quot; 1&gt;&amp;2
-        mkdir &quot;$pathcomp&quot; &gt; /dev/null 2&gt;&amp;1 || lasterr=$?
-     fi
-
-     if test ! -d &quot;$pathcomp&quot;; then
-	errstatus=$lasterr
-     fi
-
-     pathcomp=&quot;$pathcomp/&quot;
-   done
-done
-
-exit $errstatus
diff --git a/nxcompshad/CHANGELOG b/nxcompshad/CHANGELOG
new file mode 100644
index 0000000..54c3722
--- /dev/null
+++ b/nxcompshad/CHANGELOG
@@ -0,0 +1,329 @@
+ChangeLog:
+
+nxcompshad-3.1.0-2
+
+- Updated file VERSION to match the current release version.
+
+nxcompshad-3.1.0-1
+
+- Opened the 3.1.0 branch based on nxcompshad-3.0.0-19.
+
+nxcompshad-3.0.0-19
+
+- Skip initialization of damage extension if it was already disabled.
+
+nxcompshad-3.0.0-18
+
+- The poller destructor checks if the damage extension is in use.
+
+- Small changes to the function getting the screen content in the case
+  damage is not in use.
+
+nxcompshad-3.0.0-17
+
+- Cleanup of some log messages.
+
+nxcompshad-3.0.0-16
+
+- Disabled some log message in the functions initializing the poller.
+
+nxcompshad-3.0.0-15
+
+- Before calling XTest functions, it is checked if the connection to
+  master X server has been initialized.
+
+nxcompshad-3.0.0-14
+
+- After the shm segment is created, its mode is changed and it is
+  marked for destroying. A check on the number of attaches is done.
+
+nxcompshad-3.0.0-13
+
+- Creating the shm segment even if the uid of master X server can't be
+  retrieved.
+
+- Fixed reallocation of update region.
+
+- Checking if the master X server provides XTest extension.
+
+nxcompshad-3.0.0-12
+
+- Fixed a compiler warning on AMD64 platform.
+
+- Changed configure script to add -fPIC option.
+
+- Fixed a mismatch in UpdateManager destructor.
+
+nxcompshad-3.0.0-11
+
+- Fixed the function setting the uid of shm segment.
+
+- Sync with the master X server before marking the shm segment to be
+  destroyed.
+
+nxcompshad-3.0.0-10
+
+- Setting the shm segments as readable only by the master X server
+  process.
+
+- Mark shm segments to be destroyed when the last process detach.
+
+- Enabled keycode translation in order to allow keyboards of different
+  models to work.
+
+nxcompshad-3.0.0-9
+
+- Changed the LICENSE file to state that the software is only made
+  available under the version 2 of the GPL.
+
+- Added file COPYING.
+
+- Changes to translate keycodes between different keyboard types. The
+  keycodes are translated through the keysym.
+
+- Changes to convert a Mode_switch key to ISO_Level3_Shift if it is
+  needed.
+
+nxcompshad-3.0.0-8
+
+- Added interface function NXShadowDisableShm disabling the use of
+  MIT-SHM extension.
+
+- Added interface function NXShadowDisableDamage disabling the use of
+  DAMAGE extension.
+
+- Added interface function NXShadowSetDisplayUid setting the uid of
+  shadowed X server
+
+- Changed the owner of shared memory segments to the uid of the sha-
+  dowed X server.
+
+- Fixed logWarning method.
+
+- Moved the code initializing the use of shared memory to shmInit
+  method of X11 Poller.
+
+nxcompshad-3.0.0-7
+
+- Removed the class qualifier in the declaration of destroyUpdate-
+  ManagerRegion().
+
+nxcompshad-3.0.0-6
+
+- Fixed build errors on 64 bit platforms.
+
+- Called XTestGrabControl to override possible grabs of the X server.
+
+nxcompshad-3.0.0-5
+
+- Added some stub members to the Poller class. These are intended to
+  handle keyboard state.
+
+- Changes in the default polling algorithm to disable the line pri-
+  ority persistence.
+
+nxcompshad-3.0.0-4
+
+- If a low layer handling of screen changes is available (DAMAGE in
+  case of X11), polling routine uses it and returns immediately.
+
+- Creating a Damage notify object if the extension is supported.
+
+- DamageNotify events are saved in the update region. After all avail-
+  able events have been handled, the content of screen is retrieved
+  by ShnGetImage requests.
+
+- XDamageSubtract and XSync are done before any event handling.
+
+- Damages are requested as raw rectangles.
+
+- Added Xdamage and Xrandr to required libraries.
+
+- Fixed a problem with some lines not refreshed in shadowing mode.
+
+nxcompshad-3.0.0-3
+
+- Added destroyUpdateManagerRegion() method to UpdateManager class.
+
+- Turned off some log messages.
+
+- Changed configure.in to remove warnings related to deprecated header
+  files and options.
+
+- Changed Makefile.in to remove autom4te.cache dir if the target is
+  'distclean'.
+
+- Removed multi-word file names.
+
+nxcompshad-3.0.0-2
+
+- Changes to get the screen of original display by a ShmGetImage.
+
+- Exit the polling loop if more than 50 ms have elapsed.
+
+nxcompshad-3.0.0-1
+
+- Created nxcompshad based on nxshadow-3.0.0-7.
+
+nxshadow-3.0.0-7
+
+- Deleted files KeyCursorTmp.cpp, scancodes.h, constant.h.
+
+- Renamed NXshadow.h to Shadow.h.
+
+- Merged NXshadowEvent.h with Shadow.h.
+
+- Fixed configure.in, changed Makefile.in to build Xcompshad library,
+  rebuilt configure script.
+
+nxshadow-3.0.0-6
+
+- Implemented a callback mechanism to ask the caller program if screen
+  polling have to be suspended.
+
+nxshadow-3.0.0-5
+
+- Changes to comply with the library name.
+
+- Fixed a bug in CorePoller that could prevent the update of the last
+  line of a rectangle.
+
+nxshadow-3.0.0-4
+
+- Removed some parameters of the NXShadowAddUpdaterDisplay() function.
+
+nxshadow-3.0.0-3
+
+- Updated copyright notices to the current year.
+
+- Code cleanup in KeysCursorTmp.c file.
+
+nxshadow-3.0.0-2
+
+- If master agent uses shared memory extension, the GetImage is rea-
+  lized by XShmGetImage() function.
+
+- Added new parameters to NXShadowAddUpdaterDisplay() function, the
+  depth and bit mask color of the master display.
+
+nxshadow-3.0.0-1
+
+- Opened the nxshadow-3.0.0 branch based on the nxaccess-3.0.0-13.
+
+- Renamed NXaccess.h NXaccessEvent.h and RegionM.h files as NXshadow.h
+  NXshadowEvent.h and Regions.h.
+
+- Modified the Makefile.in file and configure scripts in order to
+  compile the component.
+
+nxaccess-3.0.0-13
+
+- Fixed X11Poller.cpp pre-processing.
+
+nxaccess-3.0.0-12
+
+- Fixed build problems on Solaris.
+
+nxaccess-3.0.0-11
+
+- Added NXShadowUpdateBuffer() function. This function creates the
+  buffer for the polling.
+
+- If the scaline fails, the polling will suspend for 50 ms.
+
+- Added some functions in order to access data member class.
+
+nxaccess-3.0.0-10
+
+- Used XTEST extension to make the shared display create input events.
+
+nxaccess-3.0.0-9
+
+- Added the mouse events.
+
+- Now, it's possible to connect to X server display or agent display,
+  the display's content is captured by GetImage and sent to another
+  display by PutImage.
+
+nxaccess-3.0.0-8
+
+- Added KeysCursorTmp.cpp file.
+
+- Solved a problem with the keys, when the window lost focus the Key-
+  Release events weren't propagated.
+
+nxaccess-3.0.0-7
+
+- Added functions in order to remove issues with some keys combina-
+  tion.
+
+nxaccess-3.0.0-6
+
+- Added functions to simulate keys Ctrl + Alt + Del in order to run
+  the Task Manager application.
+
+- Now nxaccess is able to manage all switches between desktops.
+
+nxaccess-3.0.0-5
+
+- Solved a problem with the cursor shape. After a while, the cursor
+  shape are no more updated.
+
+- Now the cursor is updated only when it changes its shape.
+
+- Removed a dirty lines after screen updates.
+
+- Removed the unused file Keyboard.cpp.
+
+- Added the colorCorrect() macro in NXaccess.h.
+
+- Removed the colorCorrect() function in Updater.cpp.
+
+nxaccess-3.0.0-4
+
+- Renamed some source files and functions conforming them to the name
+  of component.
+
+nxaccess-3.0.0-3
+
+- Removed the parameter of type Display in all methods of the class
+  Poller.
+
+- Print, Break and Pause keys are enabled.
+
+nxaccess-3.0.0-2
+
+- Modified the Makefile.in in order to avoid compiling the executive
+  file.
+
+- Removed the unused file Main.cpp.
+
+- The Windows keys are enabled.
+
+- Synchronized local and remote states of Num_Lock, Caps_Lock and
+  Scroll_Lock.
+
+- Updated the NoMachine copyright notices.
+
+nxaccess-3.0.0-1
+
+- Opened the 3.0.0 branch based on the nxmirror-2.0.0-3.
+
+nxmirror-2.0.0-3
+
+- Added the keyboard events for all layouts.
+
+- The mouse wheel button is enabled.
+
+nxmirror-2.0.0-2
+
+- Completed implementation of the keyboard events only for italian
+  layout.
+
+- Added the mouse events and shape cursor.
+
+nxmirror-2.0.0-1
+
+- Opened the 2.0.0 branch based on the 1.5.0-60.
+
+- Added CHANGELOG.
diff --git a/nxcompext/COPYING b/nxcompshad/COPYING
similarity index 100%
rename from nxcompext/COPYING
rename to nxcompshad/COPYING
diff --git a/nxcompshad/Core.cpp b/nxcompshad/Core.cpp
new file mode 100644
index 0000000..351fa8f
--- /dev/null
+++ b/nxcompshad/Core.cpp
@@ -0,0 +1,598 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;string.h&gt;
+#include &lt;sys/time.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &quot;Core.h&quot;
+#include &quot;Logger.h&quot;
+
+const int CorePoller::maxSliceHeight_ = 20;
+const int CorePoller::minSliceHeight_ = 3;
+
+const char CorePoller::interlace_[] =
+{
+  0, 16,
+  8, 24,
+  4, 20, 12, 28,
+  2, 18, 10, 26, 6, 22, 14, 30,
+  1, 17,
+  9, 25,
+  5, 21, 13, 29,
+  3, 19, 11, 27, 7, 23, 15, 31
+};
+
+CorePoller::CorePoller(Input *input, Display *display) : input_(input)
+{
+  logTrace(&quot;CorePoller::CorePoller&quot;);
+
+  buffer_ = NULL;
+  lastUpdatedRegion_ = NULL;
+  lineStatus_ = NULL;
+  linePriority_ = NULL;
+  lefts_ = NULL;
+  rights_ = NULL;
+}
+
+CorePoller::~CorePoller()
+{
+  logTrace(&quot;CorePoller::~CorePoller&quot;);
+
+  if (buffer_ != NULL)
+  {
+    delete [] buffer_;
+
+    buffer_ = NULL;
+  }
+
+  if (lastUpdatedRegion_ != NULL)
+  {
+    XDestroyRegion(lastUpdatedRegion_);
+
+    lastUpdatedRegion_ = NULL;
+  }
+
+  if (lineStatus_ != NULL)
+  {
+    delete [] lineStatus_;
+
+    lineStatus_ = NULL;
+  }
+
+  if (linePriority_ != NULL)
+  {
+    delete [] linePriority_;
+
+    linePriority_ = NULL;
+  }
+
+  if (lefts_ != NULL)
+  {
+    delete [] lefts_;
+
+    lefts_ = NULL;
+  }
+
+  if (rights_ != NULL)
+  {
+    delete [] rights_;
+
+    rights_ = NULL;
+  }
+}
+
+int CorePoller::init()
+{
+  logTrace(&quot;CorePoller::init&quot;);
+
+  createFrameBuffer();
+
+  if (buffer_ == NULL)
+  {
+    logError(&quot;CorePoller::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  logTest(&quot;CorePoller::init&quot;, &quot;Allocated frame buffer at [%p] for [%d] bytes.&quot;,
+            buffer_, bpl_ * height_);
+
+  if (lastUpdatedRegion_ != NULL)
+  {
+    XDestroyRegion(lastUpdatedRegion_);
+
+    lastUpdatedRegion_ = NULL;
+  }
+
+  lastUpdatedRegion_ = XCreateRegion();
+
+  if (lineStatus_ != NULL)
+  {
+    delete[] lineStatus_;
+  }
+
+  lineStatus_ = new LineStatus[height_ + 1];
+
+  if (lineStatus_ == NULL)
+  {
+    logError(&quot;CorePoller::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  //
+  // We need this boundary element to
+  // speed up the algo.
+  //
+
+  if (linePriority_ != NULL)
+  {
+    delete[] linePriority_;
+  }
+
+  linePriority_ = new int [height_ + 1];
+
+  if (linePriority_ == NULL)
+  {
+    logError(&quot;CorePoller::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  for (unsigned int i = 0; i &lt; height_; i++)
+  {
+    linePriority_[i] = HIGHEST_PRIORITY;
+  }
+
+  if (lefts_ != NULL)
+  {
+    delete[] lefts_;
+  }
+
+  lefts_ = new int [height_];
+
+  if (rights_ != NULL)
+  {
+    delete[] rights_;
+  }
+
+  rights_ = new int [height_];
+
+  for (unsigned int i = 0; i &lt; height_; i++)
+  {
+    rights_[i] = lefts_[i] = 0;
+  }
+
+  return 1;
+}
+
+int CorePoller::isChanged(int (*checkIfInputCallback)(void *), void *arg, int *suspended)
+{
+  logTrace(&quot;CorePoller::isChanged&quot;);
+
+#if defined(__CYGWIN32__) || defined(WIN32)
+
+  checkDesktop();
+
+#endif
+
+#if !defined(__CYGWIN32__) &amp;&amp; !defined(WIN32)
+
+  if (mirror_ == 1)
+  {
+    int result = mirrorChanges_;
+
+    mirrorChanges_ = 0;
+
+    return result;
+  }
+
+#endif
+
+  logDebug(&quot;CorePoller:isChanged&quot;, &quot;Going to use default polling algorithm.\n&quot;);
+
+  //
+  // In order to allow this function to
+  // be suspended and resumed later, we
+  // need to save these two status vars.
+  // 
+
+  static int idxIlace = 0;
+  static int curLine = 0;
+
+
+  const long timeout = 50;
+  long oldTime;
+  long newTime;
+  struct timeval ts;
+
+  gettimeofday(&amp;ts, NULL);
+
+  oldTime = ts.tv_sec * 1000 + ts.tv_usec / 1000;
+
+  if (curLine == 0) // &amp;&amp; idxIlace == 0 ?
+  {
+    for (unsigned int i = 0; i &lt; height_; i++)
+    {
+      lineStatus_[i] = LINE_NOT_CHECKED;
+    }
+  }
+
+  int foundChanges = 0;
+
+  foundChanges = 0;
+
+  int curIlace = interlace_[idxIlace];
+
+  bool moveBackward = false;
+
+  logDebug(&quot;CorePoller::isChanged&quot;, &quot;Interlace index [%d] interlace [%d].&quot;, idxIlace, curIlace);
+
+  for (; curLine &lt; (int) height_; curLine++)
+  {
+    logDebug(&quot;CorePoller::isChanged&quot;, &quot;Analizing line [%d] move backward [%d] status [%d] priority [%d].&quot;,
+                curLine, moveBackward, lineStatus_[curIlace], linePriority_[curLine]);
+
+    //
+    // Ask the caller if the polling have to be suspended.
+    //
+
+    if ((*checkIfInputCallback)(arg) == 1)
+    {
+      *suspended = 1;
+
+      break;
+    }
+
+    //
+    // Suspend if too much time is elapsed.
+    //
+
+    gettimeofday(&amp;ts, NULL);
+
+    newTime = ts.tv_sec * 1000 + ts.tv_usec / 1000;
+
+    if (newTime - oldTime &gt;= timeout)
+    {
+      *suspended = 1;
+
+      break;
+    }
+
+    oldTime = newTime;
+
+    if (lineStatus_[curLine] != LINE_NOT_CHECKED)
+    {
+      continue;
+    }
+
+    if (moveBackward)
+    {
+      moveBackward = false;
+    }
+    else
+    {
+      switch (linePriority_[curLine])
+      {
+        case 1:
+        case 29:
+        {
+          //
+          // It was a priority,
+          // but now it may not be.
+          //
+        }
+        case 31:
+        {
+          //
+          // Not a priority, still isn't.
+          //
+
+          linePriority_[curLine] = NOT_PRIORITY;
+
+          break;
+        }
+        case 0:
+        {
+          //
+          // Make it a priority.
+          //
+
+          linePriority_[curLine] = PRIORITY;
+
+          break;
+        }
+        default:
+        {
+          linePriority_[curLine]--;
+
+          break;
+        }
+      }
+
+      if ((linePriority_[curLine] &gt; PRIORITY) &amp;&amp; ((curLine &amp; 31) != curIlace))
+      {
+        continue;
+      }
+    }
+
+    XRectangle rect = {0, curLine, width_, 1};
+
+    char *buffer;
+
+    logDebug(&quot;CorePoller::isChanged&quot;, &quot;Checking line [%d].&quot;, curLine);
+
+    if ((buffer = getRect(rect)) == NULL)
+    {
+      logDebug(&quot;CorePoller::isChanged&quot;, &quot;Failed to retrieve line [%d].&quot;, curLine);
+
+      return -1;
+    }
+
+    if (memcmp(buffer, buffer_ + curLine * bpl_, bpl_) == 0 || differ(buffer, rect) == 0)
+    {
+      logDebug(&quot;CorePoller::isChanged&quot;, &quot;Data buffer didn't change.&quot;);
+
+      lineStatus_[curLine] = LINE_NOT_CHANGED;
+
+      continue;
+    }
+
+    rect.x = lefts_[rect.y];
+    rect.width = rights_[rect.y] - lefts_[rect.y] + 1;
+
+    update(buffer + rect.x * bpp_, rect);
+
+    foundChanges = 1;
+
+    lineStatus_[curLine] = LINE_HAS_CHANGED;
+
+    //
+    // Wake up the next line.
+    //
+
+    if (linePriority_[curLine + 1] &gt; PRIORITY)
+    {
+      linePriority_[curLine + 1] = HIGHEST_PRIORITY;
+    }
+
+    //
+    // Give this line priority.
+    //
+
+    linePriority_[curLine] = HIGHEST_PRIORITY;
+
+    //
+    // Wake up previous line.
+    //
+
+    if (curLine &gt; 0 &amp;&amp; lineStatus_[curLine - 1] == LINE_NOT_CHECKED)
+    {
+      moveBackward = true;
+      curLine -= 2;
+    }
+  }
+
+  //
+  // Execution reached the end of loop.
+  //
+
+  if (curLine == (int) height_)
+  {
+    idxIlace = (idxIlace + 1) % 32;
+
+    curLine = 0;
+  }
+
+  //
+  // Create the region of changed pixels.
+  //
+
+  if (foundChanges)
+  {
+    int start, last, curLine, left, right;
+
+    for (curLine = 0; curLine &lt; (int) height_; curLine++)
+    {
+      if (lineStatus_[curLine] == LINE_HAS_CHANGED)
+      {
+        break;
+      }
+    }
+
+    start = curLine;
+    last = curLine;
+
+    left = lefts_[curLine];
+    right = rights_[curLine];
+    curLine++;
+
+    while (1)
+    {
+      for (; curLine &lt; (int) height_; curLine++)
+      {
+        if (lineStatus_[curLine] == LINE_HAS_CHANGED)
+        {
+          break;
+        }
+      }
+
+      if (curLine == (int) height_)
+      {
+        break;
+      }
+
+      if ((curLine - last &gt; minSliceHeight_) || (last - start &gt; maxSliceHeight_))
+      {
+        XRectangle rect = {left, start, right - left + 1, last - start + 1};
+
+        XUnionRectWithRegion(&amp;rect, lastUpdatedRegion_, lastUpdatedRegion_);
+
+        start = curLine;
+        left = lefts_[curLine];
+        right = rights_[curLine];
+      }
+      else
+      {
+        if (lefts_[curLine] &lt; left)
+        {
+          left = lefts_[curLine];
+        }
+
+        if (rights_[curLine] &gt; right)
+        {
+          right = rights_[curLine];
+        }
+      }
+
+      last = curLine;
+
+      curLine++;
+    }
+
+    //
+    // Send last block.
+    //
+
+    if (last &gt;= start)
+    {
+      XRectangle rect = {left, start, right - left + 1, last - start + 1};
+
+      XUnionRectWithRegion(&amp;rect, lastUpdatedRegion_, lastUpdatedRegion_);
+    }
+  }
+
+  return foundChanges;
+}
+
+int CorePoller::differ(char *buffer, XRectangle r)
+{
+  logTrace(&quot;CorePoller::differ&quot;);
+
+  int bpl = bpp_ * r.width;
+  int i;
+  char *pBuf;
+  char *pFb;
+
+  pBuf = (buffer);
+  pFb = (buffer_ + r.x + r.y * bpl_);
+
+  for (i = 0; i &lt; bpl; i++)
+  {
+    if (*pFb++ != *pBuf++)
+    {
+      lefts_[r.y] = i / bpp_;
+
+      break;
+    }
+  }
+
+  if (i == bpl)
+  {
+    return 0;
+  }
+
+  pBuf = (buffer) + bpl - 1;
+  pFb = (buffer_ + r.x + r.y * bpl_) + bpl - 1;
+
+  int j = i - 1;
+
+  for (i = bpl - 1; i &gt; j; i--)
+  {
+    if (*pFb-- != *pBuf--)
+    {
+      rights_[r.y] = i / bpp_;
+
+      break;
+    }
+  }
+
+  return 1;
+}
+
+void CorePoller::update(char *src, XRectangle r)
+{
+  logTrace(&quot;CorePoller::update&quot;);
+
+  char *dst = buffer_ + r.x * bpp_ + r.y * bpl_;
+  int bpl = bpp_ * r.width;
+
+  for (unsigned int i = 0; i &lt; r.height; i++)
+  {
+    memcpy(dst, src, bpl);
+
+    src += bpl;
+
+    dst += bpl_;
+  }
+}
+
+void CorePoller::handleEvent(Display *display, XEvent *event)
+{
+  logTrace(&quot;CorePoller::handleEvent&quot;);
+
+  switch (event -&gt; type)
+  {
+    case KeyPress:
+    case KeyRelease:
+    {
+      handleKeyboardEvent(display, event);
+      break;
+    }
+    case ButtonPress:
+    case ButtonRelease:
+    case MotionNotify:
+    {
+      handleMouseEvent(display, event);
+      break;
+    }
+    default:
+    {
+      logTest(&quot;CorePoller::handleEvent&quot;, &quot;Handling unexpected event [%d] from display [%p].&quot;,
+                  event -&gt; type, display);
+      break;
+    }
+  }
+}
+
+void CorePoller::handleInput()
+{
+  while (input_ -&gt; checkIfEvent())
+  {
+    Display *display = input_ -&gt; currentDisplay();
+    XEvent *event = input_ -&gt; popEvent();
+
+    handleEvent(display, event);
+
+    delete event;
+  }
+}
+
+void CorePoller::createFrameBuffer()
+{
+  logTrace(&quot;CorePoller::createFrameBuffer&quot;);
+
+  if (buffer_ == NULL)
+  {
+    buffer_ = new char[bpl_ * height_];
+  }
+}
diff --git a/nxcompshad/Core.h b/nxcompshad/Core.h
new file mode 100644
index 0000000..6d2053b
--- /dev/null
+++ b/nxcompshad/Core.h
@@ -0,0 +1,200 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef CorePoller_H
+#define CorePoller_H
+
+#include &lt;stdio.h&gt;
+
+#include &quot;Logger.h&quot;
+#include &quot;Regions.h&quot;
+#include &quot;Input.h&quot;
+
+typedef enum{
+  LINE_HAS_CHANGED,
+  LINE_NOT_CHECKED,
+  LINE_NOT_CHANGED
+} LineStatus;
+
+typedef enum{
+  HIGHEST_PRIORITY = 0,
+  PRIORITY = 30,
+  NOT_PRIORITY = 90
+} LinePriority;
+
+class CorePoller
+{
+  public:
+
+  CorePoller(Input*, Display*);
+
+  virtual ~CorePoller();
+
+  virtual int init();
+
+  unsigned int width() const;
+
+  unsigned int height() const;
+
+  unsigned char depth() const;
+
+  int isChanged(int (*)(void*), void *, int *);
+
+  char *getFrameBuffer() const;
+
+  void destroyFrameBuffer();
+
+  void createFrameBuffer();
+
+  Region lastUpdatedRegion();
+
+  Region getLastUpdatedRegion();
+
+  void handleInput();
+
+  void handleEvent(Display *, XEvent *);
+
+  Display *getShadowDisplay();
+
+  void setShadowDisplay(Display *shadowDisplay);
+
+  protected:
+
+  unsigned int bpp_;
+
+  unsigned int bpl_;
+
+  unsigned int width_;
+
+  unsigned int height_;
+
+  int depth_;
+
+  char *buffer_;
+
+  unsigned long redMask_;
+  unsigned long greenMask_;
+  unsigned long blueMask_;
+  unsigned long colorMask_[3];
+
+  char mirror_;
+
+  char mirrorChanges_;
+
+  virtual int updateShadowFrameBuffer(void) = 0;
+
+  virtual char *getRect(XRectangle r) = 0;
+
+  int imageByteOrder_;
+
+  #ifdef __CYGWIN32__
+  virtual char checkDesktop(void) = 0;
+  #endif
+
+  Display *shadowDisplay_;
+
+  void update(char *src, XRectangle r);
+
+  Region lastUpdatedRegion_;
+
+  private:
+
+  virtual void handleKeyboardEvent(Display *, XEvent *) = 0;
+
+  virtual void handleMouseEvent(Display *, XEvent *) = 0;
+
+  Input *input_;
+
+  static const int maxSliceHeight_;
+  static const int minSliceHeight_;
+
+  LineStatus *lineStatus_;
+  int *linePriority_;
+
+  static const char interlace_[];
+
+  int *lefts_;
+  int *rights_;
+
+  // FIXME: Make them friend.
+
+  int differ(char *src, XRectangle r);
+};
+
+inline unsigned int CorePoller::width() const
+{
+  return width_;
+}
+
+inline unsigned int CorePoller::height() const
+{
+  return height_;
+}
+
+inline unsigned char CorePoller::depth() const
+{
+  return depth_;
+}
+
+inline char *CorePoller::getFrameBuffer() const
+{
+  return buffer_;
+}
+
+inline void CorePoller::destroyFrameBuffer()
+{
+  if (buffer_ != NULL)
+  {
+    delete[] buffer_;
+    buffer_ = NULL;
+  }
+}
+
+inline Region CorePoller::lastUpdatedRegion()
+{
+  Region region = lastUpdatedRegion_;
+
+  lastUpdatedRegion_ = XCreateRegion();
+
+  if (lastUpdatedRegion_ == NULL)
+  {
+    logError(&quot;CorePoller::lastUpdatedRegion&quot;, ESET(ENOMEM));
+
+    lastUpdatedRegion_ = region;
+
+    return NULL;
+  }
+
+  return region;
+}
+
+inline Region CorePoller::getLastUpdatedRegion()
+{
+  return lastUpdatedRegion_;
+}
+
+inline Display *CorePoller::getShadowDisplay()
+{
+  return shadowDisplay_ ;
+}
+
+inline void CorePoller::setShadowDisplay(Display *shadowDisplay)
+{
+  shadowDisplay_ = shadowDisplay;
+}
+
+#endif /* CorePoller_H */
diff --git a/nxcompshad/Input.cpp b/nxcompshad/Input.cpp
new file mode 100644
index 0000000..c51c5d3
--- /dev/null
+++ b/nxcompshad/Input.cpp
@@ -0,0 +1,167 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;string.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &quot;Input.h&quot;
+#include &quot;Logger.h&quot;
+
+Input::Input()
+{
+  logTrace(&quot;Input::Input&quot;);
+
+  eventsHead_ = NULL;
+  eventsTail_ = NULL;
+  keymap_ = NULL;
+}
+
+Input::~Input()
+{
+  logTrace(&quot;Input::~Input&quot;);
+
+  Event *head = eventsHead_;
+
+  while (head)
+  {
+    Event *next = head -&gt; next;
+
+    delete head -&gt; event;
+    delete head;
+
+    head = next;
+  }
+
+  if (keymap_ != NULL)
+  {
+    logDebug(&quot;Input::~Input&quot;, &quot;Delete keymap_ [%p].&quot;, keymap_);
+
+    delete [] keymap_;
+  }
+}
+
+void Input::pushEvent(Display *display, XEvent *event)
+{
+  Event *tail = new Event;
+
+  if (tail == NULL)
+  {
+    logError(&quot;Input::pushEvent&quot;, ESET(ENOMEM));
+
+    return;
+  }
+
+  tail -&gt; next = NULL;
+  tail -&gt; display = display;
+  tail -&gt; event = event;
+
+  if (eventsHead_ == NULL)
+  {
+    eventsHead_ = tail;
+  }
+  else
+  {
+    eventsTail_ -&gt; next = tail;
+  }
+
+  eventsTail_ = tail;
+}
+
+XEvent *Input::popEvent()
+{
+  Event *head = eventsHead_;
+
+  if (head == NULL)
+  {
+    return 0;
+  }
+
+  XEvent *event = head -&gt; event;
+
+  eventsHead_ = head -&gt; next;
+
+  delete head;
+
+  if (eventsHead_ == NULL)
+  {
+    eventsTail_ = NULL;
+  }
+
+  return event;
+}
+
+int Input::removeAllEvents(Display *display)
+{
+  logTrace(&quot;Input::removeAllEvents&quot;);
+
+  int nRemoved = 0;
+
+  Event *current = eventsHead_;
+
+  while (current)
+  {
+    if (display == current -&gt; display)
+    {
+      //
+      // Update head of list.
+      //
+
+      if (current == eventsHead_)
+      {
+        eventsHead_ = current -&gt; next;
+      }
+
+      //
+      // Update tail of list.
+      //
+
+      if (current == eventsTail_)
+      {
+        eventsTail_ = eventsHead_;
+
+        while (eventsTail_ &amp;&amp; eventsTail_ -&gt; next)
+        {
+          eventsTail_ = eventsTail_ -&gt; next;
+        }
+      }
+
+      //
+      // Remove event.
+      //
+
+      Event *next = current -&gt; next;
+
+      delete current -&gt; event;
+      delete current;
+
+      current = next;
+
+      nRemoved++;
+    }
+    else
+    {
+      current = current -&gt; next;
+    }
+  }
+
+  return nRemoved;
+}
+
diff --git a/nxcompshad/Input.h b/nxcompshad/Input.h
new file mode 100644
index 0000000..64775c2
--- /dev/null
+++ b/nxcompshad/Input.h
@@ -0,0 +1,91 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Input_H
+#define Input_H
+
+#include &lt;X11/Xlib.h&gt;
+
+typedef struct Event
+{
+  struct Event *next;
+  Display *display;
+  XEvent *event;
+} Event;
+
+class Input
+{
+  public:
+
+  Input();
+
+  ~Input();
+
+  int checkIfEvent();
+
+  void pushEvent(Display *, XEvent *);
+
+  XEvent *popEvent();
+  Display *currentDisplay();
+
+  int removeAllEvents(Display *);
+
+  void setKeymap(char *keymap);
+  char *getKeymap();
+
+  void setShadowDisplayName(char *shadowDisplayName);
+  char *getShadowDisplayName();
+
+  private:
+
+  Event *eventsHead_;
+  Event *eventsTail_;
+  char *keymap_;
+  char *shadowDisplayName_;
+};
+
+inline Display *Input::currentDisplay()
+{
+  return eventsHead_ ? eventsHead_ -&gt; display : NULL;
+}
+
+inline int Input::checkIfEvent()
+{
+  return (eventsHead_ != NULL);
+}
+
+inline void Input::setKeymap(char *keymap)
+{
+  keymap_ = keymap;
+}
+
+inline char *Input::getKeymap()
+{
+  return keymap_;
+}
+
+inline void Input::setShadowDisplayName(char *shadowDisplayName)
+{
+  shadowDisplayName_ = shadowDisplayName;
+}
+
+inline char *Input::getShadowDisplayName()
+{
+  return shadowDisplayName_;
+}
+
+#endif /* Input_H */
diff --git a/nxcompext/LICENSE b/nxcompshad/LICENSE
similarity index 85%
rename from nxcompext/LICENSE
rename to nxcompshad/LICENSE
index 12eb657..0631b9d 100644
--- a/nxcompext/LICENSE
+++ b/nxcompshad/LICENSE
@@ -1,6 +1,7 @@
-Copyright (c) 2001, 2009 NoMachine - <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>
+Copyright (C) 2001, 2007 NoMachine - <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>
+
+NXCOMPSHAD and NX extensions to X are copyright of NoMachine.
 
-NXCOMPEXT library and NX extensions to X are copyright of NoMachine.
 Redistribution and use of this software is allowed according to the
 following terms:
 
diff --git a/nxcompshad/Logger.cpp b/nxcompshad/Logger.cpp
new file mode 100644
index 0000000..1f55ce9
--- /dev/null
+++ b/nxcompshad/Logger.cpp
@@ -0,0 +1,116 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com.">http://www.nomachine.com.</A>          */
+/*                                                                        */
+/* NXCOMP, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;unistd.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#define DEBUG
+
+#include &quot;Misc.h&quot;
+#include &quot;Logger.h&quot;
+
+Logger logger;
+
+void Logger::user(const char *format, va_list arguments)
+{
+  char string[1024];
+
+  vsnprintf(string, 1024, format, arguments);
+
+  fprintf(stderr, &quot;%s\n&quot;, string);
+}
+
+void Logger::error(const char *name, int error)
+{
+  fprintf(stderr, &quot;PANIC! %s: Failed with code %d: %s\n&quot;,
+               name, error, strerror(error));
+}
+
+void Logger::warning(const char *name, const char *format, va_list arguments)
+{
+  char string[1024];
+
+  vsnprintf(string, 1024, format, arguments);
+
+  fprintf(stderr, &quot;%s: WARNING! %s\n&quot;, name, string);
+}
+
+void Logger::test(const char *name, const char *format, va_list arguments)
+{
+  char string[1024];
+
+  vsnprintf(string, 1024, format, arguments);
+
+  fprintf(stderr, &quot;%s: %s\n&quot;, name, string);
+}
+
+void Logger::trace(const char *name)
+{
+  fprintf(stderr, &quot;%s\n&quot;, name);
+}
+
+void Logger::debug(const char *name, const char *format, va_list arguments)
+{
+  char string[1024];
+
+  vsnprintf(string, 1024, format, arguments);
+
+  fprintf(stderr, &quot;%s: %s\n&quot;, name, string);
+}
+
+void Logger::dump(const char *name, const char *data, int size)
+{
+  fprintf(stderr, &quot;%s: Dumping %d bytes of data at %p\n&quot;,
+              name, size, data);
+
+  for (int i = 0; i &lt; size;)
+  {
+    fprintf(stderr, &quot;[%d]\t&quot;, i);
+
+    int t = i;
+
+    for (unsigned int ii = 0; i &lt; size &amp;&amp; ii &lt; 8; i++, ii++)
+    {
+      fprintf(stderr, &quot;%02x/%d\t&quot;, data[i] &amp; 0xff, data[i]);
+    }
+
+    for (unsigned int ii = i % 8; ii &gt; 0 &amp;&amp; ii &lt; 8; ii++)
+    {
+      fprintf(stderr, &quot;\t&quot;);
+    }
+
+    i = t;
+
+    for (unsigned int ii = 0; i &lt; size &amp;&amp; ii &lt; 8; i++, ii++)
+    {
+      if (isprint(data[i]))
+      {
+        fprintf(stderr, &quot;%c&quot;, data[i]);
+      }
+      else
+      {
+        fprintf(stderr, &quot;.&quot;);
+      }
+    }
+
+    fprintf(stderr, &quot;\n&quot;);
+  }
+}
diff --git a/nxcompshad/Logger.h b/nxcompshad/Logger.h
new file mode 100644
index 0000000..4eff83e
--- /dev/null
+++ b/nxcompshad/Logger.h
@@ -0,0 +1,159 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com.">http://www.nomachine.com.</A>          */
+/*                                                                        */
+/* NXCOMP, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Logger_H
+#define Logger_H
+
+#include &lt;errno.h&gt;
+#include &lt;stdarg.h&gt;
+
+//
+// Error handling macros.
+//
+
+#define ESET(e)  (errno = (e))
+#define EGET()   (errno)
+#define ESTR()   strerror(errno)
+
+extern class Logger logger;
+
+class Logger
+{
+  public:
+
+  void user(const char *format, va_list arguments);
+
+  void error(const char *name, int error);
+
+  void warning(const char *name, const char *format, va_list arguments);
+
+  void test(const char *name, const char *format, va_list arguments);
+
+  void trace(const char *name);
+
+  void debug(const char *name, const char *format, va_list arguments);
+
+  void dump(const char *name, const char *data, int size);
+};
+
+static inline void logUser(const char *format, ...) \
+    __attribute__((format(printf, 1, 2))) __attribute__((__unused__));
+
+static inline void logError(const char *name, int error) \
+    __attribute__((__unused__));
+
+static inline void logWarning(const char *name, const char *format, ...) \
+    __attribute__((__unused__));
+
+static inline void logTest(const char *name, const char *format, ...) \
+    __attribute__((format(printf, 2, 3))) __attribute__((__unused__));
+
+static inline void logTrace(const char *name) \
+    __attribute__((__unused__));
+
+static inline void logDebug(const char *name, const char *format, ...) \
+    __attribute__((format(printf, 2, 3))) __attribute__((__unused__));
+
+static inline void logDump(const char *name, const char *data, int size) \
+    __attribute__((__unused__));
+
+static inline void logUser(const char *format, ...)
+{
+  va_list arguments;
+
+  va_start(arguments, format);
+
+  logger.user(format, arguments);
+
+  va_end(arguments);
+}
+
+static inline void logError(const char *name, int error)
+{
+  #if defined(DEBUG) || defined(TEST) || \
+          defined(WARNING) || defined(PANIC)
+
+  logger.error(name, error);
+
+  #endif
+}
+
+static inline void logWarning(const char *name, const char *format, ...)
+{
+  #if defined(DEBUG) || defined(TEST) || \
+          defined(WARNING)
+
+  va_list arguments;
+
+  va_start(arguments, format);
+
+  logger.warning(name, format, arguments);
+
+  va_end(arguments);
+
+  #endif
+}
+
+static inline void logTest(const char *name, const char *format, ...)
+{
+  #if defined(TEST)
+
+  va_list arguments;
+
+  va_start(arguments, format);
+
+  logger.test(name, format, arguments);
+
+  va_end(arguments);
+
+  #endif
+}
+
+static inline void logTrace(const char *name)
+{
+  #if defined(DEBUG)
+
+  logger.trace(name);
+
+  #endif
+}
+
+static inline void logDebug(const char *name, const char *format, ...)
+{
+  #if defined(DEBUG)
+
+  va_list arguments;
+
+  va_start(arguments, format);
+
+  logger.debug(name, format, arguments);
+
+  va_end(arguments);
+
+  #endif
+}
+
+static inline void logDump(const char *name, const char *data, int size)
+{
+  #if defined(TEST)
+
+  logger.dump(name, data, size);
+
+  #endif
+}
+
+#endif /* Logger_H */
diff --git a/nxcompshad/Makefile.in b/nxcompshad/Makefile.in
new file mode 100755
index 0000000..c7c22ad
--- /dev/null
+++ b/nxcompshad/Makefile.in
@@ -0,0 +1,192 @@
+############################################################################
+#                                                                          #
+#  Copyright (c) 2001, 2005 NoMachine, <A HREF="http://www.nomachine.com.">http://www.nomachine.com.</A>           #
+#                                                                          #
+#  NXCOMP, NX protocol compression and NX extensions to this software      #
+#  are copyright of NoMachine. Redistribution and use of the present       #
+#  software is allowed according to terms specified in the file LICENSE    #
+#  which comes in the source distribution.                                 #
+#                                                                          #
+#  Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.        #
+#                                                                          #
+#  NX and NoMachine are trademarks of Medialogic S.p.A.                    #
+#                                                                          #
+#  All rights reserved.                                                    #
+#                                                                          #
+############################################################################
+
+#
+# Get values from configure script.
+#
+
+VERSION=@VERSION@
+LIBVERSION=@LIBVERSION@
+
+#
+# We would really like to enable all warnings, -Wredundant-decls,
+# though, gives a warning caused by pthread.h and unistd.h and
+# GCC 3.4 was changed in a way that it now complains about some
+# of the -W directives we used before (-Wmissing-declarations,
+# -Wnested-externs, -Wstrict-prototypes and -Wmissing-prototypes).
+#
+
+CXX         = @CXX@
+CXXFLAGS    = @CXXFLAGS@ @X_CFLAGS@ @DEFS@ \
+              -Wall -Wpointer-arith
+CXXINCLUDES =
+CXXDEFINES  =
+
+#
+# C programs don't share the C++ flags. They should
+# have their own @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">CCFLAGS at .</A>
+#
+
+CC          = @CC@
+CCFLAGS     = @X_CFLAGS@ @DEFS@ \
+              -Wall -Wpointer-arith
+CCINCLUDES  =
+CCDEFINES   =
+
+LDFLAGS     = @LDFLAGS@
+LIBS        = @LIBS@ -L/usr/X11R6/lib -lX11
+
+#
+# Only if THREADS is defined.
+#
+# LIBS = $(LIBS) -lpthread
+#
+
+#
+# Only if you want ElectricFence.
+#
+# LIBS = $(LIBS) -lefence
+#
+
+#
+# Only if you want mpatrol.
+#
+# LIBS = $(LIBS) -lmpatrol -lbfd -liberty
+#
+
+srcdir      = @srcdir@
+prefix      = @prefix@
+exec_prefix = @exec_prefix@
+bindir      = @bindir@
+man1dir     = @mandir@/man1
+VPATH       = @srcdir@
+
+INSTALL         = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA    = @INSTALL_DATA@
+
+#
+# This should be autodetected.
+#
+
+MAKEDEPEND     = @MAKEDEPEND@
+DEPENDINCLUDES = -I/usr/include/g++ -I/usr/include/g++-3
+
+.SUFFIXES: .cpp.c
+
+.cpp.o:
+	$(CXX) -c $(CXXFLAGS) $(CXXINCLUDES) $(CXXDEFINES) $&lt;
+.c.o:
+	$(CC) -c $(CCFLAGS) $(CCINCLUDES) $(CCDEFINES) $&lt;
+
+LIBRARY = Xcompshad
+
+LIBNAME    = lib$(LIBRARY)
+LIBFULL    = lib$(LIBRARY).so.$(VERSION)
+LIBLOAD    = lib$(LIBRARY).so.$(LIBVERSION)
+LIBSHARED  = lib$(LIBRARY).so
+LIBARCHIVE = lib$(LIBRARY).a
+
+MSRC   = Main.c
+
+CSRC   =
+
+CXXSRC = Core.cpp \
+	 Input.cpp \
+	 Logger.cpp \
+	 Shadow.cpp \
+	 X11.cpp \
+	 Win.cpp \
+	 Updater.cpp \
+	 Manager.cpp
+
+MOBJ   = $(MSRC:.c.cpp=.o)
+COBJ   = $(CSRC:.c=.o)
+CXXOBJ = $(CXXSRC:.cpp=.o)
+
+MLIBS  = -L. -lXShadow
+
+ifeq ($(findstring -lgdi32,$(LIBS)),-lgdi32)
+
+# We need a smarter way to detect windows
+# platform.
+
+LIBDLL       = cyg$(LIBRARY).dll
+LIBDLLSTATIC = lib${LIBRARY}.dll.a
+
+all: depend $(LIBARCHIVE) $(LIBDLL)
+
+else
+
+EXTRALIBS = -lXtst -lXrandr -lXdamage
+
+all: depend $(LIBFULL) $(LIBLOAD) $(LIBSHARED) $(LIBARCHIVE)
+
+endif
+
+$(LIBFULL):	$(CXXOBJ) $(COBJ)
+		$(CXX) -o $@ $(LDFLAGS) $(CXXOBJ) $(COBJ) $(LIBS) $(EXTRALIBS)
+
+$(LIBLOAD):	$(LIBFULL)
+		rm -f $(LIBLOAD)
+		ln -s $(LIBFULL) $(LIBLOAD)
+
+$(LIBSHARED):	$(LIBFULL)
+		rm -f $(LIBSHARED)
+		ln -s $(LIBFULL) $(LIBSHARED)
+
+$(LIBARCHIVE):	$(CXXOBJ) $(COBJ)
+		rm -f  $(LIBARCHIVE)
+		ar clq $(LIBARCHIVE) $(CXXOBJ) $(COBJ)
+		ranlib $(LIBARCHIVE)
+
+$(LIBDLL): $(LIBARCHIVE)
+		$(CC) -o $@ \
+		-shared \
+		-Wl,--out-implib=$(LIBDLLSTATIC) \
+		-Wl,--export-all-symbols \
+		-Wl,--enable-auto-import \
+		-Wl,--whole-archive ${LIBARCHIVE} \
+		-Wl,--no-whole-archive \
+		${LIBS} -L/usr/X11R6/lib
+
+$(PROGRAM):	$(MOBJ) $(COBJ) $(CXXOBJ) $(LIBDLL)
+#		$(CC) $(CCFLAGS) -o $@ $(MOBJ) $(MLIBS)
+
+depends:	depend.status
+
+depend:		depend.status
+
+depend.status:	
+		if [ -x $(MAKEDEPEND) ] ; then \
+			$(MAKEDEPEND) $(CXXINCLUDES) $(CCINCLUDES) \
+                        $(DEPENDINCLUDES) -f Makefile $(MSRC) $(CSRC) $(CXXSRC) 2&gt;/dev/null; \
+		fi
+		touch depend.status
+
+install:	install.bin install.man
+
+install.bin:
+
+install.man:
+
+clean:
+		-rm -f *~ *.o *.bak st?????? core core.* *.out.* *.exe.stackdump \
+		$(LIBFULL) $(LIBLOAD) $(LIBSHARED) $(LIBARCHIVE) $(LIBDLL) $(LIBDLLSTATIC) $(PROGRAM) $(PROGRAM).exe
+
+distclean:	clean
+		-rm -rf config.status config.log config.cache depend.status Makefile tags autom4te.cache
diff --git a/nxcompshad/Manager.cpp b/nxcompshad/Manager.cpp
new file mode 100644
index 0000000..92a7cda
--- /dev/null
+++ b/nxcompshad/Manager.cpp
@@ -0,0 +1,252 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xutil.h&gt;
+#include &lt;X11/keysym.h&gt;
+#include &lt;string.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &quot;Manager.h&quot;
+#include &quot;Logger.h&quot;
+
+UpdateManager::UpdateManager(int w, int h, char *f, Input *i)
+  : width_(w), height_(h), frameBuffer_(f), input_(i)
+{
+  logTrace(&quot;UpdateManager::UpdateManager&quot;);
+
+  nUpdater = 0;
+  updaterVector = NULL;
+  updateManagerRegion_ = NULL;
+}
+
+UpdateManager::~UpdateManager()
+{
+  logTrace(&quot;UpdateManager::~UpdateManager&quot;);
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    delete updaterVector[i];
+  }
+
+  delete [] updaterVector;
+}
+
+Updater *UpdateManager::createUpdater(char *displayName, Display *display)
+{
+  Updater *updater = new Updater(displayName, display);
+
+  if (updater == NULL)
+  {
+    logError(&quot;UpdateManager::createUpdater&quot;, ESET(ENOMEM));
+
+    return NULL;
+  }
+
+  if (updater -&gt; init(width_, height_, frameBuffer_, input_) == -1)
+  {
+    logError(&quot;UpdateManager::createUpdater&quot;, EGET());
+
+    delete updater;
+
+    return NULL;
+  }
+
+  return updater;
+}
+
+UpdaterHandle UpdateManager::addUpdater(char *displayName, Display *display)
+{
+  Updater *newUpdater = createUpdater(displayName, display);
+
+  if (newUpdater == NULL)
+  {
+    logError(&quot;UpdateManager::addUpdater&quot;, EGET());
+
+    return NULL;
+  }
+
+  Updater **newUpdaterVector = new Updater*[nUpdater + 1];
+
+  if (newUpdaterVector == NULL)
+  {
+    logError(&quot;UpdateManager::addUpdater&quot;, ESET(ENOMEM));
+
+    delete newUpdater;
+
+    return NULL;
+  }
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    newUpdaterVector[i] = updaterVector[i];
+  }
+
+  newUpdaterVector[nUpdater] = newUpdater;
+
+  delete [] updaterVector;
+
+  updaterVector = newUpdaterVector;
+
+  nUpdater++;
+
+  logTest(&quot;UpdateManager::AddUpdater&quot;, &quot;Number of updaters [%d].&quot;, nUpdater);
+
+  return reinterpret_cast&lt;UpdaterHandle&gt;(newUpdater);
+}
+
+int UpdateManager::removeAllUpdaters()
+{
+  logTest(&quot;UpdateManager::removeAllUpdaters&quot;, &quot;Number of updaters [%d].&quot;, nUpdater);
+
+  int nullUpdaters = 0;
+
+  for (int i = nUpdater; i &gt; 0; i--)
+  {
+    if (removeUpdater(reinterpret_cast&lt;UpdaterHandle&gt;(updaterVector[i - 1])) == 0)
+    {
+      nullUpdaters++;
+    }
+  }
+
+  if (nUpdater == 0)
+  {
+    return 1;
+  }
+
+  if (nUpdater == nullUpdaters)
+  {
+    logTest(&quot;UpdateManager::removeAllUpdaters&quot;, &quot;Ignored null records in Updater vector.&quot;);
+
+    return 0;
+  }
+
+  logTest(&quot;UpdateManager::removeAllUpdaters&quot;, &quot;Failed to remove some updaters.&quot;);
+
+  return -1;
+}
+
+int UpdateManager::removeUpdater(UpdaterHandle handle)
+{
+  Updater * const updater = (Updater*) handle;
+
+  logTest(&quot;UpdateManager::removeUpdater&quot;, &quot;Removing Updater [%p].&quot;, updater);
+
+  if (updater == NULL)
+  {
+    return 0;
+  }
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    if (updater == updaterVector[i])
+    {
+      updaterVector[i] = updaterVector[nUpdater - 1];
+
+      nUpdater--;
+
+      delete updater;
+
+      return 1;
+    }
+  }
+
+  logTest(&quot;UpdateManager::removeUpdater&quot;, &quot;Couldn't find Updater [%p].&quot;, updater);
+
+  return -1;
+}
+
+void UpdateManager::addRegion(Region region)
+{
+  logTrace(&quot;UpdateManager::addRegion&quot;);
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    updaterVector[i] -&gt; addRegion(region);
+  }
+
+  XDestroyRegion(region);
+}
+
+void UpdateManager::update()
+{
+  logTrace(&quot;UpdateManager::update&quot;);
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    /*updaterVector[i] -&gt; update();*/
+    if (updaterVector[i] -&gt; getUpdateRegion())
+    {
+      logDebug(&quot;UpdateManager::update&quot;, &quot;pRegion [%p] rect[%ld].&quot;,
+                   updaterVector[i] -&gt; getUpdateRegion(), (updaterVector[i] -&gt; getUpdateRegion()) -&gt; numRects);
+
+      updateManagerRegion_ = updaterVector[i] -&gt; getUpdateRegion();
+      //
+      // FIXME: Remove me.
+      //
+      for (int j = 0; j &lt; updateManagerRegion_ -&gt; numRects; j++)
+      {
+        int x = updateManagerRegion_ -&gt; rects[j].x1;
+        int y = updateManagerRegion_ -&gt; rects[j].y1;
+        unsigned int width = updateManagerRegion_ -&gt; rects[j].x2 - updateManagerRegion_ -&gt; rects[j].x1;
+        unsigned int height = updateManagerRegion_ -&gt; rects[j].y2 - updateManagerRegion_ -&gt; rects[j].y1;
+        logDebug(&quot;UpdateManager::update&quot;, &quot;x[%d]y[%d]width[%u]height[%u], updateManagerRegion_[%p]&quot;,
+                  x, y, width, height, updateManagerRegion_);
+      }
+    }
+  }
+}
+
+void UpdateManager::handleInput()
+{
+  logTrace(&quot;UpdateManager::handleInput&quot;);
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    try
+    {
+      updaterVector[i] -&gt; handleInput();
+    }
+    catch (UpdaterClosing u)
+    {
+      logTest(&quot;UpdateManager::handleInput&quot;, &quot;Catched exception UpdaterClosing().&quot;);
+
+      removeUpdater((UpdaterHandle)updaterVector[i]);
+
+      //
+      // Now the i-element of the updaterVector
+      // is changed. We don't want to skip it.
+      //
+
+      i--;
+    }
+  }
+}
+
+void UpdateManager::newRegion()
+{
+  logTrace(&quot;UpdateManager::newRegion&quot;);
+
+  for (int i = 0; i &lt; nUpdater; i++)
+  {
+    updaterVector[i] -&gt; newRegion();
+  }
+}
diff --git a/nxcompshad/Manager.h b/nxcompshad/Manager.h
new file mode 100644
index 0000000..22f6b15
--- /dev/null
+++ b/nxcompshad/Manager.h
@@ -0,0 +1,115 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef UpdateManager_H
+#define UpdateManager_H
+
+#include &lt;X11/Xlib.h&gt;
+
+#include &quot;Updater.h&quot;
+#include &quot;Regions.h&quot;
+#include &quot;Input.h&quot;
+
+typedef char* UpdaterHandle;
+
+class UpdateManager
+{
+  public:
+
+  UpdateManager(int, int, char *, Input *);
+
+  ~UpdateManager();
+
+  void handleInput();
+
+  void addRegion(Region);
+
+  void update();
+
+  UpdaterHandle addUpdater(char *displayName, Display *display);
+
+  int removeUpdater(UpdaterHandle);
+
+  int removeAllUpdaters();
+
+  int numberOfUpdaters();
+
+  int getWidth();
+
+  int getHeight();
+
+  char *getBuffer();
+
+  Region getUpdateManagerRegion();
+
+  void destroyUpdateManagerRegion();
+
+  void newRegion();
+
+  private:
+
+  Updater *createUpdater(char *displayName, Display *display);
+
+  int width_;
+  int height_;
+  char *frameBuffer_;
+  Input *input_;
+
+  int nUpdater;
+
+  Updater **updaterVector;
+
+  Region updateManagerRegion_;
+
+};
+
+inline int UpdateManager::numberOfUpdaters()
+{
+  return nUpdater;
+}
+
+inline int UpdateManager::getWidth()
+{
+  return width_;
+}
+
+inline int UpdateManager::getHeight()
+{
+  return height_;
+}
+
+inline char *UpdateManager::getBuffer()
+{
+  return frameBuffer_;
+}
+
+inline Region UpdateManager::getUpdateManagerRegion()
+{
+  return updateManagerRegion_;
+}
+
+inline void UpdateManager::destroyUpdateManagerRegion()
+{
+  if (updateManagerRegion_ != NULL)
+  {
+    XDestroyRegion(updateManagerRegion_);
+
+    updateManagerRegion_ = NULL;
+  }
+}
+
+#endif /* UpdateManager_H */
diff --git a/nxcompext/Rgb.h b/nxcompshad/Misc.h
similarity index 68%
rename from nxcompext/Rgb.h
rename to nxcompshad/Misc.h
index 931ee6a..674d346 100644
--- a/nxcompext/Rgb.h
+++ b/nxcompshad/Misc.h
@@ -2,35 +2,39 @@
 /*                                                                        */
 /* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
 /*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
 /* are copyright of NoMachine. Redistribution and use of the present      */
 /* software is allowed according to terms specified in the file LICENSE   */
 /* which comes in the source distribution.                                */
 /*                                                                        */
 /* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
 /*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
 /*                                                                        */
-/* All rigths reserved.                                                   */
+/* All rights reserved.                                                   */
 /*                                                                        */
 /**************************************************************************/
 
-#ifndef Rgb_H
-#define Rgb_H
+#ifndef Misc_H
+#define Misc_H
 
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
+#include &lt;iostream.h&gt;
 
-extern char *RgbCompressData(
-#if NeedFunctionPrototypes
-    XImage*                   /* image */,
-    unsigned int*             /* compressed_size */
-#endif
-);
+#include &lt;errno.h&gt;
+#include &lt;string.h&gt;
 
-#ifdef __cplusplus
-}
-#endif
+//
+// Error handling macros.
+//
 
-#endif /* Rgb_H */
+#define ESET(e)  (errno = (e))
+#define EGET()   (errno)
+#define ESTR()   strerror(errno)
+
+//
+// Log file.
+//
+
+extern ostream *logofs;
+
+#endif /* Misc_H */
diff --git a/nxcompext/NXlibint.h b/nxcompshad/Poller.h
similarity index 74%
rename from nxcompext/NXlibint.h
rename to nxcompshad/Poller.h
index 37ba637..489ba30 100644
--- a/nxcompext/NXlibint.h
+++ b/nxcompshad/Poller.h
@@ -2,30 +2,30 @@
 /*                                                                        */
 /* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
 /*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
 /* are copyright of NoMachine. Redistribution and use of the present      */
 /* software is allowed according to terms specified in the file LICENSE   */
 /* which comes in the source distribution.                                */
 /*                                                                        */
 /* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
 /*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
 /*                                                                        */
-/* All rigths reserved.                                                   */
+/* All rights reserved.                                                   */
 /*                                                                        */
 /**************************************************************************/
 
-#ifndef NXlibint_H
-#define NXlibint_H
+#ifndef Poller_H
+#define Poller_H
 
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
+#if defined(__CYGWIN32__) || defined(WIN32)
+
+#include &quot;Win.h&quot;
+
+#else
 
-#include &quot;NXvars.h&quot;
+#include &quot;X11.h&quot;
 
-#ifdef __cplusplus
-}
 #endif
 
-#endif /* NXlibint_H */
+#endif /* Poller_H */
diff --git a/nxcompext/Clean.h b/nxcompshad/Regions.h
similarity index 68%
rename from nxcompext/Clean.h
rename to nxcompshad/Regions.h
index ba2a62d..6e6827f 100644
--- a/nxcompext/Clean.h
+++ b/nxcompshad/Regions.h
@@ -2,35 +2,34 @@
 /*                                                                        */
 /* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
 /*                                                                        */
-/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
 /* are copyright of NoMachine. Redistribution and use of the present      */
 /* software is allowed according to terms specified in the file LICENSE   */
 /* which comes in the source distribution.                                */
 /*                                                                        */
 /* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
 /*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
 /*                                                                        */
-/* All rigths reserved.                                                   */
+/* All rights reserved.                                                   */
 /*                                                                        */
 /**************************************************************************/
 
-#ifndef Clean_H
-#define Clean_H
+#ifndef Region_H
+#define Region_H
 
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xutil.h&gt;
 
-#include &quot;Xlib.h&quot;
+typedef struct {
+    short x1, x2, y1, y2;
+} Box, BOX, BoxRec, *BoxPtr;
 
-int CleanXYImage(XImage *image);
-int CleanZImage(XImage *image);
+typedef struct _XRegion {
+    long size;
+    long numRects;
+    BOX *rects;
+    BOX extents;
+};
 
-int CopyAndCleanImage(XImage *src_image, XImage *dst_image);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* Clean_H */
+#endif /* Region_H */
diff --git a/nxcompshad/Shadow.cpp b/nxcompshad/Shadow.cpp
new file mode 100644
index 0000000..7221396
--- /dev/null
+++ b/nxcompshad/Shadow.cpp
@@ -0,0 +1,439 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com.">http://www.nomachine.com.</A>          */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;signal.h&gt;
+#include &lt;string.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &quot;Logger.h&quot;
+#include &quot;Shadow.h&quot;
+#include &quot;Poller.h&quot;
+#include &quot;Manager.h&quot;
+
+ShadowOptions NXShadowOptions = {1, 1, -1};
+
+static int mirrorException = 0;
+
+static UpdateManager *updateManager;
+static Poller *poller;
+static Input *input;
+
+int NXShadowRemoveAllUpdaters();
+
+inline bool NXShadowNotInitialized()
+{
+  //
+  // updateManager depends on input and poller.
+  // So this test seem redundant.
+  //
+  // return (input == NULL) || (poller == NULL) || (updateManager == NULL);
+  //
+
+  return (updateManager == NULL);
+}
+
+#ifdef NEED_SIGNAL_HANDLER
+static void NXSignalHandler(int signal)
+{
+  logTest(&quot;NXSignalHandler&quot;, &quot;Got signal [%d]&quot;, signal);
+
+  if (signal == SIGINT)
+  {
+    mirrorException = 1;
+  }
+  else if (signal == SIGTERM)
+  {
+    mirrorException = 1;
+  }
+}
+
+static int NXInitSignal()
+{
+  logTrace(&quot;NXInitSignal&quot;);
+
+  struct sigaction sa;
+
+  sa.sa_handler = NXSignalHandler;
+  sigfillset(&amp;sa.sa_mask);
+  sa.sa_flags = 0;
+
+  int res;
+
+  while ((res = sigaction(SIGINT, &amp;sa, NULL)) == -1 &amp;&amp;
+             errno == EINTR);
+
+  if (res == -1)
+  {
+    logError(&quot;NXInitSignal&quot;, EGET());
+
+    return -1;
+  }
+
+  return 1;
+}
+#endif
+
+static void NXHandleException()
+{
+  if (mirrorException)
+  {
+    mirrorException = 0;
+
+    NXShadowRemoveAllUpdaters();
+  }
+}
+
+static int NXCreateInput(char *keymap, char *shadowDisplayName)
+{
+  logTrace(&quot;NXCreateInput&quot;);
+
+  input = new Input;
+
+  if (input == NULL)
+  {
+    logError(&quot;NXCreateInput&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  input -&gt; setKeymap(keymap);
+
+  input -&gt; setShadowDisplayName(shadowDisplayName);
+
+  return 1;
+}
+
+static int NXCreatePoller(Display *display, Display **shadowDisplay)
+{
+  logTrace(&quot;NXCreatePoller&quot;);
+
+  if (input == NULL)
+  {
+    logError(&quot;NXCreatePoller&quot;, ESET(EBADFD));
+
+    return -1;
+  }
+
+  poller = new Poller(input,display);
+
+  if (poller == NULL)
+  {
+    logError(&quot;NXCreatePoller&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  if (poller -&gt; init() == -1)
+  {
+    logTest(&quot;NXCreatePoller&quot;, &quot;Failed to initialize poller.&quot;);
+
+    return -1;
+  }
+
+  *shadowDisplay = poller -&gt; getShadowDisplay();
+
+  logTest(&quot;NXCreatePoller&quot;, &quot;Poller geometry [%d, %d], ShadowDisplay[%p].&quot;, poller -&gt; width(),
+              poller -&gt; height(), (Display *) *shadowDisplay);
+
+  return 1;
+}
+
+static int NXCreateUpdateManager()
+{
+  logTrace(&quot;NXCreateUpdateManager&quot;);
+
+  if (input == NULL || poller == NULL)
+  {
+    logError(&quot;NXCreateUpdateManager&quot;, ESET(EBADFD));
+
+    return -1;
+  }
+
+  updateManager = new UpdateManager(poller -&gt; width(), poller -&gt; height(),
+                                        poller -&gt; getFrameBuffer(), input);
+
+  if (updateManager == NULL)
+  {
+    logError(&quot;NXCreateUpdateManager&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  return 1;
+}
+
+void  NXShadowResetOptions()
+{
+  NXShadowOptions.optionShmExtension = 1;
+  NXShadowOptions.optionDamageExtension = 1;
+}
+
+//
+// Exported functions.
+//
+
+int NXShadowHasUpdaters()
+{
+  logTrace(&quot;NXShadowHasUpdaters&quot;);
+
+  return (updateManager &amp;&amp; updateManager -&gt; numberOfUpdaters()) ? 1 : 0;
+}
+
+int NXShadowRemoveAllUpdaters()
+{
+  logTrace(&quot;NXShadowRemoveAllUpdaters&quot;);
+
+  return updateManager ? updateManager -&gt; removeAllUpdaters() : 0;
+}
+
+int NXShadowRemoveUpdater(UpdaterHandle handle)
+{
+  logTrace(&quot;NXShadowRemoveUpdater&quot;);
+
+  return updateManager ? updateManager -&gt; removeUpdater(handle) : 0;
+}
+
+UpdaterHandle NXShadowAddUpdater(char *displayName)
+{
+  logTrace(&quot;NXShadowAddUpdater&quot;);
+
+  return updateManager ? updateManager -&gt; addUpdater(displayName, NULL) : NULL;
+}
+
+int NXShadowAddUpdaterDisplay(void *dpy, int *w, int *h, unsigned char *d)
+{
+  Display *display = reinterpret_cast&lt;Display*&gt;(dpy);
+
+  logTrace(&quot;NXShadowAddUpdaterDisplay&quot;);
+
+  if ((updateManager ? updateManager -&gt; addUpdater(NULL, display) : NULL) == NULL)
+  {
+    logTest(&quot;NXShadowAddUpdaterDisplay&quot;, &quot;Error&quot;);
+
+    return 0;
+  }
+
+  *w = updateManager -&gt; getWidth();
+  *h = updateManager -&gt; getHeight();
+  *d = poller -&gt; depth();
+
+  return 1;
+}
+
+int NXShadowCreate(void *dpy, char *keymap, char* shadowDisplayName, void **shadowDpy)
+{
+  logTrace(&quot;NXShadowCreate&quot;);
+
+  Display *display = reinterpret_cast&lt;Display*&gt;(dpy);
+  Display **shadowDisplay = reinterpret_cast&lt;Display**&gt;(shadowDpy);
+
+/*  if (NXInitSignal() != 1)
+  {
+    logError(&quot;NXShadowCreate&quot;, EGET());
+
+    return -1;
+  }*/
+
+  if (NXCreateInput(keymap, shadowDisplayName) != 1)
+  {
+    logError(&quot;NXShadowCreate&quot;, EGET());
+
+    return -1;
+  }
+
+  if (NXCreatePoller(display, shadowDisplay) != 1)
+  {
+    logTest(&quot;NXShadowCreate&quot;, &quot;NXCreatePoller failed.&quot;);
+
+    return -1;
+  }
+
+  if (NXCreateUpdateManager() != 1)
+  {
+    logError(&quot;NXShadowCreate&quot;, EGET());
+
+    return -1;
+  }
+
+  return 1;
+}
+
+#if !defined(__CYGWIN32__) &amp;&amp; !defined(WIN32)
+
+void NXShadowSetDisplayUid(int uid)
+{
+  NXShadowOptions.optionShadowDisplayUid = uid;
+}
+
+void NXShadowDisableShm(void)
+{
+  logUser(&quot;NXShadowDisableShm: Disabling SHM.\n&quot;);
+
+  NXShadowOptions.optionShmExtension = 0;
+}
+
+void NXShadowDisableDamage(void)
+{
+  NXShadowOptions.optionDamageExtension = 0;
+}
+
+#endif
+
+void NXShadowDestroy()
+{
+  if (poller)
+  {
+    delete poller;
+
+    poller = NULL;
+  }
+
+  if (updateManager)
+  {
+    delete updateManager;
+
+    updateManager = NULL;
+  }
+
+  if (input)
+  {
+    delete input;
+
+    input = NULL;
+  }
+}
+
+void NXShadowHandleInput()
+{
+  logTrace(&quot;NXShadowHandleInput&quot;);
+
+  if (NXShadowNotInitialized())
+  {
+    logError(&quot;NXShadowHandleInput - NXShadow not properly initialized.&quot;, ESET(EBADFD));
+
+    return;
+  }
+
+  NXHandleException();
+
+  updateManager -&gt; handleInput();
+
+  poller -&gt; handleInput();
+}
+
+int NXShadowHasChanged(int (*callback)(void *), void *arg, int *suspended)
+{
+  int result;
+
+  logTrace(&quot;NXShadowHasChanged&quot;);
+
+  if (NXShadowNotInitialized())
+  {
+    logError(&quot;NXShadowHasChanged - NXShadow not properly initialized.&quot;, ESET(EBADFD));
+
+    return -1;
+  }
+
+  //
+  // FIXME
+  //updateManager -&gt; destroyUpdateManagerRegion();
+  //
+
+  updateManager -&gt; newRegion();
+
+#if !defined(__CYGWIN32__) &amp;&amp; !defined(WIN32)
+  poller -&gt; getEvents();
+#endif
+
+  result = poller -&gt; isChanged(callback, arg, suspended);
+
+  if (result == 1)
+  {
+    updateManager -&gt; addRegion(poller -&gt; lastUpdatedRegion());
+
+    return 1;
+  }
+  else if (result == -1)
+  {
+    logTest(&quot;NXShadowHasChanged&quot;, &quot;Scanline error.&quot;);
+    return -1;
+  }
+
+  return 0;
+}
+
+void NXShadowExportChanges(long *numRects, char **pBox)
+{
+  Region pReg;
+
+  logTrace(&quot;NXShadowExportChanges&quot;);
+
+  if (NXShadowNotInitialized())
+  {
+    logError(&quot;NXShadowExportChanges - NXShadow not properly initialized.&quot;, ESET(EBADFD));
+  }
+
+  updateManager -&gt; update();
+  pReg = updateManager -&gt; getUpdateManagerRegion();
+  *numRects = pReg -&gt; numRects;
+  *pBox = (char *)pReg -&gt; rects;
+
+  logTest(&quot;NXShadowExportChanges&quot;, &quot;numRects [%ld] pBox[%p], pReg-&gt;numRects[%ld], rects[%p], size[%lu]&quot;,
+              *numRects, *pBox, pReg -&gt; numRects, &amp;(pReg -&gt; rects -&gt; x2),
+                  (unsigned long) sizeof(pReg -&gt; rects -&gt; x2));
+}
+
+void NXShadowEvent(Display *display, XEvent event)
+{
+  poller -&gt; handleEvent(display, &amp;event);
+}
+
+#ifdef __CYGWIN32__
+
+int NXShadowCaptureCursor(unsigned int wnd, void *vis)
+{
+  Window window = (Window)wnd;
+  Visual *visual = reinterpret_cast&lt;Visual*&gt;(vis);
+
+  logTrace(&quot;NXShadowCaptureCursor&quot;);
+
+  logTest(&quot;NXShadowCaptureCursor&quot;,&quot;Init&quot;);
+
+  return poller -&gt; updateCursor(window, visual);
+}
+
+#endif
+
+void NXShadowUpdateBuffer(void **buffer)
+{
+  char **fBuffer = reinterpret_cast&lt;char **&gt;(buffer);
+
+  if (*fBuffer != NULL)
+  {
+    poller -&gt; destroyFrameBuffer();
+
+    poller -&gt; init();
+  }
+
+  *fBuffer = poller -&gt; getFrameBuffer();
+
+  logTest(&quot;NXShadowUpdateBuffer&quot;,&quot;New frame buffer [0x%p]&quot;, (void *)*fBuffer);
+}
diff --git a/nxcompshad/Shadow.h b/nxcompshad/Shadow.h
new file mode 100644
index 0000000..eb3c141
--- /dev/null
+++ b/nxcompshad/Shadow.h
@@ -0,0 +1,95 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com.">http://www.nomachine.com.</A>          */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Shadow_H
+#define Shadow_H
+
+#include &lt;X11/Xlib.h&gt;
+
+#define NXShadowCorrectColor(length, buffer) \
+\
+{ \
+  unsigned short a; \
+  unsigned short b; \
+  unsigned short *shorts; \
+  int i; \
+\
+  length &gt;&gt;= 1; \
+  shorts = (unsigned short *)buffer; \
+  for (i = 0; i &lt; length ; i++) \
+  { \
+    a = shorts[i]; \
+\
+    b = a &amp; 63; \
+    a &lt;&lt;= 1; \
+    a = (a &amp; ~127) | b; \
+\
+    shorts[i] = a; \
+  } \
+}
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef char* UpdaterHandle;
+
+typedef struct _ShadowOptions
+{
+  char  optionShmExtension;
+  char  optionDamageExtension;
+  int   optionShadowDisplayUid;
+} ShadowOptions;
+
+extern ShadowOptions NXShadowOptions;
+
+extern int           NXShadowCreate(void *, char *, char *, void **);
+extern void          NXShadowDestroy(void);
+
+/*
+ * Use an already opened Display connection.
+ * We use &lt;void *&gt; instead of &lt;Display *&gt; to avoid
+ * useless dependences from Xlib headers.
+ */
+
+extern int NXShadowAddUpdaterDisplay(void *display, int *width, int *height,
+                                         unsigned char *depth);
+extern UpdaterHandle NXShadowAddUpdater(char *displayName);
+extern int           NXShadowRemoveUpdater(UpdaterHandle handle);
+extern int           NXShadowRemoveAllUpdaters(void);
+
+extern void          NXShadowHandleInput(void);
+extern int           NXShadowHasChanged(int (*)(void *), void *, int *);
+extern void          NXShadowExportChanges(long *, char **);
+extern int           NXShadowHasUpdaters(void);
+extern int           NXShadowCaptureCursor(unsigned int wnd, void *vis);
+extern void          NXShadowColorCorrect(int, int, unsigned int, unsigned int, char *);
+extern void          NXShadowUpdateBuffer(void **);
+
+extern void          NXShadowEvent(Display *, XEvent);
+
+extern void          NXShadowSetDisplayUid(int uid);
+
+extern void          NXShadowDisableShm(void);
+extern void          NXShadowDisableDamage(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Shadow_H */
+
diff --git a/nxcompshad/Updater.cpp b/nxcompshad/Updater.cpp
new file mode 100644
index 0000000..3f0e6a4
--- /dev/null
+++ b/nxcompshad/Updater.cpp
@@ -0,0 +1,383 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xutil.h&gt;
+#include &lt;X11/keysym.h&gt;
+#include &lt;string.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+//
+#include &lt;stdio.h&gt;
+//
+#include &quot;Updater.h&quot;
+#include &quot;Logger.h&quot;
+
+Updater::Updater(char *displayName, Display *display)
+{
+  logTrace(&quot;Updater::Updater&quot;);
+
+  displayName_ = displayName;
+  display_ = display;
+  closeDisplay_ = false;
+  image_ = NULL;
+  updateRegion_ = NULL;
+  buffer_ = NULL;
+}
+
+Updater::~Updater()
+{
+  logTrace(&quot;Updater::~Updater&quot;);
+
+  if (input_)
+  {
+    int removedEvents = input_ -&gt; removeAllEvents(display_);
+
+    logTest(&quot;Updater::~Updater&quot;, &quot;Removed events in input queue is [%d].&quot;, removedEvents);
+  }
+
+  if (display_)
+  {
+    XDestroyWindow(display_, window_);
+    XFreePixmap(display_, pixmap_);
+
+    if (closeDisplay_)
+    {
+      XCloseDisplay(display_);
+    }
+  }
+
+  if (image_)
+  {
+    image_ -&gt; data = NULL;
+
+    XDestroyImage(image_);
+  }
+
+  if (updateRegion_)
+  {
+    XDestroyRegion(updateRegion_);
+  }
+}
+
+int Updater::init(int width, int height, char *fb, Input *input)
+{
+  logTrace(&quot;Updater::init&quot;);
+
+  if (fb == NULL || input == NULL || width &lt;= 0 || height &lt;= 0)
+  {
+    logError(&quot;Updater::init&quot;, ESET(EINVAL));
+
+    return -1;
+  }
+
+  width_ = width;
+  height_ = height;
+  buffer_ = fb;
+  input_ = input;
+/*
+  if (display_ == NULL)
+  {
+    display_ = XOpenDisplay(displayName_);
+
+    closeDisplay_ = true;
+
+    if (display_ == NULL)
+    {
+      logError(&quot;Updater::init&quot;, ESET(ENOMSG));
+
+      return -1;
+    }
+  }
+*/
+  depth_ = DefaultDepth(display_, DefaultScreen(display_));
+
+  if (depth_ == 8) bpl_ = width_;
+  else if (depth_ == 16) bpl_ = width_ * 2;
+  else bpl_ = width_ * 4;
+
+  logTest(&quot;Updater::init&quot;, &quot;Server geometry [%d, %d] depth [%d] bpl [%d].&quot;, width_, height_, depth_, bpl_);
+
+/*  int bitmap_pad = 8;
+
+  image_ = XCreateImage(display_, DefaultVisual(display_, DefaultScreen(display_)), depth_, ZPixmap, 0,
+                            buffer_, width_, height_, bitmap_pad, 0);
+
+  if (image_ == NULL)
+  {
+    logError(&quot;Updater::init&quot;, ESET(ENOMSG));
+
+    logTest(&quot;Updater::init&quot;, &quot;Failed to create default image.&quot;);
+
+    return -1;
+  }
+
+  pixmap_ = XCreatePixmap(display_, DefaultRootWindow(display_), width_, height_, depth_);
+
+  unsigned int mask = CWBackPixmap | CWBorderPixel | CWEventMask;
+
+  XSetWindowAttributes attributes;
+
+  attributes.background_pixmap = pixmap_;
+  attributes.border_pixel = WhitePixel(display_, DefaultScreen(display_));
+  attributes.event_mask = KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask;
+
+  window_ = XCreateWindow(display_, DefaultRootWindow(display_),
+                              0, 0, width_, height_, 0, depth_, InputOutput,
+                                  DefaultVisual(display_, DefaultScreen(display_)), mask, &amp;attributes);
+
+  if (window_ == None)
+  {
+    logError(&quot;Updater::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  XSizeHints *size_hints;
+
+  if ((size_hints = XAllocSizeHints()) == NULL)
+  {
+    logError(&quot;Updater::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  size_hints -&gt; flags = PMinSize | PMaxSize;
+  size_hints -&gt; min_width = width_;
+  size_hints -&gt; max_width = width_;
+  size_hints -&gt; min_height = height_;
+  size_hints -&gt; max_height = height_;
+
+  XSetWMNormalHints(display_, window_, size_hints);
+
+  XFree(size_hints);
+
+  Atom deleteWMatom = XInternAtom(display_, &quot;WM_DELETE_WINDOW&quot;, 1);
+
+  XSetWMProtocols(display_, window_, &amp;deleteWMatom, 1);
+
+  XMapWindow(display_, window_);*/
+
+  updateRegion_ = XCreateRegion();
+
+  logTest(&quot;Updater::init&quot;, &quot;updateRegion_[%p]&quot;, updateRegion_);
+  return 1;
+}
+
+void Updater::addRegion(Region region)
+{
+  //
+  // FIXME: Is this too paranoid ?
+  //
+
+  if (updateRegion_ == NULL)
+  {
+    logError(&quot;Updater::addRegion&quot;, ESET(EINVAL));
+
+    return;
+  }
+
+  XUnionRegion(region, updateRegion_, updateRegion_);
+}
+
+void Updater::update()
+{
+  logTrace(&quot;Updater::update&quot;);
+
+  if (updateRegion_ == NULL)
+  {
+    logError(&quot;Updater::update&quot;, ESET(EINVAL));
+
+    return;
+  }
+
+  logTest(&quot;Updater::update&quot;, &quot;Number of rectangles [%ld].&quot;, updateRegion_ -&gt; numRects);
+
+/*  for (; updateRegion_ -&gt; numRects &gt; 0; updateRegion_ -&gt; numRects--)
+  {
+    int n = updateRegion_ -&gt; numRects - 1;
+
+    int x = updateRegion_ -&gt; rects[n].x1;
+    int y = updateRegion_ -&gt; rects[n].y1;
+    unsigned int width = updateRegion_ -&gt; rects[n].x2 - updateRegion_ -&gt; rects[n].x1;
+    unsigned int height = updateRegion_ -&gt; rects[n].y2 - updateRegion_ -&gt; rects[n].y1;
+
+    logDebug(&quot;Updater::update&quot;, &quot;Sending rectangle: [%d, %d, %d, %d].&quot;, x, y, width, height);
+
+    //
+    // We need to update the extents.
+    //
+
+    int bitmap_pad;
+
+    if (depth_ == 32 || depth_ == 24)
+    {
+      bitmap_pad = 32;
+    }
+    else if (depth_ == 16)
+    {
+      if ((width &amp; 1) == 0)
+      {
+        bitmap_pad = 32;
+      }
+      else
+      {
+        bitmap_pad = 16;
+      }
+    }
+    else if ((width &amp; 3) == 0)
+    {
+      bitmap_pad = 32;
+    }
+    else if ((width &amp; 1) == 0)
+    {
+      bitmap_pad = 16;
+    }
+    else
+    {
+      bitmap_pad = 8;
+    }*/
+
+/*    image_ -&gt; bitmap_pad = bitmap_pad;*/
+
+   /* NXShadowCorrectColor(x, y, width, height);*/
+
+/*    XPutImage(display_, pixmap_, DefaultGC(display_, DefaultScreen(display_)),
+                  image_, x, y, x, y, width, height);
+
+    XClearArea(display_, window_, x, y, width, height, 0);
+  }*/
+
+  //
+  // Should we reduces the box vector ?
+  //
+  // BOX *box = Xrealloc(updateRegion_ -&gt; rects,
+  //                         updateRegion_ -&gt; numRects == 0 ? sizeof(BOX) :
+  //                             updateRegion_ -&gt; numRects * sizeof(BOX));
+  //
+  // if (box)
+  // {
+  //   updateRegion_ -&gt; rects = box;
+  //   updateRegion_ -&gt; size = 1;
+  // }
+  //
+
+  if (updateRegion_ -&gt; numRects == 0)
+  {
+    updateRegion_ -&gt; extents.x1 = 0;
+    updateRegion_ -&gt; extents.y1 = 0;
+    updateRegion_ -&gt; extents.x2 = 0;
+    updateRegion_ -&gt; extents.y2 = 0;
+  }
+  else
+  {
+    //
+    // FIXME: We have to update the region extents.
+    //
+
+    logTest(&quot;Updater::update&quot;, &quot;Region extents has not been updated.&quot;);
+  }
+}
+
+void Updater::handleInput()
+{
+  logTrace(&quot;Updater::handleInput&quot;);
+
+  XEvent *event = new XEvent;
+
+  if (event == NULL)
+  {
+    logError(&quot;Updater::handleInput&quot;, ESET(ENOMEM));
+
+    return;
+  }
+
+  while (XCheckIfEvent(display_, event, anyEventPredicate, NULL))
+  {
+    switch (event -&gt; type)
+    {
+     /* case ClientMessage:
+      {
+        Atom wmProtocols = XInternAtom(display_, &quot;WM_PROTOCOLS&quot;, 0);
+        Atom wmDeleteWindow = XInternAtom(display_, &quot;WM_DELETE_WINDOW&quot;, 0);
+
+        if (event -&gt; xclient.message_type == wmProtocols &amp;&amp;
+                (Atom)event -&gt; xclient.data.l[0] == wmDeleteWindow)
+        {
+          logTest(&quot;Updater::handleInput&quot;, &quot;Got client message of type WM_PROTOCOLS and value WM_DELETE_WINDOW,&quot;
+                      &quot; throwing exception UpdaterClosing.&quot;);
+
+          delete event;
+
+          throw UpdaterClosing();
+        }
+        else
+        {
+          logTest(&quot;Updater::handleInput&quot;, &quot;Unexpected client message type [%ld] format [%d] first value [%ld]&quot;,
+                      event -&gt; xclient.message_type, event -&gt; xclient.format, event -&gt; xclient.data.l[0]);
+        }
+
+        break;
+      }*/
+      case KeyPress:
+      case KeyRelease:
+      case ButtonPress:
+      case ButtonRelease:
+      case MotionNotify:
+      {
+        input_ -&gt; pushEvent(display_, event);
+
+        event = new XEvent;
+
+        if (event == NULL)
+        {
+          logError(&quot;Updater::handleInput&quot;, ESET(ENOMEM));
+
+          return;
+        }
+
+        break;
+      }
+      default:
+      {
+        logTest(&quot;Updater::handleInput&quot;, &quot;Handling unexpected event [%d].&quot;, event -&gt; type);
+
+        break;
+      }
+    }
+  }
+
+  delete event;
+}
+
+void Updater::newRegion()
+{
+  if (updateRegion_ != NULL)
+  {
+    XDestroyRegion(updateRegion_);
+  }
+
+  updateRegion_ = XCreateRegion();
+
+  logTest(&quot;Updater::newRegion&quot;, &quot;updateRegion_ [%p].&quot;, updateRegion_);
+}
+//
+// Private functions.
+//
diff --git a/nxcompshad/Updater.h b/nxcompshad/Updater.h
new file mode 100644
index 0000000..386c726
--- /dev/null
+++ b/nxcompshad/Updater.h
@@ -0,0 +1,95 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Updater_H
+#define Updater_H
+
+#include &lt;X11/Xlib.h&gt;
+
+#include &quot;Regions.h&quot;
+#include &quot;Input.h&quot;
+
+class UpdaterClosing {};
+
+class Updater
+{
+  public:
+
+  Updater(char *displayName, Display *display);
+
+  ~Updater();
+
+  int init(int, int, char *, Input*);
+
+  void addRegion(Region r);
+
+  void update();
+
+  void handleInput();
+
+  XImage *getImage();
+
+  Region getUpdateRegion();
+
+  void newRegion();
+
+  private:
+
+  Input *input_;
+
+  static inline Bool anyEventPredicate(Display*, XEvent*, XPointer);
+
+  void handleKeyboardEvent(XEvent &amp;event);
+
+  char *displayName_;
+
+  char *buffer_;
+
+  bool closeDisplay_;
+
+  Display *display_;
+
+  int depth_;
+
+  int width_;
+  int height_;
+
+  int bpl_;
+
+  Window window_;
+  XImage *image_;
+
+  Pixmap pixmap_;
+
+  Region updateRegion_;
+
+};
+
+Bool Updater::anyEventPredicate(Display*, XEvent*, XPointer)
+{
+  return true;
+}
+
+inline XImage* Updater::getImage()
+{
+  return image_;
+}
+inline Region Updater::getUpdateRegion()
+{
+  return updateRegion_;
+}
+#endif /* Updater_H */
diff --git a/nxcompshad/VERSION b/nxcompshad/VERSION
new file mode 100644
index 0000000..fd2a018
--- /dev/null
+++ b/nxcompshad/VERSION
@@ -0,0 +1 @@
+3.1.0
diff --git a/nxcompshad/Win.cpp b/nxcompshad/Win.cpp
new file mode 100644
index 0000000..9f8cdc9
--- /dev/null
+++ b/nxcompshad/Win.cpp
@@ -0,0 +1,1130 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#if defined(__CYGWIN32__) || defined(WIN32)
+
+#include &lt;X11/keysym.h&gt;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &quot;Poller.h&quot;
+#include &quot;Logger.h&quot;
+
+Poller::Poller(Input *input, Display *display, int depth) : CorePoller(input, display)
+{
+  logTrace(&quot;Poller::Poller&quot;);
+
+  screenDC_ = NULL;
+  screenBmp_ = NULL;
+  memoryDC_ = NULL;
+  pDIBbits_ = NULL;
+  DIBBuffer_ = NULL;
+  pKey_ = NULL;
+  pMouse_ = NULL;
+  path_ = NULL;
+  keymapName_ = input -&gt; getKeymap();
+  keymap_ = NULL;
+  toggleButtonState_ = 0;
+  serverModifierState_ = 0;
+  display_ = display;
+  depth_ = DefaultDepth(display_, DefaultScreen(display_));
+  oldCursor_ = 0;
+  xCursor_ = 0;
+}
+
+Poller::~Poller()
+{
+  logTrace(&quot;Poller::~Poller&quot;);
+
+  if (screenDC_)
+  {
+    BOOL result = ReleaseDC(NULL, screenDC_);
+
+    logTest(&quot;Poller::~Poller&quot;, &quot;ReleaseDC returned [%d].&quot;, result);
+
+    screenDC_ = NULL;
+  }
+
+  if (memoryDC_)
+  {
+    BOOL result = DeleteDC(memoryDC_);
+
+    logTest(&quot;Poller::~Poller&quot;, &quot;DeleteDC returned [%d].&quot;, result);
+
+    memoryDC_ = NULL;
+  }
+
+  if (screenBmp_)
+  {
+    BOOL result = DeleteObject(screenBmp_);
+
+    logTest(&quot;Poller::~Poller&quot;, &quot;DeleteObject returned [%d].&quot;, result);
+
+    screenBmp_ = NULL;
+  }
+
+  if (DIBBuffer_)
+  {
+    logDebug(&quot;Poller::~Poller&quot;, &quot;Delete DIBBuffer_ [%p].&quot;, DIBBuffer_);
+
+    delete [] DIBBuffer_;
+  }
+
+  if (pKey_)
+  {
+    logDebug(&quot;Poller::~Poller&quot;, &quot; pKey_[%p].&quot;, pKey_);
+
+    delete [] pKey_;
+  }
+
+  if (pMouse_)
+  {
+    logDebug(&quot;Poller::~Poller&quot;, &quot; pMouse_[%p].&quot;, pMouse_);
+
+    delete [] pMouse_;
+  }
+
+  if (keymap_)
+  {
+    logDebug(&quot;Poller::~Poller&quot;, &quot; keymap_[%p].&quot;, keymap_);
+
+    delete [] keymap_;
+  }
+}
+
+int Poller::init()
+{
+  logTrace(&quot;Poller::init&quot;);
+
+  int maxLengthArrayINPUT = 6;
+
+  platformOS();
+
+  pKey_ = new INPUT [maxLengthArrayINPUT];
+
+  if (pKey_ == NULL)
+  {
+    logError(&quot;Poller::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  for (int i = 0; i &lt; maxLengthArrayINPUT; i++)
+  {
+    pKey_[i].type = INPUT_KEYBOARD;
+    pKey_[i].ki.wVk = (WORD) 0;
+    pKey_[i].ki.time = (DWORD) 0;
+    pKey_[i].ki.dwExtraInfo = (DWORD) 0;
+  }
+
+  pMouse_ = new INPUT;
+
+  if (pMouse_ == NULL)
+  {
+    logError(&quot;Poller::init&quot;, ESET(ENOMEM));
+
+    return -1;
+  }
+
+  pMouse_ -&gt; type = INPUT_MOUSE;
+
+  pMouse_ -&gt; mi.dx = 0;
+  pMouse_ -&gt; mi.dy = 0;
+  pMouse_ -&gt; mi.mouseData = (DWORD) 0;
+  pMouse_ -&gt; mi.time = 0;
+  pMouse_ -&gt; mi.dwExtraInfo = (ULONG_PTR) NULL;
+
+  screenDC_ = GetDC(NULL);
+
+  if (screenDC_ == NULL)
+  {
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  switch(depth_)
+  {
+    case 8:
+    {
+      depth_ = 16;
+      break;
+    }
+    case 16:
+    {
+      depth_ = 16;
+      break;
+    }
+    case 24:
+    {
+      depth_ = 32;
+      break;
+    }
+    default:
+    {
+      logError(&quot;Poller::init&quot;, ESET(EINVAL));
+
+      return -1;
+    }
+  }
+
+  width_ = GetDeviceCaps(screenDC_, HORZRES);
+  height_ = GetDeviceCaps(screenDC_, VERTRES);
+
+  bpl_ = width_ * (depth_ &gt;&gt; 3);
+  bpp_ = (depth_ &gt;&gt; 3);
+
+  logTest(&quot;Poller::init&quot;, &quot;Screen geometry is [%d, %d] depth is [%d] bpl [%d] bpp [%d].&quot;,
+              width_, height_, depth_, bpl_, bpp_);
+
+  logTest(&quot;Poller::init&quot;, &quot;Got device context at [%p] screen size is (%d,%d).&quot;,
+            screenDC_, width_, height_);
+
+  memoryDC_ = CreateCompatibleDC(screenDC_);
+
+  if (memoryDC_ == NULL)
+  {
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  //
+  // Delete the old bitmap for the memory device.
+  //
+
+  HBITMAP bitmap = (HBITMAP) GetCurrentObject(memoryDC_, OBJ_BITMAP);
+
+  if (bitmap &amp;&amp; DeleteObject(bitmap) == 0)
+  {
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+  }
+
+  //
+  // Bitmap header describing the bitmap we want to get from GetDIBits.
+  //
+
+  bmi_.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
+  bmi_.bmiHeader.biWidth         = width_;
+  bmi_.bmiHeader.biHeight        = -height_;
+  bmi_.bmiHeader.biPlanes        = 1;
+  bmi_.bmiHeader.biBitCount      = depth_;
+  bmi_.bmiHeader.biCompression   = BI_RGB;
+  bmi_.bmiHeader.biSizeImage     = 0;
+  bmi_.bmiHeader.biXPelsPerMeter = 0;
+  bmi_.bmiHeader.biYPelsPerMeter = 0;
+  bmi_.bmiHeader.biClrUsed       = 0;
+  bmi_.bmiHeader.biClrImportant  = 0;
+
+  screenBmp_ = CreateDIBSection(memoryDC_, &amp;bmi_, DIB_RGB_COLORS, &amp;pDIBbits_, NULL, 0);
+  ReleaseDC(NULL,memoryDC_);
+
+  if (screenBmp_ == NULL)
+  {
+    logTest (&quot;Poller::init&quot;, &quot;This video device is not supporting DIB section&quot;);
+
+    pDIBbits_ = NULL;
+
+    screenBmp_ = CreateCompatibleBitmap(screenDC_, width_, height_);
+
+    if (screenBmp_ == NULL)
+    {
+      logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+      return -1;
+    }
+
+    if (SelectObject(memoryDC_, screenBmp_) == NULL)
+    {
+      logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+      return -1;
+    }
+  }
+  else
+  {
+    logTest (&quot;Poller::init&quot;, &quot;Enabled the DIB section&quot;);
+
+    if (SelectObject(memoryDC_, screenBmp_) == NULL)
+    {
+      logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+      return -1;
+    }
+  }
+
+  //
+  // Check if the screen device raster capabilities
+  // support the bitmap transfer.
+  //
+
+  if ((GetDeviceCaps(screenDC_, RASTERCAPS) &amp; RC_BITBLT) == 0)
+  {
+    logTest(&quot;Poller::init&quot;, &quot;This video device is not supporting the bitmap transfer.&quot;);
+
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  //
+  // Check if the memory device raster capabilities
+  // support the GetDIBits and SetDIBits functions.
+  //
+
+  if ((GetDeviceCaps(memoryDC_, RASTERCAPS) &amp; RC_DI_BITMAP) == 0)
+  {
+    logTest(&quot;Poller::init&quot;, &quot;This memory device is not supporting the GetDIBits and SetDIBits &quot;
+               &quot;function.&quot;);
+
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  if (GetDeviceCaps(screenDC_, PLANES) != 1)
+  {
+    logTest(&quot;Poller::init&quot;, &quot;This video device has more than 1 color plane.&quot;);
+
+    logError(&quot;Poller::init&quot;, ESET(ENOMSG));
+
+    return -1;
+  }
+
+  return CorePoller::init();
+}
+
+//
+// FIXME: Remove me.
+//
+
+void ErrorExit(LPTSTR lpszFunction)
+{
+    LPVOID lpMsgBuf;
+    DWORD dw = GetLastError();
+
+    FormatMessage(
+        FORMAT_MESSAGE_ALLOCATE_BUFFER |
+        FORMAT_MESSAGE_FROM_SYSTEM,
+        NULL,
+        dw,
+        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+        (LPTSTR) &amp;lpMsgBuf,
+        0, NULL );
+
+    logTest(lpszFunction, &quot; Failed with error [%ld]: %s&quot;, dw, (char*)lpMsgBuf);
+
+    LocalFree(lpMsgBuf);
+    ExitProcess(dw);
+}
+
+//
+// FIXME: End.
+//
+
+char *Poller::getRect(XRectangle r)
+{
+  logTrace(&quot;Poller::getRect&quot;);
+
+  logDebug(&quot;Poller::getRect&quot;, &quot;Going to retrive rectangle [%d, %d, %d, %d].&quot;,
+              r.x, r.y, r.width, r.height);
+
+  //
+  // The CAPTUREBLT operation could be a very
+  // cpu-consuming task. We should make some
+  // test to see how much it is expensive.
+  // Anyway we get tooltip windows and any
+  // other special effect not included with
+  // only the SRCCOPY operation.
+  //
+
+  if (BitBlt(memoryDC_, r.x, r.y, r.width, r.height,
+                 screenDC_, r.x, r.y, SRCCOPY | CAPTUREBLT) == 0)
+  {
+    logError(&quot;Poller::getRect&quot;, ESET(ENOMSG));
+
+    logTest(&quot;Poller::getRect&quot;, &quot;Failed to perform a bit-block transfer.&quot;);
+    logTest(&quot;Poller::getRect&quot;, &quot;bit-block error=%lu&quot;, GetLastError());
+
+    return NULL;
+  }
+
+  // bmi_.bmiHeader.biWidth = r.width;
+  // bmi_.bmiHeader.biHeight = -r.height;
+
+  if (pDIBbits_ == NULL)
+  {
+    static long nPixel = 0;
+
+    if (nPixel &lt; r.width * r.height)
+    {
+
+      if (DIBBuffer_)
+      {
+        delete [] DIBBuffer_;
+      }
+
+      nPixel = r.width * r.height;
+
+      DIBBuffer_ = new char [nPixel * bpp_];
+
+      if (DIBBuffer_ == NULL)
+      {
+        logError(&quot;Poller::getRect&quot;, ESET(ENOMEM));
+
+        nPixel = 0;
+
+        return NULL;
+      }
+    }
+
+    if (GetDIBits(memoryDC_, screenBmp_, height_ - r.height - r.y, r.height,
+                      DIBBuffer_, &amp;bmi_, DIB_RGB_COLORS) == 0)
+    {
+      logError(&quot;Poller::getRect&quot;, ESET(ENOMSG));
+
+      logTest(&quot;Poller::getRect&quot;, &quot;Failed to retrieve the screen bitmap.&quot;);
+
+      return NULL;
+    }
+
+    return DIBBuffer_;
+  }
+  else
+  {
+    return (char *) pDIBbits_ + r.y * bpl_ + r.x * bpp_;
+  }
+}
+
+void Poller::handleKeyboardEvent(Display *display, XEvent *event)
+{
+  KeySym keysym;
+  char *keyname = new char [31];
+  keyTranslation tr = {0, 0};
+  unsigned char scancode = 0;
+  int lengthArrayINPUT = 0;
+
+  if (XLookupString((XKeyEvent *) event, keyname, 30, &amp;keysym, NULL) &gt; 0)
+  {
+    logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;keyname %s, keysym [%x]&quot;, keyname, (unsigned int)keysym);
+  }
+
+  if (specialKeys(keysym, event -&gt; xkey.state, event -&gt; type) == 1)
+  {
+    delete[] keyname;
+    return;
+  }
+
+  tr = xkeymapTranslateKey(keysym, event -&gt; xkey.keycode, event -&gt; xkey.state);
+  scancode = tr.scancode;
+
+  logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;keyname [%s] scancode [0x%x], keycode[0x%x], keysym [%x]&quot;, keyname,
+              tr.scancode, event -&gt;xkey.keycode, (unsigned int)keysym);
+
+  if (scancode == 0)
+  {
+    delete[] keyname;
+    return;
+  }
+
+  if (event -&gt; type == KeyPress)
+  {
+    int test1 = MapVirtualKey(scancode, MAPVK_VSC_TO_VK_EX);
+    int test2 = MapVirtualKey(0x24, MAPVK_VSC_TO_VK_EX);
+
+    if (test1 == test2)
+    {
+      simulateCtrlAltDel();
+    }
+
+    if (isModifier(scancode) == 0)
+    {
+      savedServerModifierState_ = serverModifierState_;
+    }
+
+    ensureServerModifiers(tr, &amp;lengthArrayINPUT);
+    if (sendInput(scancode, 1, &amp;lengthArrayINPUT) == 0)
+    {
+      logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;lengthArrayINPUT [%d].&quot;, lengthArrayINPUT);
+    }
+    restoreServerModifiers(scancode);
+  }
+  else if (event -&gt; type == KeyRelease)
+  {
+    if (sendInput(scancode, 0, &amp;lengthArrayINPUT) == 0)
+    {
+      logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;lengthArrayINPUT [%d].&quot;, lengthArrayINPUT);
+    }
+  }
+
+  updateModifierState(scancode, (event -&gt; type == KeyPress));
+
+  delete[] keyname;
+}
+
+void Poller::handleMouseEvent(Display *display, XEvent *event)
+{
+  DWORD flg = 0;
+  DWORD whl = 0;
+
+  if (event -&gt; type == ButtonPress)
+  {
+    logTest(&quot;Poller::handleMouseEvent&quot;, &quot;ButtonPress.\n&quot;);
+    switch (event -&gt; xbutton.button)
+    {
+      case Button1:
+      {
+        flg = MOUSEEVENTF_LEFTDOWN;
+        break;
+      }
+      case Button2:
+      {
+        flg = MOUSEEVENTF_MIDDLEDOWN;
+        break;
+      }
+      case Button3:
+      {
+        flg = MOUSEEVENTF_RIGHTDOWN;
+        break;
+      }
+      case Button4:
+      {
+        flg = MOUSEEVENTF_WHEEL;
+        whl = WHEEL_DELTA;
+        pMouse_ -&gt; mi.mouseData = whl;
+        break;
+      }
+      case Button5:
+      {
+        flg = MOUSEEVENTF_WHEEL;
+        whl = (DWORD) (-WHEEL_DELTA);
+        pMouse_ -&gt; mi.mouseData = whl;
+        break;
+      }
+    }
+  }
+  else if (event -&gt; type == ButtonRelease)
+  {
+    switch (event -&gt; xbutton.button)
+    {
+      case Button1:
+      {
+        flg = MOUSEEVENTF_LEFTUP;
+        break;
+      }
+      case Button2:
+      {
+        flg = MOUSEEVENTF_MIDDLEUP;
+        break;
+      }
+      case Button3:
+      {
+        flg = MOUSEEVENTF_RIGHTUP;
+        break;
+      }
+      case Button4:
+      {
+        flg = MOUSEEVENTF_WHEEL;
+        whl = 0;
+        pMouse_ -&gt; mi.mouseData = whl;
+        break;
+      }
+      case Button5:
+      {
+        flg = MOUSEEVENTF_WHEEL;
+        whl = 0;
+        pMouse_ -&gt; mi.mouseData = whl;
+        break;
+      }
+    }
+  }
+  else if (event -&gt; type == MotionNotify)
+  {
+    logTest(&quot;Poller::handleMouseEvent&quot;, &quot;SetCursor - MotionNotify&quot;);
+
+    SetCursorPos(event -&gt; xmotion.x, event -&gt; xmotion.y);
+  }
+
+  if (flg &gt; 0)
+  {
+  //  logTest(&quot;Poller::handleMouseEvent&quot;, &quot;SetCursor - flg &gt; 0&quot;);
+    //
+    // FIXME: move the cursor to the pace the event occurred
+    //
+
+    SetCursorPos(event -&gt; xbutton.x, event -&gt; xbutton.y);
+
+    //
+    // FIXME: Remove me: send the click/release event
+    // mouse_event(flg, 0, 0, whl, (ULONG_PTR)NULL);
+    //
+
+    pMouse_ -&gt; mi.dwFlags = flg;
+
+    if (SendInput(1, pMouse_, sizeof(INPUT)) == 0)
+    {
+      logTest(&quot;Poller::handleMouseEvent&quot;, &quot;Failed SendInput&quot;);
+    }
+  }
+}
+
+int Poller::updateCursor(Window wnd, Visual* vis)
+{
+  BYTE *mBits, *andBits, *xorBits;
+
+  logTrace(&quot;Poller::Cursor&quot;);
+
+  //
+  // Retrieve mouse cursor handle.
+  //
+
+  CURSORINFO cursorInfo;
+  cursorInfo.cbSize = sizeof(CURSORINFO);
+
+  if (GetCursorInfo(&amp;cursorInfo) == 0)
+  {
+    logTest(&quot;Poller::Cursor&quot;, &quot;GetCursorInfo() failed [%u].\n&quot;, (unsigned int)GetLastError());
+    LocalFree(&amp;cursorInfo);
+    return -1;
+  }
+
+  HCURSOR hCursor = cursorInfo.hCursor;
+
+  if (hCursor == 0)
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;Cursor Handle is NULL. Error[%u].\n&quot;, (unsigned int)GetLastError());
+    return 1;
+  }
+
+  if (hCursor == oldCursor_)
+  {
+    LocalFree(&amp;cursorInfo);
+    return 1;
+  }
+  else
+  {
+    oldCursor_ = hCursor;
+  }
+
+  //
+  // Get cursor info.
+  //
+
+  //  logTest(&quot;Poller::Cursor&quot;,&quot;hCursor [%xH] GetCursor [%xH].\n&quot;, hCursor, GetCursor());
+
+  ICONINFO iconInfo;
+  if (GetIconInfo(hCursor, &amp;iconInfo) == 0)
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;GetIconInfo() failed. Error[%d].&quot;, (unsigned int)GetLastError());
+    LocalFree(&amp;iconInfo);
+    //    return -1;
+  }
+
+  BOOL isColorCursor = FALSE;
+  if (iconInfo.hbmColor != NULL)
+  {
+    isColorCursor = TRUE;
+  }
+
+  if (iconInfo.hbmMask == NULL)
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;Cursor bitmap handle is NULL.\n&quot;);
+    return -1;
+  }
+
+  //
+  // Check bitmap info for the cursor
+  //
+
+  BITMAP bmMask;
+  if (!GetObject(iconInfo.hbmMask, sizeof(BITMAP), (LPVOID)&amp;bmMask))
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;GetObject() for bitmap failed.\n&quot;);
+    DeleteObject(iconInfo.hbmMask);
+    LocalFree(&amp;bmMask);
+    return -1;
+  }
+
+  if (bmMask.bmPlanes != 1 || bmMask.bmBitsPixel != 1)
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;Incorrect data in cursor bitmap.\n&quot;);
+    LocalFree(&amp;bmMask);
+    DeleteObject(iconInfo.hbmMask);
+    return -1;
+  }
+
+  // Get monochrome bitmap data for cursor
+  // NOTE: they say we should use GetDIBits() instead of GetBitmapBits().
+  mBits = new BYTE[bmMask.bmWidthBytes * bmMask.bmHeight];
+
+  if (mBits == NULL)//Data bitmap
+  {
+    DeleteObject(iconInfo.hbmMask);
+    DestroyCursor(cursorInfo.hCursor);
+    LocalFree(&amp;iconInfo);
+    LocalFree(&amp;bmMask);
+    delete[] mBits;
+    return -1;
+  }
+
+  BOOL success = GetBitmapBits(iconInfo.hbmMask, bmMask.bmWidthBytes * bmMask.bmHeight, mBits);
+
+  if (!success)
+  {
+    logTest(&quot;Poller::Cursor&quot;,&quot;GetBitmapBits() failed.\n&quot;);
+    delete[] mBits;
+    return -1;
+  }
+
+  andBits = mBits;
+
+  long width = bmMask.bmWidth;
+  long height = (isColorCursor) ? bmMask.bmHeight : bmMask.bmHeight/2;
+
+  //
+  // The bitmask is formatted so that the upper half is
+  // the icon AND bitmask and the lower half is the icon XOR bitmask.
+  //
+
+  if (!isColorCursor)
+  {
+    xorBits = andBits + bmMask.bmWidthBytes * height;
+
+/*    logTest(&quot;Poller::Cursor&quot;,&quot;no color widthB[%ld] width[%ld] height[%ld] totByte[%ld] mbits[%ld].\n&quot;,
+                 bmMask.bmWidthBytes,width,height,success,bmMask.bmHeight * bmMask.bmWidthBytes);*/
+
+    if (xCursor_ &gt; 0)
+    {
+      XFreeCursor(display_, xCursor_);
+    }
+
+    xCursor_ = createCursor(wnd, vis, (unsigned int)iconInfo.xHotspot, (unsigned int)iconInfo.yHotspot,
+                    width, height, (unsigned char *)xorBits, (unsigned char *)andBits);
+
+    XDefineCursor(display_, wnd, xCursor_);
+  }
+
+  delete []mBits;
+  DeleteObject(iconInfo.hbmMask);
+  LocalFree(&amp;bmMask);
+  DestroyCursor(cursorInfo.hCursor);
+  LocalFree(&amp;iconInfo);
+
+  return success;
+}
+
+unsigned char Poller::specialKeys(unsigned int keysym, unsigned int state, int pressed)
+{
+  return 0;
+}
+
+void Poller::ensureServerModifiers(keyTranslation tr, int *lengthArrayINPUT)
+{
+  return;
+}
+
+void Poller::restoreServerModifiers(UINT scancode)
+{
+  keyTranslation dummy;
+  int lengthArrayINPUT = 0;
+
+  if (isModifier(scancode) == 1)
+  {
+    return;
+  }
+
+  dummy.scancode = 0;
+  dummy.modifiers = savedServerModifierState_;
+  ensureServerModifiers(dummy, &amp;lengthArrayINPUT);
+  if (sendInput(0, 0, &amp;lengthArrayINPUT) == 0)
+  {
+    logTest(&quot;Poller::restoreServerModifiers&quot;, &quot;lengthArrayINPUT [%d]&quot;, lengthArrayINPUT);
+  }
+}
+
+int Poller::updateShadowFrameBuffer(void)
+{
+  return 1;
+}
+
+void Poller::addToKeymap(char *keyname, unsigned char scancode, unsigned short modifiers, char *mapname)
+{
+  return;
+}
+
+FILE *Poller::xkeymapOpen(char *filename)
+{
+  return NULL;
+}
+
+int Poller::xkeymapRead(char *mapname)
+{
+  return 1;
+}
+
+void Poller::xkeymapInit(char *keyMapName)
+{
+  return;
+}
+
+keyTranslation Poller::xkeymapTranslateKey(unsigned int keysym, unsigned int keycode,
+                                               unsigned int state)
+{
+  keyTranslation tr = { 0, 0 };
+
+  return tr;
+}
+
+unsigned char Poller::getKeyState(unsigned int state, unsigned int keysym)
+{
+  return 0;
+}
+
+char *Poller::getKsname(unsigned int keysym)
+{
+        char *ksname = NULL;
+
+        return ksname;
+}
+
+//
+// Routine used to fool Winlogon into thinking CtrlAltDel was pressed
+//
+char Poller::simulateCtrlAltDel(void)
+{
+  HDESK oldDesktop = GetThreadDesktop(GetCurrentThreadId());
+
+  //
+  // Switch into the Winlogon desktop.
+  //
+  if (selectDesktopByName(&quot;Winlogon&quot;) == 0)
+  {
+    logTest(&quot;SimulateCtrlAltDelThreadFn&quot;,&quot;Failed to select logon desktop.&quot;);
+    return 0;
+  }
+
+  logTest(&quot;SimulateCtrlAltDelThreadFn&quot;,&quot;Generating ctrl-alt-del.&quot;);
+
+  //
+  // Winlogon uses hotkeys to trap Ctrl-Alt-Del.
+  //
+  PostMessage(HWND_BROADCAST, WM_HOTKEY, 0, MAKELONG(MOD_ALT | MOD_CONTROL, VK_DELETE));
+
+  //
+  // Switch back to our original desktop.
+  //
+  if (oldDesktop != NULL)
+  {
+    selectDesktop(oldDesktop);
+  }
+
+  return 1;
+}
+
+// Switches the current thread into a different desktop by desktop handle
+// This call takes care of all the evil memory management involved
+char Poller::selectDesktop(HDESK newDesktop)
+{
+  //
+  // Only on NT.
+  //
+  if (isWinNT())
+  {
+    HDESK oldDesktop = GetThreadDesktop(GetCurrentThreadId());
+
+    DWORD dummy;
+    char newName[256];
+
+    if (GetUserObjectInformation(newDesktop, UOI_NAME, &amp;newName, 256, &amp;dummy) == 0)
+    {
+      logDebug(&quot;Poller::selectDesktop&quot;,&quot;GetUserObjectInformation() failed. Error[%lu].&quot;, GetLastError());
+      return 0;
+    }
+
+    logTest(&quot;Poller::selectDesktop&quot;,&quot;New Desktop to [%s] (%x) from (%x).&quot;,
+                 newName, (unsigned int)newDesktop, (unsigned int)oldDesktop);
+
+    //
+    // Switch the desktop.
+    //
+    if(SetThreadDesktop(newDesktop) == 0)
+    {
+      logDebug(&quot;Poller::SelectDesktop&quot;,&quot;Unable to SetThreadDesktop(), Error=%lu.&quot;, GetLastError());
+      return 0;
+    }
+
+    //
+    // Switched successfully - destroy the old desktop.
+    //
+    if (CloseDesktop(oldDesktop) == 0)
+    {
+      logDebug(&quot;Poller::selectHdesk&quot;,&quot;Failed to close old desktop (%x), Error=%lu.&quot;,
+                   (unsigned int)oldDesktop, GetLastError());
+      return 0;
+    }
+  }
+
+  return 1;
+}
+
+//
+// Switches the current thread into a different desktop, by name
+// Calling with a valid desktop name will place the thread in that desktop.
+// Calling with a NULL name will place the thread in the current input desktop.
+//
+
+char Poller::selectDesktopByName(char *name)
+{
+  //
+  // Only on NT.
+  //
+  if (isWinNT())
+  {
+    HDESK desktop;
+
+    if (name != NULL)
+    {
+      //
+      // Attempt to open the named desktop.
+      //
+      desktop = OpenDesktop(name, 0, FALSE,
+                                DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW |
+                                DESKTOP_ENUMERATE | DESKTOP_HOOKCONTROL |
+                                DESKTOP_WRITEOBJECTS | DESKTOP_READOBJECTS |
+                                DESKTOP_SWITCHDESKTOP | GENERIC_WRITE);
+    }
+    else
+    {
+      //
+      // Open the input desktop.
+      //
+      desktop = OpenInputDesktop(0, FALSE,
+                                     DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW |
+                                     DESKTOP_ENUMERATE | DESKTOP_HOOKCONTROL |
+                                     DESKTOP_WRITEOBJECTS | DESKTOP_READOBJECTS |
+                                     DESKTOP_SWITCHDESKTOP | GENERIC_WRITE);
+    }
+
+    if (desktop == NULL)
+    {
+      logDebug(&quot;Poller::selectDesktopByName&quot;,&quot;Unable to open desktop, Error=%lu.&quot;, GetLastError());
+      return 0;
+    }
+
+    //
+    // Switch to the new desktop
+    //
+    if (selectDesktop(desktop) == 0)
+    {
+      //
+      // Failed to enter the new desktop, so free it!
+      //
+      logDebug(&quot;Poller::selectDesktopByName&quot;,&quot;Failed to select desktop.&quot;);
+
+      if (CloseDesktop(desktop) == 0)
+      {
+        logDebug(&quot;Poller::selectDesktopByName&quot;,&quot;Failed to close desktop, Error=%lu.&quot;, GetLastError());
+        return 0;
+      }
+    }
+
+    return 1;
+  }
+
+  return (name == NULL);
+}
+
+void Poller::platformOS()
+{
+    OSVERSIONINFO osversioninfo;
+    osversioninfo.dwOSVersionInfoSize = sizeof(osversioninfo);
+
+    //
+    // Get the current OS version.
+    //
+    if (GetVersionEx(&amp;osversioninfo) == 0)
+    {
+      platformID_ = 0;
+    }
+    platformID_ = osversioninfo.dwPlatformId;
+
+//
+//    versionMajor = osversioninfo.dwMajorVersion;
+//    versionMinor = osversioninfo.dwMinorVersion;
+//
+}
+
+char Poller::checkDesktop()
+{
+  //
+  // Only on NT.
+  //
+  if (isWinNT())
+  {
+    //
+    // Get the input and thread desktops.
+    //
+    HDESK desktop = GetThreadDesktop(GetCurrentThreadId());
+    HDESK inputDesktop = OpenInputDesktop(0, FALSE,
+                        DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW |
+                        DESKTOP_ENUMERATE | DESKTOP_HOOKCONTROL |
+                        DESKTOP_WRITEOBJECTS | DESKTOP_READOBJECTS |
+                        DESKTOP_SWITCHDESKTOP | GENERIC_WRITE);
+
+    if (inputDesktop == NULL)
+    {
+      return 0;
+    }
+
+    DWORD dummy;
+    char desktopName[256];
+    char inputName[256];
+
+    if (GetUserObjectInformation(desktop, UOI_NAME, &amp;desktopName, 256, &amp;dummy) == 0)
+    {
+      if (CloseDesktop(inputDesktop) == 0)
+      {
+        logDebug(&quot;Poller::checkDesktop&quot;, &quot;Failed to close desktop, Error[%d].&quot;, (unsigned int)GetLastError());
+        return 0;
+      }
+    }
+
+    if (GetUserObjectInformation(inputDesktop, UOI_NAME, &amp;inputName, 256, &amp;dummy) == 0)
+    {
+      if (CloseDesktop(inputDesktop) == 0)
+      {
+        logDebug(&quot;Poller::checkDesktop&quot;, &quot;Failed to close input desktop, Error[%d].&quot;, (unsigned int)GetLastError());
+        return 0;
+      }
+    }
+
+    if (strcmp(desktopName, inputName) != 0)
+    {
+      //
+      // Switch to new desktop.
+      //
+      selectDesktop(inputDesktop);
+    }
+
+    if (CloseDesktop(desktop) == 0)
+    {
+      logDebug(&quot;Poller::checkDesktop&quot;, &quot;Failed to close input desktop, Error[%d].&quot;, (unsigned int)GetLastError());
+      return 0;
+    }
+
+    if (CloseDesktop(inputDesktop) == 0)
+    {
+      logDebug(&quot;Poller::checkDesktop&quot;, &quot;Failed to close input desktop, Error[%d].&quot;, (unsigned int)GetLastError());
+      return 0;
+    }
+  }
+
+  return 1;
+}
+
+unsigned char Poller::isModifier(UINT scancode)
+{
+  return 0;
+}
+
+void Poller::updateModifierState(UINT scancode, unsigned char pressed)
+{
+  return;
+}
+
+Cursor Poller::createCursor(Window wnd, Visual *vis,unsigned int x, unsigned int y,
+                                int width, int height, unsigned char *xormask, unsigned char *andmask)
+{
+  Pixmap maskglyph, cursorglyph;
+  XColor bg, fg;
+  Cursor xcursor;
+  unsigned char *cursor;
+  unsigned char *mask, *pmask, *pcursor, tmp;
+  int scanline, offset;
+
+  scanline = (width + 7) / 8;
+  offset = scanline * height;
+
+  pmask = andmask;
+  pcursor = xormask;
+  for (int i = 0; i &lt; offset; i++)
+  {
+    //
+    // The pixel is black if both the bit of andmask and xormask is one.
+    //
+
+    tmp = *pcursor &amp; *pmask;
+    *pcursor ^= tmp;
+    *pmask ^= tmp;
+
+    *pmask = ~(*pmask);
+
+    pmask++;
+    pcursor++;
+  }
+
+  cursor = new unsigned char[offset];
+  memcpy(cursor, xormask, offset);
+
+  mask = new unsigned char[offset];
+  memcpy(mask, andmask, offset);
+
+  fg.red = fg.blue = fg.green = 0xffff;
+  bg.red = bg.blue = bg.green = 0x0000;
+  fg.flags = bg.flags = DoRed | DoBlue | DoGreen;
+
+  cursorglyph = createGlyph(wnd, vis, width, height, cursor);
+  maskglyph = createGlyph(wnd, vis, width, height, mask);
+
+  xcursor = XCreatePixmapCursor(display_, cursorglyph, maskglyph, &amp;fg, &amp;bg, x, y);
+
+  XFreePixmap(display_, maskglyph);
+  XFreePixmap(display_, cursorglyph);
+  delete[]mask;
+  delete[]cursor;
+
+  return xcursor;
+}
+
+Pixmap Poller::createGlyph(Window wnd, Visual *visual, int width, int height, unsigned char *data)
+{
+  XImage *image;
+  Pixmap bitmap;
+  int scanline;
+  GC glyphGC;
+
+  scanline = (width + 7) / 8;
+
+  bitmap = XCreatePixmap(display_, wnd, width, height, 1);
+  glyphGC = XCreateGC(display_, bitmap, 0, NULL);
+
+  image = XCreateImage(display_, visual, 1, ZPixmap, 0, (char *)data, width, height, 8, scanline);
+  image-&gt;byte_order = 1; // MSBFirst -- LSBFirst = 0
+  image-&gt;bitmap_bit_order = 1;
+  XInitImage(image);
+
+/*  logTest(&quot;Poller::createGlyph&quot;,&quot;XPutImage on pixmap %d,%d,%d,%d.\n&quot;,
+              0, 0, width, height);*/
+  XPutImage(display_, bitmap, glyphGC, image, 0, 0, 0, 0, width, height);
+  XFree(image);
+
+  return bitmap;
+}
+#endif /* defined(__CYGWIN32__) || defined(WIN32) */
diff --git a/nxcompshad/Win.h b/nxcompshad/Win.h
new file mode 100644
index 0000000..b44b5a0
--- /dev/null
+++ b/nxcompshad/Win.h
@@ -0,0 +1,223 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifdef __CYGWIN32__
+
+#ifndef Win32Poller_H
+#define Win32Poller_H
+
+//#include &lt;X11/X.h&gt;
+
+#include &lt;Windows.h&gt;
+#include &lt;wingdi.h&gt;
+#include &lt;winable.h&gt;
+#include &lt;winuser.h&gt;
+
+#define CAPTUREBLT 0x40000000
+
+#define KEYEVENTF_SCANCODE 0x00000008
+#define MAPVK_VSC_TO_VK_EX 3
+//
+// The CAPTUREBLT is a raster operation used
+// in bit blit transfer.
+//
+// Using this operation includes any windows
+// that are layered on top of your window in
+// the resulting image. By default, the image
+// only contains your window.
+//
+
+#include &quot;Core.h&quot;
+
+typedef struct _keyTranslation
+{
+ unsigned char scancode;
+ unsigned short modifiers;
+
+}keyTranslation;
+
+class Poller : public CorePoller
+{
+  public:
+
+  Display *display_;
+  keyTranslation *keymap_;
+  unsigned char keymapLoaded_;
+  int minKeycode_;
+
+  Poller(Input *, Display *display, int = 16);
+
+  ~Poller();
+
+  int init();
+
+  int updateCursor(Window, Visual*);
+
+  private:
+
+  
+  int Poller::updateShadowFrameBuffer(void);
+  void handleKeyboardEvent(Display *, XEvent *);
+  void addToKeymap(char *keyname, unsigned char scancode, unsigned short modifiers, char *mapname);
+  int xkeymapRead(char *mapname);
+  FILE *xkeymapOpen(char *filename);
+  void xkeymapInit(char *keyMapName);
+  keyTranslation xkeymapTranslateKey(unsigned int keysym, unsigned int keycode, unsigned int state);
+  unsigned char getKeyState(unsigned int state, unsigned int keysym);
+  char *getKsname(unsigned int keysym);
+  unsigned char specialKeys(unsigned int keysym, unsigned int state, int pressed);
+
+  unsigned char toggleSwitch(unsigned char ToggleStateClient, unsigned char ToggleStateServer, UINT scancode,
+                                 int *lengthArrayINPUT);
+
+  void updateModifierState(UINT, unsigned char);
+
+  unsigned char toggleServerState(UINT scancode);
+  unsigned char keyState(UINT scancode, UINT mapType);
+  unsigned char keyStateAsync(UINT scancode);
+
+  void handleMouseEvent(Display *, XEvent *);
+
+  Cursor createCursor(Window wnd, Visual *vis, unsigned int x, unsigned int y, int width,
+                           int height, unsigned char *xormask, unsigned char *andmask);
+
+  Pixmap createGlyph(Window wnd, Visual *visual, int width, int height, unsigned char *data);
+
+  char isWinNT();
+  char selectDesktop(HDESK new_desktop);
+  char selectDesktopByName(char *name);
+  void platformOS();
+  char simulateCtrlAltDel(void);
+  DWORD platformID_;
+
+  INPUT *pKey_, *pMouse_;
+
+  char *keymapName_;
+  char *path_;
+
+  unsigned char toggleButtonState_;
+  unsigned short serverModifierState_;
+  unsigned short savedServerModifierState_;
+
+  void ensureServerModifiers(keyTranslation tr, int *lenghtArrayINPUT);
+  void restoreServerModifiers(UINT scancode);
+  unsigned char isModifier(UINT scancode);
+
+  char sendInput(unsigned char scancode, unsigned char pressed, int *lengthArrayINPUT);
+
+  char *getRect(XRectangle);
+  char checkDesktop();
+
+  char *DIBBuffer_;
+
+  HCURSOR oldCursor_;
+
+  VOID *pDIBbits_;
+  HDC screenDC_;
+  HDC memoryDC_;
+  BITMAPINFO bmi_;
+  HBITMAP screenBmp_;
+
+  Cursor xCursor_;
+
+};
+
+#undef TEST
+
+inline unsigned char Poller::toggleSwitch(unsigned char ToggleStateClient, unsigned char ToggleStateServer,
+                                              UINT scancode, int *lengthArrayINPUT)
+{
+  return 1;
+}
+
+inline unsigned char Poller::toggleServerState(UINT scancode)
+{
+  return (GetKeyState(MapVirtualKeyEx(scancode, 3, GetKeyboardLayout((DWORD)NULL))) &amp; 0x1);
+}
+
+inline unsigned char Poller::keyStateAsync(UINT vKeycode)
+{
+  return GetAsyncKeyState(vKeycode);
+}
+
+inline unsigned char Poller::keyState(UINT code, UINT mapType)
+{
+  if (mapType == 0)
+  {
+    //
+    // Virtual Keycode
+    //
+    return ((GetKeyState(code) &amp; 0x80) == 0x80);
+  }
+  else
+  {
+    //
+    // scancode
+    //
+    return ((GetKeyState(MapVirtualKeyEx(code, 3, GetKeyboardLayout((DWORD)NULL))) &amp; 0x80) == 0x80);
+  }
+}
+
+inline char Poller::isWinNT()
+{
+  return (platformID_ == VER_PLATFORM_WIN32_NT);
+}
+
+inline char Poller::sendInput(unsigned char scancode, unsigned char pressed, int *lengthArrayINPUT)
+{
+  DWORD keyEvent = 0;
+  DWORD extended = 0;
+
+  if (scancode &gt; 0)
+  {
+    if (pressed == 0)
+    {
+      keyEvent = KEYEVENTF_KEYUP;
+    }
+
+    if (scancode &amp; 0x80)
+    {
+      scancode &amp;= ~0x80;
+      extended = KEYEVENTF_EXTENDEDKEY;
+    }
+
+    pKey_[*lengthArrayINPUT].ki.wScan = (WORD) scancode;
+    pKey_[*lengthArrayINPUT].ki.dwFlags = (DWORD) (keyEvent | KEYEVENTF_SCANCODE | extended);
+    (*lengthArrayINPUT)++;
+  }
+
+
+  if (*lengthArrayINPUT &gt; 0)                                                                                                   {
+    // FIXME: Remove me.
+    logTest(&quot;Poller::sendInput&quot;, &quot;length Input [%d] event: %s&quot;, *lengthArrayINPUT,
+              pressed == 1 ? &quot;KeyPress&quot;: &quot;KeyRelease&quot;);
+
+    if (SendInput(*lengthArrayINPUT, pKey_, sizeof(INPUT)) == 0)
+    {
+      logTest(&quot;Poller::sendInput&quot;, &quot;Failed SendInput, event: %s&quot;, pressed == 1 ? &quot;KeyPress&quot;: &quot;KeyRelease&quot;);
+      *lengthArrayINPUT = 0;
+      return 0;
+    }
+
+    *lengthArrayINPUT = 0;
+  }
+
+  return 1;
+}
+#endif /* Win32Poller_H */
+
+#endif /* __CYGWIN32__ */
diff --git a/nxcompshad/X11.cpp b/nxcompshad/X11.cpp
new file mode 100644
index 0000000..a2165d8
--- /dev/null
+++ b/nxcompshad/X11.cpp
@@ -0,0 +1,720 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#if !defined(__CYGWIN32__) &amp;&amp; !defined(WIN32)
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#include &lt;X11/Xlibint.h&gt;
+#include &lt;X11/extensions/XTest.h&gt;
+#include &lt;X11/keysym.h&gt;
+#include &lt;string.h&gt;
+#include &lt;sys/ipc.h&gt;
+#include &lt;sys/shm.h&gt;
+
+#include &quot;Poller.h&quot;
+#include &quot;Logger.h&quot;
+#include &quot;Shadow.h&quot;
+
+#define ROUNDUP(nbytes, pad) ((((nbytes) + ((pad)-1)) / (pad)) * ((pad)&gt;&gt;3))
+
+#define TRANSLATE_KEYCODES
+
+Poller::Poller(Input *input, Display *display, int depth) : CorePoller(input, display)
+{
+  logTrace(&quot;Poller::Poller&quot;);
+
+  display_ = NULL;
+  shadowDisplayName_ = input -&gt; getShadowDisplayName();
+
+  tmpBuffer_ = NULL;
+
+  xtestExtension_  = -1;
+  shmExtension_    = -1;
+  randrExtension_  = -1;
+  damageExtension_ = -1;
+
+  shadowDisplayUid_ = -1;
+
+  image_ = NULL;
+
+  shminfo_ = NULL;
+}
+
+Poller::~Poller()
+{
+  logTrace(&quot;Poller::~Poller&quot;);
+
+  if (shmExtension_ == 1)
+  {
+    XShmDetach(display_, shminfo_);
+    XDestroyImage(image_);
+    shmdt(shminfo_ -&gt; shmaddr);
+    shmctl(shminfo_ -&gt; shmid, IPC_RMID, 0);
+  }
+
+  if (shminfo_ != NULL)
+  {
+    delete shminfo_;
+
+    shminfo_ = NULL;
+  }
+
+  if (display_ != NULL)
+  {
+    XCloseDisplay(display_);
+  }
+
+  if (tmpBuffer_ != NULL &amp;&amp; shmExtension_ == 1 &amp;&amp; damageExtension_ == 1)
+  {
+    XFree(tmpBuffer_);
+
+    tmpBuffer_ = NULL;
+  }
+}
+
+int Poller::init()
+{
+  logTrace(&quot;Poller::init&quot;);
+
+  if (display_ == NULL)
+  {
+    display_ = XOpenDisplay(shadowDisplayName_);
+
+    setShadowDisplay(display_);
+  }
+
+  logTest(&quot;Poller::init:&quot; ,&quot;Shadow display [%p] name [%s].&quot;, (Display *) display_, shadowDisplayName_);
+
+  if (display_ == NULL)
+  {
+    logTest(&quot;Poller::init&quot;, &quot;Failed to connect to display [%s].&quot;, shadowDisplayName_ ? shadowDisplayName_ : &quot;&quot;);
+
+    return -1;
+  }
+
+  setRootSize();
+
+  logTest(&quot;Poller::init&quot;, &quot;Screen geometry is [%d, %d] depth is [%d] bpl [%d] bpp [%d].&quot;,
+              width_, height_, depth_, bpl_, bpp_);
+
+  xtestInit();
+
+  shmInit();
+
+  randrInit();
+
+  damageInit();
+
+  return CorePoller::init();
+}
+
+int Poller::updateShadowFrameBuffer(void)
+{
+  if (shmExtension_ == 1)
+  {
+    if (XShmGetImage(display_, DefaultRootWindow(display_), image_, 0, 0, AllPlanes) == 0)
+    {
+      logDebug(&quot;Poller::updateShadowFrameBuffer&quot;, &quot;XShmGetImage failed!&quot;);
+
+      return -1;
+    }
+
+    return 1;
+  }
+  else
+  {
+    return 0;
+  }
+}
+
+char *Poller::getRect(XRectangle r)
+{
+  logTrace(&quot;Poller::getRect&quot;);
+
+  logDebug(&quot;Poller::getRect&quot;, &quot;Going to retrive rectangle [%d, %d, %d, %d].&quot;,
+              r.x, r.y, r.width, r.height);
+
+  if (shmExtension_ == 1)
+  {
+    if (damageExtension_ == 1)
+    {
+      image_ -&gt; width = r.width;
+      image_ -&gt; height = r.height;
+
+      image_ -&gt; bytes_per_line = ROUNDUP((image_ -&gt; bits_per_pixel * image_ -&gt; width), image_ -&gt; bitmap_pad);
+
+      if (XShmGetImage(display_, DefaultRootWindow(display_), image_, r.x, r.y, AllPlanes) == 0)
+      {
+        logDebug(&quot;Poller::getRect&quot;, &quot;XShmGetImage failed!&quot;);
+
+        return NULL;
+      }
+
+      tmpBuffer_ = image_ -&gt; data;
+    }
+    else
+    {
+      image_ -&gt; width  = r.width;
+      image_ -&gt; height = r.height; 
+
+      image_ -&gt; bytes_per_line = ROUNDUP((image_ -&gt; bits_per_pixel * image_ -&gt; width), image_ -&gt; bitmap_pad);
+
+      if (XShmGetImage(display_, DefaultRootWindow(display_), image_, r.x, r.y, AllPlanes) == 0)
+      {
+        logDebug(&quot;Poller::getRect&quot;, &quot;XShmGetImage failed!&quot;);
+      }
+
+      tmpBuffer_ = image_ -&gt; data;
+    }
+  }
+  else
+  {
+    if (tmpBuffer_)
+    {
+      XFree(tmpBuffer_);
+      tmpBuffer_ = NULL;
+    }
+
+    image_ = XGetImage(display_, DefaultRootWindow(display_), r.x, r.y, r.width, r.height, AllPlanes, ZPixmap);
+
+    if (image_ == NULL)
+    {
+      logError(&quot;Poller::getRect&quot;, ESET(ENOMSG));
+
+      return NULL;
+    }
+
+    tmpBuffer_ = image_ -&gt; data;
+
+    if (image_ -&gt; obdata)
+    {
+      XFree(image_ -&gt; obdata);
+    }
+
+    XFree(image_);
+  }
+
+  return tmpBuffer_;
+}
+
+void Poller::shmInit(void)
+{
+  int major, minor;
+  int pixmaps;
+
+  logTest(&quot;Poller::shmInit&quot;, &quot;Added shmExtension_ [%d].&quot;, shmExtension_);
+
+  if (shmExtension_ &gt;= 0)
+  {
+    logDebug(&quot;Poller::shmInit&quot;, &quot;Called with shared memory already initialized.&quot;);
+
+    return;
+  }
+
+  if (shmExtension_ &lt; 0 &amp;&amp; NXShadowOptions.optionShmExtension == 0)
+  {
+    shmExtension_ = 0;
+
+    logUser(&quot;Poller::shmInit: Disabling use of MIT-SHM extension.\n&quot;);
+
+    return;
+  }
+
+  if (XShmQueryVersion(display_, &amp;major, &amp;minor, &amp;pixmaps) == 0)
+  {
+    logDebug(&quot;Poller::shmInit&quot;, &quot;MIT_SHM: Shared memory extension not available.&quot;);
+
+    shmExtension_ = 0;
+  }
+  else
+  {
+    logDebug(&quot;Poller::shmInit&quot;, &quot;MIT_SHM: Shared memory extension available.&quot;);
+
+    if (shminfo_ != NULL)
+    {
+      destroyShmImage();
+    }
+
+    shminfo_ = (XShmSegmentInfo* ) new XShmSegmentInfo;
+
+    if (shminfo_ == NULL)
+    {
+      logError(&quot;Poller::shmInit&quot;, ESET(ENOMEM));
+
+      shmExtension_ = 0;
+
+      return;
+    }
+
+    image_ = (XImage *)XShmCreateImage(display_, display_ -&gt; screens[0].root_visual, depth_, ZPixmap,
+                                           NULL,  shminfo_, width_, height_);
+
+    if (image_ == NULL)
+    {
+      logError(&quot;Poller::shmInit&quot;, ESET(ENOMSG));
+
+      shmExtension_ = 0;
+
+      return;
+    }
+
+    shadowDisplayUid_ = NXShadowOptions.optionShadowDisplayUid;
+
+    logDebug(&quot;Poller::shmInit&quot;, &quot;Master X server uid [%d].&quot;, NXShadowOptions.optionShadowDisplayUid);
+
+    shminfo_ -&gt; shmid = shmget(IPC_PRIVATE, image_ -&gt; bytes_per_line * image_ -&gt; height, IPC_CREAT | 0666);
+
+    if (shminfo_ -&gt; shmid &lt; 0)
+    {
+      logDebug(&quot;Poller::shmInit&quot;, &quot;kernel id error.&quot;);
+
+      shmExtension_ = 0;
+
+      return;
+    }
+
+    logDebug(&quot;Poller::shmInit&quot;, &quot;Created shm segment with shmid [%d].&quot;, shminfo_ -&gt; shmid);
+
+    shminfo_ -&gt; shmaddr = (char *)shmat(shminfo_ -&gt; shmid, 0, 0);
+
+    if (shminfo_ -&gt; shmaddr &lt; 0)
+    {
+      logWarning(&quot;Poller::shmInit&quot;, &quot;Couldn't attach to shm segment.&quot;);
+    }
+
+    logDebug(&quot;Poller::shmInit&quot;, &quot;shminfo_ -&gt; shmaddr [%p].&quot;, shminfo_ -&gt; shmaddr);
+
+    image_ -&gt; data = shminfo_ -&gt; shmaddr;
+
+    shminfo_ -&gt; readOnly = 0;
+
+    if (XShmAttach(display_, shminfo_) == 0)
+    {
+      logDebug(&quot;Poller::shmInit&quot;, &quot;XShmAttach failed.&quot;);
+
+      shmExtension_ = 0;
+
+      return;
+    }
+
+    //
+    // Mark the shm segment to be destroyed after
+    // the last process detach. Let the X server
+    // complete the X_ShmAttach request, before.
+    //
+
+    XSync(display_, 0);
+
+    struct shmid_ds ds;
+
+    shmctl(shminfo_ -&gt; shmid, IPC_STAT, &amp;ds);
+
+    if (shadowDisplayUid_ != -1)
+    {
+      ds.shm_perm.uid = (ushort) shadowDisplayUid_;
+    }
+    else
+    {
+      logWarning(&quot;Poller::shmInit&quot;, &quot;Couldn't set uid for shm segment.&quot;);
+    }
+
+    ds.shm_perm.mode = 0600;
+
+    shmctl(shminfo_ -&gt; shmid, IPC_SET, &amp;ds);
+
+    shmctl(shminfo_ -&gt; shmid, IPC_STAT, &amp;ds);
+
+    shmctl(shminfo_ -&gt; shmid, IPC_RMID, 0);
+
+    logDebug(&quot;Poller::shmInit&quot;, &quot;Number of attaches to shm segment [%d] are [%d].\n&quot;,
+                 shminfo_ -&gt; shmid, (int) ds.shm_nattch);
+
+    if (ds.shm_nattch &gt; 2)
+    {
+      logWarning(&quot;Poller::shmInit&quot;, &quot;More than two attaches to the shm segment.&quot;);
+
+      destroyShmImage();
+
+      shmExtension_ = 0;
+
+      return;
+    }
+
+    shmExtension_ = 1;
+  }
+}
+
+void Poller::handleKeyboardEvent(Display *display, XEvent *event)
+{
+  if (xtestExtension_ == 0 || display_ == 0)
+  {
+    return;
+  }
+
+  logTest(&quot;Poller::handleKeyboardEvent&quot;, &quot;Handling event at [%p]&quot;, event);
+
+  //
+  // Use keysyms to translate keycodes across different
+  // keyboard models. Unuseful when both keyboards have
+  // same keycodes (e.g. both are pc keyboards).
+  //
+
+  #ifdef TRANSLATE_KEYCODES
+
+  KeyCode keycode = XKeysymToKeycode(display_, XK_A);
+
+  if (XKeysymToKeycode(event -&gt; xkey.display, XK_A) != keycode)
+  {
+    KeySym keysym = XKeycodeToKeysym(event -&gt; xkey.display, event -&gt; xkey.keycode, 0);
+  
+    if (keysym == XK_Mode_switch || keysym == XK_ISO_Level3_Shift)
+    {
+      logUser(&quot;Poller::handleKeyboardEvent: keysym [%x].\n&quot;, (unsigned int)keysym);
+  
+      if (XKeycodeToKeysym(display_, 113, 0) == XK_ISO_Level3_Shift ||
+             (XKeycodeToKeysym(display_, 124, 0) == XK_ISO_Level3_Shift))
+      {
+        event -&gt; xkey.keycode = 113;
+      }
+      else
+      {
+        event -&gt; xkey.keycode = XKeysymToKeycode(display_, XK_Mode_switch);
+      }
+  
+      logUser(&quot;Poller::handleKeyboardEvent: keycode translated to [%x].\n&quot;, (unsigned int)event -&gt; xkey.keycode);
+    }
+    else
+    {
+      event -&gt; xkey.keycode = XKeysymToKeycode(display_, keysym);
+    }
+  }
+
+  #endif // TRANSLATE_KEYCODES
+
+  if (event -&gt; type == KeyPress)
+  {
+    XTestFakeKeyEvent(display_, event -&gt; xkey.keycode, 1, 0);
+  }
+  else if (event -&gt; type == KeyRelease)
+  {
+    XTestFakeKeyEvent(display_, event -&gt; xkey.keycode, 0, 0);
+  }
+}
+
+void Poller::handleMouseEvent(Display *display, XEvent *event)
+{
+  if (xtestExtension_ == 0 || display_ == 0)
+  {
+    return;
+  }
+
+  if (event -&gt; type == MotionNotify)
+  {
+    XTestFakeMotionEvent(display_, 0, event -&gt; xmotion.x, event -&gt; xmotion.y, 0);
+  }
+  else if (event -&gt; type == ButtonPress)
+  {
+    XTestFakeButtonEvent(display_, event -&gt; xbutton.button, True, 0);
+  }
+  else if (event -&gt; type == ButtonRelease)
+  {
+    XTestFakeButtonEvent(display_, event -&gt; xbutton.button, False, 0);
+  }
+
+  XFlush(display_);
+}
+
+void Poller::setRootSize(void)
+{
+  width_ = WidthOfScreen(DefaultScreenOfDisplay(display_));
+  height_ = HeightOfScreen(DefaultScreenOfDisplay(display_));
+  depth_ = DefaultDepth(display_, DefaultScreen(display_));
+
+  if (depth_ == 8) bpp_ = 1;
+  else if (depth_ == 16) bpp_ = 2;
+  else bpp_ = 4;
+
+  bpl_ = width_ * bpp_;
+}
+
+void Poller::destroyShmImage(void)
+{
+    XShmDetach(display_, shminfo_);
+    XDestroyImage(image_);
+    image_ = NULL;
+
+    shmdt(shminfo_ -&gt; shmaddr);
+    shmctl(shminfo_ -&gt; shmid, IPC_RMID, 0);
+
+    delete shminfo_;
+    shminfo_ = NULL;
+}
+
+void Poller::xtestInit(void)
+{
+  int eventBase;
+  int errorBase;
+  int versionMajor;
+  int versionMinor;
+  int result;
+
+  xtestExtension_ = 0;
+
+  result = XTestQueryExtension(display_, &amp;eventBase, &amp;errorBase, &amp;versionMajor, &amp;versionMinor);
+
+  if (result == 0)
+  {
+    xtestExtension_ = 0;
+
+    logWarning(&quot;Poller::xtestInit&quot;, &quot;Failed while querying for XTEST extension.&quot;);
+  }
+  else
+  {
+    logDebug(&quot;Poller::xtestInit&quot;, &quot;XTEST version %d.%d.&quot;, versionMajor, versionMinor);
+
+    xtestExtension_ = 1;
+  }
+
+  //
+  // Make this client impervious to grabs.
+  //
+
+  if (xtestExtension_ == 1)
+  {
+    XTestGrabControl(display_, 1);
+  }
+}
+
+void Poller::randrInit(void)
+{
+  int randrEventBase;
+  int randrErrorBase;
+
+  randrExtension_ = 0;
+
+  XRRSelectInput(display_, DefaultRootWindow(display_), RRScreenChangeNotifyMask);
+
+  if (XRRQueryExtension(display_, &amp;randrEventBase, &amp;randrErrorBase) == 0)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;nxagentShadowInit: Randr extension not supported on this display.\n&quot;);
+    #endif
+  }
+
+  randrEventBase_ = randrEventBase;
+
+  randrExtension_ = 1;
+
+  return;
+}
+
+void Poller::damageInit(void)
+{
+  int damageMajorVersion = 0;
+  int damageMinorVersion = 0;
+
+  int damageEventBase = 0;
+  int damageErrorBase = 0;
+
+  if (damageExtension_ &gt;= 0)
+  {
+    logDebug(&quot;Poller::damageInit&quot;, &quot;Called with damage already initialized.&quot;);
+  }
+
+  if (damageExtension_ == 0)
+  {
+    logDebug(&quot;Poller::damageInit&quot;, &quot;Damage disabled. Skip initialization.&quot;);
+
+    return;
+  }
+
+  if (damageExtension_ &lt; 0 &amp;&amp; NXShadowOptions.optionDamageExtension == 0)
+  {
+    damageExtension_ = 0;
+
+    logUser(&quot;Poller::damageInit: Disabling use of DAMAGE extension.\n&quot;);
+
+    return;
+  }
+
+  damageExtension_ = 0;
+
+  mirrorChanges_ = 0;
+
+  if (XDamageQueryExtension(display_, &amp;damageEventBase, &amp;damageErrorBase) == 0)
+  {
+    logUser(&quot;Poller::damageInit: DAMAGE not supported.\n&quot;);
+
+    return;
+  }
+  #ifdef DEBUG
+  else
+  {
+    fprintf(stderr, &quot;Poller::damageInit: DAMAGE supported. &quot;
+                &quot;Event base [%d] error base [%d].\n&quot;, damageEventBase, damageErrorBase);
+  }
+  #endif
+
+  damageEventBase_ = damageEventBase;
+
+  if (XDamageQueryVersion(display_, &amp;damageMajorVersion, &amp;damageMinorVersion) == 0)
+  {
+    logWarning(&quot;Poller::damageInit&quot;, &quot;Error on querying DAMAGE version.\n&quot;);
+
+    damageExtension_ = 0;
+
+    return;
+  }
+  #ifdef DEBUG
+  else
+  {
+    fprintf(stderr, &quot;Poller::damageInit: DAMAGE version %d.%d.\n&quot;,
+                damageMajorVersion, damageMinorVersion);
+  }
+  #endif
+
+  damage_ = XDamageCreate(display_, DefaultRootWindow(display_), XDamageReportRawRectangles);
+
+  damageExtension_= 1;
+
+  mirror_ = 1;
+
+  return;
+}
+
+void Poller::getEvents(void)
+{
+  XEvent X;
+
+  if (damageExtension_ == 1)
+  {
+    XDamageSubtract(display_, damage_, None, None);
+  }
+
+  XSync(display_, 0);
+
+  while (XCheckIfEvent(display_, &amp;X, anyEventPredicate, NULL) == 1)
+  {
+    if (randrExtension_ == 1 &amp;&amp; (X.type == randrEventBase_ + RRScreenChangeNotify || X.type == ConfigureNotify))
+    {
+      XRRUpdateConfiguration (&amp;X);
+
+      handleRRScreenChangeNotify(&amp;X);
+
+      continue;
+    }
+
+    if (damageExtension_ == 1 &amp;&amp; X.type == damageEventBase_ + XDamageNotify)
+    {
+      handleDamageNotify(&amp;X);
+    }
+  }
+
+  if (damageExtension_ == 1)
+  {
+    updateDamagedAreas();
+  }
+
+  XFlush(display_);
+}
+
+void Poller::handleRRScreenChangeNotify(XEvent *X)
+{
+  return;
+}
+
+void Poller::handleDamageNotify(XEvent *X)
+{
+  XDamageNotifyEvent *e = (XDamageNotifyEvent *) X;
+
+  //
+  //  e-&gt;drawable is the window ID of the damaged window
+  //  e-&gt;geometry is the geometry of the damaged window
+  //  e-&gt;area     is the bounding rect for the damaged area
+  //  e-&gt;damage   is the damage handle returned by XDamageCreate()
+  //
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;handleDamageNotify: drawable [%d] damage [%d] geometry [%d][%d][%d][%d] area [%d][%d][%d][%d].\n&quot;,
+              (int) e -&gt; drawable, (int) e -&gt; damage, e -&gt; geometry.x, e -&gt; geometry.y,
+                  e -&gt; geometry.width, e -&gt; geometry.height, e -&gt; area.x, e -&gt; area.y,
+                      e -&gt; area.width, e -&gt; area.height);
+  #endif
+
+  XRectangle rectangle = {e -&gt; area.x, e -&gt; area.y, e -&gt; area.width, e -&gt; area.height};
+
+  XUnionRectWithRegion(&amp;rectangle, lastUpdatedRegion_, lastUpdatedRegion_);
+
+  mirrorChanges_ = 1;
+
+  return;
+}
+
+void Poller::updateDamagedAreas(void)
+{
+  if (shmExtension_ == 1)
+  {
+    BOX *boxPtr;
+
+    XRectangle rectangle;
+
+    int i;
+    int y;
+
+    for (i = 0; i &lt; lastUpdatedRegion_ -&gt; numRects; i++)
+    {
+      boxPtr = lastUpdatedRegion_ -&gt; rects + i;
+
+      image_ -&gt; width  = boxPtr -&gt; x2 - boxPtr -&gt; x1;
+      image_ -&gt; height = boxPtr -&gt; y2 - boxPtr -&gt; y1; 
+
+      image_ -&gt; bytes_per_line = ROUNDUP((image_ -&gt; bits_per_pixel * image_ -&gt; width), image_ -&gt; bitmap_pad);
+
+      if (XShmGetImage(display_, DefaultRootWindow(display_), image_, boxPtr -&gt; x1, boxPtr -&gt; y1, AllPlanes) == 0)
+      {
+        logDebug(&quot;Poller::getRect&quot;, &quot;XShmGetImage failed!&quot;);
+
+        return;
+      }
+
+      rectangle.height = 1;
+      rectangle.width = image_ -&gt; width;
+      rectangle.x = boxPtr -&gt; x1;
+      rectangle.y = boxPtr -&gt; y1;
+
+      for (y = 0; y &lt; image_ -&gt; height; y++)
+      {
+        update(image_ -&gt; data + y * image_ -&gt; bytes_per_line, rectangle);
+
+        rectangle.y++; 
+      }
+    }
+  }
+
+  return;
+}
+
+int anyEventPredicate(Display *display, XEvent *event, XPointer parameter)
+{
+  return 1;
+}
+
+#endif /* !defined(__CYGWIN32__) &amp;&amp; !defined(WIN32) */
diff --git a/nxcompshad/X11.h b/nxcompshad/X11.h
new file mode 100644
index 0000000..e3a62ba
--- /dev/null
+++ b/nxcompshad/X11.h
@@ -0,0 +1,101 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPSHAD, NX protocol compression and NX extensions to this software */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef X11Poller_H
+#define X11Poller_H
+
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/extensions/XShm.h&gt;
+#include &lt;X11/extensions/Xdamage.h&gt;
+#include &lt;X11/extensions/Xrandr.h&gt;
+
+#include &quot;Core.h&quot;
+
+class Poller : public CorePoller
+{
+  public:
+
+  Poller(Input *, Display *display, int = 0);
+
+  ~Poller();
+
+  int init();
+
+  void setRootSize();
+
+  void destroyShmImage();
+
+  void getEvents(void);
+
+  private:
+
+  Display *display_;
+
+  char *shadowDisplayName_;
+
+  int shadowDisplayUid_;
+
+  char *tmpBuffer_;
+
+  char xtestExtension_;
+
+  char shmExtension_;
+
+  char randrExtension_;
+
+  int randrEventBase_;
+
+  char damageExtension_;
+
+  int damageEventBase_;
+
+  Damage damage_;
+
+  Region repair_;
+
+  char damageChanges_;
+
+  XShmSegmentInfo *shminfo_;
+
+  XImage *image_;
+
+  int updateShadowFrameBuffer(void);
+
+  char *getRect(XRectangle);
+
+  void handleKeyboardEvent(Display *display, XEvent *);
+
+  void handleMouseEvent(Display *, XEvent *);
+
+  void xtestInit(void);
+
+  void shmInit(void);
+
+  void randrInit(void);
+
+  void damageInit(void);
+
+  void handleRRScreenChangeNotify(XEvent *);
+
+  void handleDamageNotify(XEvent *);
+
+  void updateDamagedAreas(void);
+};
+
+int anyEventPredicate(Display *display, XEvent *event, XPointer parameter);
+
+#endif /* X11Poller_H */
diff --git a/nxcompext/configure b/nxcompshad/configure
similarity index 95%
rename from nxcompext/configure
rename to nxcompshad/configure
index 87d630e..d5b4228 100755
--- a/nxcompext/configure
+++ b/nxcompshad/configure
@@ -271,8 +271,8 @@ PACKAGE_VERSION=
 PACKAGE_STRING=
 PACKAGE_BUGREPORT=
 
-ac_unique_file=&quot;NXlib.h&quot;
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CXX CXXFLAGS LDFLAGS CPPFLAGS ac_ct_CXX EXEEXT OBJEXT CC CFLAGS ac_ct_CC INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CXXCPP X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS LIBVERSION VERSION MAKEDEPEND ALL LIBOBJS LTLIBOBJS'
+ac_unique_file=&quot;Shadow.h&quot;
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS armcxx armcc CXX CXXFLAGS LDFLAGS CPPFLAGS ac_ct_CXX EXEEXT OBJEXT CC CFLAGS ac_ct_CC INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CXXCPP X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS LIBVERSION VERSION MAKEDEPEND LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -1270,19 +1270,110 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 CXXFLAGS=&quot;-O3&quot;
-CFLAGS=&quot;-O3&quot;
+CPPFLAGS=&quot;-O3&quot;
 
 
 LIBSTATIC=&quot;&quot;
 LIBSHARED=&quot;&quot;
 
 
-if test -d &quot;../nx-X11/include&quot; ; then
-    CXXFLAGS=&quot;$CXXFLAGS -I../nx-X11/exports/include -I../nx-X11/lib/X11 \
-                        -I../nx-X11/include -I../nx-X11/programs/Xserver/include&quot;
-    CFLAGS=&quot;$CFLAGS -I../nx-X11/exports/include -I../nx-X11/lib/X11 \
-                    -I../nx-X11/include -I../nx-X11/programs/Xserver/include&quot;
-    LDFLAGS=&quot;$LDFLAGS -L../nx-X11/exports/lib&quot;
+if test -d &quot;../nx-X11/exports/include&quot; ; then
+    CXXFLAGS=&quot;$CXXFLAGS -I../nx-X11/exports/include&quot;
+    LIBS=&quot;$LIBS -L../nx-X11/exports/lib&quot;
+fi
+
+
+if test &quot;${with_ipaq}&quot; = yes; then
+  echo -e &quot;enabling IPAQ configuration&quot;
+  CXX=&quot;arm-linux-c++&quot;
+  CC=&quot;arm-linux-gcc&quot;
+  unset ac_cv_prog_armcxx
+  unset ac_cv_prog_armcc
+  unset ac_cv_prog_CXXCPP
+  # Extract the first word of &quot;&quot;$CXX&quot;&quot;, so it can be a program name with args.
+set dummy &quot;$CXX&quot;; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_armcxx+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$armcxx&quot;; then
+  ac_cv_prog_armcxx=&quot;$armcxx&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_armcxx=&quot;yes&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+  test -z &quot;$ac_cv_prog_armcxx&quot; &amp;&amp; ac_cv_prog_armcxx=&quot;no&quot;
+fi
+fi
+armcxx=$ac_cv_prog_armcxx
+if test -n &quot;$armcxx&quot;; then
+  echo &quot;$as_me:$LINENO: result: $armcxx&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$armcxx&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  # Extract the first word of &quot;&quot;$CC&quot;&quot;, so it can be a program name with args.
+set dummy &quot;$CC&quot;; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_armcc+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$armcc&quot;; then
+  ac_cv_prog_armcc=&quot;$armcc&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_armcc=&quot;yes&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+  test -z &quot;$ac_cv_prog_armcc&quot; &amp;&amp; ac_cv_prog_armcc=&quot;no&quot;
+fi
+fi
+armcc=$ac_cv_prog_armcc
+if test -n &quot;$armcc&quot;; then
+  echo &quot;$as_me:$LINENO: result: $armcc&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$armcc&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  if test $armcxx = &quot;yes&quot; &amp;&amp; test $armcc = &quot;yes&quot; ; then
+    ac_cv_prog_CXX=&quot;$CXX&quot;
+    ac_cv_prog_CC=&quot;$CC&quot;
+  else
+    { { echo &quot;$as_me:$LINENO: error: installation or configuration problem: I cannot find compiler for arm-linux&quot; &gt;&amp;5
+echo &quot;$as_me: error: installation or configuration problem: I cannot find compiler for arm-linux&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+  fi
+else
+  unset ac_cv_prog_CXX
+  unset ac_cv_prog_CC
+  unset ac_cv_prog_CXXCPP
 fi
 
 
@@ -2579,6 +2670,41 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
 
 
+echo &quot;$as_me:$LINENO: checking whether compiler needs -Wno-deprecated&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether compiler needs -Wno-deprecated... $ECHO_C&quot; &gt;&amp;6
+gcc_version=`${CC} --version | grep 'gcc (GCC) [3-4].' | head -n 1`
+case &quot;${gcc_version}&quot; in
+     gcc*)
+        echo &quot;$as_me:$LINENO: result: yes&quot; &gt;&amp;5
+echo &quot;${ECHO_T}yes&quot; &gt;&amp;6
+        CXXFLAGS=&quot;$CXXFLAGS -Wno-deprecated&quot;
+        CPPFLAGS=&quot;$CPPFLAGS -Wno-deprecated&quot;
+        ;;
+
+     *)
+        echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+        ;;
+esac
+
+echo &quot;$as_me:$LINENO: checking whether compiler accepts -Wmissing-declarations and -Wnested-externs&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether compiler accepts -Wmissing-declarations and -Wnested-externs... $ECHO_C&quot; &gt;&amp;6
+gcc_version=`${CC} --version | grep 'gcc (GCC) [3-4].' | head -n 1`
+case &quot;${gcc_version}&quot; in
+     gcc*)
+        echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+        ;;
+
+     *)
+        echo &quot;$as_me:$LINENO: result: yes&quot; &gt;&amp;5
+echo &quot;${ECHO_T}yes&quot; &gt;&amp;6
+        CXXFLAGS=&quot;$CXXFLAGS -Wmissing-declarations -Wnested-externs&quot;
+        CPPFLAGS=&quot;$CPPFLAGS -Wmissing-declarations -Wnested-externs&quot;
+        ;;
+esac
+
+
 ac_aux_dir=
 for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
   if test -f $ac_dir/install-sh; then
@@ -4306,22 +4432,21 @@ fi
 fi
 
 
+
 ac_help=&quot;$ac_help
-  --with-symbols          add the -g flag to produce the debug symbols
-  --with-info             enable basic log output to trace the program
+  --with-symbols          give -g flag to compiler to produce debug symbols
+  --with-info             define INFO at compile time to get basic log output
   --with-valgrind         clean up allocated buffers to avoid valgrind warnings
   --with-version          use this version for produced libraries
 
-  --with-static-png       enable static linking of PNG library
-  --with-static-jpeg      enable static linking of JPEG library&quot;
-
-
+  --with-static-jpeg      enable static linking of JPEG library
+  --with-static-z         enable static linking of Z library&quot;
 
 
 
 echo &quot;$as_me:$LINENO: checking for Cygwin32 environment&quot; &gt;&amp;5
 echo $ECHO_N &quot;checking for Cygwin32 environment... $ECHO_C&quot; &gt;&amp;6
-if test &quot;${nxproxy_cv_cygwin32+set}&quot; = set; then
+if test &quot;${nxconf_cv_cygwin32+set}&quot; = set; then
   echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
 else
   cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
@@ -4361,29 +4486,31 @@ if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
   ac_status=$?
   echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
   (exit $ac_status); }; }; then
-  nxproxy_cv_cygwin32=yes
+  nxconf_cv_cygwin32=yes
 else
   echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
 sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
 
-nxproxy_cv_cygwin32=no
+nxconf_cv_cygwin32=no
 fi
 rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 rm -f conftest*
 fi
-echo &quot;$as_me:$LINENO: result: $nxproxy_cv_cygwin32&quot; &gt;&amp;5
-echo &quot;${ECHO_T}$nxproxy_cv_cygwin32&quot; &gt;&amp;6
+echo &quot;$as_me:$LINENO: result: $nxconf_cv_cygwin32&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxconf_cv_cygwin32&quot; &gt;&amp;6
 CYGWIN32=
-test &quot;$nxproxy_cv_cygwin32&quot; = yes &amp;&amp; CYGWIN32=yes
+test &quot;$nxconf_cv_cygwin32&quot; = yes &amp;&amp; CYGWIN32=yes
+
+
 if test &quot;$CYGWIN32&quot; = yes; then
-    LIBS=&quot;$LIBS -mwindows -lstdc++&quot;
+    LIBS=&quot;$LIBS -lstdc++ -lcygipc -lgdi32&quot;
 fi
 
 
 
-echo &quot;$as_me:$LINENO: checking for Amd64 environment&quot; &gt;&amp;5
-echo $ECHO_N &quot;checking for Amd64 environment... $ECHO_C&quot; &gt;&amp;6
-if test &quot;${nxconf_cv_amd64+set}&quot; = set; then
+echo &quot;$as_me:$LINENO: checking for Darwin environment&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for Darwin environment... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${nxconf_cv_darwin+set}&quot; = set; then
   echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
 else
   cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
@@ -4396,7 +4523,7 @@ cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
 int
 main ()
 {
-return (__amd64__ || __x86_64__);
+return __APPLE__;
   ;
   return 0;
 }
@@ -4423,25 +4550,25 @@ if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
   ac_status=$?
   echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
   (exit $ac_status); }; }; then
-  nxconf_cv_amd64=yes
+  nxconf_cv_darwin=yes
 else
   echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
 sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
 
-nxconf_cv_amd64=no
+nxconf_cv_darwin=no
 fi
 rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 rm -f conftest*
 fi
-echo &quot;$as_me:$LINENO: result: $nxconf_cv_amd64&quot; &gt;&amp;5
-echo &quot;${ECHO_T}$nxconf_cv_amd64&quot; &gt;&amp;6
-AMD64=
-test &quot;$nxconf_cv_amd64&quot; = yes &amp;&amp; AMD64=yes
+echo &quot;$as_me:$LINENO: result: $nxconf_cv_darwin&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxconf_cv_darwin&quot; &gt;&amp;6
+DARWIN=
+test &quot;$nxconf_cv_darwin&quot; = yes &amp;&amp; DARWIN=yes
 
 
 
-echo &quot;$as_me:$LINENO: checking for SunOS environment&quot; &gt;&amp;5
-echo $ECHO_N &quot;checking for SunOS environment... $ECHO_C&quot; &gt;&amp;6
+echo &quot;$as_me:$LINENO: checking for Solaris environment&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for Solaris environment... $ECHO_C&quot; &gt;&amp;6
 if test &quot;${nxconf_cv_sun+set}&quot; = set; then
   echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
 else
@@ -4497,16 +4624,6 @@ echo &quot;${ECHO_T}$nxconf_cv_sun&quot; &gt;&amp;6
 SUN=
 test &quot;$nxconf_cv_sun&quot; = yes &amp;&amp; SUN=yes
 
-if test &quot;$SUN&quot; = yes; then
-  CFLAGS=&quot;$CFLAGS -I/usr/sfw/include&quot;
-fi
-
-if test &quot;$SUN&quot; = yes; then
-  LDFLAGS=&quot;$LDFLAGS -G -h \$(LIBLOAD) -L/usr/sfw/lib&quot;
-else
-  LDFLAGS=&quot;$LDFLAGS -shared -Wl,-soname,\$(LIBLOAD)&quot;
-fi
-
 
 
 echo &quot;$as_me:$LINENO: checking for FreeBSD environment&quot; &gt;&amp;5
@@ -4573,97 +4690,148 @@ if test &quot;$CYGWIN32&quot; != yes -a &quot;$DARWIN&quot; != yes; then
 fi
 
 
+if test &quot;$SUN&quot; = yes; then
+  LIBS=&quot;$LIBS  -L/usr/sfw/lib -lsocket &quot;
+  CXXFLAGS=&quot;$CXXFLAGS -I/usr/sfw/include&quot;
+fi
+
+
 if test &quot;$FreeBSD&quot; = yes; then
   LIBS=&quot;$LIBS  -L/usr/local/lib&quot;
   CXXFLAGS=&quot;$CXXFLAGS -I/usr/local/include&quot;
-  CFLAGS=&quot;$CFLAGS -I/usr/local/include&quot;
 fi
 
 
-if test &quot;${with_static_png}&quot; = yes; then
-  echo -e &quot;enabling static linking of PNG library&quot;
-  if test &quot;$CYGWIN32&quot; = yes; then
-    LIBS=&quot;$LIBSTATIC -static -lpng&quot;
-  else
-    if test -f &quot;/usr/lib/libpng.a&quot; ; then
-      LIBS=&quot;/usr/lib/libpng.a $LIBS&quot;
-    else
-      if test -f &quot;/usr/local/lib/libpng.a&quot; ; then
-        echo -e &quot;assuming libpng.a in /usr/local/lib&quot;
-        LIBS=&quot;/usr/local/lib/libpng.a $LIBS&quot;
-      else
-        echo -e &quot;assuming libpng.a in default linker path&quot;
-        LIBS=&quot;libpng.a $LIBS&quot;
-      fi
-    fi
-  fi
+if test &quot;$DARWIN&quot; = yes; then
+  LDFLAGS=&quot;$LDFLAGS -bundle&quot;
+elif test &quot;$SUN&quot; = yes; then
+  LDFLAGS=&quot;$LDFLAGS -G -h \$(LIBLOAD)&quot;
 else
-  echo -e &quot;enabling dynamic linking of PNG library&quot;
-  LIBS=&quot;-lpng $LIBS&quot;
+  LDFLAGS=&quot;$LDFLAGS -Wl,-soname,\$(LIBLOAD)&quot;
 fi
 
-if test &quot;${with_static_jpeg}&quot; = yes; then
-  echo -e &quot;enabling static linking of JPEG library&quot;
-  if test &quot;$CYGWIN32&quot; = yes; then
-    LIBSTATIC=&quot;$LIBS -static -ljpeg&quot;
-  else
-    if test -f &quot;/usr/lib/libjpeg.a&quot; ; then
-      LIBS=&quot;/usr/lib/libjpeg.a $LIBS&quot;
-    else
-      if test -f &quot;/usr/local/lib/libjpeg.a&quot; ; then
-        echo -e &quot;assuming libjpeg.a in /usr/local/lib&quot;
-        LIBS=&quot;/usr/local/lib/libjpeg.a $LIBS&quot;
-      else
-        echo -e &quot;assuming libjpeg.a in default linker path&quot;
-        LIBS=&quot;libjpeg.a $LIBS&quot;
-      fi
-    fi
-  fi
+
+
+echo &quot;$as_me:$LINENO: checking for in_addr_t&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for in_addr_t... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${nxconf_cv_inaddrt+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
 else
-  echo -e &quot;enabling dynamic linking of JPEG library&quot;
-  LIBS=&quot;-ljpeg $LIBS&quot;
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;netinet/in.h&gt;
+int
+main ()
+{
+in_addr_t t; t = 1; return t;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  nxconf_cv_inaddrt=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+nxconf_cv_inaddrt=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest*
+fi
+echo &quot;$as_me:$LINENO: result: $nxconf_cv_inaddrt&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxconf_cv_inaddrt&quot; &gt;&amp;6
+INADDRT=
+test &quot;$nxconf_cv_inaddrt&quot; = yes &amp;&amp; INADDRT=yes
+
+
+if test &quot;$INADDRT&quot; != yes ; then
+  echo -e &quot;using unsigned int for type in_addr_t&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DIN_ADDR_T=unsigned&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DIN_ADDR_T=unsigned&quot;
+else
+  CXXFLAGS=&quot;$CXXFLAGS -DIN_ADDR_T=in_addr_t&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DIN_ADDR_T=in_addr_t&quot;
+fi
+
+
+
+
+if test &quot;${with_version}&quot; = yes; then
+  VERSION=${ac_option}
+else
+  VERSION=`cat VERSION`
+fi
+echo -e &quot;compiling version ${VERSION}&quot;
+
+LIBVERSION=`echo ${VERSION} | cut -d '.' -f 1`
+
+CXXFLAGS=&quot;$CXXFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+CPPFLAGS=&quot;$CPPFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+
+
+if test &quot;$DARWIN&quot; = yes ; then
+  LIBS=&quot;$LIBS $LIBSTATIC $LIBSHARED&quot;
+elif test &quot;$SUN&quot; = yes ; then
+  LIBS=&quot;$LIBS $LIBSTATIC $LIBSHARED&quot;
+else
+  LIBS=&quot;$LIBS $LIBSTATIC -shared $LIBSHARED&quot;
 fi
 
+
 if test &quot;${with_symbols}&quot; = yes; then
   echo -e &quot;enabling production of debug symbols&quot;
   CXXFLAGS=&quot;-g $CXXFLAGS&quot;
-  CFLAGS=&quot;-g $CFLAGS&quot;
+  CPPFLAGS=&quot;-g $CPPFLAGS&quot;
 else
   echo -e &quot;disabling production of debug symbols&quot;
 fi
 
+
 if test &quot;${with_info}&quot; = yes; then
   echo -e &quot;enabling info output in the log file&quot;
   CXXFLAGS=&quot;$CXXFLAGS -DINFO&quot;
-  CFLAGS=&quot;$CFLAGS -DINFO&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DINFO&quot;
 else
   echo -e &quot;disabling info output in the log file&quot;
 fi
 
+
 if test &quot;${with_valgrind}&quot; = yes; then
   echo -e &quot;enabling valgrind memory checker workarounds&quot;
   CXXFLAGS=&quot;$CXXFLAGS -DVALGRIND&quot;
-  CFLAGS=&quot;$CFLAGS -DVALGRIND&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DVALGRIND&quot;
 else
   echo -e &quot;disabling valgrind memory checker workarounds&quot;
 fi
 
 
 
-if test &quot;${with_version}&quot; = yes; then
-  VERSION=${ac_option}
-else
-  VERSION=`cat VERSION`
-fi
-echo -e &quot;compiling version ${VERSION}&quot;
-
-LIBVERSION=`echo ${VERSION} | cut -d '.' -f 1`
-
-CXXFLAGS=&quot;$CXXFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
-CFLAGS=&quot;$CFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
-
-
-
 
 if test -x &quot;../nx-X11/config/makedepend/makedepend&quot; ; then
   MAKEDEPEND=../nx-X11/config/makedepend/makedepend
@@ -4674,20 +4842,11 @@ else
     if test -x &quot;/usr/openwin/bin/makedepend&quot; ; then
       MAKEDEPEND=/usr/openwin/bin/makedepend
     else
-      MAKEDEPEND=/usr/bin/makedepend
+      MAKEDEPEND=makedepend
     fi
   fi
 fi
 
-
-
-
-if test &quot;$CYGWIN32&quot; = yes; then
-    ALL=&quot;\$(LIBCYGARCHIVE) \$(LIBCYGSHARED) \$(LIBARCHIVE)&quot;
-else
-    ALL=&quot;\$(LIBFULL) \$(LIBLOAD) \$(LIBSHARED) \$(LIBARCHIVE)&quot;
-fi
-
           ac_config_files=&quot;$ac_config_files Makefile&quot;
 cat &gt;confcache &lt;&lt;\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -5324,6 +5483,8 @@ <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at ECHO_C</A>@,$ECHO_C,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at ECHO_N</A>@,$ECHO_N,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at ECHO_T</A>@,$ECHO_T,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at LIBS</A>@,$LIBS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at armcxx</A>@,$armcxx,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at armcc</A>@,$armcc,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at CXX</A>@,$CXX,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at CXXFLAGS</A>@,$CXXFLAGS,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at LDFLAGS</A>@,$LDFLAGS,;t t
@@ -5345,7 +5506,6 @@ <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at X_EXTRA_LIBS</A>@,$X_EXTRA_LIBS,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at LIBVERSION</A>@,$LIBVERSION,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at VERSION</A>@,$VERSION,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at MAKEDEPEND</A>@,$MAKEDEPEND,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">-s, at ALL</A>@,$ALL,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at LIBOBJS</A>@,$LIBOBJS,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">s, at LTLIBOBJS</A>@,$LTLIBOBJS,;t t
 CEOF
diff --git a/nxcompshad/configure.in b/nxcompshad/configure.in
new file mode 100644
index 0000000..3f16ee9
--- /dev/null
+++ b/nxcompshad/configure.in
@@ -0,0 +1,287 @@
+dnl Process this file with autoconf to produce a configure script.
+
+dnl Prolog
+
+AC_INIT(Shadow.h)
+AC_PREREQ(2.13)
+
+dnl Reset default compilation flags.
+
+CXXFLAGS=&quot;-O3&quot;
+CPPFLAGS=&quot;-O3&quot;
+
+dnl Reset default linking directives.
+
+LIBSTATIC=&quot;&quot;
+LIBSHARED=&quot;&quot;
+
+dnl Prefer headers and libraries from nx-X11, if present.
+
+if test -d &quot;../nx-X11/exports/include&quot; ; then
+    CXXFLAGS=&quot;$CXXFLAGS -I../nx-X11/exports/include&quot;
+    LIBS=&quot;$LIBS -L../nx-X11/exports/lib&quot;
+fi
+
+dnl Check whether --with-ipaq was given.
+
+if test &quot;${with_ipaq}&quot; = yes; then
+  echo -e &quot;enabling IPAQ configuration&quot;
+  CXX=&quot;arm-linux-c++&quot;
+  CC=&quot;arm-linux-gcc&quot;
+  unset ac_cv_prog_armcxx
+  unset ac_cv_prog_armcc
+  unset ac_cv_prog_CXXCPP
+  AC_CHECK_PROG([armcxx],[&quot;$CXX&quot;],[yes],[no],[$PATH])
+  AC_CHECK_PROG([armcc],[&quot;$CC&quot;],[yes],[no],[$PATH])
+  if test $armcxx = &quot;yes&quot; &amp;&amp; test $armcc = &quot;yes&quot; ; then
+    ac_cv_prog_CXX=&quot;$CXX&quot;
+    ac_cv_prog_CC=&quot;$CC&quot;
+  else
+    AC_MSG_ERROR(installation or configuration problem: I cannot find compiler for arm-linux)
+  fi
+else
+  unset ac_cv_prog_CXX
+  unset ac_cv_prog_CC
+  unset ac_cv_prog_CXXCPP
+fi  
+
+dnl Check for programs.
+
+AC_PROG_CXX
+AC_PROG_CC
+AC_LANG_CPLUSPLUS
+
+dnl Check whether option -Wno-deprecated
+dnl is needed by GCC compiler.
+
+AC_MSG_CHECKING([whether compiler needs -Wno-deprecated])
+gcc_version=`${CC} --version | grep 'gcc (GCC) [[3-4]].' | head -n 1`
+case &quot;${gcc_version}&quot; in
+     gcc*)
+        AC_MSG_RESULT([yes])
+        CXXFLAGS=&quot;$CXXFLAGS -Wno-deprecated&quot;
+        CPPFLAGS=&quot;$CPPFLAGS -Wno-deprecated&quot;
+        ;;
+
+     *)
+        AC_MSG_RESULT([no])
+        ;;
+esac
+
+AC_MSG_CHECKING([whether compiler accepts -Wmissing-declarations and -Wnested-externs])
+gcc_version=`${CC} --version | grep 'gcc (GCC) [[3-4]].' | head -n 1`
+case &quot;${gcc_version}&quot; in
+     gcc*)
+        AC_MSG_RESULT([no])
+        ;;
+
+     *)
+        AC_MSG_RESULT([yes])
+        CXXFLAGS=&quot;$CXXFLAGS -Wmissing-declarations -Wnested-externs&quot;
+        CPPFLAGS=&quot;$CPPFLAGS -Wmissing-declarations -Wnested-externs&quot;
+        ;;
+esac
+
+dnl Check for BSD compatible install.
+
+AC_PROG_INSTALL
+
+dnl Check for extra header files.
+
+AC_PATH_XTRA
+
+dnl Custom addition.
+
+ac_help=&quot;$ac_help
+  --with-symbols          give -g flag to compiler to produce debug symbols
+  --with-info             define INFO at compile time to get basic log output
+  --with-valgrind         clean up allocated buffers to avoid valgrind warnings
+  --with-version          use this version for produced libraries
+
+  --with-static-jpeg      enable static linking of JPEG library
+  --with-static-z         enable static linking of Z library&quot;
+
+dnl Check to see if we're running under Cygwin32.
+
+AC_DEFUN(nxconf_CYGWIN32,
+[AC_CACHE_CHECK(for Cygwin32 environment, nxconf_cv_cygwin32,
+[AC_TRY_COMPILE(,[return __CYGWIN32__;],
+nxconf_cv_cygwin32=yes, nxconf_cv_cygwin32=no)
+rm -f conftest*])
+CYGWIN32=
+test &quot;$nxconf_cv_cygwin32&quot; = yes &amp;&amp; CYGWIN32=yes])
+nxconf_CYGWIN32
+
+dnl Cygwin32 requires the stdc++ library explicitly linked.
+
+if test &quot;$CYGWIN32&quot; = yes; then
+    LIBS=&quot;$LIBS -lstdc++ -lcygipc -lgdi32&quot;
+fi
+
+dnl Check for Darwin environment.
+
+AC_DEFUN(nxconf_DARWIN,
+[AC_CACHE_CHECK(for Darwin environment, nxconf_cv_darwin,
+[AC_TRY_COMPILE(,[return __APPLE__;],
+nxconf_cv_darwin=yes, nxconf_cv_darwin=no)
+rm -f conftest*])
+DARWIN=
+test &quot;$nxconf_cv_darwin&quot; = yes &amp;&amp; DARWIN=yes])
+nxconf_DARWIN
+
+dnl Check to see if we're running under Solaris.
+
+AC_DEFUN(nxconf_SUN,
+[AC_CACHE_CHECK(for Solaris environment, nxconf_cv_sun,
+[AC_TRY_COMPILE(,[return __sun;],
+nxconf_cv_sun=yes, nxconf_cv_sun=no)
+rm -f conftest*])
+SUN=
+test &quot;$nxconf_cv_sun&quot; = yes &amp;&amp; SUN=yes])
+nxconf_SUN
+
+dnl Check to see if we're running under FreeBSD.
+
+AC_DEFUN(nxconf_FreeBSD,
+[AC_CACHE_CHECK(for FreeBSD environment, nxconf_cv_freebsd,
+[AC_TRY_COMPILE(,[return __FreeBSD__;],
+nxconf_cv_freebsd=yes, nxconf_cv_freebsd=no)
+rm -f conftest*])
+FreeBSD=
+test &quot;$nxconf_cv_freebsd&quot; = yes &amp;&amp; FreeBSD=yes])
+nxconf_FreeBSD
+
+dnl Build PIC libraries.
+
+if test &quot;$CYGWIN32&quot; != yes -a &quot;$DARWIN&quot; != yes; then
+  CXXFLAGS=&quot;$CXXFLAGS -fPIC&quot;
+  CFLAGS=&quot;$CFLAGS -fPIC&quot;
+fi
+
+dnl Solaris requires the socket and gcc_s libs explicitly linked.
+dnl Note also that headers from default /usr/openwin/include/X11
+dnl cause a warning due to pragma in Xmd.h.
+
+if test &quot;$SUN&quot; = yes; then
+  LIBS=&quot;$LIBS  -L/usr/sfw/lib -lsocket &quot;
+  CXXFLAGS=&quot;$CXXFLAGS -I/usr/sfw/include&quot;
+fi
+
+dnl On FreeBSD search libraries and includes under /usr/local.
+
+if test &quot;$FreeBSD&quot; = yes; then
+  LIBS=&quot;$LIBS  -L/usr/local/lib&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -I/usr/local/include&quot;
+fi
+
+dnl Under Darwin we don't have support for -soname option and
+dnl we need the -bundle flag. Under Solaris, instead, we need
+dnl the options -G -h.
+
+if test &quot;$DARWIN&quot; = yes; then
+  LDFLAGS=&quot;$LDFLAGS -bundle&quot;
+elif test &quot;$SUN&quot; = yes; then
+  LDFLAGS=&quot;$LDFLAGS -G -h \$(LIBLOAD)&quot;
+else
+  LDFLAGS=&quot;$LDFLAGS -Wl,-soname,\$(LIBLOAD)&quot;
+fi
+
+dnl Check to see if in_addr_t is defined.
+dnl Could use a specific configure test.
+
+AC_DEFUN(nxconf_INADDRT,
+[AC_CACHE_CHECK(for in_addr_t, nxconf_cv_inaddrt,
+[AC_TRY_COMPILE([#include &lt;netinet/in.h&gt;],[in_addr_t t; t = 1; return t;],
+nxconf_cv_inaddrt=yes, nxconf_cv_inaddrt=no)
+rm -f conftest*])
+INADDRT=
+test &quot;$nxconf_cv_inaddrt&quot; = yes &amp;&amp; INADDRT=yes])
+nxconf_INADDRT
+
+dnl If in_addr_t is not defined use unsigned int.
+
+if test &quot;$INADDRT&quot; != yes ; then
+  echo -e &quot;using unsigned int for type in_addr_t&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DIN_ADDR_T=unsigned&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DIN_ADDR_T=unsigned&quot;
+else
+  CXXFLAGS=&quot;$CXXFLAGS -DIN_ADDR_T=in_addr_t&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DIN_ADDR_T=in_addr_t&quot;
+fi
+
+dnl Check whether --with-version was given.
+
+AC_SUBST(LIBVERSION)
+AC_SUBST(VERSION)
+if test &quot;${with_version}&quot; = yes; then
+  VERSION=${ac_option}
+else
+  VERSION=`cat VERSION`
+fi
+echo -e &quot;compiling version ${VERSION}&quot;
+
+LIBVERSION=`echo ${VERSION} | cut -d '.' -f 1`
+
+CXXFLAGS=&quot;$CXXFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+CPPFLAGS=&quot;$CPPFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+
+dnl Finally compose the LIB variable.
+
+if test &quot;$DARWIN&quot; = yes ; then
+  LIBS=&quot;$LIBS $LIBSTATIC $LIBSHARED&quot;
+elif test &quot;$SUN&quot; = yes ; then
+  LIBS=&quot;$LIBS $LIBSTATIC $LIBSHARED&quot;
+else
+  LIBS=&quot;$LIBS $LIBSTATIC -shared $LIBSHARED&quot;
+fi
+
+dnl Check whether --with-symbols or --without-symbols was
+dnl given and set the required optimization level.
+
+if test &quot;${with_symbols}&quot; = yes; then
+  echo -e &quot;enabling production of debug symbols&quot;
+  CXXFLAGS=&quot;-g $CXXFLAGS&quot;
+  CPPFLAGS=&quot;-g $CPPFLAGS&quot;
+else
+  echo -e &quot;disabling production of debug symbols&quot;
+fi
+
+dnl Check whether --with-info or --without-info was given.
+
+if test &quot;${with_info}&quot; = yes; then
+  echo -e &quot;enabling info output in the log file&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DINFO&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DINFO&quot;
+else
+  echo -e &quot;disabling info output in the log file&quot;
+fi
+
+dnl Check whether --with-valgrind or --without-valgrind was given.
+
+if test &quot;${with_valgrind}&quot; = yes; then
+  echo -e &quot;enabling valgrind memory checker workarounds&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DVALGRIND&quot;
+  CPPFLAGS=&quot;$CPPFLAGS -DVALGRIND&quot;
+else
+  echo -e &quot;disabling valgrind memory checker workarounds&quot;
+fi
+
+dnl Find makedepend somewhere.
+
+AC_SUBST(MAKEDEPEND)
+
+if test -x &quot;../nx-X11/config/makedepend/makedepend&quot; ; then
+  MAKEDEPEND=../nx-X11/config/makedepend/makedepend
+else
+  if test -x &quot;/usr/X11R6/bin/makedepend&quot; ; then
+    MAKEDEPEND=/usr/X11R6/bin/makedepend
+  else
+    if test -x &quot;/usr/openwin/bin/makedepend&quot; ; then
+      MAKEDEPEND=/usr/openwin/bin/makedepend
+    else
+      MAKEDEPEND=makedepend
+    fi
+  fi
+fi
+
+AC_OUTPUT(Makefile)
diff --git a/nxcompext/install-sh b/nxcompshad/install-sh
similarity index 100%
rename from nxcompext/install-sh
rename to nxcompshad/install-sh


hooks/post-receive
-- 
nx-libs.git (NX (redistributed))

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;nx-libs.git&quot; (NX (redistributed)).

</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011737.html">[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxcompext/3.3.0-2
</A></li>
	<LI>Next message: <A HREF="011699.html">[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxproxy/3.1.0-2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11778">[ date ]</a>
              <a href="thread.html#11778">[ thread ]</a>
              <a href="subject.html#11778">[ subject ]</a>
              <a href="author.html#11778">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2Go-commits
mailing list</a><br>
</body></html>
