<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-10
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2013-August/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-main%20%28branch%29%20updated%3A%0A%09nxagent/3.2.0-10&In-Reply-To=%3C20130830142200.67EBA5DB22%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011323.html">
   <LINK REL="Next"  HREF="011326.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-10</H1>
    <B>X2Go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-main%20%28branch%29%20updated%3A%0A%09nxagent/3.2.0-10&In-Reply-To=%3C20130830142200.67EBA5DB22%40ymir%3E"
       TITLE="[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-10">git-admin at x2go.org
       </A><BR>
    <I>Fri Aug 30 16:22:00 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="011323.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-6
</A></li>
        <LI>Next message: <A HREF="011326.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-7
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11324">[ date ]</a>
              <a href="thread.html#11324">[ thread ]</a>
              <a href="subject.html#11324">[ subject ]</a>
              <a href="author.html#11324">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, build-main has been updated
       via  1c25e92b9ea5811d8ab9c2bfdc0dcb2e4d21bd0a (commit)
      from  266b5554943baffafbf1d574f567283cc9792278 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
-----------------------------------------------------------------------

Summary of changes:
 nx-X11/programs/Xserver/hw/nxagent/Args.c          |   12 +-
 nx-X11/programs/Xserver/hw/nxagent/Atoms.c         |    1 +
 nx-X11/programs/Xserver/hw/nxagent/Atoms.h         |    2 +-
 nx-X11/programs/Xserver/hw/nxagent/CHANGELOG       |  117 ++++++++++-
 .../hw/nxagent/{CHANGELOG =&gt; CHANGELOG.orig}       |  109 ++++++++++-
 nx-X11/programs/Xserver/hw/nxagent/Clipboard.c     |   64 +++++-
 nx-X11/programs/Xserver/hw/nxagent/Clipboard.h     |   15 ++
 nx-X11/programs/Xserver/hw/nxagent/Display.c       |   27 ++-
 nx-X11/programs/Xserver/hw/nxagent/Drawable.c      |   22 ++-
 nx-X11/programs/Xserver/hw/nxagent/Events.c        |  204 ++++++++++++++------
 nx-X11/programs/Xserver/hw/nxagent/Events.h        |    1 +
 nx-X11/programs/Xserver/hw/nxagent/Font.c          |  155 ++++++++++++++-
 nx-X11/programs/Xserver/hw/nxagent/GCOps.c         |   18 ++
 nx-X11/programs/Xserver/hw/nxagent/Handlers.c      |   15 ++
 nx-X11/programs/Xserver/hw/nxagent/Image.c         |    9 +-
 nx-X11/programs/Xserver/hw/nxagent/Init.c          |    9 +-
 nx-X11/programs/Xserver/hw/nxagent/Keyboard.c      |    4 +-
 nx-X11/programs/Xserver/hw/nxagent/Literals.h      |    7 +
 nx-X11/programs/Xserver/hw/nxagent/Reconnect.c     |   22 ++-
 nx-X11/programs/Xserver/hw/nxagent/Screen.c        |   56 +++++-
 nx-X11/programs/Xserver/hw/nxagent/Trap.c          |   15 ++
 nx-X11/programs/Xserver/hw/nxagent/Trap.h          |   16 ++
 nx-X11/programs/Xserver/hw/nxagent/X/NXdispatch.c  |    3 +-
 .../Xserver/hw/nxagent/X/NXdispatch.c.NX.original  |    3 +-
 nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c     |   19 +-
 .../Xserver/hw/nxagent/X/NXglyph.c.NX.original     |   19 +-
 .../Xserver/hw/nxagent/X/NXglyph.c.X.original      |   14 +-
 nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c    |   18 +-
 .../Xserver/hw/nxagent/X/NXrender.c.NX.original    |   18 +-
 .../Xserver/hw/nxagent/X/NXrender.c.X.original     |   18 +-
 nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c  |   77 ++++++++
 .../Xserver/hw/nxagent/X/NXresource.c.NX.original  |   77 ++++++++
 nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c       |   13 +-
 .../Xserver/hw/nxagent/X/NXshm.c.NX.original       |   13 +-
 .../Xserver/hw/nxagent/X/NXshm.c.X.original        |   13 +-
 nx-X11/programs/Xserver/hw/nxagent/X/NXwindow.c    |   21 +-
 .../Xserver/hw/nxagent/X/NXwindow.c.NX.original    |   21 +-
 37 files changed, 1090 insertions(+), 157 deletions(-)
 copy nx-X11/programs/Xserver/hw/nxagent/{CHANGELOG =&gt; CHANGELOG.orig} (98%)

The diff of changes is:
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Args.c b/nx-X11/programs/Xserver/hw/nxagent/Args.c
index 5b33627..c74bc3f 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Args.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Args.c
@@ -2080,8 +2080,8 @@ void nxagentSetDeferLevel()
 
       deferTimeout = 200;
 
-      tileWidth  = 65536;
-      tileHeight = 65536;
+      tileWidth  = 4096;
+      tileHeight = 4096;
 
       break;
     }
@@ -2091,8 +2091,8 @@ void nxagentSetDeferLevel()
 
       deferTimeout = 200;
 
-      tileWidth  = 65536;
-      tileHeight = 65536;
+      tileWidth  = 4096;
+      tileHeight = 4096;
 
       break;
     }
@@ -2103,8 +2103,8 @@ void nxagentSetDeferLevel()
 
       deferTimeout = 200;
 
-      tileWidth  = 65536;
-      tileHeight = 65536;
+      tileWidth  = 4096;
+      tileHeight = 4096;
 
       break;
     }
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Atoms.c b/nx-X11/programs/Xserver/hw/nxagent/Atoms.c
index 1f412fd..ac26646 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Atoms.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Atoms.c
@@ -78,6 +78,7 @@ static char *nxagentAtomNames[NXAGENT_NUMBER_OF_ATOMS + 1] =
   &quot;NXDARWIN&quot;,             /* 9  */
   &quot;CLIPBOARD&quot;,            /* 10 */
   &quot;TIMESTAMP&quot;,            /* 11 */
+  &quot;UTF8_STRING&quot;,          /* 12 */
   NULL,
   NULL
 };
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Atoms.h b/nx-X11/programs/Xserver/hw/nxagent/Atoms.h
index 0dd75de..17b2d8f 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Atoms.h
+++ b/nx-X11/programs/Xserver/hw/nxagent/Atoms.h
@@ -22,7 +22,7 @@
 #include &quot;../../include/window.h&quot;
 #include &quot;screenint.h&quot;
 
-#define NXAGENT_NUMBER_OF_ATOMS  13
+#define NXAGENT_NUMBER_OF_ATOMS  14
 
 extern Atom nxagentAtoms[NXAGENT_NUMBER_OF_ATOMS];
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG b/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG
index 285ecb6..1c10208 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG
+++ b/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG
@@ -1,5 +1,116 @@
 ChangeLog:
 
+nxagent-3.2.0-10
+
+- Extended fix for TR07F02091 to include font names having zero in
+  fields RESOLUTION_X and RESOLUTION_Y.
+
+nxagent-3.2.0-9
+
+- Fixed TR07F02091. Scalable fonts were not correctly listed among
+  available fonts.
+
+- Fixed TR06F02080. Use the corrupted area extents as maximum size of
+  the image data.
+
+nxagent-3.2.0-8
+
+- Fixed TR07F02082. The agent server could be unable to init core
+  keyboard on 64 bit systems.
+
+nxagent-3.2.0-7
+
+- Imported patch fixing issues from  X.Org security advisory, June
+  11th, 2008: Multiple vulnerabilities in X server extensions. CVE
+  IDs: CVE-2008-1377, CVE-2008-1379, CVE-2008-2360, CVE-2008-2361,
+  CVE-2008-2362.
+
+nxagent-3.2.0-6
+
+- Fixed TR05F02063. Ignore ReparentNotify events for non-rootless
+  sessions.
+
+- Fixed TR06F02068. Try to pack images only if format is ZPixmap.
+
+- Don't require reparent on close of NX window.
+
+nxagent-3.2.0-5
+
+- Fixed TR04F02044. Restored the original MakeRootTile() function in
+  order to create the root window background pixmap.
+
+- Fixed TR04F02041. Gnome panels stayed on top of the NX session win-
+  dow with desktops running Compiz. This fix provides a solution for
+  the Fullscreen mode.
+
+- Improved for the shadow session the handling of master session win-
+  dow resize.
+
+nxagent-3.2.0-4
+
+- Fixed TR10D01535. The agent window is not minimized anymore when
+  pointer leaves.
+
+- Changes aimed to avoid possible type mismatch in XDisplay struct
+  on 64 bit architectures.
+
+nxagent-3.2.0-3
+
+- Fixed a build issue on Solaris.
+
+nxagent-3.2.0-2
+
+- Code clean up. Moved a variable definition to the beginnning of a
+  block.
+
+nxagent-3.2.0-1
+
+- Opened the 3.2.0 branch based on nxagent-3.1.0-9.
+
+nxagent-3.1.0-9
+
+- Fixed TR03F02025. German umlauts couldn't be pasted into a remote
+  Windows application. Now also the UTF8_STRING target is available
+  for ConvertSelection requests.
+
+- Fixed TR03F02031. Moved SetScreenSaverTimer() call in order to avoid
+  undesired reset of the auto-disconnect timeout when a screen saver
+  turns on.
+
+nxagent-3.1.0-8
+
+- Added reference to fixed TR02F02007 and TR07E01762 in the CHANGELOG.
+
+- Set the GC trap before calling fbPolySegment.
+
+- Fixed TR09E01863. A flag is set if a resource has been added or fre-
+  ed and it is checked in FindClientResourcesByType().
+
+- Added void entries to nxagentRequestLiteral vector in order to avoid
+  a wrong string is printed to the output for NoOperation request.
+
+- Fixed TR11E01948. Now keyboard status is initialized again after
+  the NX session is reconnected. This avoids CAPS LOCK and NUM LOCK
+  synchronization problems.
+
+- Added nxagentXkbCapsTrap and nxagentXkbNumTrap to avoid CAPS LOCK
+  and NUM LOCK synchronization problems when CAPS LOCK or NUM LOCK is
+  the first key to be pressed in the NX session.
+
+- Corrected subSize variable initialization in nxagentRealizeImage().
+
+- Fixed various memory leaks.
+
+- Fixed TR11E01950. Copy and paste via edit menu didn't work for some
+  applications.
+
+- Corrected property type in nxagentRequestSelection(). Some external
+  applications didn't enable their paste button when nxagent was the
+  owner of the CLIPBOARD selection.
+
+- Added struct to save values queried by XQueryExtension for XFixes
+  extension.
+
 nxagent-3.1.0-7
 
 - Imported patch fixing issues from  X.Org security advisory, January
@@ -7,8 +118,8 @@ nxagent-3.1.0-7
   CVE-2007-5760    CVE-2007-5958    CVE-2007-6427   CVE-2007-6428
   CVE-2007-6429    CVE-2008-0006.
 
-- Handled the case if nxagentCreateDrawableBitmap() fails to create
-  the pixmap intended to store the bitmap data.
+- Fixed TR02F02007. Handled the case if nxagentCreateDrawableBitmap()
+  fails to create the pixmap intended to store the bitmap data.
 
 nxagent-3.1.0-6
 
@@ -81,7 +192,7 @@ nxagent-3.0.0-90
 - Fixed TR11E01930. If the defer level is set by means of the command
   line, the DeferLevel option is not reset while resuming the session.
 
-- Fixed string comparison in the font replacement routine.
+- Fixed TR07E01762. Problem in comparison of font names.
 
 - Printed the new geometry in the session log when the agent screen is
   resized.
diff --git a/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG b/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG.orig
similarity index 98%
copy from nx-X11/programs/Xserver/hw/nxagent/CHANGELOG
copy to nx-X11/programs/Xserver/hw/nxagent/CHANGELOG.orig
index 285ecb6..539a7b8 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG
+++ b/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG.orig
@@ -1,5 +1,108 @@
 ChangeLog:
 
+nxagent-3.2.0-8-MAR1
+
+- Fixed TR07F02091. Scalable fonts were not correctly listed among
+  available fonts.
+
+nxagent-3.2.0-8
+
+- Fixed TR07F02082. The agent server could be unable to init core
+  keyboard on 64 bit systems.
+
+nxagent-3.2.0-7
+
+- Imported patch fixing issues from  X.Org security advisory, June
+  11th, 2008: Multiple vulnerabilities in X server extensions. CVE
+  IDs: CVE-2008-1377, CVE-2008-1379, CVE-2008-2360, CVE-2008-2361,
+  CVE-2008-2362.
+
+nxagent-3.2.0-6
+
+- Fixed TR05F02063. Ignore ReparentNotify events for non-rootless
+  sessions.
+
+- Fixed TR06F02068. Try to pack images only if format is ZPixmap.
+
+- Don't require reparent on close of NX window.
+
+nxagent-3.2.0-5
+
+- Fixed TR04F02044. Restored the original MakeRootTile() function in
+  order to create the root window background pixmap.
+
+- Fixed TR04F02041. Gnome panels stayed on top of the NX session win-
+  dow with desktops running Compiz. This fix provides a solution for
+  the Fullscreen mode.
+
+- Improved for the shadow session the handling of master session win-
+  dow resize.
+
+nxagent-3.2.0-4
+
+- Fixed TR10D01535. The agent window is not minimized anymore when
+  pointer leaves.
+
+- Changes aimed to avoid possible type mismatch in XDisplay struct
+  on 64 bit architectures.
+
+nxagent-3.2.0-3
+
+- Fixed a build issue on Solaris.
+
+nxagent-3.2.0-2
+
+- Code clean up. Moved a variable definition to the beginnning of a
+  block.
+
+nxagent-3.2.0-1
+
+- Opened the 3.2.0 branch based on nxagent-3.1.0-9.
+
+nxagent-3.1.0-9
+
+- Fixed TR03F02025. German umlauts couldn't be pasted into a remote
+  Windows application. Now also the UTF8_STRING target is available
+  for ConvertSelection requests.
+
+- Fixed TR03F02031. Moved SetScreenSaverTimer() call in order to avoid
+  undesired reset of the auto-disconnect timeout when a screen saver
+  turns on.
+
+nxagent-3.1.0-8
+
+- Added reference to fixed TR02F02007 and TR07E01762 in the CHANGELOG.
+
+- Set the GC trap before calling fbPolySegment.
+
+- Fixed TR09E01863. A flag is set if a resource has been added or fre-
+  ed and it is checked in FindClientResourcesByType().
+
+- Added void entries to nxagentRequestLiteral vector in order to avoid
+  a wrong string is printed to the output for NoOperation request.
+
+- Fixed TR11E01948. Now keyboard status is initialized again after
+  the NX session is reconnected. This avoids CAPS LOCK and NUM LOCK
+  synchronization problems.
+
+- Added nxagentXkbCapsTrap and nxagentXkbNumTrap to avoid CAPS LOCK
+  and NUM LOCK synchronization problems when CAPS LOCK or NUM LOCK is
+  the first key to be pressed in the NX session.
+
+- Corrected subSize variable initialization in nxagentRealizeImage().
+
+- Fixed various memory leaks.
+
+- Fixed TR11E01950. Copy and paste via edit menu didn't work for some
+  applications.
+
+- Corrected property type in nxagentRequestSelection(). Some external
+  applications didn't enable their paste button when nxagent was the
+  owner of the CLIPBOARD selection.
+
+- Added struct to save values queried by XQueryExtension for XFixes
+  extension.
+
 nxagent-3.1.0-7
 
 - Imported patch fixing issues from  X.Org security advisory, January
@@ -7,8 +110,8 @@ nxagent-3.1.0-7
   CVE-2007-5760    CVE-2007-5958    CVE-2007-6427   CVE-2007-6428
   CVE-2007-6429    CVE-2008-0006.
 
-- Handled the case if nxagentCreateDrawableBitmap() fails to create
-  the pixmap intended to store the bitmap data.
+- Fixed TR02F02007. Handled the case if nxagentCreateDrawableBitmap()
+  fails to create the pixmap intended to store the bitmap data.
 
 nxagent-3.1.0-6
 
@@ -81,7 +184,7 @@ nxagent-3.0.0-90
 - Fixed TR11E01930. If the defer level is set by means of the command
   line, the DeferLevel option is not reset while resuming the session.
 
-- Fixed string comparison in the font replacement routine.
+- Fixed TR07E01762. Problem in comparison of font names.
 
 - Printed the new geometry in the session log when the agent screen is
   resized.
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Clipboard.c b/nx-X11/programs/Xserver/hw/nxagent/Clipboard.c
index 4d8f3f6..a575cab 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Clipboard.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Clipboard.c
@@ -31,6 +31,10 @@
 #include &quot;Rootless.h&quot;
 #include &quot;Clipboard.h&quot;
 
+#include &quot;gcstruct.h&quot;
+#include &quot;xfixeswire.h&quot;
+#include &lt;X11/extensions/Xfixes.h&gt;
+
 /*
  * Use asyncronous get property replies.
  */
@@ -115,15 +119,24 @@ static Time   lastServerTime;
 
 static Atom serverTARGETS;
 static Atom serverTEXT;
+static Atom serverUTF8_STRING;
 static Atom clientTARGETS;
 static Atom clientTEXT;
 static Atom clientCOMPOUND_TEXT;
+static Atom clientUTF8_STRING;
 
 static char szAgentTARGETS[] = &quot;TARGETS&quot;;
 static char szAgentTEXT[] = &quot;TEXT&quot;;
 static char szAgentCOMPOUND_TEXT[] = &quot;COMPOUND_TEXT&quot;;
+static char szAgentUTF8_STRING[] = &quot;UTF8_STRING&quot;;
 static char szAgentNX_CUT_BUFFER_CLIENT[] = &quot;NX_CUT_BUFFER_CLIENT&quot;;
 
+/*
+ * Save the values queried from X server.
+ */
+
+XFixesAgentInfoRec nxagentXFixesInfo = { -1, -1, -1, 0 };
+
 extern Display *nxagentDisplay;
 
 Bool nxagentValidServerTargets(Atom target);
@@ -299,7 +312,7 @@ FIXME: Do we need this?
       result = XChangeProperty (nxagentDisplay,
                                 X-&gt;xselectionrequest.requestor,
                                 X-&gt;xselectionrequest.property,
-                                X-&gt;xselectionrequest.target,
+                                XInternAtom(nxagentDisplay, &quot;ATOM&quot;, 0),
                                 sizeof(Atom)*8,
                                 PropModeReplace,
                                 (unsigned char*)&amp;xa_STRING,
@@ -1178,19 +1191,20 @@ int nxagentConvertSelection(ClientPtr client, WindowPtr pWin, Atom selection,
 
   if (target == clientTARGETS)
   {
-    Atom xa_STRING[3];
+    Atom xa_STRING[4];
     xEvent x;
 
     xa_STRING[0] = XA_STRING;
     xa_STRING[1] = clientTEXT;
     xa_STRING[2] = clientCOMPOUND_TEXT;
+    xa_STRING[3] = clientUTF8_STRING;
 
     ChangeWindowProperty(pWin,
                          property,
-                         target,
+                         MakeAtom(&quot;ATOM&quot;, 4, 1),
                          sizeof(Atom)*8,
                          PropModeReplace,
-                         3,
+                         4,
                          &amp;xa_STRING, 1);
 
     x.u.u.type = SelectionNotify;
@@ -1264,7 +1278,10 @@ int nxagentConvertSelection(ClientPtr client, WindowPtr pWin, Atom selection,
     }
   }
 
-  if ((target == clientTEXT) || (target == XA_STRING) || (target == clientCOMPOUND_TEXT))
+  if ((target == clientTEXT) ||
+          (target == XA_STRING) ||
+              (target == clientCOMPOUND_TEXT) ||
+                  (target == clientUTF8_STRING))
   {
     lastClientWindowPtr = pWin;
     lastClientStage = SelectionStageNone;
@@ -1283,8 +1300,16 @@ int nxagentConvertSelection(ClientPtr client, WindowPtr pWin, Atom selection,
       selection = lastSelectionOwner[nxagentClipboardSelection].selection;
     }
 
-    XConvertSelection(nxagentDisplay, selection, XA_STRING, serverCutProperty,
-                         serverWindow, CurrentTime);
+    if (target == clientUTF8_STRING)
+    {
+      XConvertSelection(nxagentDisplay, selection, serverUTF8_STRING, serverCutProperty,
+                           serverWindow, CurrentTime);
+    }
+    else
+    {
+      XConvertSelection(nxagentDisplay, selection, XA_STRING, serverCutProperty,
+                           serverWindow, CurrentTime);
+    }
 
     #ifdef DEBUG
     fprintf(stderr, &quot;nxagentConvertSelection: Sent XConvertSelection with target=[%s], property [%s]\n&quot;,
@@ -1465,6 +1490,7 @@ int nxagentInitClipboard(WindowPtr pWin)
   serverCutProperty = nxagentAtoms[5];  /* NX_CUT_BUFFER_SERVER */
   serverTARGETS = nxagentAtoms[6];  /* TARGETS */
   serverTEXT = nxagentAtoms[7];  /* TEXT */
+  serverUTF8_STRING = nxagentAtoms[12]; /* UTF8_STRING */
 
   if (serverCutProperty == None)
   {
@@ -1482,6 +1508,29 @@ int nxagentInitClipboard(WindowPtr pWin)
 
   XSetSelectionOwner(nxagentDisplay, serverCutProperty, iWindow, CurrentTime);
 
+  if (XQueryExtension(nxagentDisplay,
+                      &quot;XFIXES&quot;,
+                      &amp;nxagentXFixesInfo.Opcode,
+                      &amp;nxagentXFixesInfo.EventBase,
+                      &amp;nxagentXFixesInfo.ErrorBase) == 0)
+  {
+    ErrorF(&quot;Unable to initialize XFixes extension.\n&quot;);
+  }
+
+  else
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;nxagentInitClipboard: Registering for XFixesSelectionNotify events.\n&quot;);
+    #endif
+
+    XFixesSelectSelectionInput(nxagentDisplay, iWindow, nxagentClipboardAtom,
+                               XFixesSetSelectionOwnerNotifyMask |
+                               XFixesSelectionWindowDestroyNotifyMask |
+                               XFixesSelectionClientCloseNotifyMask);
+
+    nxagentXFixesInfo.Initialized = 1;
+  }
+
   if (nxagentSessionId[0])
   {
     #ifdef TEST
@@ -1525,6 +1574,7 @@ int nxagentInitClipboard(WindowPtr pWin)
     clientTARGETS = MakeAtom(szAgentTARGETS, strlen(szAgentTARGETS), True);
     clientTEXT = MakeAtom(szAgentTEXT, strlen(szAgentTEXT), True);
     clientCOMPOUND_TEXT = MakeAtom(szAgentCOMPOUND_TEXT, strlen(szAgentCOMPOUND_TEXT), True);
+    clientUTF8_STRING = MakeAtom(szAgentUTF8_STRING, strlen(szAgentUTF8_STRING), True);
 
     if (clientCutProperty == None)
     {
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Clipboard.h b/nx-X11/programs/Xserver/hw/nxagent/Clipboard.h
index e4bcbf6..912260b 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Clipboard.h
+++ b/nx-X11/programs/Xserver/hw/nxagent/Clipboard.h
@@ -19,6 +19,21 @@
 #define __Clipboard_H__
 
 /*
+ * Queried at clipboard initialization.
+ */
+
+typedef struct _XFixesAgentInfo
+{
+  int Opcode;
+  int EventBase;
+  int ErrorBase;
+  int Initialized;
+
+} XFixesAgentInfoRec;
+
+extern XFixesAgentInfoRec nxagentXFixesInfo;
+
+/*
  * Create the NX_CUT_BUFFER_CLIENT atom and
  * initialize the required property to exchange
  * data with the X server.
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Display.c b/nx-X11/programs/Xserver/hw/nxagent/Display.c
index c2e1319..9f257e5 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Display.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Display.c
@@ -123,12 +123,12 @@ static enum
 } reconnectDisplayState;
 
 int nxagentDefaultVisualIndex;
-Colormap *nxagentDefaultColormaps;
+Colormap *nxagentDefaultColormaps = NULL;
 int nxagentNumDefaultColormaps;
-int *nxagentDepths;
+int *nxagentDepths = NULL;
 int nxagentNumDepths;
-XPixmapFormatValues *nxagentPixmapFormats;
-XPixmapFormatValues *nxagentRemotePixmapFormats;
+XPixmapFormatValues *nxagentPixmapFormats = NULL;
+XPixmapFormatValues *nxagentRemotePixmapFormats = NULL;
 int nxagentNumPixmapFormats;
 int nxagentRemoteNumPixmapFormats;
 Pixel nxagentBlackPixel;
@@ -2500,6 +2500,25 @@ Bool nxagentReconnectDisplay(void *p0)
   }
 
   /*
+   * nxagentPixmapFormats and nxagentRemotePixmapFormats
+   * will be reallocated in nxagentInitPixmapFormats().
+   */
+
+  if (nxagentPixmapFormats != NULL)
+  {
+    XFree(nxagentPixmapFormats);
+
+    nxagentPixmapFormats = NULL;
+  }
+
+  if (nxagentRemotePixmapFormats != NULL)
+  {
+    XFree(nxagentRemotePixmapFormats);
+
+    nxagentRemotePixmapFormats = NULL;
+  }
+
+  /*
    * Check if all the required pixmap
    * formats are supported.
    */
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Drawable.c b/nx-X11/programs/Xserver/hw/nxagent/Drawable.c
index abc228e..2c1b07f 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Drawable.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Drawable.c
@@ -371,6 +371,7 @@ int nxagentSynchronizeRegion(DrawablePtr pDrawable, RegionPtr pRegion, unsigned
   int nBox;
   int x, y;
   int w, h;
+  int extentWidth, extentHeight;
   int tileWidth, tileHeight;
   int length, format, leftPad;
   int i;
@@ -590,8 +591,20 @@ int nxagentSynchronizeRegion(DrawablePtr pDrawable, RegionPtr pRegion, unsigned
               pDrawable -&gt; x, pDrawable -&gt; y, pDrawable -&gt; width, pDrawable -&gt; height);
   #endif
 
-  w = tileWidth  = (nxagentOption(TileWidth)  &gt; pDrawable -&gt; width  ? pDrawable -&gt; width  : nxagentOption(TileWidth));
-  h = tileHeight = (nxagentOption(TileHeight) &gt; pDrawable -&gt; height ? pDrawable -&gt; height : nxagentOption(TileHeight));
+  /*
+   * We are going to synchronize the corrupted
+   * area, so we use the corrupted extents as
+   * maximum size of the image data. It's im-
+   * portant to avoid using the drawable size,
+   * because in case of a huge window it had to
+   * result in a failed data memory allocation.
+   */
+
+  extentWidth  = clipRegion -&gt; extents.x2 - clipRegion -&gt; extents.x1;
+  extentHeight = clipRegion -&gt; extents.y2 - clipRegion -&gt; extents.y1;
+
+  w = tileWidth  = (nxagentOption(TileWidth)  &gt; extentWidth  ? extentWidth  : nxagentOption(TileWidth));
+  h = tileHeight = (nxagentOption(TileHeight) &gt; extentHeight ? extentHeight : nxagentOption(TileHeight));
 
   #ifdef DEBUG
   fprintf(stderr, &quot;nxagentSynchronizeRegion: Using tiles of size [%dx%d].\n&quot;, tileWidth, tileHeight);
@@ -2613,7 +2626,10 @@ void nxagentCreateDrawableBitmap(DrawablePtr pDrawable)
    * FIXME: A better way it would be create the bitmap
    * with the same extents of the clipRegion. This
    * requires to save the offset with respect to the
-   * drawable origin like in the backing store.
+   * drawable origin like in the backing store. This
+   * becomes particularly important when the drawable
+   * is a huge window, because the pixmap creation
+   * would fail.
    */
 
   pBitmap = nxagentCreatePixmap(pDrawable -&gt; pScreen, pDrawable -&gt; width, pDrawable -&gt; height, pDrawable -&gt; depth);
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Events.c b/nx-X11/programs/Xserver/hw/nxagent/Events.c
index d2d9f87..b37d81a 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Events.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Events.c
@@ -22,6 +22,7 @@
 #include &quot;Xproto.h&quot;
 #include &quot;screenint.h&quot;
 #include &quot;input.h&quot;
+#include &quot;dix.h&quot;
 #include &quot;misc.h&quot;
 #include &quot;scrnintstr.h&quot;
 #include &quot;windowstr.h&quot;
@@ -61,6 +62,9 @@
 #include &quot;NXvars.h&quot;
 #include &quot;NXproto.h&quot;
 
+#include &quot;xfixesproto.h&quot;
+#include &lt;X11/extensions/Xfixes.h&gt;
+
 #ifdef NXAGENT_FIXKEYS
 #include &quot;inputstr.h&quot;
 #include &quot;input.h&quot;
@@ -113,6 +117,15 @@ extern int nxagentLastClipboardClient;
 extern Bool nxagentRootlessTreesMatch(void);
 #endif
 
+extern Selection *CurrentSelections;
+extern int NumCurrentSelections;
+
+typedef union _XFixesSelectionEvent {
+        int                          type;
+        XFixesSelectionNotifyEvent   xfixesselection;
+        XEvent                       core;
+} XFixesSelectionEvent;
+
 Bool   xkbdRunning = False;
 pid_t  pidkbd;
 
@@ -742,7 +755,19 @@ void nxagentDispatchEvents(PredicateFuncPtr predicate)
 
         if (nxagentXkbState.Initialized == 0)
         {
+          if (X.xkey.keycode == 66)
+          {
+            nxagentXkbCapsTrap = 1;
+          }
+          else if (X.xkey.keycode == 77)
+          {
+            nxagentXkbNumTrap = 1;
+          }
+
           nxagentInitKeyboardState();
+
+          nxagentXkbCapsTrap = 0;
+          nxagentXkbNumTrap = 0;
         }
 
         x.u.u.type = KeyRelease;
@@ -1283,10 +1308,6 @@ void nxagentDispatchEvents(PredicateFuncPtr predicate)
                       X.xcrossing.mode == NotifyNormal)
           {
             nxagentUngrabPointerAndKeyboard(&amp;X);
-
-            pScreen = nxagentScreen(X.xcrossing.window);
-
-            minimize = True;
           }
         }
 
@@ -1610,7 +1631,7 @@ void nxagentDispatchEvents(PredicateFuncPtr predicate)
          * state modification event.
          */
 
-        if (nxagentHandleKeyboardEvent(&amp;X) == 0)
+        if (nxagentHandleKeyboardEvent(&amp;X) == 0 &amp;&amp; nxagentHandleXFixesSelectionNotify(&amp;X) == 0)
         {
           #ifdef TEST
           fprintf(stderr, &quot;nxagentDispatchEvents: WARNING! Unhandled event code [%d].\n&quot;,
@@ -1805,7 +1826,19 @@ int nxagentHandleKeyPress(XEvent *X, enum HandleEventResult *result)
 
   if (nxagentXkbState.Initialized == 0)
   {
+    if (X -&gt; xkey.keycode == 66)
+    {
+      nxagentXkbCapsTrap = 1;
+    }
+    else if (X -&gt; xkey.keycode == 77)
+    {
+      nxagentXkbNumTrap = 1;
+    }
+
     nxagentInitKeyboardState();
+
+    nxagentXkbCapsTrap = 0;
+    nxagentXkbNumTrap = 0;
   }
 
   if (nxagentCheckSpecialKeystroke(&amp;X -&gt; xkey, result))
@@ -2228,7 +2261,11 @@ int nxagentHandleClientMessageEvent(XEvent *X, enum HandleEventResult *result)
         {
           pScreen = nxagentScreen(X -&gt; xmap.window);
 
-          nxagentMaximizeToFullScreen(pScreen);
+          XMapRaised(nxagentDisplay, nxagentFullscreenWindow);
+
+          XIconifyWindow(nxagentDisplay, nxagentIconWindow,
+                             DefaultScreen(nxagentDisplay));
+
         }
 
         if (X -&gt; xclient.window == (nxagentOption(Fullscreen) ?
@@ -2273,7 +2310,10 @@ int nxagentHandleKeyboardEvent(XEvent *X)
       fprintf(stderr, &quot;nxagentHandleKeyboardEvent: Sending fake key [66] to engage capslock.\n&quot;);
       #endif
 
-      nxagentSendFakeKey(66);
+      if (!nxagentXkbCapsTrap)
+      {
+        nxagentSendFakeKey(66);
+      }
     }
 
     if (nxagentXkbState.Caps == 1 &amp;&amp;
@@ -2288,6 +2328,18 @@ int nxagentHandleKeyboardEvent(XEvent *X)
       nxagentSendFakeKey(66);
     }
 
+    if (nxagentXkbState.Caps == 0 &amp;&amp;
+          !(nxagentXkbState.Locked &amp; CAPSFLAG_IN_EVENT) &amp;&amp;
+              nxagentXkbCapsTrap)
+    {
+
+      #ifdef TEST
+      fprintf(stderr, &quot;nxagentHandleKeyboardEvent: Sending fake key [66] to release capslock.\n&quot;);
+      #endif
+
+      nxagentSendFakeKey(66);
+    }
+
     if (nxagentXkbState.Num == 0 &amp;&amp;
             (nxagentXkbState.Locked &amp; NUMFLAG_IN_EVENT))
     {
@@ -2297,7 +2349,10 @@ int nxagentHandleKeyboardEvent(XEvent *X)
       fprintf(stderr, &quot;nxagentHandleKeyboardEvent: Sending fake key [77] to engage numlock.\n&quot;);
       #endif
 
-      nxagentSendFakeKey(77);
+      if (!nxagentXkbNumTrap)
+      {
+        nxagentSendFakeKey(77);
+      }
     }
 
     if (nxagentXkbState.Num == 1 &amp;&amp;
@@ -2312,12 +2367,95 @@ int nxagentHandleKeyboardEvent(XEvent *X)
       nxagentSendFakeKey(77);
     }
 
+    if (nxagentXkbState.Num == 0 &amp;&amp;
+          !(nxagentXkbState.Locked &amp; NUMFLAG_IN_EVENT) &amp;&amp;
+              nxagentXkbNumTrap)
+    {
+
+      #ifdef TEST
+      fprintf(stderr, &quot;nxagentHandleKeyboardEvent: Sending fake key [77] to release numlock.\n&quot;);
+      #endif
+
+      nxagentSendFakeKey(77);
+    }
+
     return 1;
   }
 
   return 0;
 }
 
+int nxagentHandleXFixesSelectionNotify(XEvent *X)
+{
+  int i;
+  Atom local;
+
+  XFixesSelectionEvent *xfixesEvent = (XFixesSelectionEvent *) X;
+
+  if (nxagentXFixesInfo.Initialized == 0 ||
+          xfixesEvent -&gt; type != (nxagentXFixesInfo.EventBase + XFixesSelectionNotify))
+    return 0;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;nxagentHandleXFixesSelectionNotify: Handling event.\n&quot;);
+  #endif
+
+  local = nxagentRemoteToLocalAtom(xfixesEvent -&gt; xfixesselection.selection);
+
+  if (SelectionCallback)
+  {
+    i = 0;
+
+    while ((i &lt; NumCurrentSelections) &amp;&amp;
+            CurrentSelections[i].selection != local)
+      i++;
+
+    if (i &lt; NumCurrentSelections)
+    {
+      SelectionInfoRec    info;
+
+      if (CurrentSelections[i].client != 0)
+      {
+        #ifdef TEST
+        fprintf(stderr, &quot;nxagentHandleXFixesSelectionNotify: Do nothing.\n&quot;);
+        #endif
+
+        return 1;
+      }
+
+      #ifdef TEST
+      fprintf(stderr, &quot;nxagentHandleXFixesSelectionNotify: Calling callbacks for %d [%s] selection.\n&quot;,
+                       CurrentSelections[i].selection, NameForAtom(CurrentSelections[i].selection));
+      #endif
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;nxagentHandleXFixesSelectionNotify: Subtype &quot;);
+
+      switch (xfixesEvent -&gt; xfixesselection.subtype)
+      {
+        case SelectionSetOwner:
+          fprintf(stderr, &quot;SelectionSetOwner.\n&quot;);
+          break;
+        case SelectionWindowDestroy:
+          fprintf(stderr, &quot;SelectionWindowDestroy.\n&quot;);
+          break;
+        case SelectionClientClose:
+          fprintf(stderr, &quot;SelectionClientClose.\n&quot;);
+          break;
+        default:
+          fprintf(stderr, &quot;.\n&quot;);
+          break;
+      }
+      #endif
+
+      info.selection = &amp;CurrentSelections[i];
+      info.kind = xfixesEvent-&gt;xfixesselection.subtype;
+      CallCallbacks(&amp;SelectionCallback, &amp;info);
+    }
+  }
+  return 1;
+}
+
 int nxagentHandleProxyEvent(XEvent *X)
 {
   switch (X -&gt; xclient.data.l[0])
@@ -2924,56 +3062,6 @@ int nxagentHandleReparentNotify(XEvent* X)
 
     return 1;
   }
-  else
-  {
-    /*
-     * This code is supposed to detect if a window manager
-     * is running but in some cases it may be unreliable.
-     * Each window manager behaves differently so the check
-     * can fail for some less common WMs.
-     */
-
-    if (!nxagentWMIsRunning &amp;&amp; nxagentOption(Fullscreen) &amp;&amp;
-            X -&gt; xreparent.window == nxagentDefaultWindows[pScreen -&gt; myNum])
-    {
-      #ifdef WARNING
-      fprintf(stderr, &quot;Warning: The agent window was reparented. Is a &quot;
-                  &quot;window manager running?\n&quot;);
-      #endif
-
-      /*
-       * If no window manager is running and we are supposed to
-       * be in fullscreen mode then don't wait for the reparent
-       * event. We can assume that there is an undetected window
-       * manager and, as switching to fullscreen could have fail-
-       * ed, we try it again.
-       */
-
-      nxagentSwitchFullscreen(pScreen, True);
-
-      nxagentWMIsRunning = True;
-    }
-    else if (nxagentWMIsRunning &amp;&amp; X -&gt; xreparent.window ==
-                 nxagentDefaultWindows[pScreen -&gt; myNum] &amp;&amp; X -&gt; xreparent.parent ==
-                     RootWindow(nxagentDisplay, (pScreen -&gt; myNum)))
-    {
-      #ifdef WARNING
-
-      fprintf(stderr, &quot;Warning: The agent window has been reparented to the root.\n&quot;);
-
-      fprintf(stderr, &quot;Warning: No window manager seems to be running.\n&quot;);
-
-      #endif
-
-      /*
-       * The agent window was unexpectedly reparented
-       * to the root window. We assume that the window
-       * manager was terminated.
-       */
-
-      nxagentWMIsRunning = False;
-    }
-  }
 
   return 1;
 }
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Events.h b/nx-X11/programs/Xserver/hw/nxagent/Events.h
index 4870f83..ab0d257 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Events.h
+++ b/nx-X11/programs/Xserver/hw/nxagent/Events.h
@@ -115,6 +115,7 @@ extern int nxagentHandlePropertyNotify(XEvent *X);
 extern int nxagentHandleKeyPress(XEvent *X, enum HandleEventResult*);
 extern int nxagentHandleReparentNotify(XEvent *X);
 extern int nxagentHandleConfigureNotify(XEvent *X);
+extern int nxagentHandleXFixesSelectionNotify(XEvent *X);
 
 /*
  * Send a fake keystroke to the remote
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Font.c b/nx-X11/programs/Xserver/hw/nxagent/Font.c
index ff968bc..e552f82 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Font.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Font.c
@@ -101,6 +101,8 @@ static XFontStruct *nxagentLoadQueryFont(register Display *dpy , char *fontName
 int nxagentFreeFont(XFontStruct *fs);
 static Bool nxagentGetFontServerPath(char * fontServerPath);
 
+static char * nxagentMakeScalableFontName(const char *fontName, int scalableResolution);
+
 RESTYPE RT_NX_FONT;
 
 #ifdef NXAGENT_RECONNECT_FONT_DEBUG
@@ -419,13 +421,59 @@ Bool nxagentFontFind(const char *name, int *pos)
 Bool nxagentFontLookUp(const char *name)
 {
   int i;
-  if (name)
-    if (!strlen(name))
-       return 0;
-  if (nxagentFontFind(name, &amp;i))
-    return (nxagentRemoteFontList.list[i]-&gt;status &gt; 0);
-  else
+  int result;
+
+  char *scalable;
+
+  if (name != NULL &amp;&amp; strlen(name) == 0)
+  {
+    return 0;
+  }
+
+  result = nxagentFontFind(name, &amp;i);
+
+  scalable = NULL;
+
+  /*
+   * Let's try with the scalable font description.
+   */
+
+  if (result == 0)
+  {
+    scalable = nxagentMakeScalableFontName(name, 0); 
+
+    if (scalable != NULL)
+    {
+      result = nxagentFontFind(scalable, &amp;i);
+
+      free(scalable);
+    }
+  }
+
+  /*
+   * Let's try again after replacing zero to xdpi and ydpi in the pattern.
+   */
+
+  if (result == 0)
+  {
+    scalable = nxagentMakeScalableFontName(name, 1); 
+
+    if (scalable != NULL)
+    {
+      result = nxagentFontFind(scalable, &amp;i);
+
+      free(scalable);
+    }
+  }
+
+  if (result == 0)
+  {
     return 0;
+  }
+  else
+  {
+    return (nxagentRemoteFontList.list[i]-&gt;status &gt; 0);
+  }
 }
 
 Bool nxagentRealizeFont(ScreenPtr pScreen, FontPtr pFont)
@@ -768,6 +816,11 @@ static XFontStruct *nxagentLoadBestQueryFont(Display* dpy, char *fontName, FontP
         fprintf(stderr, &quot;nxagentLoadBestQueryFont: Weight '%d' of more accurate font '%s' .\n&quot;, weight, substFontBuf);
         #endif
       }
+
+      for (j = 0; j &lt; numSearchFields; j++)
+      {
+        free (searchFields[j]);
+      }
     }
   }
 
@@ -783,6 +836,11 @@ static XFontStruct *nxagentLoadBestQueryFont(Display* dpy, char *fontName, FontP
 
   free (substFontBuf);
 
+  for (j = 0; j &lt; numFontFields; j++)
+  {
+    free (fontNameFields[j]);
+  }
+
   return fontStruct;
 }
 
@@ -1688,3 +1746,88 @@ int nxagentSplitString(char *string, char *fields[], int nfields, char *sep)
   return i;
 }
 
+char *nxagentMakeScalableFontName(const char *fontName, int scalableResolution)
+{
+  char *scalableFontName;
+  const char *s;
+  int len;
+  int field;
+
+  len = strlen(fontName) + 1;
+
+  scalableFontName = malloc(len);
+
+  if (scalableFontName == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;nxagentMakeScalableFontName: PANIC! malloc() failed.\n&quot;);
+    #endif
+
+    return NULL;
+  }
+
+  scalableFontName[0] = 0;
+
+  if (*fontName != '-')
+  {
+    goto MakeScalableFontNameError;
+  }
+
+  s = fontName;
+
+  field = 0;
+
+  while (s != NULL)
+  {
+    s = strchr(s + 1, '-');
+
+    if (s != NULL)
+    {
+      if (field == 6 || field == 7 || field == 11)
+      {
+        /*
+         * PIXEL_SIZE || POINT_SIZE || AVERAGE_WIDTH
+         */
+
+        strcat(scalableFontName, &quot;-0&quot;);
+      }
+      else if (scalableResolution == 1 &amp;&amp; (field == 8 || field == 9))
+      {
+        /*
+         * RESOLUTION_X || RESOLUTION_Y
+         */
+
+        strcat(scalableFontName, &quot;-0&quot;);
+      }
+      else
+      {
+        strncat(scalableFontName, fontName, s - fontName);
+      }
+
+      fontName = s;
+    }
+    else
+    {
+      strcat(scalableFontName, fontName);
+    }
+
+    field++;
+  }
+
+  if (field != 14)
+  {
+    goto MakeScalableFontNameError;
+  }
+
+  return scalableFontName;
+
+MakeScalableFontNameError:
+
+  free(scalableFontName);
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;nxagentMakeScalableFontName: Invalid font name.\n&quot;);
+  #endif
+
+  return NULL;
+}
diff --git a/nx-X11/programs/Xserver/hw/nxagent/GCOps.c b/nx-X11/programs/Xserver/hw/nxagent/GCOps.c
index 7a6432a..83aa04f 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/GCOps.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/GCOps.c
@@ -451,6 +451,8 @@ FIXME: The popup could be synchronized with one
 
       CARD32 targetAttributes[2];
 
+      Bool pClipRegionFree = True;
+
       /*
        * As we want to copy only the synchronized
        * areas of the source drawable, we create
@@ -503,6 +505,13 @@ FIXME: The popup could be synchronized with one
 
         nxagentChangeClip(targetGC, CT_REGION, pClipRegion, 0);
 
+        /*
+         * Next call to nxagentChangeClip() will destroy
+         * pClipRegion, so it has not to be freed.
+         */
+
+        pClipRegionFree = False;
+
         #ifdef DEBUG
         fprintf(stderr, &quot;nxagentDeferCopyArea: Going to execute a copy area with clip mask &quot;
                     &quot;[%d,%d,%d,%d] and origin [%d,%d].\n&quot;, ((RegionPtr) targetGC -&gt; clientClip) -&gt; extents.x1,
@@ -518,6 +527,11 @@ FIXME: The popup could be synchronized with one
 
       nxagentChangeClip(targetGC, CT_NONE, NullRegion, 0);
 
+      if (pClipRegionFree == True)
+      {
+        nxagentFreeRegion(pSrcDrawable, pClipRegion);
+      }
+
       FreeScratchGC(targetGC);
     }
     else
@@ -1184,7 +1198,9 @@ void nxagentPolySegment(DrawablePtr pDrawable, GCPtr pGC,
                     (XSegment *) pSegments, nSegments);
     }
 
+    SET_GC_TRAP();
     fbPolySegment(nxagentVirtualDrawable(pDrawable), pGC, nSegments, pSegments);
+    RESET_GC_TRAP();
 
     return;
   }
@@ -1193,7 +1209,9 @@ void nxagentPolySegment(DrawablePtr pDrawable, GCPtr pGC,
     XDrawSegments(nxagentDisplay, nxagentDrawable(pDrawable), nxagentGC(pGC),
                  (XSegment *) pSegments, nSegments);
 
+    SET_GC_TRAP();
     fbPolySegment(pDrawable, pGC, nSegments, pSegments);
+    RESET_GC_TRAP();
   }
 }
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Handlers.c b/nx-X11/programs/Xserver/hw/nxagent/Handlers.c
index dc9770c..3abc357 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Handlers.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Handlers.c
@@ -33,6 +33,7 @@
 #include &quot;Millis.h&quot;
 
 #include &quot;NXlib.h&quot;
+#include &quot;Shadow.h&quot;
 
 /*
  * Set here the required log level.
@@ -705,6 +706,7 @@ void nxagentShadowBlockHandler(pointer data, struct timeval **timeout, pointer m
   int changed;
   int suspended = 0;
   int result;
+  int width_, height_;
 
   #ifdef BLOCKS
   fprintf(stderr, &quot;[Begin block]\n&quot;);
@@ -754,6 +756,19 @@ void nxagentShadowBlockHandler(pointer data, struct timeval **timeout, pointer m
 
   changed = 0;
 
+  NXShadowGetScreenSize(&amp;width_, &amp;height_);
+
+  if (width_ != nxagentShadowWidth || height_ != nxagentShadowHeight)
+  {
+    /*
+     * The master session has been resized.
+     */
+
+    NXShadowSetScreenSize(&amp;nxagentShadowWidth, &amp;nxagentShadowHeight);
+
+    nxagentShadowAdaptToRatio();
+  }
+
   nxagentShadowPoll(nxagentShadowPixmapPtr, nxagentShadowGCPtr, nxagentShadowDepth, nxagentShadowWidth,
                         nxagentShadowHeight, nxagentShadowBuffer, &amp;changed, &amp;suspended);
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Image.c b/nx-X11/programs/Xserver/hw/nxagent/Image.c
index 5108046..4e08f6b 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Image.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Image.c
@@ -922,7 +922,12 @@ void nxagentRealizeImage(DrawablePtr pDrawable, GCPtr pGC, int depth,
   int numSubImages;
   int totalHeight;
 
-  const int subSize = (MAX_REQUEST_SIZE &lt;&lt; 2) - sizeof(xPutImageReq);
+  /*
+   * NXPutPackedImage is longer than PutPackedImage
+   * so that we subtract the bigger one to be sure.
+   */
+
+  const int subSize = (MAX_REQUEST_SIZE &lt;&lt; 2) - sizeof(xNXPutPackedImageReq);
 
   Visual *pVisual = NULL;
 
@@ -1171,7 +1176,7 @@ FIXME: Should use an unpack resource here.
    */
 
   pack = (nxagentOption(LinkType) != LINK_TYPE_NONE &amp;&amp;
-              packMethod != PACK_NONE &amp;&amp; depth &gt; 8);
+              packMethod != PACK_NONE &amp;&amp; depth &gt; 8 &amp;&amp; format == ZPixmap);
 
   lossless = (packMethod == nxagentPackLossless);
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Init.c b/nx-X11/programs/Xserver/hw/nxagent/Init.c
index 197bd8c..4e47f8f 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Init.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Init.c
@@ -74,7 +74,7 @@ is&quot; without express or implied warranty.
 #undef  DEBUG
 #undef  DUMP
 
-#define NXAGENT_VERSION  &quot;3.1.0&quot;
+#define NXAGENT_VERSION  &quot;3.2.0&quot;
 
 /*
  * ProcVector array defined in tables.c.
@@ -332,6 +332,13 @@ FIXME: These variables, if not removed at all because have probably
   nxagentAllocateGraphicContexts();
 
   nxagentDoFullGeneration = nxagentFullGeneration;
+
+  /*
+   * Use a solid black root window
+   * background.
+   */
+
+  blackRoot = TRUE;
 }
 
 void InitInput(argc, argv)
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Keyboard.c b/nx-X11/programs/Xserver/hw/nxagent/Keyboard.c
index dbdfc5b..88e99a1 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Keyboard.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Keyboard.c
@@ -444,7 +444,7 @@ N/A
                                      max_keycode - min_keycode + 1,
                                      &amp;mapWidth);
 
-        if (keymap == NULL)
+        if (keymap64 == NULL)
         {
           XFreeModifiermap(modifier_keymap);
 
@@ -756,6 +756,8 @@ XkbError:
           XkbInitKeyboardDeviceStruct((pointer)pDev, &amp;names, &amp;keySyms, modmap,
                                           nxagentBell, nxagentChangeKeyboardControl);
 
+          free(nxagentXkbConfigFilePath);
+
           if (!nxagentKeyboard ||
                  (nxagentKeyboard &amp;&amp; (strcmp(nxagentKeyboard, &quot;query&quot;) == 0)))
           {
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Literals.h b/nx-X11/programs/Xserver/hw/nxagent/Literals.h
index e80f622..f6aab84 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Literals.h
+++ b/nx-X11/programs/Xserver/hw/nxagent/Literals.h
@@ -142,6 +142,13 @@ static char *nxagentRequestLiteral[] =
   &quot;GetPointerMapping&quot;,
   &quot;SetModifierMapping&quot;,
   &quot;GetModifierMapping&quot;,
+  &quot;&quot;,
+  &quot;&quot;,
+  &quot;&quot;,
+  &quot;&quot;,
+  &quot;&quot;,
+  &quot;&quot;,
+  &quot;&quot;,
   &quot;NoOperation&quot;
 };
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Reconnect.c b/nx-X11/programs/Xserver/hw/nxagent/Reconnect.c
index de5f78f..ce3e6ee 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Reconnect.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Reconnect.c
@@ -553,12 +553,6 @@ Bool nxagentReconnectSession(void)
            strcmp(nxagentKeyboard, nxagentOldKeyboard) != 0 ||
                strcmp(nxagentKeyboard, &quot;query&quot;) == 0)
     {
-      if (nxagentOldKeyboard != NULL)
-      {
-        xfree(nxagentOldKeyboard);
-
-        nxagentOldKeyboard = NULL;
-      }
 
       if (nxagentResetKeyboard() == 0)
       {
@@ -576,6 +570,15 @@ Bool nxagentReconnectSession(void)
     }
   }
 
+  nxagentXkbState.Initialized = 0;
+
+  if (nxagentOldKeyboard != NULL)
+  {
+    xfree(nxagentOldKeyboard);
+
+    nxagentOldKeyboard = NULL;
+  }
+
   nxagentDeactivatePointerGrab();
 
   nxagentWakeupByReconnect();
@@ -686,6 +689,13 @@ nxagentReconnectError:
     nxagentDisconnectDisplay();
   }
 
+  if (nxagentOldKeyboard != NULL)
+  {
+    xfree(nxagentOldKeyboard);
+
+    nxagentOldKeyboard = NULL;
+  }
+
   return 0;
 }
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Screen.c b/nx-X11/programs/Xserver/hw/nxagent/Screen.c
index 4cc1075..34d498f 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Screen.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Screen.c
@@ -78,7 +78,16 @@ is&quot; without express or implied warranty.
 #include &quot;Utils.h&quot;
 
 #include &quot;Xrandr.h&quot;
+
+#define GC     XlibGC
+#define Font   XlibFont
+#define KeySym XlibKeySym
+#define XID    XlibXID
 #include &lt;X11/Xlibint.h&gt;
+#undef  GC
+#undef  Font
+#undef  KeySym
+#undef  XID
 
 #include &quot;Xatom.h&quot;
 #include &quot;Xproto.h&quot;
@@ -309,10 +318,44 @@ void nxagentMaximizeToFullScreen(ScreenPtr pScreen)
 /*
     XUnmapWindow(nxagentDisplay, nxagentIconWindow);
 */
+/*
+FIXME: We'll chech for ReparentNotify and LeaveNotify events after XReparentWindow()
+       in order to avoid the session window is iconified.
+       We could avoid the sesssion window is iconified when a LeaveNotify event is received,
+       so this check would be unnecessary.
+*/
+    struct timeval timeout;
+    int i;
+    XEvent e;
+
+    XReparentWindow(nxagentDisplay, nxagentFullscreenWindow,
+                        RootWindow(nxagentDisplay, DefaultScreen(nxagentDisplay)), 0, 0);
+
+    for (i = 0; i &lt; 100 &amp;&amp; nxagentWMIsRunning; i++)
+    {
+      #ifdef TEST
+      fprintf(stderr, &quot;nxagentSwitchFullscreen: WARNING! Going to wait for the ReparentNotify event.\n&quot;);
+      #endif
+
+      if (XCheckTypedWindowEvent(nxagentDisplay, nxagentFullscreenWindow, ReparentNotify, &amp;e))
+      {
+        break;
+      }
+
+      XSync(nxagentDisplay, 0);
+
+      timeout.tv_sec = 0;
+      timeout.tv_usec = 50 * 1000;
+
+      nxagentWaitEvents(nxagentDisplay, &amp;timeout);
+    }
+
     XMapRaised(nxagentDisplay, nxagentFullscreenWindow);
 
     XIconifyWindow(nxagentDisplay, nxagentIconWindow,
                        DefaultScreen(nxagentDisplay));
+
+    while (XCheckTypedWindowEvent(nxagentDisplay, nxagentFullscreenWindow, LeaveNotify, &amp;e));
 /*
     XMapWindow(nxagentDisplay, nxagentIconWindow);
 */
@@ -2872,6 +2915,15 @@ int nxagentShadowPoll(PixmapPtr nxagentShadowPixmapPtr, GCPtr nxagentShadowGCPtr
       width = pBox[n].y1 - pBox[n].x1;/* y1 = x2 */
       height = y2 - pBox[n].x2;   /* x2 = y1 */
 
+      if((x + width) &gt; nxagentShadowWidth || (y + height) &gt; nxagentShadowHeight)
+      {
+        /*
+         * Out of bounds. Maybe a resize of the master session is going on.
+         */
+
+        continue;
+      }
+
       line = PixmapBytePad(width, nxagentMasterDepth);
 
       #ifdef DEBUG
@@ -3826,8 +3878,8 @@ void nxagentShadowAdaptToRatio(void)
 
   pScreen = screenInfo.screens[0];
 
-  nxagentShadowSetRatio(nxagentOption(Width) * 1.0 / WindowTable[0] -&gt; drawable.width, 
-                            nxagentOption(Height) * 1.0 / WindowTable[0] -&gt; drawable.height);
+  nxagentShadowSetRatio(nxagentOption(Width) * 1.0 / nxagentShadowWidth,
+                            nxagentOption(Height) * 1.0 / nxagentShadowHeight);
 
   nxagentShadowCreateMainWindow(pScreen, WindowTable[0], nxagentShadowWidth, nxagentShadowHeight);
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Trap.c b/nx-X11/programs/Xserver/hw/nxagent/Trap.c
index 3b801d8..2796b2f 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Trap.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Trap.c
@@ -96,4 +96,19 @@ int nxagentLosslessTrap = 0;
 
 int nxagentSplitTrap = 0;
 
+/*
+ * Set to avoid CapsLock synchronization
+ * problems when CapsLock is the first
+ * key to be pressed in the session.
+ */
+
+int nxagentXkbCapsTrap = 0;
+
+/*
+ * Set to avoid NumLock synchronization
+ * problems when NumLock is the first
+ * key to be pressed in the session.
+ */
+
+int nxagentXkbNumTrap = 0;
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Trap.h b/nx-X11/programs/Xserver/hw/nxagent/Trap.h
index f699306..493a18a 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Trap.h
+++ b/nx-X11/programs/Xserver/hw/nxagent/Trap.h
@@ -97,4 +97,20 @@ extern int nxagentLosslessTrap;
 
 extern int nxagentSplitTrap;
 
+/*
+ * Set to avoid CapsLock synchronization
+ * problems when CapsLock is the first
+ * key to be pressed in the session.
+ */
+
+extern int nxagentXkbCapsTrap;
+
+/*
+ * Set to avoid NumLock synchronization
+ * problems when NumLock is the first
+ * key to be pressed in the session.
+ */
+
+extern int nxagentXkbNumTrap;
+
 #endif /* __Trap_H__ */
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXdispatch.c b/nx-X11/programs/Xserver/hw/nxagent/X/NXdispatch.c
index 845c6cf..f84ca0e 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXdispatch.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXdispatch.c
@@ -3835,6 +3835,8 @@ ProcSetScreenSaver (register ClientPtr client)
       {
         ScreenSaverInterval = defaultScreenSaverInterval;
       }
+
+      SetScreenSaverTimer();
     }
     #ifdef TEST
 
@@ -3846,7 +3848,6 @@ ProcSetScreenSaver (register ClientPtr client)
 
     #endif
 
-    SetScreenSaverTimer();
     return (client-&gt;noClientException);
 }
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXdispatch.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXdispatch.c.NX.original
index 845c6cf..f84ca0e 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXdispatch.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXdispatch.c.NX.original
@@ -3835,6 +3835,8 @@ ProcSetScreenSaver (register ClientPtr client)
       {
         ScreenSaverInterval = defaultScreenSaverInterval;
       }
+
+      SetScreenSaverTimer();
     }
     #ifdef TEST
 
@@ -3846,7 +3848,6 @@ ProcSetScreenSaver (register ClientPtr client)
 
     #endif
 
-    SetScreenSaverTimer();
     return (client-&gt;noClientException);
 }
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c
index 06dabdd..f51a8bc 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c
@@ -69,6 +69,17 @@
 #undef  DEBUG
 #undef  TEST
 
+#else
+
+#include &quot;picturestr.h&quot;
+#include &quot;glyphstr.h&quot;
+
+#endif
+
+#if HAVE_STDINT_H
+#include &lt;stdint.h&gt;
+#elif !defined(UINT32_MAX)
+#define UINT32_MAX 0xffffffffU
 #endif
 
 /*
@@ -401,8 +412,12 @@ AllocateGlyph (xGlyphInfo *gi, int fdepth)
 {
     int		size;
     GlyphPtr	glyph;
-
-    size = gi-&gt;height * PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    size_t	     padded_width;
+    
+    padded_width = PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    if (gi-&gt;height &amp;&amp; padded_width &gt; (UINT32_MAX - sizeof(GlyphRec))/gi-&gt;height)
+	return 0;
+    size = gi-&gt;height * padded_width;
     glyph = (GlyphPtr) xalloc (size + sizeof (GlyphRec));
     if (!glyph)
 	return 0;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.NX.original
index 06dabdd..f51a8bc 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.NX.original
@@ -69,6 +69,17 @@
 #undef  DEBUG
 #undef  TEST
 
+#else
+
+#include &quot;picturestr.h&quot;
+#include &quot;glyphstr.h&quot;
+
+#endif
+
+#if HAVE_STDINT_H
+#include &lt;stdint.h&gt;
+#elif !defined(UINT32_MAX)
+#define UINT32_MAX 0xffffffffU
 #endif
 
 /*
@@ -401,8 +412,12 @@ AllocateGlyph (xGlyphInfo *gi, int fdepth)
 {
     int		size;
     GlyphPtr	glyph;
-
-    size = gi-&gt;height * PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    size_t	     padded_width;
+    
+    padded_width = PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    if (gi-&gt;height &amp;&amp; padded_width &gt; (UINT32_MAX - sizeof(GlyphRec))/gi-&gt;height)
+	return 0;
+    size = gi-&gt;height * padded_width;
     glyph = (GlyphPtr) xalloc (size + sizeof (GlyphRec));
     if (!glyph)
 	return 0;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.X.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.X.original
index 45c5dd9..9f4d1c8 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.X.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.X.original
@@ -43,6 +43,12 @@
 #include &quot;picturestr.h&quot;
 #include &quot;glyphstr.h&quot;
 
+#if HAVE_STDINT_H
+#include &lt;stdint.h&gt;
+#elif !defined(UINT32_MAX)
+#define UINT32_MAX 0xffffffffU
+#endif
+
 /*
  * From Knuth -- a good choice for hash/rehash values is p, p-2 where
  * p and p-2 are both prime.  These tables are sized to have an extra 10%
@@ -334,8 +340,12 @@ AllocateGlyph (xGlyphInfo *gi, int fdepth)
 {
     int		size;
     GlyphPtr	glyph;
-
-    size = gi-&gt;height * PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    size_t	     padded_width;
+    
+    padded_width = PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    if (gi-&gt;height &amp;&amp; padded_width &gt; (UINT32_MAX - sizeof(GlyphRec))/gi-&gt;height)
+	return 0;
+    size = gi-&gt;height * padded_width;
     glyph = (GlyphPtr) xalloc (size + sizeof (GlyphRec));
     if (!glyph)
 	return 0;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c
index 00c55cd..de2df85 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c
@@ -1893,6 +1893,8 @@ ProcRenderCreateCursor (ClientPtr client)
     pScreen = pSrc-&gt;pDrawable-&gt;pScreen;
     width = pSrc-&gt;pDrawable-&gt;width;
     height = pSrc-&gt;pDrawable-&gt;height;
+    if (height &amp;&amp; width &gt; UINT32_MAX/(height*sizeof(CARD32)))
+	return BadAlloc;
     if ( stuff-&gt;x &gt; width 
       || stuff-&gt;y &gt; height )
 	return (BadMatch);
@@ -2353,6 +2355,8 @@ static int ProcRenderCreateLinearGradient (ClientPtr client)
     LEGAL_NEW_RESOURCE(stuff-&gt;pid, client);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -2955,18 +2959,18 @@ SProcRenderCreateSolidFill(ClientPtr client)
     return (*ProcRenderVector[stuff-&gt;renderReqType]) (client);
 }
 
-static void swapStops(void *stuff, int n)
+static void swapStops(void *stuff, int num)
 {
-    int i;
+    int i, n;
     CARD32 *stops;
     CARD16 *colors;
     stops = (CARD32 *)(stuff);
-    for (i = 0; i &lt; n; ++i) {
+    for (i = 0; i &lt; num; ++i) {
         swapl(stops, n);
         ++stops;
     }
     colors = (CARD16 *)(stops);
-    for (i = 0; i &lt; 4*n; ++i) {
+    for (i = 0; i &lt; 4*num; ++i) {
         swaps(stops, n);
         ++stops;
     }
@@ -2989,6 +2993,8 @@ SProcRenderCreateLinearGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -3016,6 +3022,8 @@ SProcRenderCreateRadialGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateRadialGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -3040,6 +3048,8 @@ SProcRenderCreateConicalGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateConicalGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original
index 00c55cd..de2df85 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original
@@ -1893,6 +1893,8 @@ ProcRenderCreateCursor (ClientPtr client)
     pScreen = pSrc-&gt;pDrawable-&gt;pScreen;
     width = pSrc-&gt;pDrawable-&gt;width;
     height = pSrc-&gt;pDrawable-&gt;height;
+    if (height &amp;&amp; width &gt; UINT32_MAX/(height*sizeof(CARD32)))
+	return BadAlloc;
     if ( stuff-&gt;x &gt; width 
       || stuff-&gt;y &gt; height )
 	return (BadMatch);
@@ -2353,6 +2355,8 @@ static int ProcRenderCreateLinearGradient (ClientPtr client)
     LEGAL_NEW_RESOURCE(stuff-&gt;pid, client);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -2955,18 +2959,18 @@ SProcRenderCreateSolidFill(ClientPtr client)
     return (*ProcRenderVector[stuff-&gt;renderReqType]) (client);
 }
 
-static void swapStops(void *stuff, int n)
+static void swapStops(void *stuff, int num)
 {
-    int i;
+    int i, n;
     CARD32 *stops;
     CARD16 *colors;
     stops = (CARD32 *)(stuff);
-    for (i = 0; i &lt; n; ++i) {
+    for (i = 0; i &lt; num; ++i) {
         swapl(stops, n);
         ++stops;
     }
     colors = (CARD16 *)(stops);
-    for (i = 0; i &lt; 4*n; ++i) {
+    for (i = 0; i &lt; 4*num; ++i) {
         swaps(stops, n);
         ++stops;
     }
@@ -2989,6 +2993,8 @@ SProcRenderCreateLinearGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -3016,6 +3022,8 @@ SProcRenderCreateRadialGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateRadialGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -3040,6 +3048,8 @@ SProcRenderCreateConicalGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateConicalGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.X.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.X.original
index d2759ab..d25d497 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.X.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.X.original
@@ -1505,6 +1505,8 @@ ProcRenderCreateCursor (ClientPtr client)
     pScreen = pSrc-&gt;pDrawable-&gt;pScreen;
     width = pSrc-&gt;pDrawable-&gt;width;
     height = pSrc-&gt;pDrawable-&gt;height;
+    if (height &amp;&amp; width &gt; UINT32_MAX/(height*sizeof(CARD32)))
+	return BadAlloc;
     if ( stuff-&gt;x &gt; width 
       || stuff-&gt;y &gt; height )
 	return (BadMatch);
@@ -1918,6 +1920,8 @@ static int ProcRenderCreateLinearGradient (ClientPtr client)
     LEGAL_NEW_RESOURCE(stuff-&gt;pid, client);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -2489,18 +2493,18 @@ SProcRenderCreateSolidFill(ClientPtr client)
     return (*ProcRenderVector[stuff-&gt;renderReqType]) (client);
 }
 
-static void swapStops(void *stuff, int n)
+static void swapStops(void *stuff, int num)
 {
-    int i;
+    int i, n;
     CARD32 *stops;
     CARD16 *colors;
     stops = (CARD32 *)(stuff);
-    for (i = 0; i &lt; n; ++i) {
+    for (i = 0; i &lt; num; ++i) {
         swapl(stops, n);
         ++stops;
     }
     colors = (CARD16 *)(stops);
-    for (i = 0; i &lt; 4*n; ++i) {
+    for (i = 0; i &lt; 4*num; ++i) {
         swaps(stops, n);
         ++stops;
     }
@@ -2523,6 +2527,8 @@ SProcRenderCreateLinearGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -2550,6 +2556,8 @@ SProcRenderCreateRadialGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateRadialGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -2574,6 +2582,8 @@ SProcRenderCreateConicalGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateConicalGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c b/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c
index 9af5c41..91e03cb 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c
@@ -201,6 +201,10 @@ void RegisterResourceName (RESTYPE type, char *name)
 
 #endif
 
+#ifdef NXAGENT_SERVER
+static int nxagentResChangedFlag = 0;
+#endif
+
 RESTYPE
 CreateNewResourceType(DeleteType deleteFunc)
 {
@@ -590,6 +594,9 @@ AddResource(XID id, RESTYPE type, pointer value)
     res-&gt;value = value;
     *head = res;
     rrec-&gt;elements++;
+    #ifdef NXAGENT_SERVER
+    nxagentResChangedFlag = 1;
+    #endif
     if (!(id &amp; SERVER_BIT) &amp;&amp; (id &gt;= rrec-&gt;expectID))
 	rrec-&gt;expectID = id + 1;
     return TRUE;
@@ -675,6 +682,9 @@ FreeResource(XID id, RESTYPE skipDeleteFuncType)
 		RESTYPE rtype = res-&gt;type;
 		*prev = res-&gt;next;
 		elements = --*eltptr;
+                #ifdef NXAGENT_SERVER
+                nxagentResChangedFlag = 1;
+                #endif
 		if (rtype &amp; RC_CACHED)
 		    FlushClientCaches(res-&gt;id);
 		if (rtype != skipDeleteFuncType)
@@ -715,6 +725,9 @@ FreeResourceByType(XID id, RESTYPE type, Bool skipFree)
 	    if (res-&gt;id == id &amp;&amp; res-&gt;type == type)
 	    {
 		*prev = res-&gt;next;
+                #ifdef NXAGENT_SERVER
+                nxagentResChangedFlag = 1;
+                #endif
 		if (type &amp; RC_CACHED)
 		    FlushClientCaches(res-&gt;id);
 		if (!skipFree)
@@ -809,12 +822,44 @@ RestartLoop:
 	    next = this-&gt;next;
 	    if (!type || this-&gt;type == type) {
 		elements = *eltptr;
+
+                /*
+                 * FIXME:
+                 * It is not safe to let a function change the resource
+                 * table we are reading!
+                 */
+
+                #ifdef NXAGENT_SERVER
+                nxagentResChangedFlag = 0;
+                #endif
 		(*func)(this-&gt;value, this-&gt;id, cdata);
+
+                /*
+                 * Avoid that a call to RebuildTable() could invalidate the
+                 * pointer. This is safe enough, because in RebuildTable()
+                 * the new pointer is allocated just before the old one is
+                 * freed, so it can't point to the same address.
+                 */
+
                 #ifdef NXAGENT_SERVER
                 if (*resptr != resources)
                    goto RestartLoop;
                 #endif
+
+                /*
+                 * It's not enough to check if the number of elements has
+                 * changed, beacause it could happen that the number of
+                 * resources that have been added matches the number of
+                 * the freed ones.
+                 * 'nxagentResChangedFlag' is set if a resource has been
+                 * added or freed.
+                 */
+
+                #ifdef NXAGENT_SERVER
+                if (*eltptr != elements || nxagentResChangedFlag)
+                #else
 		if (*eltptr != elements)
+                #endif
 		    next = resources[i]; /* start over */
 	    }
 	}
@@ -861,12 +906,44 @@ RestartLoop:
         {
             next = this-&gt;next;
             elements = *eltptr;
+
+            /*
+             * FIXME:
+             * It is not safe to let a function change the resource
+             * table we are reading!
+             */
+
+            #ifdef NXAGENT_SERVER
+            nxagentResChangedFlag = 0;
+            #endif
             (*func)(this-&gt;value, this-&gt;id, this-&gt;type, cdata);
+
+            /*
+             * Avoid that a call to RebuildTable() could invalidate the
+             * pointer. This is safe enough, because in RebuildTable()
+             * the new pointer is allocated just before the old one is
+             * freed, so it can't point to the same address.
+             */
+
             #ifdef NXAGENT_SERVER
             if (*resptr != resources)
                 goto RestartLoop;
             #endif
+
+            /*
+             * It's not enough to check if the number of elements has
+             * changed, beacause it could happen that the number of
+             * resources that have been added matches the number of
+             * the freed ones.
+             * 'nxagentResChangedFlag' is set if a resource has been
+             * added or freed.
+             */
+
+            #ifdef NXAGENT_SERVER
+            if (*eltptr != elements || nxagentResChangedFlag)
+            #else
             if (*eltptr != elements)
+            #endif
                 next = resources[i]; /* start over */
         }
     }
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c.NX.original
index 9af5c41..91e03cb 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c.NX.original
@@ -201,6 +201,10 @@ void RegisterResourceName (RESTYPE type, char *name)
 
 #endif
 
+#ifdef NXAGENT_SERVER
+static int nxagentResChangedFlag = 0;
+#endif
+
 RESTYPE
 CreateNewResourceType(DeleteType deleteFunc)
 {
@@ -590,6 +594,9 @@ AddResource(XID id, RESTYPE type, pointer value)
     res-&gt;value = value;
     *head = res;
     rrec-&gt;elements++;
+    #ifdef NXAGENT_SERVER
+    nxagentResChangedFlag = 1;
+    #endif
     if (!(id &amp; SERVER_BIT) &amp;&amp; (id &gt;= rrec-&gt;expectID))
 	rrec-&gt;expectID = id + 1;
     return TRUE;
@@ -675,6 +682,9 @@ FreeResource(XID id, RESTYPE skipDeleteFuncType)
 		RESTYPE rtype = res-&gt;type;
 		*prev = res-&gt;next;
 		elements = --*eltptr;
+                #ifdef NXAGENT_SERVER
+                nxagentResChangedFlag = 1;
+                #endif
 		if (rtype &amp; RC_CACHED)
 		    FlushClientCaches(res-&gt;id);
 		if (rtype != skipDeleteFuncType)
@@ -715,6 +725,9 @@ FreeResourceByType(XID id, RESTYPE type, Bool skipFree)
 	    if (res-&gt;id == id &amp;&amp; res-&gt;type == type)
 	    {
 		*prev = res-&gt;next;
+                #ifdef NXAGENT_SERVER
+                nxagentResChangedFlag = 1;
+                #endif
 		if (type &amp; RC_CACHED)
 		    FlushClientCaches(res-&gt;id);
 		if (!skipFree)
@@ -809,12 +822,44 @@ RestartLoop:
 	    next = this-&gt;next;
 	    if (!type || this-&gt;type == type) {
 		elements = *eltptr;
+
+                /*
+                 * FIXME:
+                 * It is not safe to let a function change the resource
+                 * table we are reading!
+                 */
+
+                #ifdef NXAGENT_SERVER
+                nxagentResChangedFlag = 0;
+                #endif
 		(*func)(this-&gt;value, this-&gt;id, cdata);
+
+                /*
+                 * Avoid that a call to RebuildTable() could invalidate the
+                 * pointer. This is safe enough, because in RebuildTable()
+                 * the new pointer is allocated just before the old one is
+                 * freed, so it can't point to the same address.
+                 */
+
                 #ifdef NXAGENT_SERVER
                 if (*resptr != resources)
                    goto RestartLoop;
                 #endif
+
+                /*
+                 * It's not enough to check if the number of elements has
+                 * changed, beacause it could happen that the number of
+                 * resources that have been added matches the number of
+                 * the freed ones.
+                 * 'nxagentResChangedFlag' is set if a resource has been
+                 * added or freed.
+                 */
+
+                #ifdef NXAGENT_SERVER
+                if (*eltptr != elements || nxagentResChangedFlag)
+                #else
 		if (*eltptr != elements)
+                #endif
 		    next = resources[i]; /* start over */
 	    }
 	}
@@ -861,12 +906,44 @@ RestartLoop:
         {
             next = this-&gt;next;
             elements = *eltptr;
+
+            /*
+             * FIXME:
+             * It is not safe to let a function change the resource
+             * table we are reading!
+             */
+
+            #ifdef NXAGENT_SERVER
+            nxagentResChangedFlag = 0;
+            #endif
             (*func)(this-&gt;value, this-&gt;id, this-&gt;type, cdata);
+
+            /*
+             * Avoid that a call to RebuildTable() could invalidate the
+             * pointer. This is safe enough, because in RebuildTable()
+             * the new pointer is allocated just before the old one is
+             * freed, so it can't point to the same address.
+             */
+
             #ifdef NXAGENT_SERVER
             if (*resptr != resources)
                 goto RestartLoop;
             #endif
+
+            /*
+             * It's not enough to check if the number of elements has
+             * changed, beacause it could happen that the number of
+             * resources that have been added matches the number of
+             * the freed ones.
+             * 'nxagentResChangedFlag' is set if a resource has been
+             * added or freed.
+             */
+
+            #ifdef NXAGENT_SERVER
+            if (*eltptr != elements || nxagentResChangedFlag)
+            #else
             if (*eltptr != elements)
+            #endif
                 next = resources[i]; /* start over */
         }
     }
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c
index e3e4f4b..a6d638e 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c
@@ -967,8 +967,17 @@ ProcShmPutImage(client)
         return BadValue;
     }
 
-    VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
-		   client);
+    /* 
+     * There's a potential integer overflow in this check:
+     * VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
+     *                client);
+     * the version below ought to avoid it
+     */
+    if (stuff-&gt;totalHeight != 0 &amp;&amp; 
+	length &gt; (shmdesc-&gt;size - stuff-&gt;offset)/stuff-&gt;totalHeight) {
+	client-&gt;errorValue = stuff-&gt;totalWidth;
+	return BadValue;
+    }
     if (stuff-&gt;srcX &gt; stuff-&gt;totalWidth)
     {
 	client-&gt;errorValue = stuff-&gt;srcX;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.NX.original
index e3e4f4b..a6d638e 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.NX.original
@@ -967,8 +967,17 @@ ProcShmPutImage(client)
         return BadValue;
     }
 
-    VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
-		   client);
+    /* 
+     * There's a potential integer overflow in this check:
+     * VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
+     *                client);
+     * the version below ought to avoid it
+     */
+    if (stuff-&gt;totalHeight != 0 &amp;&amp; 
+	length &gt; (shmdesc-&gt;size - stuff-&gt;offset)/stuff-&gt;totalHeight) {
+	client-&gt;errorValue = stuff-&gt;totalWidth;
+	return BadValue;
+    }
     if (stuff-&gt;srcX &gt; stuff-&gt;totalWidth)
     {
 	client-&gt;errorValue = stuff-&gt;srcX;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.X.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.X.original
index e2cf8cd..f25bb9b 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.X.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.X.original
@@ -863,8 +863,17 @@ ProcShmPutImage(client)
         return BadValue;
     }
 
-    VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
-		   client);
+    /* 
+     * There's a potential integer overflow in this check:
+     * VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
+     *                client);
+     * the version below ought to avoid it
+     */
+    if (stuff-&gt;totalHeight != 0 &amp;&amp; 
+	length &gt; (shmdesc-&gt;size - stuff-&gt;offset)/stuff-&gt;totalHeight) {
+	client-&gt;errorValue = stuff-&gt;totalWidth;
+	return BadValue;
+    }
     if (stuff-&gt;srcX &gt; stuff-&gt;totalWidth)
     {
 	client-&gt;errorValue = stuff-&gt;srcX;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXwindow.c b/nx-X11/programs/Xserver/hw/nxagent/X/NXwindow.c
index 7ba468a..24dad32 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXwindow.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXwindow.c
@@ -153,6 +153,9 @@ extern Bool nxagentScreenTrap;
  *
  ******/
 
+static unsigned char _back_lsb[4] = {0x88, 0x22, 0x44, 0x11};
+static unsigned char _back_msb[4] = {0x11, 0x44, 0x22, 0x88};
+
 int screenIsSaved = SCREEN_SAVER_OFF;
 
 ScreenSaverStuffRec savedScreenInfo[MAXSCREENS];
@@ -355,18 +358,7 @@ void nxagentClearSplash(WindowPtr pW)
     (*pScreen-&gt;ChangeWindowAttributes)(pW, CWBackPixmap|CWBackPixel);
 }
 
-static void
-#if NeedFunctionPrototypes
-MakeRootTile(WindowPtr pWin)
-#else
-MakeRootTile(pWin)
-    WindowPtr pWin;
-#endif
-{
-    nxagentRootTileWindow = pWin;
-}
-
-#else /* NXAGENT_SERVER */
+#endif /* NXAGENT_SERVER */
 
 static void
 MakeRootTile(WindowPtr pWin)
@@ -412,9 +404,10 @@ MakeRootTile(WindowPtr pWin)
 
    FreeScratchGC(pGC);
 
-}
-
+#ifdef NXAGENT_SERVER
+   nxagentRootTileWindow = pWin;
 #endif /* NXAGENT_SERVER */
+}
 
 WindowPtr
 AllocateWindow(ScreenPtr pScreen)
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXwindow.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXwindow.c.NX.original
index 7ba468a..24dad32 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXwindow.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXwindow.c.NX.original
@@ -153,6 +153,9 @@ extern Bool nxagentScreenTrap;
  *
  ******/
 
+static unsigned char _back_lsb[4] = {0x88, 0x22, 0x44, 0x11};
+static unsigned char _back_msb[4] = {0x11, 0x44, 0x22, 0x88};
+
 int screenIsSaved = SCREEN_SAVER_OFF;
 
 ScreenSaverStuffRec savedScreenInfo[MAXSCREENS];
@@ -355,18 +358,7 @@ void nxagentClearSplash(WindowPtr pW)
     (*pScreen-&gt;ChangeWindowAttributes)(pW, CWBackPixmap|CWBackPixel);
 }
 
-static void
-#if NeedFunctionPrototypes
-MakeRootTile(WindowPtr pWin)
-#else
-MakeRootTile(pWin)
-    WindowPtr pWin;
-#endif
-{
-    nxagentRootTileWindow = pWin;
-}
-
-#else /* NXAGENT_SERVER */
+#endif /* NXAGENT_SERVER */
 
 static void
 MakeRootTile(WindowPtr pWin)
@@ -412,9 +404,10 @@ MakeRootTile(WindowPtr pWin)
 
    FreeScratchGC(pGC);
 
-}
-
+#ifdef NXAGENT_SERVER
+   nxagentRootTileWindow = pWin;
 #endif /* NXAGENT_SERVER */
+}
 
 WindowPtr
 AllocateWindow(ScreenPtr pScreen)


hooks/post-receive
-- 
nx-libs.git (NX (redistributed))

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;nx-libs.git&quot; (NX (redistributed)).

</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011323.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-6
</A></li>
	<LI>Next message: <A HREF="011326.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-7
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11324">[ date ]</a>
              <a href="thread.html#11324">[ thread ]</a>
              <a href="subject.html#11324">[ subject ]</a>
              <a href="author.html#11324">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2Go-commits
mailing list</a><br>
</body></html>
