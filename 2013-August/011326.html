<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-7
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2013-August/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-main%20%28branch%29%20updated%3A%0A%09nxagent/3.2.0-7&In-Reply-To=%3C20130830142201.0D8F55DB22%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011324.html">
   <LINK REL="Next"  HREF="011330.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-7</H1>
    <B>X2Go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-main%20%28branch%29%20updated%3A%0A%09nxagent/3.2.0-7&In-Reply-To=%3C20130830142201.0D8F55DB22%40ymir%3E"
       TITLE="[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-7">git-admin at x2go.org
       </A><BR>
    <I>Fri Aug 30 16:22:00 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="011324.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-10
</A></li>
        <LI>Next message: <A HREF="011330.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-5
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11326">[ date ]</a>
              <a href="thread.html#11326">[ thread ]</a>
              <a href="subject.html#11326">[ subject ]</a>
              <a href="author.html#11326">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, build-main has been updated
       via  c4e7705d299fcfc058baaa0867e1a1e29d626c6f (commit)
      from  c9983230f1f37db868f628856122739566a9286d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
-----------------------------------------------------------------------

Summary of changes:
 nx-X11/programs/Xserver/hw/nxagent/CHANGELOG       |    7 +
 nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c     |   19 +-
 .../Xserver/hw/nxagent/X/NXglyph.c.NX.original     |   19 +-
 .../Xserver/hw/nxagent/X/NXglyph.c.X.original      |   14 +-
 nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c    |   18 +-
 .../Xserver/hw/nxagent/X/NXrender.c.NX.original    |   18 +-
 .../Xserver/hw/nxagent/X/NXrender.c.X.original     |   18 +-
 .../Xserver/hw/nxagent/X/NXresource.c.NX.original  |    8 +-
 nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c~ | 1250 --------------------
 nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c       |   13 +-
 .../Xserver/hw/nxagent/X/NXshm.c.NX.original       |   13 +-
 .../Xserver/hw/nxagent/X/NXshm.c.X.original        |   13 +-
 12 files changed, 132 insertions(+), 1278 deletions(-)
 delete mode 100644 nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c~

The diff of changes is:
diff --git a/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG b/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG
index e3b71e6..7cf04ac 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG
+++ b/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG
@@ -1,5 +1,12 @@
 ChangeLog:
 
+nxagent-3.2.0-7
+
+- Imported patch fixing issues from  X.Org security advisory, June
+  11th, 2008: Multiple vulnerabilities in X server extensions. CVE
+  IDs: CVE-2008-1377, CVE-2008-1379, CVE-2008-2360, CVE-2008-2361,
+  CVE-2008-2362.
+
 nxagent-3.2.0-6
 
 - Fixed TR05F02063. Ignore ReparentNotify events for non-rootless
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c
index 06dabdd..f51a8bc 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c
@@ -69,6 +69,17 @@
 #undef  DEBUG
 #undef  TEST
 
+#else
+
+#include &quot;picturestr.h&quot;
+#include &quot;glyphstr.h&quot;
+
+#endif
+
+#if HAVE_STDINT_H
+#include &lt;stdint.h&gt;
+#elif !defined(UINT32_MAX)
+#define UINT32_MAX 0xffffffffU
 #endif
 
 /*
@@ -401,8 +412,12 @@ AllocateGlyph (xGlyphInfo *gi, int fdepth)
 {
     int		size;
     GlyphPtr	glyph;
-
-    size = gi-&gt;height * PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    size_t	     padded_width;
+    
+    padded_width = PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    if (gi-&gt;height &amp;&amp; padded_width &gt; (UINT32_MAX - sizeof(GlyphRec))/gi-&gt;height)
+	return 0;
+    size = gi-&gt;height * padded_width;
     glyph = (GlyphPtr) xalloc (size + sizeof (GlyphRec));
     if (!glyph)
 	return 0;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.NX.original
index 06dabdd..f51a8bc 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.NX.original
@@ -69,6 +69,17 @@
 #undef  DEBUG
 #undef  TEST
 
+#else
+
+#include &quot;picturestr.h&quot;
+#include &quot;glyphstr.h&quot;
+
+#endif
+
+#if HAVE_STDINT_H
+#include &lt;stdint.h&gt;
+#elif !defined(UINT32_MAX)
+#define UINT32_MAX 0xffffffffU
 #endif
 
 /*
@@ -401,8 +412,12 @@ AllocateGlyph (xGlyphInfo *gi, int fdepth)
 {
     int		size;
     GlyphPtr	glyph;
-
-    size = gi-&gt;height * PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    size_t	     padded_width;
+    
+    padded_width = PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    if (gi-&gt;height &amp;&amp; padded_width &gt; (UINT32_MAX - sizeof(GlyphRec))/gi-&gt;height)
+	return 0;
+    size = gi-&gt;height * padded_width;
     glyph = (GlyphPtr) xalloc (size + sizeof (GlyphRec));
     if (!glyph)
 	return 0;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.X.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.X.original
index 45c5dd9..9f4d1c8 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.X.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXglyph.c.X.original
@@ -43,6 +43,12 @@
 #include &quot;picturestr.h&quot;
 #include &quot;glyphstr.h&quot;
 
+#if HAVE_STDINT_H
+#include &lt;stdint.h&gt;
+#elif !defined(UINT32_MAX)
+#define UINT32_MAX 0xffffffffU
+#endif
+
 /*
  * From Knuth -- a good choice for hash/rehash values is p, p-2 where
  * p and p-2 are both prime.  These tables are sized to have an extra 10%
@@ -334,8 +340,12 @@ AllocateGlyph (xGlyphInfo *gi, int fdepth)
 {
     int		size;
     GlyphPtr	glyph;
-
-    size = gi-&gt;height * PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    size_t	     padded_width;
+    
+    padded_width = PixmapBytePad (gi-&gt;width, glyphDepths[fdepth]);
+    if (gi-&gt;height &amp;&amp; padded_width &gt; (UINT32_MAX - sizeof(GlyphRec))/gi-&gt;height)
+	return 0;
+    size = gi-&gt;height * padded_width;
     glyph = (GlyphPtr) xalloc (size + sizeof (GlyphRec));
     if (!glyph)
 	return 0;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c
index 00c55cd..de2df85 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c
@@ -1893,6 +1893,8 @@ ProcRenderCreateCursor (ClientPtr client)
     pScreen = pSrc-&gt;pDrawable-&gt;pScreen;
     width = pSrc-&gt;pDrawable-&gt;width;
     height = pSrc-&gt;pDrawable-&gt;height;
+    if (height &amp;&amp; width &gt; UINT32_MAX/(height*sizeof(CARD32)))
+	return BadAlloc;
     if ( stuff-&gt;x &gt; width 
       || stuff-&gt;y &gt; height )
 	return (BadMatch);
@@ -2353,6 +2355,8 @@ static int ProcRenderCreateLinearGradient (ClientPtr client)
     LEGAL_NEW_RESOURCE(stuff-&gt;pid, client);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -2955,18 +2959,18 @@ SProcRenderCreateSolidFill(ClientPtr client)
     return (*ProcRenderVector[stuff-&gt;renderReqType]) (client);
 }
 
-static void swapStops(void *stuff, int n)
+static void swapStops(void *stuff, int num)
 {
-    int i;
+    int i, n;
     CARD32 *stops;
     CARD16 *colors;
     stops = (CARD32 *)(stuff);
-    for (i = 0; i &lt; n; ++i) {
+    for (i = 0; i &lt; num; ++i) {
         swapl(stops, n);
         ++stops;
     }
     colors = (CARD16 *)(stops);
-    for (i = 0; i &lt; 4*n; ++i) {
+    for (i = 0; i &lt; 4*num; ++i) {
         swaps(stops, n);
         ++stops;
     }
@@ -2989,6 +2993,8 @@ SProcRenderCreateLinearGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -3016,6 +3022,8 @@ SProcRenderCreateRadialGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateRadialGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -3040,6 +3048,8 @@ SProcRenderCreateConicalGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateConicalGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original
index 00c55cd..de2df85 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original
@@ -1893,6 +1893,8 @@ ProcRenderCreateCursor (ClientPtr client)
     pScreen = pSrc-&gt;pDrawable-&gt;pScreen;
     width = pSrc-&gt;pDrawable-&gt;width;
     height = pSrc-&gt;pDrawable-&gt;height;
+    if (height &amp;&amp; width &gt; UINT32_MAX/(height*sizeof(CARD32)))
+	return BadAlloc;
     if ( stuff-&gt;x &gt; width 
       || stuff-&gt;y &gt; height )
 	return (BadMatch);
@@ -2353,6 +2355,8 @@ static int ProcRenderCreateLinearGradient (ClientPtr client)
     LEGAL_NEW_RESOURCE(stuff-&gt;pid, client);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -2955,18 +2959,18 @@ SProcRenderCreateSolidFill(ClientPtr client)
     return (*ProcRenderVector[stuff-&gt;renderReqType]) (client);
 }
 
-static void swapStops(void *stuff, int n)
+static void swapStops(void *stuff, int num)
 {
-    int i;
+    int i, n;
     CARD32 *stops;
     CARD16 *colors;
     stops = (CARD32 *)(stuff);
-    for (i = 0; i &lt; n; ++i) {
+    for (i = 0; i &lt; num; ++i) {
         swapl(stops, n);
         ++stops;
     }
     colors = (CARD16 *)(stops);
-    for (i = 0; i &lt; 4*n; ++i) {
+    for (i = 0; i &lt; 4*num; ++i) {
         swaps(stops, n);
         ++stops;
     }
@@ -2989,6 +2993,8 @@ SProcRenderCreateLinearGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -3016,6 +3022,8 @@ SProcRenderCreateRadialGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateRadialGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -3040,6 +3048,8 @@ SProcRenderCreateConicalGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateConicalGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.X.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.X.original
index d2759ab..d25d497 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.X.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.X.original
@@ -1505,6 +1505,8 @@ ProcRenderCreateCursor (ClientPtr client)
     pScreen = pSrc-&gt;pDrawable-&gt;pScreen;
     width = pSrc-&gt;pDrawable-&gt;width;
     height = pSrc-&gt;pDrawable-&gt;height;
+    if (height &amp;&amp; width &gt; UINT32_MAX/(height*sizeof(CARD32)))
+	return BadAlloc;
     if ( stuff-&gt;x &gt; width 
       || stuff-&gt;y &gt; height )
 	return (BadMatch);
@@ -1918,6 +1920,8 @@ static int ProcRenderCreateLinearGradient (ClientPtr client)
     LEGAL_NEW_RESOURCE(stuff-&gt;pid, client);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -2489,18 +2493,18 @@ SProcRenderCreateSolidFill(ClientPtr client)
     return (*ProcRenderVector[stuff-&gt;renderReqType]) (client);
 }
 
-static void swapStops(void *stuff, int n)
+static void swapStops(void *stuff, int num)
 {
-    int i;
+    int i, n;
     CARD32 *stops;
     CARD16 *colors;
     stops = (CARD32 *)(stuff);
-    for (i = 0; i &lt; n; ++i) {
+    for (i = 0; i &lt; num; ++i) {
         swapl(stops, n);
         ++stops;
     }
     colors = (CARD16 *)(stops);
-    for (i = 0; i &lt; 4*n; ++i) {
+    for (i = 0; i &lt; 4*num; ++i) {
         swaps(stops, n);
         ++stops;
     }
@@ -2523,6 +2527,8 @@ SProcRenderCreateLinearGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateLinearGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -2550,6 +2556,8 @@ SProcRenderCreateRadialGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateRadialGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
@@ -2574,6 +2582,8 @@ SProcRenderCreateConicalGradient (ClientPtr client)
     swapl(&amp;stuff-&gt;nStops, n);
 
     len = (client-&gt;req_len &lt;&lt; 2) - sizeof(xRenderCreateConicalGradientReq);
+    if (stuff-&gt;nStops &gt; UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
+	return BadLength;
     if (len != stuff-&gt;nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
         return BadLength;
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c.NX.original
index 7dd021a..91e03cb 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c.NX.original
@@ -194,10 +194,6 @@ static DeleteType *DeleteFuncs = (DeleteType *)NULL;
 
 Atom * ResourceNames = NULL;
 
-#ifdef NXAGENT_SERVER
-static int nxagentResChangedFlag = 0;
-#endif
-
 void RegisterResourceName (RESTYPE type, char *name)
 {
     ResourceNames[type &amp; TypeMask] =  MakeAtom(name, strlen(name), TRUE);
@@ -205,6 +201,10 @@ void RegisterResourceName (RESTYPE type, char *name)
 
 #endif
 
+#ifdef NXAGENT_SERVER
+static int nxagentResChangedFlag = 0;
+#endif
+
 RESTYPE
 CreateNewResourceType(DeleteType deleteFunc)
 {
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c~ b/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c~
deleted file mode 100644
index 7dd021a..0000000
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXresource.c~
+++ /dev/null
@@ -1,1250 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXAGENT, NX protocol compression and NX extensions to this software    */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
-/*                                                                        */
-/* All rights reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-/************************************************************
-
-Copyright 1987, 1998  The Open Group
-
-Permission to use, copy, modify, distribute, and sell this software and its
-documentation for any purpose is hereby granted without fee, provided that
-the above copyright notice appear in all copies and that both that
-copyright notice and this permission notice appear in supporting
-documentation.
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of The Open Group shall not be
-used in advertising or otherwise to promote the sale, use or other dealings
-in this Software without prior written authorization from The Open Group.
-
-
-Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
-
-                        All Rights Reserved
-
-Permission to use, copy, modify, and distribute this software and its 
-documentation for any purpose and without fee is hereby granted, 
-provided that the above copyright notice appear in all copies and that
-both that copyright notice and this permission notice appear in 
-supporting documentation, and that the name of Digital not be
-used in advertising or publicity pertaining to distribution of the
-software without specific, written prior permission.  
-
-DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
-ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
-DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
-ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
-WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-SOFTWARE.
-
-********************************************************/
-/* The panoramix components contained the following notice */
-/*****************************************************************
-
-Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the &quot;Software&quot;), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software.
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
-BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
-WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
-IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of Digital Equipment Corporation
-shall not be used in advertising or otherwise to promote the sale, use or other
-dealings in this Software without prior written authorization from Digital
-Equipment Corporation.
-
-******************************************************************/
-
-/* $Xorg: resource.c,v 1.5 2001/02/09 02:04:40 xorgcvs Exp $ */
-/* $XdotOrg: xc/programs/Xserver/dix/resource.c,v 1.8 2005/07/03 08:53:38 daniels Exp $ */
-/* $TOG: resource.c /main/41 1998/02/09 14:20:31 kaleb $ */
-
-/*	Routines to manage various kinds of resources:
- *
- *	CreateNewResourceType, CreateNewResourceClass, InitClientResources,
- *	FakeClientID, AddResource, FreeResource, FreeClientResources,
- *	FreeAllResources, LookupIDByType, LookupIDByClass, GetXIDRange
- */
-
-/* 
- *      A resource ID is a 32 bit quantity, the upper 2 bits of which are
- *	off-limits for client-visible resources.  The next 8 bits are
- *      used as client ID, and the low 22 bits come from the client.
- *	A resource ID is &quot;hashed&quot; by extracting and xoring subfields
- *      (varying with the size of the hash table).
- *
- *      It is sometimes necessary for the server to create an ID that looks
- *      like it belongs to a client.  This ID, however,  must not be one
- *      the client actually can create, or we have the potential for conflict.
- *      The 31st bit of the ID is reserved for the server's use for this
- *      purpose.  By setting CLIENT_ID(id) to the client, the SERVER_BIT to
- *      1, and an otherwise arbitrary ID in the low 22 bits, we can create a
- *      resource &quot;owned&quot; by the client.
- */
-/* $XFree86: xc/programs/Xserver/dix/resource.c,v 3.13 2003/09/24 02:43:13 dawes Exp $ */
-
-#define NEED_EVENTS
-#ifdef HAVE_DIX_CONFIG_H
-#include &lt;dix-config.h&gt;
-#endif
-
-#include &lt;X11/X.h&gt;
-#include &quot;misc.h&quot;
-#include &quot;os.h&quot;
-#include &quot;resource.h&quot;
-#include &quot;dixstruct.h&quot; 
-#include &quot;opaque.h&quot;
-#include &quot;windowstr.h&quot;
-#include &quot;dixfont.h&quot;
-#include &quot;colormap.h&quot;
-#include &quot;inputstr.h&quot;
-#include &quot;dixevents.h&quot;
-#include &quot;dixgrabs.h&quot;
-#include &quot;cursor.h&quot;
-#ifdef PANORAMIX
-#include &quot;panoramiX.h&quot;
-#include &quot;panoramiXsrv.h&quot;
-#endif
-#include &lt;assert.h&gt;
-
-#ifdef NXAGENT_SERVER
-
-#include &quot;Agent.h&quot;
-#include &quot;Font.h&quot;
-#include &quot;Pixmaps.h&quot;
-#include &quot;GCs.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-#endif
-
-static void RebuildTable(
-    int /*client*/
-);
-
-#define SERVER_MINID 32
-
-#define INITBUCKETS 64
-#define INITHASHSIZE 6
-#define MAXHASHSIZE 11
-
-typedef struct _Resource {
-    struct _Resource	*next;
-    XID			id;
-    RESTYPE		type;
-    pointer		value;
-} ResourceRec, *ResourcePtr;
-#define NullResource ((ResourcePtr)NULL)
-
-typedef struct _ClientResource {
-    ResourcePtr *resources;
-    int		elements;
-    int		buckets;
-    int		hashsize;	/* log(2)(buckets) */
-    XID		fakeID;
-    XID		endFakeID;
-    XID		expectID;
-} ClientResourceRec;
-
-RESTYPE lastResourceType;
-static RESTYPE lastResourceClass;
-RESTYPE TypeMask;
-
-static DeleteType *DeleteFuncs = (DeleteType *)NULL;
-
-#ifdef XResExtension
-
-Atom * ResourceNames = NULL;
-
-#ifdef NXAGENT_SERVER
-static int nxagentResChangedFlag = 0;
-#endif
-
-void RegisterResourceName (RESTYPE type, char *name)
-{
-    ResourceNames[type &amp; TypeMask] =  MakeAtom(name, strlen(name), TRUE);
-}
-
-#endif
-
-RESTYPE
-CreateNewResourceType(DeleteType deleteFunc)
-{
-    RESTYPE next = lastResourceType + 1;
-    DeleteType *funcs;
-
-    if (next &amp; lastResourceClass)
-	return 0;
-    funcs = (DeleteType *)xrealloc(DeleteFuncs,
-				   (next + 1) * sizeof(DeleteType));
-    if (!funcs)
-	return 0;
-
-#ifdef XResExtension
-    {
-       Atom *newnames;
-       newnames = xrealloc(ResourceNames, (next + 1) * sizeof(Atom));
-       if(!newnames)
-           return 0;
-       ResourceNames = newnames;
-       ResourceNames[next] = 0;
-    }
-#endif
-
-    lastResourceType = next;
-    DeleteFuncs = funcs;
-    DeleteFuncs[next] = deleteFunc;
-    return next;
-}
-
-RESTYPE
-CreateNewResourceClass()
-{
-    RESTYPE next = lastResourceClass &gt;&gt; 1;
-
-    if (next &amp; lastResourceType)
-	return 0;
-    lastResourceClass = next;
-    TypeMask = next - 1;
-    return next;
-}
-
-ClientResourceRec clientTable[MAXCLIENTS];
-
-/*****************
- * InitClientResources
- *    When a new client is created, call this to allocate space
- *    in resource table
- *****************/
-
-Bool
-InitClientResources(ClientPtr client)
-{
-    register int i, j;
- 
-    if (client == serverClient)
-    {
-	lastResourceType = RT_LASTPREDEF;
-	lastResourceClass = RC_LASTPREDEF;
-	TypeMask = RC_LASTPREDEF - 1;
-	if (DeleteFuncs)
-	    xfree(DeleteFuncs);
-	DeleteFuncs = (DeleteType *)xalloc((lastResourceType + 1) *
-					   sizeof(DeleteType));
-	if (!DeleteFuncs)
-	    return FALSE;
-	DeleteFuncs[RT_NONE &amp; TypeMask] = (DeleteType)NoopDDA;
-	DeleteFuncs[RT_WINDOW &amp; TypeMask] = DeleteWindow;
-	DeleteFuncs[RT_PIXMAP &amp; TypeMask] = dixDestroyPixmap;
-	DeleteFuncs[RT_GC &amp; TypeMask] = FreeGC;
-	DeleteFuncs[RT_FONT &amp; TypeMask] = CloseFont;
-	DeleteFuncs[RT_CURSOR &amp; TypeMask] = FreeCursor;
-	DeleteFuncs[RT_COLORMAP &amp; TypeMask] = FreeColormap;
-	DeleteFuncs[RT_CMAPENTRY &amp; TypeMask] = FreeClientPixels;
-	DeleteFuncs[RT_OTHERCLIENT &amp; TypeMask] = OtherClientGone;
-	DeleteFuncs[RT_PASSIVEGRAB &amp; TypeMask] = DeletePassiveGrab;
-
-#ifdef XResExtension
-        if(ResourceNames)
-            xfree(ResourceNames);
-        ResourceNames = xalloc((lastResourceType + 1) * sizeof(Atom));
-        if(!ResourceNames)
-           return FALSE;
-#endif
-    }
-    clientTable[i = client-&gt;index].resources =
-	(ResourcePtr *)xalloc(INITBUCKETS*sizeof(ResourcePtr));
-    if (!clientTable[i].resources)
-	return FALSE;
-    clientTable[i].buckets = INITBUCKETS;
-    clientTable[i].elements = 0;
-    clientTable[i].hashsize = INITHASHSIZE;
-    /* Many IDs allocated from the server client are visible to clients,
-     * so we don't use the SERVER_BIT for them, but we have to start
-     * past the magic value constants used in the protocol.  For normal
-     * clients, we can start from zero, with SERVER_BIT set.
-     */
-    clientTable[i].fakeID = client-&gt;clientAsMask |
-			    (client-&gt;index ? SERVER_BIT : SERVER_MINID);
-    clientTable[i].endFakeID = (clientTable[i].fakeID | RESOURCE_ID_MASK) + 1;
-    clientTable[i].expectID = client-&gt;clientAsMask;
-    for (j=0; j&lt;INITBUCKETS; j++) 
-    {
-        clientTable[i].resources[j] = NullResource;
-    }
-    return TRUE;
-}
-
-
-static int
-Hash(int client, register XID id)
-{
-    id &amp;= RESOURCE_ID_MASK;
-    switch (clientTable[client].hashsize)
-    {
-	case 6:
-	    return ((int)(0x03F &amp; (id ^ (id&gt;&gt;6) ^ (id&gt;&gt;12))));
-	case 7:
-	    return ((int)(0x07F &amp; (id ^ (id&gt;&gt;7) ^ (id&gt;&gt;13))));
-	case 8:
-	    return ((int)(0x0FF &amp; (id ^ (id&gt;&gt;8) ^ (id&gt;&gt;16))));
-	case 9:
-	    return ((int)(0x1FF &amp; (id ^ (id&gt;&gt;9))));
-	case 10:
-	    return ((int)(0x3FF &amp; (id ^ (id&gt;&gt;10))));
-	case 11:
-	    return ((int)(0x7FF &amp; (id ^ (id&gt;&gt;11))));
-    }
-    return -1;
-}
-
-static XID
-AvailableID(
-    register int client,
-    register XID id,
-    register XID maxid,
-    register XID goodid)
-{
-    register ResourcePtr res;
-
-    if ((goodid &gt;= id) &amp;&amp; (goodid &lt;= maxid))
-	return goodid;
-    for (; id &lt;= maxid; id++)
-    {
-	res = clientTable[client].resources[Hash(client, id)];
-	while (res &amp;&amp; (res-&gt;id != id))
-	    res = res-&gt;next;
-	if (!res)
-	    return id;
-    }
-    return 0;
-}
-
-void
-GetXIDRange(int client, Bool server, XID *minp, XID *maxp)
-{
-    register XID id, maxid;
-    register ResourcePtr *resp;
-    register ResourcePtr res;
-    register int i;
-    XID goodid;
-
-    id = (Mask)client &lt;&lt; CLIENTOFFSET;
-    if (server)
-	id |= client ? SERVER_BIT : SERVER_MINID;
-    maxid = id | RESOURCE_ID_MASK;
-    goodid = 0;
-    for (resp = clientTable[client].resources, i = clientTable[client].buckets;
-	 --i &gt;= 0;)
-    {
-	for (res = *resp++; res; res = res-&gt;next)
-	{
-	    if ((res-&gt;id &lt; id) || (res-&gt;id &gt; maxid))
-		continue;
-	    if (((res-&gt;id - id) &gt;= (maxid - res-&gt;id)) ?
-		(goodid = AvailableID(client, id, res-&gt;id - 1, goodid)) :
-		!(goodid = AvailableID(client, res-&gt;id + 1, maxid, goodid)))
-		maxid = res-&gt;id - 1;
-	    else
-		id = res-&gt;id + 1;
-	}
-    }
-    if (id &gt; maxid)
-	id = maxid = 0;
-    *minp = id;
-    *maxp = maxid;
-}
-
-/**
- *  GetXIDList is called by the XC-MISC extension's MiscGetXIDList function.
- *  This function tries to find count unused XIDs for the given client.  It 
- *  puts the IDs in the array pids and returns the number found, which should
- *  almost always be the number requested.
- *
- *  The circumstances that lead to a call to this function are very rare.
- *  Xlib must run out of IDs while trying to generate a request that wants
- *  multiple ID's, like the Multi-buffering CreateImageBuffers request.
- *
- *  No rocket science in the implementation; just iterate over all
- *  possible IDs for the given client and pick the first count IDs
- *  that aren't in use.  A more efficient algorithm could probably be
- *  invented, but this will be used so rarely that this should suffice.
- */
-
-unsigned int
-GetXIDList(ClientPtr pClient, unsigned count, XID *pids)
-{
-    unsigned int found = 0;
-    XID id = pClient-&gt;clientAsMask;
-    XID maxid;
-
-    maxid = id | RESOURCE_ID_MASK;
-    while ( (found &lt; count) &amp;&amp; (id &lt;= maxid) )
-    {
-	if (!LookupIDByClass(id, RC_ANY))
-	{
-	    pids[found++] = id;
-	}
-	id++;
-    }
-    return found;
-}
-
-/*
- * Return the next usable fake client ID.
- *
- * Normally this is just the next one in line, but if we've used the last
- * in the range, we need to find a new range of safe IDs to avoid
- * over-running another client.
- */
-
-XID
-FakeClientID(register int client)
-{
-    XID id, maxid;
-
-    id = clientTable[client].fakeID++;
-    if (id != clientTable[client].endFakeID)
-	return id;
-    GetXIDRange(client, TRUE, &amp;id, &amp;maxid);
-    if (!id) {
-	if (!client)
-	    FatalError(&quot;FakeClientID: server internal ids exhausted\n&quot;);
-	MarkClientException(clients[client]);
-	id = ((Mask)client &lt;&lt; CLIENTOFFSET) | (SERVER_BIT * 3);
-	maxid = id | RESOURCE_ID_MASK;
-    }
-    clientTable[client].fakeID = id + 1;
-    clientTable[client].endFakeID = maxid + 1;
-    return id;
-}
-
-#ifdef NXAGENT_SERVER
-
-int nxagentFindClientResource(int client, RESTYPE type, pointer value)
-{
-  ResourcePtr pResource;
-  ResourcePtr *resources;
-
-  int i;
-
-  for (i = 0; i &lt; clientTable[client].buckets; i++)
-  {
-    resources = clientTable[client].resources;
-
-    for (pResource = resources[i]; pResource; pResource = pResource -&gt; next)
-    {
-      if (pResource -&gt; type == type &amp;&amp; pResource -&gt; value == value)
-      {
-        #ifdef TEST
-        fprintf(stderr, &quot;nxagentFindClientResource: Found resource [%p] type [%lu] &quot;
-                    &quot;for client [%d].\n&quot;, (void *) value,
-                        pResource -&gt; type, client);
-        #endif
-
-        return 1;
-      }
-    }
-  }
-
-  return 0;
-}
-
-int nxagentSwitchResourceType(int client, RESTYPE type, pointer value)
-{
-  ResourcePtr pResource;
-  ResourcePtr *resources;
-
-  RESTYPE internalType = 0;
-
-  int i;
-
-  if (type == RT_PIXMAP)
-  {
-    internalType = RT_NX_PIXMAP;
-  }
-  else if (type == RT_GC)
-  {
-    internalType = RT_NX_GC;
-  }
-  else if (type == RT_FONT)
-  {
-    internalType = RT_NX_FONT;
-  }
-  else
-  {
-    return 0;
-  }
-
-  if (client == serverClient -&gt; index)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;nxagentSwitchResourceType: Requesting client is [%d]. Skipping the resource switch.\n&quot;,
-                client);
-    #endif
-
-    return 0;
-  }
-
-  for (i = 0; i &lt; clientTable[serverClient -&gt; index].buckets; i++)
-  {
-    resources = clientTable[serverClient -&gt; index].resources;
-
-    for (pResource = resources[i]; pResource; pResource = pResource -&gt; next)
-    {
-      if (pResource -&gt; type == internalType &amp;&amp;
-              pResource -&gt; value == value)
-      {
-        #ifdef TEST
-        fprintf(stderr, &quot;nxagentSwitchResourceType: Changing resource [%p] type from [%lu] to &quot;
-                    &quot;[%lu] for server client [%d].\n&quot;, (void *) value,
-                        (unsigned long) pResource -&gt; type, (unsigned long) type, serverClient -&gt; index);
-        #endif
-
-        FreeResource(pResource -&gt; id, RT_NONE);
-
-        return 1;
-      }
-    }
-  }
-
-  return 0;
-}
-
-#endif
-
-Bool
-AddResource(XID id, RESTYPE type, pointer value)
-{
-    int client;
-    register ClientResourceRec *rrec;
-    register ResourcePtr res, *head;
-
-    client = CLIENT_ID(id);
-    rrec = &amp;clientTable[client];
-    if (!rrec-&gt;buckets)
-    {
-	ErrorF(&quot;AddResource(%lx, %lx, %lx), client=%d \n&quot;,
-		(unsigned long)id, type, (unsigned long)value, client);
-        FatalError(&quot;client not in use\n&quot;);
-    }
-
-#ifdef NXAGENT_SERVER
-
-    nxagentSwitchResourceType(client, type, value);
-
-    #ifdef TEST
-    fprintf(stderr, &quot;AddResource: Adding resource for client [%d] type [%lu] value [%p] id [%lu].\n&quot;,
-                client, (unsigned long) type, (void *) value, (unsigned long) id);
-    #endif
-
-#endif
-
-    if ((rrec-&gt;elements &gt;= 4*rrec-&gt;buckets) &amp;&amp;
-	(rrec-&gt;hashsize &lt; MAXHASHSIZE))
-	RebuildTable(client);
-    head = &amp;rrec-&gt;resources[Hash(client, id)];
-    res = (ResourcePtr)xalloc(sizeof(ResourceRec));
-    if (!res)
-    {
-	(*DeleteFuncs[type &amp; TypeMask])(value, id);
-	return FALSE;
-    }
-    res-&gt;next = *head;
-    res-&gt;id = id;
-    res-&gt;type = type;
-    res-&gt;value = value;
-    *head = res;
-    rrec-&gt;elements++;
-    #ifdef NXAGENT_SERVER
-    nxagentResChangedFlag = 1;
-    #endif
-    if (!(id &amp; SERVER_BIT) &amp;&amp; (id &gt;= rrec-&gt;expectID))
-	rrec-&gt;expectID = id + 1;
-    return TRUE;
-}
-
-static void
-RebuildTable(int client)
-{
-    register int j;
-    register ResourcePtr res, next;
-    ResourcePtr **tails, *resources;
-    register ResourcePtr **tptr, *rptr;
-
-    /*
-     * For now, preserve insertion order, since some ddx layers depend
-     * on resources being free in the opposite order they are added.
-     */
-
-    j = 2 * clientTable[client].buckets;
-    tails = (ResourcePtr **)ALLOCATE_LOCAL(j * sizeof(ResourcePtr *));
-    if (!tails)
-	return;
-    resources = (ResourcePtr *)xalloc(j * sizeof(ResourcePtr));
-    if (!resources)
-    {
-	DEALLOCATE_LOCAL(tails);
-	return;
-    }
-    for (rptr = resources, tptr = tails; --j &gt;= 0; rptr++, tptr++)
-    {
-	*rptr = NullResource;
-	*tptr = rptr;
-    }
-    clientTable[client].hashsize++;
-    for (j = clientTable[client].buckets,
-	 rptr = clientTable[client].resources;
-	 --j &gt;= 0;
-	 rptr++)
-    {
-	for (res = *rptr; res; res = next)
-	{
-	    next = res-&gt;next;
-	    res-&gt;next = NullResource;
-	    tptr = &amp;tails[Hash(client, res-&gt;id)];
-	    **tptr = res;
-	    *tptr = &amp;res-&gt;next;
-	}
-    }
-    DEALLOCATE_LOCAL(tails);
-    clientTable[client].buckets *= 2;
-    xfree(clientTable[client].resources);
-    clientTable[client].resources = resources;
-}
-
-void
-FreeResource(XID id, RESTYPE skipDeleteFuncType)
-{
-    int		cid;
-    register    ResourcePtr res;
-    register	ResourcePtr *prev, *head;
-    register	int *eltptr;
-    int		elements;
-    Bool	gotOne = FALSE;
-
-#ifdef NXAGENT_SERVER
-
-    #ifdef TEST
-    fprintf(stderr, &quot;FreeResource: Freeing resource id [%lu].\n&quot;, (unsigned long) id);
-    #endif
-
-#endif
-
-    if (((cid = CLIENT_ID(id)) &lt; MAXCLIENTS) &amp;&amp; clientTable[cid].buckets)
-    {
-	head = &amp;clientTable[cid].resources[Hash(cid, id)];
-	eltptr = &amp;clientTable[cid].elements;
-
-	prev = head;
-	while ( (res = *prev) )
-	{
-	    if (res-&gt;id == id)
-	    {
-		RESTYPE rtype = res-&gt;type;
-		*prev = res-&gt;next;
-		elements = --*eltptr;
-                #ifdef NXAGENT_SERVER
-                nxagentResChangedFlag = 1;
-                #endif
-		if (rtype &amp; RC_CACHED)
-		    FlushClientCaches(res-&gt;id);
-		if (rtype != skipDeleteFuncType)
-		    (*DeleteFuncs[rtype &amp; TypeMask])(res-&gt;value, res-&gt;id);
-		xfree(res);
-		if (*eltptr != elements)
-		    prev = head; /* prev may no longer be valid */
-		gotOne = TRUE;
-	    }
-	    else
-		prev = &amp;res-&gt;next;
-        }
-	if(clients[cid] &amp;&amp; (id == clients[cid]-&gt;lastDrawableID))
-	{
-	    clients[cid]-&gt;lastDrawable = (DrawablePtr)WindowTable[0];
-	    clients[cid]-&gt;lastDrawableID = WindowTable[0]-&gt;drawable.id;
-	}
-    }
-    if (!gotOne)
-	ErrorF(&quot;Freeing resource id=%lX which isn't there.\n&quot;,
-		   (unsigned long)id);
-}
-
-
-void
-FreeResourceByType(XID id, RESTYPE type, Bool skipFree)
-{
-    int		cid;
-    register    ResourcePtr res;
-    register	ResourcePtr *prev, *head;
-    if (((cid = CLIENT_ID(id)) &lt; MAXCLIENTS) &amp;&amp; clientTable[cid].buckets)
-    {
-	head = &amp;clientTable[cid].resources[Hash(cid, id)];
-
-	prev = head;
-	while ( (res = *prev) )
-	{
-	    if (res-&gt;id == id &amp;&amp; res-&gt;type == type)
-	    {
-		*prev = res-&gt;next;
-                #ifdef NXAGENT_SERVER
-                nxagentResChangedFlag = 1;
-                #endif
-		if (type &amp; RC_CACHED)
-		    FlushClientCaches(res-&gt;id);
-		if (!skipFree)
-		    (*DeleteFuncs[type &amp; TypeMask])(res-&gt;value, res-&gt;id);
-		xfree(res);
-		break;
-	    }
-	    else
-		prev = &amp;res-&gt;next;
-        }
-	if(clients[cid] &amp;&amp; (id == clients[cid]-&gt;lastDrawableID))
-	{
-	    clients[cid]-&gt;lastDrawable = (DrawablePtr)WindowTable[0];
-	    clients[cid]-&gt;lastDrawableID = WindowTable[0]-&gt;drawable.id;
-	}
-    }
-}
-
-/*
- * Change the value associated with a resource id.  Caller
- * is responsible for &quot;doing the right thing&quot; with the old
- * data
- */
-
-Bool
-ChangeResourceValue (XID id, RESTYPE rtype, pointer value)
-{
-    int    cid;
-    register    ResourcePtr res;
-
-    if (((cid = CLIENT_ID(id)) &lt; MAXCLIENTS) &amp;&amp; clientTable[cid].buckets)
-    {
-	res = clientTable[cid].resources[Hash(cid, id)];
-
-	for (; res; res = res-&gt;next)
-	    if ((res-&gt;id == id) &amp;&amp; (res-&gt;type == rtype))
-	    {
-		if (rtype &amp; RC_CACHED)
-		    FlushClientCaches(res-&gt;id);
-		res-&gt;value = value;
-		return TRUE;
-	    }
-    }
-    return FALSE;
-}
-
-/* Note: if func adds or deletes resources, then func can get called
- * more than once for some resources.  If func adds new resources,
- * func might or might not get called for them.  func cannot both
- * add and delete an equal number of resources!
- */
-
-void
-FindClientResourcesByType(
-    ClientPtr client,
-    RESTYPE type,
-    FindResType func,
-    pointer cdata
-){
-    register ResourcePtr *resources;
-    register ResourcePtr this, next;
-    int i, elements;
-    register int *eltptr;
-
-    #ifdef NXAGENT_SERVER
-    register ResourcePtr **resptr;
-    #endif
-
-    if (!client)
-	client = serverClient;
-
-/*
- * If func triggers a resource table
- * rebuild then restart the loop.
- */
-
-#ifdef NXAGENT_SERVER
-RestartLoop:
-#endif
-
-    resources = clientTable[client-&gt;index].resources;
-
-    #ifdef NXAGENT_SERVER
-    resptr = &amp;clientTable[client-&gt;index].resources;
-    #endif
-
-    eltptr = &amp;clientTable[client-&gt;index].elements;
-    for (i = 0; i &lt; clientTable[client-&gt;index].buckets; i++) 
-    {
-        for (this = resources[i]; this; this = next)
-	{
-	    next = this-&gt;next;
-	    if (!type || this-&gt;type == type) {
-		elements = *eltptr;
-
-                /*
-                 * FIXME:
-                 * It is not safe to let a function change the resource
-                 * table we are reading!
-                 */
-
-                #ifdef NXAGENT_SERVER
-                nxagentResChangedFlag = 0;
-                #endif
-		(*func)(this-&gt;value, this-&gt;id, cdata);
-
-                /*
-                 * Avoid that a call to RebuildTable() could invalidate the
-                 * pointer. This is safe enough, because in RebuildTable()
-                 * the new pointer is allocated just before the old one is
-                 * freed, so it can't point to the same address.
-                 */
-
-                #ifdef NXAGENT_SERVER
-                if (*resptr != resources)
-                   goto RestartLoop;
-                #endif
-
-                /*
-                 * It's not enough to check if the number of elements has
-                 * changed, beacause it could happen that the number of
-                 * resources that have been added matches the number of
-                 * the freed ones.
-                 * 'nxagentResChangedFlag' is set if a resource has been
-                 * added or freed.
-                 */
-
-                #ifdef NXAGENT_SERVER
-                if (*eltptr != elements || nxagentResChangedFlag)
-                #else
-		if (*eltptr != elements)
-                #endif
-		    next = resources[i]; /* start over */
-	    }
-	}
-    }
-}
-
-void
-FindAllClientResources(
-    ClientPtr client,
-    FindAllRes func,
-    pointer cdata
-){
-    register ResourcePtr *resources;
-    register ResourcePtr this, next;
-    int i, elements;
-    register int *eltptr;
-
-    #ifdef NXAGENT_SERVER
-    register ResourcePtr **resptr;
-    #endif
-
-    if (!client)
-        client = serverClient;
-
-/*
- * If func triggers a resource table
- * rebuild then restart the loop.
- */
-
-#ifdef NXAGENT_SERVER
-RestartLoop:
-#endif
-
-    resources = clientTable[client-&gt;index].resources;
-
-    #ifdef NXAGENT_SERVER
-    resptr = &amp;clientTable[client-&gt;index].resources;
-    #endif
-
-    eltptr = &amp;clientTable[client-&gt;index].elements;
-    for (i = 0; i &lt; clientTable[client-&gt;index].buckets; i++)
-    {
-        for (this = resources[i]; this; this = next)
-        {
-            next = this-&gt;next;
-            elements = *eltptr;
-
-            /*
-             * FIXME:
-             * It is not safe to let a function change the resource
-             * table we are reading!
-             */
-
-            #ifdef NXAGENT_SERVER
-            nxagentResChangedFlag = 0;
-            #endif
-            (*func)(this-&gt;value, this-&gt;id, this-&gt;type, cdata);
-
-            /*
-             * Avoid that a call to RebuildTable() could invalidate the
-             * pointer. This is safe enough, because in RebuildTable()
-             * the new pointer is allocated just before the old one is
-             * freed, so it can't point to the same address.
-             */
-
-            #ifdef NXAGENT_SERVER
-            if (*resptr != resources)
-                goto RestartLoop;
-            #endif
-
-            /*
-             * It's not enough to check if the number of elements has
-             * changed, beacause it could happen that the number of
-             * resources that have been added matches the number of
-             * the freed ones.
-             * 'nxagentResChangedFlag' is set if a resource has been
-             * added or freed.
-             */
-
-            #ifdef NXAGENT_SERVER
-            if (*eltptr != elements || nxagentResChangedFlag)
-            #else
-            if (*eltptr != elements)
-            #endif
-                next = resources[i]; /* start over */
-        }
-    }
-}
-
-
-pointer
-LookupClientResourceComplex(
-    ClientPtr client,
-    RESTYPE type,
-    FindComplexResType func,
-    pointer cdata
-){
-    ResourcePtr *resources;
-    ResourcePtr this;
-    int i;
-
-    #ifdef NXAGENT_SERVER
-    ResourcePtr **resptr;
-    Bool res;
-    #endif
-
-    if (!client)
-	client = serverClient;
-
-/*
- * If func triggers a resource table
- * rebuild then restart the loop.
- */
-
-#ifdef NXAGENT_SERVER
-RestartLoop:
-#endif
-
-    resources = clientTable[client-&gt;index].resources;
-
-    #ifdef NXAGENT_SERVER
-    resptr = &amp;clientTable[client-&gt;index].resources;
-    #endif
-
-    for (i = 0; i &lt; clientTable[client-&gt;index].buckets; i++) {
-        for (this = resources[i]; this; this = this-&gt;next) {
-	    if (!type || this-&gt;type == type) {
-                #ifdef NXAGENT_SERVER
-                res = (*func)(this-&gt;value, this-&gt;id, cdata);
-
-                if (*resptr != resources)
-                    goto RestartLoop;
-
-                if (res)
-                    return this-&gt;value;
-                #else
-		if((*func)(this-&gt;value, this-&gt;id, cdata))
-		    return this-&gt;value;
-                #endif
-	    }
-	}
-    }
-    return NULL;
-}
-
-
-void
-FreeClientNeverRetainResources(ClientPtr client)
-{
-    ResourcePtr *resources;
-    ResourcePtr this;
-    ResourcePtr *prev;
-    int j;
-
-    if (!client)
-	return;
-
-    resources = clientTable[client-&gt;index].resources;
-    for (j=0; j &lt; clientTable[client-&gt;index].buckets; j++) 
-    {
-	prev = &amp;resources[j];
-        while ( (this = *prev) )
-	{
-	    RESTYPE rtype = this-&gt;type;
-	    if (rtype &amp; RC_NEVERRETAIN)
-	    {
-		*prev = this-&gt;next;
-		if (rtype &amp; RC_CACHED)
-		    FlushClientCaches(this-&gt;id);
-		(*DeleteFuncs[rtype &amp; TypeMask])(this-&gt;value, this-&gt;id);
-		xfree(this);	    
-	    }
-	    else
-		prev = &amp;this-&gt;next;
-	}
-    }
-}
-
-void
-FreeClientResources(ClientPtr client)
-{
-    register ResourcePtr *resources;
-    register ResourcePtr this;
-    int j;
-
-    /* This routine shouldn't be called with a null client, but just in
-	case ... */
-
-    if (!client)
-	return;
-
-    HandleSaveSet(client);
-
-    resources = clientTable[client-&gt;index].resources;
-    for (j=0; j &lt; clientTable[client-&gt;index].buckets; j++) 
-    {
-        /* It may seem silly to update the head of this resource list as
-	we delete the members, since the entire list will be deleted any way, 
-	but there are some resource deletion functions &quot;FreeClientPixels&quot; for 
-	one which do a LookupID on another resource id (a Colormap id in this
-	case), so the resource list must be kept valid up to the point that
-	it is deleted, so every time we delete a resource, we must update the
-	head, just like in FreeResource. I hope that this doesn't slow down
-	mass deletion appreciably. PRH */
-
-	ResourcePtr *head;
-
-	head = &amp;resources[j];
-
-        for (this = *head; this; this = *head)
-	{
-	    RESTYPE rtype = this-&gt;type;
-	    *head = this-&gt;next;
-	    if (rtype &amp; RC_CACHED)
-		FlushClientCaches(this-&gt;id);
-	    (*DeleteFuncs[rtype &amp; TypeMask])(this-&gt;value, this-&gt;id);
-	    xfree(this);	    
-	}
-    }
-    xfree(clientTable[client-&gt;index].resources);
-    clientTable[client-&gt;index].resources = NULL;
-    clientTable[client-&gt;index].buckets = 0;
-}
-
-void
-FreeAllResources()
-{
-    int	i;
-
-    for (i = currentMaxClients; --i &gt;= 0; ) 
-    {
-        if (clientTable[i].buckets) 
-	    FreeClientResources(clients[i]);
-    }
-}
-
-Bool
-LegalNewID(XID id, register ClientPtr client)
-{
-
-#ifdef PANORAMIX
-    XID 	minid, maxid;
-
-	if (!noPanoramiXExtension) { 
-	    minid = client-&gt;clientAsMask | (client-&gt;index ? 
-			                    SERVER_BIT : SERVER_MINID);
-	    maxid = (clientTable[client-&gt;index].fakeID | RESOURCE_ID_MASK) + 1;
-            if ((id &gt;= minid) &amp;&amp; (id &lt;= maxid))
-	        return TRUE;
-	}
-#endif /* PANORAMIX */
-	return ((client-&gt;clientAsMask == (id &amp; ~RESOURCE_ID_MASK)) &amp;&amp;
-	    ((clientTable[client-&gt;index].expectID &lt;= id) ||
-	     !LookupIDByClass(id, RC_ANY)));
-}
-
-#ifdef XCSECURITY
-
-/* SecurityLookupIDByType and SecurityLookupIDByClass:
- * These are the heart of the resource ID security system.  They take
- * two additional arguments compared to the old LookupID functions:
- * the client doing the lookup, and the access mode (see resource.h).
- * The resource is returned if it exists and the client is allowed access,
- * else NULL is returned.
- */
-
-pointer
-SecurityLookupIDByType(ClientPtr client, XID id, RESTYPE rtype, Mask mode)
-{
-    int    cid;
-    register    ResourcePtr res;
-    pointer retval = NULL;
-
-    assert(client == NullClient ||
-     (client-&gt;index &lt;= currentMaxClients &amp;&amp; clients[client-&gt;index] == client));
-    assert( (rtype &amp; TypeMask) &lt;= lastResourceType);
-
-    if (((cid = CLIENT_ID(id)) &lt; MAXCLIENTS) &amp;&amp;
-	clientTable[cid].buckets)
-    {
-	res = clientTable[cid].resources[Hash(cid, id)];
-
-	for (; res; res = res-&gt;next)
-	    if ((res-&gt;id == id) &amp;&amp; (res-&gt;type == rtype))
-	    {
-		retval = res-&gt;value;
-		break;
-	    }
-    }
-    if (retval &amp;&amp; client &amp;&amp; client-&gt;CheckAccess)
-	retval = (* client-&gt;CheckAccess)(client, id, rtype, mode, retval);
-    return retval;
-}
-
-
-pointer
-SecurityLookupIDByClass(ClientPtr client, XID id, RESTYPE classes, Mask mode)
-{
-    int    cid;
-    register ResourcePtr res = NULL;
-    pointer retval = NULL;
-
-    assert(client == NullClient ||
-     (client-&gt;index &lt;= currentMaxClients &amp;&amp; clients[client-&gt;index] == client));
-    assert (classes &gt;= lastResourceClass);
-
-    if (((cid = CLIENT_ID(id)) &lt; MAXCLIENTS) &amp;&amp;
-	clientTable[cid].buckets)
-    {
-	res = clientTable[cid].resources[Hash(cid, id)];
-
-	for (; res; res = res-&gt;next)
-	    if ((res-&gt;id == id) &amp;&amp; (res-&gt;type &amp; classes))
-	    {
-		retval = res-&gt;value;
-		break;
-	    }
-    }
-    if (retval &amp;&amp; client &amp;&amp; client-&gt;CheckAccess)
-	retval = (* client-&gt;CheckAccess)(client, id, res-&gt;type, mode, retval);
-    return retval;
-}
-
-/* We can't replace the LookupIDByType and LookupIDByClass functions with
- * macros because of compatibility with loadable servers.
- */
-
-pointer
-LookupIDByType(XID id, RESTYPE rtype)
-{
-    return SecurityLookupIDByType(NullClient, id, rtype,
-				  SecurityUnknownAccess);
-}
-
-pointer
-LookupIDByClass(XID id, RESTYPE classes)
-{
-    return SecurityLookupIDByClass(NullClient, id, classes,
-				   SecurityUnknownAccess);
-}
-
-#else /* not XCSECURITY */
-
-/*
- *  LookupIDByType returns the object with the given id and type, else NULL.
- */ 
-pointer
-LookupIDByType(XID id, RESTYPE rtype)
-{
-    int    cid;
-    register    ResourcePtr res;
-
-    if (((cid = CLIENT_ID(id)) &lt; MAXCLIENTS) &amp;&amp;
-	clientTable[cid].buckets)
-    {
-	res = clientTable[cid].resources[Hash(cid, id)];
-
-	for (; res; res = res-&gt;next)
-	    if ((res-&gt;id == id) &amp;&amp; (res-&gt;type == rtype))
-		return res-&gt;value;
-    }
-    return (pointer)NULL;
-}
-
-/*
- *  LookupIDByClass returns the object with the given id and any one of the
- *  given classes, else NULL.
- */ 
-pointer
-LookupIDByClass(XID id, RESTYPE classes)
-{
-    int    cid;
-    register    ResourcePtr res;
-
-    if (((cid = CLIENT_ID(id)) &lt; MAXCLIENTS) &amp;&amp;
-	clientTable[cid].buckets)
-    {
-	res = clientTable[cid].resources[Hash(cid, id)];
-
-	for (; res; res = res-&gt;next)
-	    if ((res-&gt;id == id) &amp;&amp; (res-&gt;type &amp; classes))
-		return res-&gt;value;
-    }
-    return (pointer)NULL;
-}
-
-#endif /* XCSECURITY */
-
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c
index e3e4f4b..a6d638e 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c
@@ -967,8 +967,17 @@ ProcShmPutImage(client)
         return BadValue;
     }
 
-    VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
-		   client);
+    /* 
+     * There's a potential integer overflow in this check:
+     * VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
+     *                client);
+     * the version below ought to avoid it
+     */
+    if (stuff-&gt;totalHeight != 0 &amp;&amp; 
+	length &gt; (shmdesc-&gt;size - stuff-&gt;offset)/stuff-&gt;totalHeight) {
+	client-&gt;errorValue = stuff-&gt;totalWidth;
+	return BadValue;
+    }
     if (stuff-&gt;srcX &gt; stuff-&gt;totalWidth)
     {
 	client-&gt;errorValue = stuff-&gt;srcX;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.NX.original
index e3e4f4b..a6d638e 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.NX.original
@@ -967,8 +967,17 @@ ProcShmPutImage(client)
         return BadValue;
     }
 
-    VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
-		   client);
+    /* 
+     * There's a potential integer overflow in this check:
+     * VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
+     *                client);
+     * the version below ought to avoid it
+     */
+    if (stuff-&gt;totalHeight != 0 &amp;&amp; 
+	length &gt; (shmdesc-&gt;size - stuff-&gt;offset)/stuff-&gt;totalHeight) {
+	client-&gt;errorValue = stuff-&gt;totalWidth;
+	return BadValue;
+    }
     if (stuff-&gt;srcX &gt; stuff-&gt;totalWidth)
     {
 	client-&gt;errorValue = stuff-&gt;srcX;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.X.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.X.original
index e2cf8cd..f25bb9b 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.X.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXshm.c.X.original
@@ -863,8 +863,17 @@ ProcShmPutImage(client)
         return BadValue;
     }
 
-    VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
-		   client);
+    /* 
+     * There's a potential integer overflow in this check:
+     * VERIFY_SHMSIZE(shmdesc, stuff-&gt;offset, length * stuff-&gt;totalHeight,
+     *                client);
+     * the version below ought to avoid it
+     */
+    if (stuff-&gt;totalHeight != 0 &amp;&amp; 
+	length &gt; (shmdesc-&gt;size - stuff-&gt;offset)/stuff-&gt;totalHeight) {
+	client-&gt;errorValue = stuff-&gt;totalWidth;
+	return BadValue;
+    }
     if (stuff-&gt;srcX &gt; stuff-&gt;totalWidth)
     {
 	client-&gt;errorValue = stuff-&gt;srcX;


hooks/post-receive
-- 
nx-libs.git (NX (redistributed))

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;nx-libs.git&quot; (NX (redistributed)).

</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011324.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-10
</A></li>
	<LI>Next message: <A HREF="011330.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.2.0-5
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11326">[ date ]</a>
              <a href="thread.html#11326">[ thread ]</a>
              <a href="subject.html#11326">[ subject ]</a>
              <a href="author.html#11326">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2Go-commits
mailing list</a><br>
</body></html>
