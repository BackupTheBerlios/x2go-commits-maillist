<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2Go-Commits] nx-libs.git - build-main (branch) updated:	edddbe8765d46b5040fdde7b04eeee8e21282114
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2013-August/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-main%20%28branch%29%20updated%3A%0A%09edddbe8765d46b5040fdde7b04eeee8e21282114&In-Reply-To=%3C20130830142158.785485DB20%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011318.html">
   <LINK REL="Next"  HREF="011325.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2Go-Commits] nx-libs.git - build-main (branch) updated:	edddbe8765d46b5040fdde7b04eeee8e21282114</H1>
    <B>X2Go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-main%20%28branch%29%20updated%3A%0A%09edddbe8765d46b5040fdde7b04eeee8e21282114&In-Reply-To=%3C20130830142158.785485DB20%40ymir%3E"
       TITLE="[X2Go-Commits] nx-libs.git - build-main (branch) updated:	edddbe8765d46b5040fdde7b04eeee8e21282114">git-admin at x2go.org
       </A><BR>
    <I>Fri Aug 30 16:21:58 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="011318.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxauth/3.4.0-3
</A></li>
        <LI>Next message: <A HREF="011325.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.1.0-6
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11322">[ date ]</a>
              <a href="thread.html#11322">[ thread ]</a>
              <a href="subject.html#11322">[ subject ]</a>
              <a href="author.html#11322">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, build-main has been updated
  discards  caf1bc41f931009e24c28a18a7311da03b68961c (commit)
  discards  fea16d7bb7802ec2c37feed970f8ee47851fb587 (commit)
  discards  d90fd5d13f13672c1b338f60fb47b576548b6f10 (commit)
  discards  7881dac529532980624772400397d1eb08fc05a4 (commit)
  discards  c76c0783513ccd861db64aa8786f2b1c905c1d85 (commit)
  discards  76b9f2d9104af9ee21a71ae7351deb89558390b6 (commit)
  discards  9610c1e727c1f1b09a1289df8d37f393dd043993 (commit)
  discards  e5c70dac0c5b4e13cf5337936aa754c66e822335 (commit)
       via  edddbe8765d46b5040fdde7b04eeee8e21282114 (commit)

This update added new revisions after undoing existing revisions.  That is
to say, the old revision is not a strict subset of the new revision.  This
situation occurs when you --force push a change and generate a repository
containing something like this:

 * -- * -- B -- O -- O -- O (caf1bc41f931009e24c28a18a7311da03b68961c)
            \
             N -- N -- N (edddbe8765d46b5040fdde7b04eeee8e21282114)

When this happens we assume that you've already had alert emails for all
of the O revisions, and so we here report only the revisions in the N
branch from the common base, B.

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
-----------------------------------------------------------------------

Summary of changes:
 nx-X11/programs/nxauth/CHANGELOG  |  108 ---
 nx-X11/programs/nxauth/COPYING    |  339 -------
 nx-X11/programs/nxauth/Imakefile  |   38 -
 nx-X11/programs/nxauth/LICENSE    |   26 -
 nx-X11/programs/nxauth/gethost.c  |  287 ------
 nx-X11/programs/nxauth/nxauth.man |  236 -----
 nx-X11/programs/nxauth/parsedpy.c |  259 -----
 nx-X11/programs/nxauth/process.c  | 1872 -------------------------------------
 nx-X11/programs/nxauth/xauth.c    |  184 ----
 nx-X11/programs/nxauth/xauth.h    |   58 --
 10 files changed, 3407 deletions(-)
 delete mode 100644 nx-X11/programs/nxauth/CHANGELOG
 delete mode 100644 nx-X11/programs/nxauth/COPYING
 delete mode 100644 nx-X11/programs/nxauth/Imakefile
 delete mode 100644 nx-X11/programs/nxauth/LICENSE
 delete mode 100644 nx-X11/programs/nxauth/gethost.c
 delete mode 100644 nx-X11/programs/nxauth/nxauth.man
 delete mode 100644 nx-X11/programs/nxauth/parsedpy.c
 delete mode 100644 nx-X11/programs/nxauth/process.c
 delete mode 100644 nx-X11/programs/nxauth/xauth.c
 delete mode 100644 nx-X11/programs/nxauth/xauth.h

The diff of changes is:
diff --git a/nx-X11/programs/nxauth/CHANGELOG b/nx-X11/programs/nxauth/CHANGELOG
deleted file mode 100644
index 9faf9eb..0000000
--- a/nx-X11/programs/nxauth/CHANGELOG
+++ /dev/null
@@ -1,108 +0,0 @@
-ChangeLog:
-
-nxauth-3.5.0-1
-
-- Opened the 3.5.0 branch based on nxauth-3.4.0-3.
-
-- Updated copyright to year 2011.
-
-nxauth-3.4.0-3
-
-- Updated the launchd socket detection to support OSX versions relea-
-  sed so far.
-
-nxauth-3.4.0-2
-
-- Updated copyright to year 2010.
-
-nxauth-3.4.0-1
-
-- Opened the 3.4.0 branch based on nxauth-3.3.0-1.
-
-- Updated copyright to year 2009.
-
-nxauth-3.3.0-1
-
-- Opened the 3.3.0 branch based on nxauth-3.2.0-1.
-
-nxauth-3.2.0-1
-
-- Opened the 3.2.0 branch based on nxauth-3.1.0-2.
-
-nxauth-3.1.0-2
-
-- Added support for launchd socket.
-
-nxauth-3.1.0-1
-
-- Opened the 3.1.0 branch based on nxauth-3.0.0-6.
-
-nxauth-3.0.0-6
-
-- Updated the NoMachine copyright notice.
-
-nxauth-3.0.0-5
-
-- Changed the copyright attribution from Medialogic to NoMachine.
-
-nxauth-3.0.0-4
-
-- Changed the LICENSE file to state that the software is only made
-  available under the version 2 of the GPL.
-
-- Added file COPYING.
-
-nxauth-3.0.0-3
-
-- Updated copyright notices to year 2007.
-
-nxauth-3.0.0-2
-
-- Imported changes up to nxauth-2.1.0-1.
-
-- Ignoring lock on '.Xauthority' file.
-
-- Using '__CYGWIN__' definition in process.c. 'WIN32' is not defined
-  during compilation under nx-X11 and wrong code block is used to 
-  rename xauth temporary file.
-
-nxauth-3.0.0-1
-
-- Opened the 3.0.0 branch based on nxauth-2.0.0-2.
-
-nxauth-2.0.0-2
-
-- Updated the NoMachine copyright notices.
-
-nxauth-2.0.0-1
-
-- Opened the 2.0.0 branch based on the 1.6.0-1.
-
-nxauth-1.6.0-1
-
-- Opened the 1.6.0 branch based on nxauth-1.5.0-1.
-
-nxauth-1.5.0-1
-
-- Opened the 1.5.0 branch.
-
-nxauth-1.4.1-1
-
-- Opened the 1.4.1 branch.
-
-nxauth-1.4.0-2
-
-- Removed debug message 'host name is'.
-
-nxauth-1.4.0-1
-
-- Opened the 1.4.0 branch based on nxauth-1.3.2-1.
-
-nxauth-1.3.2-1
-
-- Opened the 1.3.2 branch.
-
-nxauth-1.3.1-2
-
-- Fixed problem with compilation on systems without 
-  X11 includes instaled.
diff --git a/nx-X11/programs/nxauth/COPYING b/nx-X11/programs/nxauth/COPYING
deleted file mode 100644
index d511905..0000000
--- a/nx-X11/programs/nxauth/COPYING
+++ /dev/null
@@ -1,339 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The &quot;Program&quot;, below,
-refers to any such program or work, and a &quot;work based on the Program&quot;
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term &quot;modification&quot;.)  Each licensee is addressed as &quot;you&quot;.
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and &quot;any
-later version&quot;, you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the &quot;copyright&quot; line and a pointer to where the full notice is found.
-
-    &lt;one line to give the program's name and a brief idea of what it does.&gt;
-    Copyright (C) &lt;year&gt;  &lt;name of author&gt;
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a &quot;copyright disclaimer&quot; for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  &lt;signature of Ty Coon&gt;, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.
diff --git a/nx-X11/programs/nxauth/Imakefile b/nx-X11/programs/nxauth/Imakefile
deleted file mode 100644
index 07b1ca7..0000000
--- a/nx-X11/programs/nxauth/Imakefile
+++ /dev/null
@@ -1,38 +0,0 @@
-XCOMM $Xorg: Imakefile,v 1.3 2000/08/17 19:54:11 cpqbld Exp $
-
-
-
-
-XCOMM $XFree86: xc/programs/xauth/Imakefile,v 3.5 2001/03/30 02:15:23 keithp Exp $
-
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2010 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXAUTH, NX protocol compression and NX extensions to this software     */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
-/*                                                                        */
-/* All rights reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-/* LOCAL_LIBRARIES = $(DESTDIR)$(SHLIBDIR)/libXau.a */
-
-
-  INCLUDES=-I../../lib
-  DEPLIBS = $(DEPXAUTHLIB)
-  LOCAL_LIBRARIES = ../../exports/lib/libXau.a
-           SRCS = xauth.c gethost.c process.c parsedpy.c
-           OBJS = xauth.o gethost.o process.o parsedpy.o
-   CONN_DEFINES = $(CONNECTION_FLAGS)
-
-ComplexProgramTarget(nxauth)
-
-SpecialCObjectRule(gethost,$(ICONFIGFILES),$(CONN_DEFINES) $(SIGNAL_DEFINES))
-SpecialCObjectRule(process,$(ICONFIGFILES),$(SIGNAL_DEFINES))
-SpecialCObjectRule(parsedpy,$(ICONFIGFILES),$(CONN_DEFINES))
diff --git a/nx-X11/programs/nxauth/LICENSE b/nx-X11/programs/nxauth/LICENSE
deleted file mode 100644
index 626b9c5..0000000
--- a/nx-X11/programs/nxauth/LICENSE
+++ /dev/null
@@ -1,26 +0,0 @@
-Copyright (c) 2001, 2010 NoMachine - <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>
-
-NXAUTH and NX extensions to X are copyright of NoMachine.
-
-Redistribution and use of this software is allowed according to the
-following terms:
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License Version 2, and
-not any other version, as published by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTA-
-BILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
-Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, you can request a copy to NoMachine
-or write to the Free Software Foundation, Inc., 59 Temple Place,
-Suite 330, Boston, MA  02111-1307 USA
-
-Parts of this software are derived from XFree86 project. Other copy-
-rights and the MIT/X11 license applies to different sources. Please
-check the applicable copyrights in each file or subdirectory. 
-
-All rights reserved.
diff --git a/nx-X11/programs/nxauth/gethost.c b/nx-X11/programs/nxauth/gethost.c
deleted file mode 100644
index cab2aea..0000000
--- a/nx-X11/programs/nxauth/gethost.c
+++ /dev/null
@@ -1,287 +0,0 @@
-/*
- * $Xorg: gethost.c,v 1.5 2001/02/09 02:05:38 xorgcvs Exp $
- *
- * 
-Copyright 1989, 1998  The Open Group
-
-Permission to use, copy, modify, distribute, and sell this software and its
-documentation for any purpose is hereby granted without fee, provided that
-the above copyright notice appear in all copies and that both that
-copyright notice and this permission notice appear in supporting
-documentation.
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of The Open Group shall not be
-used in advertising or otherwise to promote the sale, use or other dealings
-in this Software without prior written authorization from The Open Group.
- * *
- * Author:  Jim Fulton, MIT X Consortium
- */
-
-/* $XFree86: xc/programs/xauth/gethost.c,v 3.16 2001/12/14 20:01:14 dawes Exp $ */
-
-/* sorry, streams support does not really work yet */
-#if defined(STREAMSCONN) &amp;&amp; defined(SVR4)
-#undef STREAMSCONN
-#define TCPCONN
-#endif
-
-#ifdef WIN32
-#include &lt;X11/Xwinsock.h&gt;
-#define EPROTOTYPE WSAEPROTOTYPE
-#endif
-#include &lt;X11/X.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;setjmp.h&gt;
-#include &lt;ctype.h&gt;
-#ifndef __TYPES__
-#include &lt;sys/types.h&gt;
-#define __TYPES__
-#endif
-#ifndef WIN32
-#ifndef STREAMSCONN
-#ifndef Lynx
-#include &lt;sys/socket.h&gt;
-#else
-#include &lt;socket.h&gt;
-#endif
-#include &lt;netdb.h&gt;
-#include &lt;netinet/in.h&gt;
-#include &lt;arpa/inet.h&gt;
-#ifdef SYSV
-#ifdef i386
-#ifndef sco
-#include &lt;net/errno.h&gt;
-#endif /* !sco */
-#endif /* i386 */
-#endif /* SYSV */
-#endif /* !STREAMSCONN */
-#endif /* !WIN32 */
-#include &lt;errno.h&gt;
-#include &quot;xauth.h&quot;
-
-#ifdef DNETCONN
-#include &lt;netdnet/dn.h&gt;
-#include &lt;netdnet/dnetdb.h&gt;
-#endif
-
-#ifdef SIGALRM
-Bool nameserver_timedout = False;
-
-
-/*
- * get_hostname - Given an internet address, return a name (CHARON.MIT.EDU)
- * or a string representing the address (18.58.0.13) if the name cannot
- * be found.  Stolen from xhost.
- */
-
-static jmp_buf env;
-static 
-#ifdef SIGNALRETURNSINT
-int
-#else
-void
-#endif
-nameserver_lost(int sig)
-{
-  nameserver_timedout = True;
-  longjmp (env, -1);
-  /* NOTREACHED */
-#ifdef SIGNALRETURNSINT
-  return -1;				/* for picky compilers */
-#endif
-}
-#endif
-
-char *
-get_hostname (auth)
-    Xauth *auth;
-{
-    static struct hostent *hp = NULL;
-#ifdef DNETCONN
-    struct nodeent *np;
-    static char nodeaddr[4 + 2 * DN_MAXADDL];
-#endif /* DNETCONN */
-
-    if (auth-&gt;address_length == 0)
-	return &quot;Illegal Address&quot;;
-#ifdef TCPCONN
-    if (auth-&gt;family == FamilyInternet) {
-#ifdef SIGALRM
-	/* gethostbyaddr can take a LONG time if the host does not exist.
-	   Assume that if it does not respond in NAMESERVER_TIMEOUT seconds
-	   that something is wrong and do not make the user wait.
-	   gethostbyaddr will continue after a signal, so we have to
-	   jump out of it. 
-	   */
-	nameserver_timedout = False;
-	signal (SIGALRM, nameserver_lost);
-	alarm (4);
-	if (setjmp(env) == 0) {
-#endif
-	    hp = gethostbyaddr (auth-&gt;address, auth-&gt;address_length, AF_INET);
-#ifdef SIGALRM
-	}
-	alarm (0);
-#endif
-	if (hp)
-	  return (hp-&gt;h_name);
-	else
-	  return (inet_ntoa(*((struct in_addr *)(auth-&gt;address))));
-    }
-#endif
-#ifdef DNETCONN
-    if (auth-&gt;family == FamilyDECnet) {
-	struct dn_naddr *addr_ptr = (struct dn_naddr *) auth-&gt;address;
-
-	if (np = getnodebyaddr(addr_ptr-&gt;a_addr, addr_ptr-&gt;a_len, AF_DECnet)) {
-	    sprintf(nodeaddr, &quot;%s:&quot;, np-&gt;n_name);
-	} else {
-	    sprintf(nodeaddr, &quot;%s:&quot;, dnet_htoa(auth-&gt;address));
-	}
-	return(nodeaddr);
-    }
-#endif
-
-    return (NULL);
-}
-
-#ifdef TCPCONN
-/*
- * cribbed from lib/X/XConnDis.c
- */
-static Bool 
-get_inet_address(char *name, unsigned int *resultp)
-{
-    unsigned int hostinetaddr = inet_addr (name);
-    struct hostent *host_ptr;
-    struct sockaddr_in inaddr;		/* dummy variable for size calcs */
-
-#ifndef INADDR_NONE
-#define INADDR_NONE -1
-#endif
-
-    if (hostinetaddr == INADDR_NONE) {
-	if ((host_ptr = gethostbyname (name)) == NULL) {
-	    /* No such host! */
-	    errno = EINVAL;
-	    return False;
-	}
-	/* Check the address type for an internet host. */
-	if (host_ptr-&gt;h_addrtype != AF_INET) {
-	    /* Not an Internet host! */
-	    errno = EPROTOTYPE;
-	    return False;
-	}
- 
-	memmove( (char *)&amp;hostinetaddr, (char *)host_ptr-&gt;h_addr, 
-	      sizeof(inaddr.sin_addr));
-    }
-    *resultp = hostinetaddr;
-    return True;
-}
-#endif
-
-#ifdef DNETCONN
-static Bool get_dnet_address (name, resultp)
-    char *name;
-    struct dn_naddr *resultp;
-{
-    struct dn_naddr *dnaddrp, dnaddr;
-    struct nodeent *np;
-
-    if (dnaddrp = dnet_addr (name)) {	/* stolen from xhost */
-	dnaddr = *dnaddrp;
-    } else {
-	if ((np = getnodebyname (name)) == NULL) return False;
-	dnaddr.a_len = np-&gt;n_length;
-	memmove( dnaddr.a_addr, np-&gt;n_addr, np-&gt;n_length);
-    }
-    *resultp = dnaddr;
-    return True;
-}
-#endif
-
-char *get_address_info (family, fulldpyname, prefix, host, lenp)
-    int family;
-    char *fulldpyname;
-    int prefix;
-    char *host;
-    int *lenp;
-{
-    char *retval = NULL;
-    int len = 0;
-    char *src = NULL;
-#ifdef TCPCONN
-    unsigned int hostinetaddr;
-#endif
-#ifdef DNETCONN
-    struct dn_naddr dnaddr;
-#endif
-    char buf[255];
-
-    /*
-     * based on the family, set the pointer src to the start of the address
-     * information to be copied and set len to the number of bytes.
-     */
-    switch (family) {
-      case FamilyLocal:			/* hostname/unix:0 */
-					/* handle unix:0 and :0 specially */
-	if (prefix == 0 &amp;&amp; (strncmp (fulldpyname, &quot;unix:&quot;, 5) == 0 ||
-			    fulldpyname[0] == ':')) {
-
-	    if (!get_local_hostname (buf, sizeof buf)) {
-		len = 0;
-	    } else {
-		src = buf;
-		len = strlen (buf);
-	    }
-	} else {
-	    src = fulldpyname;
-	    len = prefix;
-	}
-	break;
-      case FamilyInternet:		/* host:0 */
-#ifdef TCPCONN
-	if (!get_inet_address (host, &amp;hostinetaddr)) return NULL;
-	src = (char *) &hostinetaddr;
-	len = 4; /* sizeof inaddr.sin_addr, would fail on Cray */
-	break;
-#else
-	return NULL;
-#endif
-      case FamilyDECnet:		/* host::0 */
-#ifdef DNETCONN
-	if (!get_dnet_address (host, &amp;dnaddr)) return NULL;
-	src = (char *) &dnaddr;
-	len = (sizeof dnaddr);
-	break;
-#else
-	/* fall through since we don't have code for it */
-#endif
-      default:
-	src = NULL;
-	len = 0;
-    }
-
-    /*
-     * if source was provided, allocate space and copy it
-     */
-    if (len == 0 || !src) return NULL;
-
-    retval = malloc (len);
-    if (retval) {
-	memmove( retval, src, len);
-	*lenp = len;
-    }
-    return retval;
-}
diff --git a/nx-X11/programs/nxauth/nxauth.man b/nx-X11/programs/nxauth/nxauth.man
deleted file mode 100644
index a414afa..0000000
--- a/nx-X11/programs/nxauth/nxauth.man
+++ /dev/null
@@ -1,236 +0,0 @@
-.\&quot; $Xorg: xauth.man,v 1.4 2001/02/09 02:05:38 xorgcvs Exp $
-.\&quot; Copyright 1993, 1998  The Open Group
-.\&quot; 
-.\&quot; Permission to use, copy, modify, distribute, and sell this software and its
-.\&quot; documentation for any purpose is hereby granted without fee, provided that
-.\&quot; the above copyright notice appear in all copies and that both that
-.\&quot; copyright notice and this permission notice appear in supporting
-.\&quot; documentation.
-.\&quot; 
-.\&quot; The above copyright notice and this permission notice shall be included
-.\&quot; in all copies or substantial portions of the Software.
-.\&quot; 
-.\&quot; THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
-.\&quot; OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-.\&quot; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-.\&quot; IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
-.\&quot; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-.\&quot; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-.\&quot; OTHER DEALINGS IN THE SOFTWARE.
-.\&quot; 
-.\&quot; Except as contained in this notice, the name of The Open Group shall
-.\&quot; not be used in advertising or otherwise to promote the sale, use or
-.\&quot; other dealings in this Software without prior written authorization
-.\&quot; from The Open Group.
-.\&quot;
-.\&quot; $XFree86: xc/programs/xauth/xauth.man,v 1.7 2001/12/14 20:01:15 dawes Exp $
-.\&quot;
-.TH XAUTH 1 __xorgversion__
-.SH NAME
-xauth \- X authority file utility
-.SH SYNOPSIS
-.B xauth
-[ \fB\-f\fP \fIauthfile\fP ] [ \fB\-vqib\fP ] [ \fIcommand arg ...\fP ]
-.SH DESCRIPTION
-.PP
-The \fIxauth\fP program is used to edit and display the authorization 
-information used in connecting to the X server.  This program is usually
-used to extract authorization records from one machine and merge them in on 
-another (as is the case when using remote logins or granting access to
-other users).  Commands (described below) may be entered interactively,
-on the \fIxauth\fP command line, or in scripts.  Note that this program
-does \fBnot\fP contact the X server except when the generate command is used.
-Normally \fIxauth\fP is not used to create the authority file entry in
-the first place; \fIxdm\fP does that.
-.SH OPTIONS
-The following options may be used with \fIxauth\fP.  They may be given 
-individually (e.g., \fI\-q \-i\|\fP) or may combined (e.g., \fI\-qi\|\fP).
-.TP 8
-.B &quot;\-f \fIauthfile\fP&quot;
-This option specifies the name of the authority file to use.  By default,
-\fIxauth\fP will use the file specified by the XAUTHORITY environment variable
-or \fI\.Xauthority\fP in the user's home directory.
-.TP 8
-.B \-q
-This option indicates that \fIxauth\fP should operate quietly and not print
-unsolicited status messages.  This is the default if an \fIxauth\fP command is
-is given on the command line or if the standard output is not directed to a
-terminal.
-.TP 8
-.B \-v
-This option indicates that \fIxauth\fP should operate verbosely and print
-status messages indicating the results of various operations (e.g., how many
-records have been read in or written out).  This is the default if \fIxauth\fP
-is reading commands from its standard input and its standard output is
-directed to a terminal.
-.TP 8
-.B \-i
-This option indicates that \fIxauth\fP should ignore any authority file
-locks.  Normally, \fIxauth\fP will refuse to read or edit any authority files
-that have been locked by other programs (usually \fIxdm\fP or another 
-\fIxauth\fP).
-.TP 8
-.B \-b
-This option indicates that \fIxauth\fP should attempt to break any authority
-file locks before proceeding.  Use this option only to clean up stale locks.
-.SH COMMANDS
-The following commands may be used to manipulate authority files:
-.TP 8
-.B &quot;add \fIdisplayname protocolname hexkey&quot;
-An authorization entry for the indicated display using the given protocol
-and key data is added to the authorization file.  The data is specified as
-an even-lengthed string of hexadecimal digits, each pair representing 
-one octet.  The first digit of each pair gives the most significant 4 bits
-of the octet, and the second digit of the pair gives the least significant 4
-bits.  For example, a 32 character hexkey would represent a 128-bit value.
-A protocol name consisting of just a 
-single period is treated as an abbreviation for \fIMIT-MAGIC-COOKIE-1\fP.
-
-.TP 8
-.B &quot;generate \fIdisplayname protocolname\fP \fR[\fPtrusted|untrusted\fR]\fP&quot;
-.B \fR[\fPtimeout \fIseconds\fP\fR]\fP  \fR[\fPgroup \fIgroup-id\fP\fR]\fP \fR[\fBdata \fIhexdata\fR]
-
-This command is similar to add.  The main difference is that instead
-of requiring the user to supply the key data, it connects to the
-server specified in \fIdisplayname\fP and uses the SECURITY extension
-in order to get the key data to store in the authorization file.  If
-the server cannot be contacted or if it does not support the SECURITY
-extension, the command fails.  Otherwise, an authorization entry for
-the indicated display using the given protocol is added to the
-authorization file.  A protocol name consisting of just a single
-period is treated as an abbreviation for \fIMIT-MAGIC-COOKIE-1\fP.
-
-If the \fBtrusted\fP option is used, clients that connect using this
-authorization will have full run of the display, as usual.  If
-\fBuntrusted\fP is used, clients that connect using this authorization
-will be considered untrusted and prevented from stealing or tampering
-with data belonging to trusted clients.  See the SECURITY extension
-specification for full details on the restrictions imposed on
-untrusted clients.  The default is \fBuntrusted\fP.
-
-The \fBtimeout\fP option specifies how long in seconds this
-authorization will be valid.  If the authorization remains unused (no
-clients are connected with it) for longer than this time period, the
-server purges the authorization, and future attempts to connect using
-it will fail.  Note that the purging done by the server does \fBnot\fP
-delete the authorization entry from the authorization file.  The
-default timeout is 60 seconds.
-
-The \fBgroup\fP option specifies the application group that clients
-connecting with this authorization should belong to.  See the
-application group extension specification for more details.  The
-default is to not belong to an application group.
-
-The \fBdata\fP option specifies data that the server should use to
-generate the authorization.  Note that this is \fBnot\fP the same data
-that gets written to the authorization file.  The interpretation of
-this data depends on the authorization protocol.  The \fIhexdata\fP is
-in the same format as the \fIhexkey\fP described in the add command.
-The default is to send no data.
-
-.TP 8
-.B &quot;[n]extract \fIfilename displayname...&quot;
-Authorization entries for each of the specified displays are written to the 
-indicated file.  If the \fInextract\fP command is used, the entries are written
-in a numeric format suitable for non-binary transmission (such as secure
-electronic mail).  The extracted entries can be read back in using the 
-\fImerge\fP and \fInmerge\fP commands.  If the filename consists of 
-just a single dash, the entries will be written to the standard output.
-.TP 8
-.B &quot;[n]list \fR[\fIdisplayname\fP...]&quot;
-Authorization entries for each of the specified displays (or all if no
-displays are named) are printed on the standard output.  If the \fInlist\fP
-command is used, entries will be shown in the numeric format used by 
-the \fInextract\fP command; otherwise, they are shown in a textual format.
-Key data is always displayed in the hexadecimal format given in the
-description of the \fIadd\fP command.
-.TP 8
-.B &quot;[n]merge \fR[\fIfilename\fP...]&quot;
-Authorization entries are read from the specified files and are merged into
-the authorization database, superceding any matching existing entries. If
-the \fInmerge\fP command is used, the numeric format given in the description
-of the \fIextract\fP command is used.  If a filename consists of just a single
-dash, the standard input will be read if it hasn't been read before.
-.TP 8
-.B &quot;remove \fIdisplayname\fR...&quot;
-Authorization entries matching the specified displays are removed from the
-authority file.
-.TP 8
-.B &quot;source \fIfilename&quot;
-The specified file is treated as a script containing \fIxauth\fP commands
-to execute.  Blank lines and lines beginning with a sharp sign (#) are 
-ignored.  A single dash may be used to indicate the standard input, if it
-hasn't already been read.
-.TP 8
-.B &quot;info&quot;
-Information describing the authorization file, whether or not any changes
-have been made, and from where \fIxauth\fP commands are being read
-is printed on the standard output. 
-.TP 8
-.B &quot;exit&quot;
-If any modifications have been made, the authority file is written out (if
-allowed), and the program exits.  An end of file is treated as an implicit
-\fIexit\fP command.
-.TP 8
-.B &quot;quit&quot;
-The program exits, ignoring any modifications.  This may also be accomplished
-by pressing the interrupt character.
-.TP 8
-.B &quot;help [\fIstring\fP]&quot;
-A description of all commands that begin with the given string (or all
-commands if no string is given) is printed on the standard output.
-.TP 8
-.B &quot;?&quot;
-A short list of the valid commands is printed on the standard output.
-.SH &quot;DISPLAY NAMES&quot;
-Display names for the \fIadd\fP, \fI[n]extract\fP, \fI[n]list\fP,
-\fI[n]merge\fP, and \fIremove\fP commands use the same format as the
-DISPLAY environment variable and the common \fI\-display\fP command line
-argument.  Display-specific information (such as the screen number)
-is unnecessary and will be ignored.
-Same-machine connections (such as local-host sockets,
-shared memory, and the Internet Protocol hostname \fIlocalhost\fP) are 
-referred to as \fIhostname\fP/unix:\fIdisplaynumber\fP so that
-local entries for different machines may be stored in one authority file.
-.SH EXAMPLE
-.PP
-The most common use for \fIxauth\fP is to extract the entry for the 
-current display, copy it to another machine, and merge it into the 
-user's authority file on the remote machine:
-.sp
-.nf
-        %  xauth extract \- $DISPLAY | rsh otherhost xauth merge \-
-.fi
-.PP
-.sp
-The following command contacts the server :0 to create an
-authorization using the MIT-MAGIC-COOKIE-1 protocol.  Clients that
-connect with this authorization will be untrusted.
-.nf
-	%  xauth generate :0 .
-.fi
-.SH ENVIRONMENT
-This \fIxauth\fP program uses the following environment variables:
-.TP 8
-.B XAUTHORITY
-to get the name of the authority file to use if the \fI\-f\fP option isn't
-used.
-.TP 8
-.B HOME
-to get the user's home directory if XAUTHORITY isn't defined.
-.SH FILES
-.TP 8
-.I $HOME/.Xauthority
-default authority file if XAUTHORITY isn't defined.
-.SH BUGS
-.PP
-Users that have unsecure networks should take care to use encrypted 
-file transfer mechanisms to copy authorization entries between machines.  
-Similarly, the \fIMIT-MAGIC-COOKIE-1\fP protocol is not very useful in
-unsecure environments.  Sites that are interested in additional security
-may need to use encrypted authorization mechanisms such as Kerberos.
-.PP
-Spaces are currently not allowed in the protocol name.  Quoting could be
-added for the truly perverse.
-.SH AUTHOR
-Jim Fulton, MIT X Consortium
diff --git a/nx-X11/programs/nxauth/parsedpy.c b/nx-X11/programs/nxauth/parsedpy.c
deleted file mode 100644
index 8ce4681..0000000
--- a/nx-X11/programs/nxauth/parsedpy.c
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
- * $Xorg: parsedpy.c,v 1.4 2001/02/09 02:05:38 xorgcvs Exp $
- *
- * parse_displayname - utility routine for splitting up display name strings
- *
- * 
-Copyright 1989, 1998  The Open Group
-
-Permission to use, copy, modify, distribute, and sell this software and its
-documentation for any purpose is hereby granted without fee, provided that
-the above copyright notice appear in all copies and that both that
-copyright notice and this permission notice appear in supporting
-documentation.
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of The Open Group shall not be
-used in advertising or otherwise to promote the sale, use or other dealings
-in this Software without prior written authorization from The Open Group.
- * *
- * Author:  Jim Fulton, MIT X Consortium
- */
-
-/* $XFree86: xc/programs/xauth/parsedpy.c,v 3.6 2001/12/14 20:01:15 dawes Exp $ */
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2010 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXAUTH, NX protocol compression and NX extensions to this software     */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
-/*                                                                        */
-/* All rights reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &lt;stdio.h&gt;			/* for NULL */
-#include &lt;ctype.h&gt;			/* for isascii() and isdigit() */
-#include &lt;X11/Xos.h&gt;			/* for strchr() and string routines */
-#include &lt;X11/Xlib.h&gt;			/* for Family contants */
-#ifdef hpux
-#include &lt;sys/utsname.h&gt;		/* for struct utsname */
-#endif
-#include &lt;X11/Xauth.h&gt;			/* for FamilyLocal */
-
-#if defined(UNIXCONN) || defined(LOCALCONN)
-#define UNIX_CONNECTION &quot;unix&quot;
-#define UNIX_CONNECTION_LENGTH 4
-#endif
-
-#include &lt;stdlib.h&gt;
-#include &quot;xauth.h&quot;
-
-#define PANIC
-#define WARNING
-#undef  TEST
-#undef  DEBUG
-
-/*
- * private utility routines
- */
-
-char *
-copystring (char *src, int len)
-{
-    char *cp;
-
-    if (!src &amp;&amp; len != 0) return NULL;
-    cp = malloc (len + 1);
-    if (cp) {
-	if (src) strncpy (cp, src, len);
-	cp[len] = '\0';
-    }
-    return cp;
-}
-
-
-char *
-get_local_hostname (char *buf, int maxlen)
-{
-    buf[0] = '\0';
-/*
-    (void) XmuGetHostname (buf, maxlen);
-*/    
-    /*FIXME*/
-     
-    (void) gethostname (buf, maxlen);
-    
-    buf [maxlen - 1] = '\0';
-
-    #ifdef TEST
-    printf(&quot;get_local_hostname: Host name is %s&quot;, buf);
-    #endif
-
-    return (buf[0] ? buf : NULL);
-}
-
-#ifndef UNIXCONN
-static char *
-copyhostname (void)
-{
-    char buf[256];
-
-    return (get_local_hostname (buf, sizeof buf) ? 
-	    copystring (buf, strlen (buf)) : NULL);
-}
-#endif
-
-/*
- * parse_displayname - display a display string up into its component parts
- */
-Bool 
-parse_displayname (char *displayname, 
-		   int *familyp,	/* return */
-		   char **hostp,	/* return */
-		   int *dpynump,	/* return */
-		   int *scrnump,	/* return */
-		   char **restp)	/* return */
-{
-    char *ptr;				/* work variables */
-    int len;				/* work variable */
-    int family = -1;			/* value to be returned */
-    char *host = NULL;			/* must free if set and error return */
-    int dpynum = -1;			/* value to be returned */
-    int scrnum = 0;			/* value to be returned */
-    char *rest = NULL;			/* must free if set and error return */
-    Bool dnet = False;			/* if true then using DECnet */
-
-					/* check the name */
-    if (!displayname || !displayname[0]) return False;
-
-					/* must have at least :number */
-    ptr = strchr(displayname, ':');
-    if (!ptr || !ptr[1]) return False;
-    if (ptr[1] == ':') {
-	if (ptr[2] == '\0') return False;
-	dnet = True;
-    }
-
-
-    /*
-     * get the host string; if none is given, use the most effiecient path
-     */
-
-    len = (ptr - displayname);	/* length of host name */
-    if (len == 0) {			/* choose most efficient path */
-#if defined(UNIXCONN) || defined(LOCALCONN)
-	host = copystring (UNIX_CONNECTION, UNIX_CONNECTION_LENGTH);
-	family = FamilyLocal;
-#else
-	if (dnet) {
-	    host = copystring (&quot;0&quot;, 1);
-	    family = FamilyDECnet;
-	} else {
-	    host = copyhostname ();
-	    family = FamilyInternet;
-	}
-#endif
-    } else {
-	host = copystring (displayname, len);
-	if (dnet) {
-	    family = dnet;
-	} else {
-#if defined(UNIXCONN) || defined(LOCALCONN)
-	    if (host &amp;&amp; strcmp (host, UNIX_CONNECTION) == 0)
-	      family = FamilyLocal;
-	    else
-#endif
-	      family = FamilyInternet;
-	}
-    }
-
-    if (!host) return False;
-
-
-    /*
-     * get the display number; we know that there is something after the
-     * colon (or colons) from above.  note that host is now set and must
-     * be freed if there is an error.
-     */
-
-    if (dnet) ptr++;			/* skip the extra DECnet colon */
-    ptr++;				/* move to start of display num */
-    {
-	register char *cp;
-
-	for (cp = ptr; *cp &amp;&amp; isascii(*cp) &amp;&amp; isdigit(*cp); cp++) ;
-	len = (cp - ptr);
-					/* check present and valid follow */
-	if (len == 0 || (*cp &amp;&amp; *cp != '.')) {
-	    free (host);
-	    return False;
-	}
-	
-	dpynum = atoi (ptr);		/* it will handle num. as well */
-	ptr = cp;
-    }
-
-    /*
-     * now get screen number if given; ptr may point to nul at this point
-     */
-    if (ptr[0] == '.') {
-	register char *cp;
-
-	ptr++;
-	for (cp = ptr; *cp &amp;&amp; isascii(*cp) &amp;&amp; isdigit(*cp); cp++) ;
-	len = (cp - ptr);
-	if (len == 0 || (*cp &amp;&amp; *cp != '.')) {	/* all prop name */
-	    free (host);
-	    return False;
-	}
-
-	scrnum = atoi (ptr);		/* it will handle num. as well */
-	ptr = cp;
-    }
-
-    /*
-     * and finally, get any additional stuff that might be following the
-     * the screen number; ptr must point to a period if there is anything
-     */
-
-    if (ptr[0] == '.') {
-	ptr++;
-	len = strlen (ptr);
-	if (len &gt; 0) {
-	    rest = copystring (ptr, len);
-	    if (!rest) {
-		free (host);
-		return False;
-	    }
-	}
-    }
-
-    /*
-     * and we are done!
-     */
-
-    *familyp = family;
-    *hostp = host;
-    *dpynump = dpynum;
-    *scrnump = scrnum;
-    *restp = rest;
-    return True;
-}
-
-	    
diff --git a/nx-X11/programs/nxauth/process.c b/nx-X11/programs/nxauth/process.c
deleted file mode 100644
index 57090e2..0000000
--- a/nx-X11/programs/nxauth/process.c
+++ /dev/null
@@ -1,1872 +0,0 @@
-/* $Xorg: process.c,v 1.6 2001/02/09 02:05:38 xorgcvs Exp $ */
-/*
-
-Copyright 1989, 1998  The Open Group
-
-Permission to use, copy, modify, distribute, and sell this software and its
-documentation for any purpose is hereby granted without fee, provided that
-the above copyright notice appear in all copies and that both that
-copyright notice and this permission notice appear in supporting
-documentation.
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
-OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of The Open Group shall
-not be used in advertising or otherwise to promote the sale, use or
-other dealings in this Software without prior written authorization
-from The Open Group.
-
-*/
-/* $XFree86: xc/programs/xauth/process.c,v 3.18 2003/02/13 02:50:22 dawes Exp $ */
-
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2010 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXAUTH, NX protocol compression and NX extensions to this software     */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
-/*                                                                        */
-/* All rights reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-/*
- * Author:  Jim Fulton, MIT X Consortium
- */
-
-#include &quot;xauth.h&quot;
-#include &lt;ctype.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;sys/stat.h&gt;
-
-#include &lt;signal.h&gt;
-/*#include &lt;X11/X.h&gt;*/			/* for Family constants */
-/*
-#include &lt;X11/Xlib.h&gt;
-#include &lt;X11/extensions/security.h&gt;
-*/
-
-/*FIXME*/
-#define FamilyInternet              0  
-#define FamilyDECnet                1
-
-extern Bool naneserver_timedout;
-
-#ifndef DEFAULT_PROTOCOL_ABBREV		/* to make add command easier */
-#define DEFAULT_PROTOCOL_ABBREV &quot;.&quot;
-#endif
-#ifndef DEFAULT_PROTOCOL		/* for protocol abbreviation */
-#define DEFAULT_PROTOCOL &quot;MIT-MAGIC-COOKIE-1&quot;
-#endif
-
-#define SECURERPC &quot;SUN-DES-1&quot;
-#define K5AUTH &quot;MIT-KERBEROS-5&quot;
-
-#define XAUTH_DEFAULT_RETRIES 10	/* number of competitors we expect */
-#define XAUTH_DEFAULT_TIMEOUT 2		/* in seconds, be quick */
-#define XAUTH_DEFAULT_DEADTIME 600L	/* 10 minutes in seconds */
-
-typedef struct _AuthList {		/* linked list of entries */
-    struct _AuthList *next;
-    Xauth *auth;
-} AuthList;
-
-typedef int (*ProcessFunc)(char *, int, int, char**);
-
-#define add_to_list(h,t,e) {if (t) (t)-&gt;next = (e); else (h) = (e); (t) = (e);}
-
-typedef struct _CommandTable {		/* commands that are understood */
-    char *name;				/* full name */
-    int minlen;				/* unique prefix */
-    int maxlen;				/* strlen(name) */
-    ProcessFunc processfunc;		/* handler */
-    char *helptext;			/* what to print for help */
-} CommandTable;
-
-struct _extract_data {			/* for iterating */
-    FILE *fp;				/* input source */
-    char *filename;			/* name of input */
-    Bool used_stdout;			/* whether or not need to close */
-    Bool numeric;			/* format in which to write */
-    int nwritten;			/* number of entries written */
-    char *cmd;				/* for error messages */
-};
-
-struct _list_data {			/* for iterating */
-    FILE *fp;				/* output file */
-    Bool numeric;			/* format in which to write */
-};
-
-
-/*
- * private data
- */
-static char *stdin_filename = &quot;(stdin)&quot;;  /* for messages */
-static char *stdout_filename = &quot;(stdout)&quot;;  /* for messages */
-static char *Yes = &quot;yes&quot;;		/* for messages */
-static char *No = &quot;no&quot;;			/* for messages */
-
-static int do_help ( char *inputfilename, int lineno, int argc, char **argv );
-static int do_questionmark ( char *inputfilename, int lineno, int argc, char **argv );
-static int do_list ( char *inputfilename, int lineno, int argc, char **argv );
-static int do_merge ( char *inputfilename, int lineno, int argc, char **argv );
-static int do_extract ( char *inputfilename, int lineno, int argc, char **argv );
-static int do_add ( char *inputfilename, int lineno, int argc, char **argv );
-static int do_remove ( char *inputfilename, int lineno, int argc, char **argv );
-static int do_info ( char *inputfilename, int lineno, int argc, char **argv );
-static int do_exit ( char *inputfilename, int lineno, int argc, char **argv );
-static int do_quit ( char *inputfilename, int lineno, int argc, char **argv );
-static int do_source ( char *inputfilename, int lineno, int argc, char **argv );
-/*
-static int do_generate ( char *inputfilename, int lineno, int argc, char **argv );
-*/
-static CommandTable command_table[] = {	/* table of known commands */
-    { &quot;add&quot;,      2, 3, do_add,
-	&quot;add dpyname protoname hexkey   add entry&quot; },
-    { &quot;exit&quot;,     3, 4, do_exit,
-	&quot;exit                           save changes and exit program&quot; },
-    { &quot;extract&quot;,  3, 7, do_extract,
-	&quot;extract filename dpyname...    extract entries into file&quot; },
-    { &quot;help&quot;,     1, 4, do_help,
-	&quot;help [topic]                   print help&quot; },
-    { &quot;info&quot;,     1, 4, do_info,
-	&quot;info                           print information about entries&quot; },
-    { &quot;list&quot;,     1, 4, do_list,
-	&quot;list [dpyname...]              list entries&quot; },
-    { &quot;merge&quot;,    1, 5, do_merge,
-	&quot;merge filename...              merge entries from files&quot; },
-    { &quot;nextract&quot;, 2, 8, do_extract,
-	&quot;nextract filename dpyname...   numerically extract entries&quot; },
-    { &quot;nlist&quot;,    2, 5, do_list,
-	&quot;nlist [dpyname...]             numerically list entries&quot; },
-    { &quot;nmerge&quot;,   2, 6, do_merge,
-	&quot;nmerge filename...             numerically merge entries&quot; },
-    { &quot;quit&quot;,     1, 4, do_quit,
-	&quot;quit                           abort changes and exit program&quot; },
-    { &quot;remove&quot;,   1, 6, do_remove,
-	&quot;remove dpyname...              remove entries&quot; },
-    { &quot;source&quot;,   1, 6, do_source,
-	&quot;source filename                read commands from file&quot; },
-    { &quot;?&quot;,        1, 1, do_questionmark,
-	&quot;?                              list available commands&quot; },
-/*    { &quot;generate&quot;, 1, 8, do_generate,
-	&quot;generate dpyname protoname [options]  use server to generate entry\n&quot; 
-        &quot;    options are:\n&quot;
-        &quot;      timeout n    authorization expiration time in seconds\n&quot;
-        &quot;      trusted      clients using this entry are trusted\n&quot;
-        &quot;      untrusted    clients using this entry are untrusted\n&quot;
-        &quot;      group n      clients using this entry belong to application group n\n&quot;
-        &quot;      data hexkey  auth protocol specific data needed to generate the entry\n&quot;
-    }, */
-    { NULL,       0, 0, NULL, NULL },
-};
-
-#define COMMAND_NAMES_PADDED_WIDTH 10	/* wider than anything above */
-
-
-static Bool okay_to_use_stdin = True;	/* set to false after using */
-
-static char *hex_table[] = {		/* for printing hex digits */
-    &quot;00&quot;, &quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, 
-    &quot;08&quot;, &quot;09&quot;, &quot;0a&quot;, &quot;0b&quot;, &quot;0c&quot;, &quot;0d&quot;, &quot;0e&quot;, &quot;0f&quot;, 
-    &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, 
-    &quot;18&quot;, &quot;19&quot;, &quot;1a&quot;, &quot;1b&quot;, &quot;1c&quot;, &quot;1d&quot;, &quot;1e&quot;, &quot;1f&quot;, 
-    &quot;20&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26&quot;, &quot;27&quot;, 
-    &quot;28&quot;, &quot;29&quot;, &quot;2a&quot;, &quot;2b&quot;, &quot;2c&quot;, &quot;2d&quot;, &quot;2e&quot;, &quot;2f&quot;, 
-    &quot;30&quot;, &quot;31&quot;, &quot;32&quot;, &quot;33&quot;, &quot;34&quot;, &quot;35&quot;, &quot;36&quot;, &quot;37&quot;, 
-    &quot;38&quot;, &quot;39&quot;, &quot;3a&quot;, &quot;3b&quot;, &quot;3c&quot;, &quot;3d&quot;, &quot;3e&quot;, &quot;3f&quot;, 
-    &quot;40&quot;, &quot;41&quot;, &quot;42&quot;, &quot;43&quot;, &quot;44&quot;, &quot;45&quot;, &quot;46&quot;, &quot;47&quot;, 
-    &quot;48&quot;, &quot;49&quot;, &quot;4a&quot;, &quot;4b&quot;, &quot;4c&quot;, &quot;4d&quot;, &quot;4e&quot;, &quot;4f&quot;, 
-    &quot;50&quot;, &quot;51&quot;, &quot;52&quot;, &quot;53&quot;, &quot;54&quot;, &quot;55&quot;, &quot;56&quot;, &quot;57&quot;, 
-    &quot;58&quot;, &quot;59&quot;, &quot;5a&quot;, &quot;5b&quot;, &quot;5c&quot;, &quot;5d&quot;, &quot;5e&quot;, &quot;5f&quot;, 
-    &quot;60&quot;, &quot;61&quot;, &quot;62&quot;, &quot;63&quot;, &quot;64&quot;, &quot;65&quot;, &quot;66&quot;, &quot;67&quot;, 
-    &quot;68&quot;, &quot;69&quot;, &quot;6a&quot;, &quot;6b&quot;, &quot;6c&quot;, &quot;6d&quot;, &quot;6e&quot;, &quot;6f&quot;, 
-    &quot;70&quot;, &quot;71&quot;, &quot;72&quot;, &quot;73&quot;, &quot;74&quot;, &quot;75&quot;, &quot;76&quot;, &quot;77&quot;, 
-    &quot;78&quot;, &quot;79&quot;, &quot;7a&quot;, &quot;7b&quot;, &quot;7c&quot;, &quot;7d&quot;, &quot;7e&quot;, &quot;7f&quot;, 
-    &quot;80&quot;, &quot;81&quot;, &quot;82&quot;, &quot;83&quot;, &quot;84&quot;, &quot;85&quot;, &quot;86&quot;, &quot;87&quot;, 
-    &quot;88&quot;, &quot;89&quot;, &quot;8a&quot;, &quot;8b&quot;, &quot;8c&quot;, &quot;8d&quot;, &quot;8e&quot;, &quot;8f&quot;, 
-    &quot;90&quot;, &quot;91&quot;, &quot;92&quot;, &quot;93&quot;, &quot;94&quot;, &quot;95&quot;, &quot;96&quot;, &quot;97&quot;, 
-    &quot;98&quot;, &quot;99&quot;, &quot;9a&quot;, &quot;9b&quot;, &quot;9c&quot;, &quot;9d&quot;, &quot;9e&quot;, &quot;9f&quot;, 
-    &quot;a0&quot;, &quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;, &quot;a5&quot;, &quot;a6&quot;, &quot;a7&quot;, 
-    &quot;a8&quot;, &quot;a9&quot;, &quot;aa&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, 
-    &quot;b0&quot;, &quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;, &quot;b5&quot;, &quot;b6&quot;, &quot;b7&quot;, 
-    &quot;b8&quot;, &quot;b9&quot;, &quot;ba&quot;, &quot;bb&quot;, &quot;bc&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, 
-    &quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;, &quot;c4&quot;, &quot;c5&quot;, &quot;c6&quot;, &quot;c7&quot;, 
-    &quot;c8&quot;, &quot;c9&quot;, &quot;ca&quot;, &quot;cb&quot;, &quot;cc&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;, 
-    &quot;d0&quot;, &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot;, &quot;d5&quot;, &quot;d6&quot;, &quot;d7&quot;, 
-    &quot;d8&quot;, &quot;d9&quot;, &quot;da&quot;, &quot;db&quot;, &quot;dc&quot;, &quot;dd&quot;, &quot;de&quot;, &quot;df&quot;, 
-    &quot;e0&quot;, &quot;e1&quot;, &quot;e2&quot;, &quot;e3&quot;, &quot;e4&quot;, &quot;e5&quot;, &quot;e6&quot;, &quot;e7&quot;, 
-    &quot;e8&quot;, &quot;e9&quot;, &quot;ea&quot;, &quot;eb&quot;, &quot;ec&quot;, &quot;ed&quot;, &quot;ee&quot;, &quot;ef&quot;, 
-    &quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;, &quot;f3&quot;, &quot;f4&quot;, &quot;f5&quot;, &quot;f6&quot;, &quot;f7&quot;, 
-    &quot;f8&quot;, &quot;f9&quot;, &quot;fa&quot;, &quot;fb&quot;, &quot;fc&quot;, &quot;fd&quot;, &quot;fe&quot;, &quot;ff&quot;, 
-};
-
-static unsigned int hexvalues[256];	/* for parsing hex input */
-
-static int original_umask = 0;		/* for restoring */
-
-
-/*
- * private utility procedures
- */
-
-static void 
-prefix(char *fn, int n)
-{
-    fprintf (stderr, &quot;%s: %s:%d:  &quot;, ProgramName, fn, n);
-}
-
-static void 
-baddisplayname(char *dpy, char *cmd)
-{
-    fprintf (stderr, &quot;bad display name \&quot;%s\&quot; in \&quot;%s\&quot; command\n&quot;,
-	     dpy, cmd);
-}
-
-static void 
-badcommandline(char *cmd)
-{
-    fprintf (stderr, &quot;bad \&quot;%s\&quot; command line\n&quot;, cmd);
-}
-
-static char *
-skip_space(register char *s)
-{
-    if (!s) return NULL;
-
-    for ( ; *s &amp;&amp; isascii(*s) &amp;&amp; isspace(*s); s++)
-	;
-    return s;
-}
-
-
-static char *
-skip_nonspace(register char *s)
-{
-    if (!s) return NULL;
-
-    /* put quoting into loop if need be */
-    for ( ; *s &amp;&amp; isascii(*s) &amp;&amp; !isspace(*s); s++)
-	;
-    return s;
-}
-
-static char **
-split_into_words(char *src, int *argcp)  /* argvify string */
-{
-    char *jword;
-    char savec;
-    char **argv;
-    int cur, total;
-
-    *argcp = 0;
-#define WORDSTOALLOC 4			/* most lines are short */
-    argv = (char **) malloc (WORDSTOALLOC * sizeof (char *));
-    if (!argv) return NULL;
-    cur = 0;
-    total = WORDSTOALLOC;
-
-    /*
-     * split the line up into separate, nul-terminated tokens; the last
-     * &quot;token&quot; will point to the empty string so that it can be bashed into
-     * a null pointer.
-     */
-
-    do {
-	jword = skip_space (src);
-	src = skip_nonspace (jword);
-	savec = *src;
-	*src = '\0';
-	if (cur == total) {
-	    total += WORDSTOALLOC;
-	    argv = (char **) realloc (argv, total * sizeof (char *));
-	    if (!argv) return NULL;
-	}
-	argv[cur++] = jword;
-	if (savec) src++;		/* if not last on line advance */
-    } while (jword != src);
-
-    argv[--cur] = NULL;			/* smash empty token to end list */
-    *argcp = cur;
-    return argv;
-}
-
-
-static FILE *
-open_file(char **filenamep, 
-	  char *mode, 
-	  Bool *usedstdp, 
-	  char *srcfn, 
-	  int srcln, 
-	  char *cmd)
-{
-    FILE *fp;
-
-    if (strcmp (*filenamep, &quot;-&quot;) == 0) {
-	*usedstdp = True;
-					/* select std descriptor to use */
-	if (mode[0] == 'r') {
-	    if (okay_to_use_stdin) {
-		okay_to_use_stdin = False;
-		*filenamep = stdin_filename;
-		return stdin;
-	    } else {
-		prefix (srcfn, srcln);
-		fprintf (stderr, &quot;%s:  stdin already in use\n&quot;, cmd);
-		return NULL;
-	    }
-	} else {
-	    *filenamep = stdout_filename;
-	    return stdout;		/* always okay to use stdout */
-	}
-    }
-
-    fp = fopen (*filenamep, mode);
-    if (!fp) {
-	prefix (srcfn, srcln);
-	fprintf (stderr, &quot;%s:  unable to open file %s\n&quot;, cmd, *filenamep);
-    }
-    return fp;
-}
-
-static int 
-getinput(FILE *fp)
-{
-    register int c;
-
-    while ((c = getc (fp)) != EOF &amp;&amp; isascii(c) &amp;&amp; c != '\n' &amp;&amp; isspace(c)) ;
-    return c;
-}
-
-static int 
-get_short(FILE *fp, unsigned short *sp)	/* for reading numeric input */
-{
-    int c;
-    int i;
-    unsigned short us = 0;
-
-    /*
-     * read family:  written with %04x
-     */
-    for (i = 0; i &lt; 4; i++) {
-	switch (c = getinput (fp)) {
-	  case EOF:
-	  case '\n':
-	    return 0;
-	}
-	if (c &lt; 0 || c &gt; 255) return 0;
-	us = (us * 16) + hexvalues[c];	/* since msb */
-    }
-    *sp = us;
-    return 1;
-}
-
-static int
-get_bytes(FILE *fp, unsigned int n, char **ptr)	/* for reading numeric input */
-{
-    char *s;
-    register char *cp;
-    int c1, c2;
-
-    cp = s = malloc (n);
-    if (!cp) return 0;
-
-    while (n &gt; 0) {
-	if ((c1 = getinput (fp)) == EOF || c1 == '\n' ||
-	    (c2 = getinput (fp)) == EOF || c2 == '\n') {
-	    free (s);
-	    return 0;
-	}
-	*cp = (char) ((hexvalues[c1] * 16) + hexvalues[c2]);
-	cp++;
-	n--;
-    }
-
-    *ptr = s;
-    return 1;
-}
-
-
-static Xauth *
-read_numeric(FILE *fp)
-{
-    Xauth *auth;
-
-    auth = (Xauth *) malloc (sizeof (Xauth));
-    if (!auth) goto bad;
-    auth-&gt;family = 0;
-    auth-&gt;address = NULL;
-    auth-&gt;address_length = 0;
-    auth-&gt;number = NULL;
-    auth-&gt;number_length = 0;
-    auth-&gt;name = NULL;
-    auth-&gt;name_length = 0;
-    auth-&gt;data = NULL;
-    auth-&gt;data_length = 0;
-
-    if (!get_short (fp, (unsigned short *) &amp;auth-&gt;family))
-      goto bad;
-    if (!get_short (fp, (unsigned short *) &amp;auth-&gt;address_length))
-      goto bad;
-    if (!get_bytes (fp, (unsigned int) auth-&gt;address_length, &amp;auth-&gt;address))
-      goto bad;
-    if (!get_short (fp, (unsigned short *) &amp;auth-&gt;number_length))
-      goto bad;
-    if (!get_bytes (fp, (unsigned int) auth-&gt;number_length, &amp;auth-&gt;number))
-      goto bad;
-    if (!get_short (fp, (unsigned short *) &amp;auth-&gt;name_length))
-      goto bad;
-    if (!get_bytes (fp, (unsigned int) auth-&gt;name_length, &amp;auth-&gt;name))
-      goto bad;
-    if (!get_short (fp, (unsigned short *) &amp;auth-&gt;data_length))
-      goto bad;
-    if (!get_bytes (fp, (unsigned int) auth-&gt;data_length, &amp;auth-&gt;data))
-      goto bad;
-    
-    switch (getinput (fp)) {		/* get end of line */
-      case EOF:
-      case '\n':
-	return auth;
-    }
-
-  bad:
-    if (auth) XauDisposeAuth (auth);	/* won't free null pointers */
-    return NULL;
-}
-
-typedef Xauth *(*ReadFunc)(FILE *);
-
-static int 
-read_auth_entries(FILE *fp, Bool numeric, AuthList **headp, AuthList **tailp)
-{
-    ReadFunc readfunc = (numeric ? read_numeric : XauReadAuth);
-    Xauth *auth;
-    AuthList *head, *tail;
-    int n;
-
-    head = tail = NULL;
-    n = 0;
-					/* put all records into linked list */
-    while ((auth = ((*readfunc) (fp))) != NULL) {
-	AuthList *l = (AuthList *) malloc (sizeof (AuthList));
-	if (!l) {
-	    fprintf (stderr,
-		     &quot;%s:  unable to alloc entry reading auth file\n&quot;,
-		     ProgramName);
-	    exit (1);
-	}
-	l-&gt;next = NULL;
-	l-&gt;auth = auth;
-	if (tail) 			/* if not first time through append */
-	  tail-&gt;next = l;
-	else
-	  head = l;			/* first time through, so assign */
-	tail = l;
-	n++;
-    }
-    *headp = head;
-    *tailp = tail;
-    return n;
-}
-
-static Bool 
-get_displayname_auth(char *displayname, Xauth *auth)
-{
-    int family;
-    char *host = NULL, *rest = NULL;
-    int dpynum, scrnum;
-    char *cp;
-    int len;
-    Xauth proto;
-    int prelen = 0;
-
-    /*
-     * check to see if the display name is of the form &quot;host/unix:&quot;
-     * which is how the list routine prints out local connections
-     */
-    cp = strchr(displayname, '/');
-    if (cp &amp;&amp; strncmp (cp, &quot;/unix:&quot;, 6) == 0)
-      prelen = (cp - displayname);
-
-    #ifdef __APPLE__
-
-    /*
-     * FIXME: This is an attempt to get the right
-     * cookie, because no one can grant that the
-     * X server is running on the display number
-     * reported in the launchd display name.
-     */
-
-    if (strncmp (displayname, &quot;/tmp/launch&quot;, 11) == 0)
-      displayname = strrchr(displayname, ':');
-
-    #endif
-
-    if (!parse_displayname (displayname + ((prelen &gt; 0) ? prelen + 1 : 0),
-			    &amp;family, &amp;host, &amp;dpynum, &amp;scrnum, &amp;rest)) {
-	return False;
-    }
-
-    proto.family = family;
-    proto.address = get_address_info (family, displayname, prelen, host, &amp;len);
-    if (proto.address) {
-	char buf[40];			/* want to hold largest display num */
-
-	proto.address_length = len;
-	buf[0] = '\0';
-	sprintf (buf, &quot;%d&quot;, dpynum);
-	proto.number_length = strlen (buf);
-	if (proto.number_length &lt;= 0) {
-	    free (proto.address);
-	    proto.address = NULL;
-	} else {
-	    proto.number = copystring (buf, proto.number_length);
-	}
-    }
-
-    if (host) free (host);
-    if (rest) free (rest);
-
-    if (proto.address) {
-	auth-&gt;family = proto.family;
-	auth-&gt;address = proto.address;
-	auth-&gt;address_length = proto.address_length;
-	auth-&gt;number = proto.number;
-	auth-&gt;number_length = proto.number_length;
-	auth-&gt;name = NULL;
-	auth-&gt;name_length = 0;
-	auth-&gt;data = NULL;
-	auth-&gt;data_length = 0;
-	return True;
-    } else {
-	return False;
-    }
-}
-
-static int 
-cvthexkey(char *hexstr, char **ptrp)	/* turn hex key string into octets */
-{
-    int i;
-    int len = 0;
-    char *retval, *s;
-    unsigned char *us;
-    char c;
-    char savec = '\0';
-
-    /* count */
-    for (s = hexstr; *s; s++) {
-	if (!isascii(*s)) return -1;
-	if (isspace(*s)) continue;
-	if (!isxdigit(*s)) return -1;
-	len++;
-    }
-
-    /* if odd then there was an error */
-    if ((len &amp; 1) == 1) return -1;
-
-
-    /* now we know that the input is good */
-    len &gt;&gt;= 1;
-    retval = malloc (len);
-    if (!retval) {
-	fprintf (stderr, &quot;%s:  unable to allocate %d bytes for hexkey\n&quot;,
-		 ProgramName, len);
-	return -1;
-    }
-
-    for (us = (unsigned char *) retval, i = len; i &gt; 0; hexstr++) {
-	c = *hexstr;
-	if (isspace(c)) continue;	 /* already know it is ascii */
-	if (isupper(c))
-	    c = tolower(c);
-	if (savec) {
-#define atoh(c) ((c) - (((c) &gt;= '0' &amp;&amp; (c) &lt;= '9') ? '0' : ('a'-10)))
-	    *us = (unsigned char)((atoh(savec) &lt;&lt; 4) + atoh(c));
-#undef atoh
-	    savec = 0;		/* ready for next character */
-	    us++;
-	    i--;
-	} else {
-	    savec = c;
-	}
-    }
-    *ptrp = retval;
-    return len;
-}
-
-static int 
-dispatch_command(char *inputfilename, 
-		 int lineno, 
-		 int argc, 
-		 char **argv, 
-		 CommandTable *tab, 
-		 int *statusp)
-{
-    CommandTable *ct;
-    char *cmd;
-    int n;
-					/* scan table for command */
-    cmd = argv[0];
-    n = strlen (cmd);
-    for (ct = tab; ct-&gt;name; ct++) {
-					/* look for unique prefix */
-	if (n &gt;= ct-&gt;minlen &amp;&amp; n &lt;= ct-&gt;maxlen &amp;&amp;
-	    strncmp (cmd, ct-&gt;name, n) == 0) {
-	    *statusp = (*(ct-&gt;processfunc))(inputfilename, lineno, argc, argv);
-	    return 1;
-	}
-    }
-
-    *statusp = 1;
-    return 0;
-}
-
-
-static AuthList *xauth_head = NULL;	/* list of auth entries */
-static Bool xauth_existed = False;	/* if was present at initialize */
-static Bool xauth_modified = False;	/* if added, removed, or merged */
-static Bool xauth_allowed = True;	/* if allowed to write auth file */
-static Bool xauth_locked = False;     /* if has been locked */
-static char *xauth_filename = NULL;
-static Bool dieing = False;
-
-#ifdef SIGNALRETURNSINT
-#define _signal_t int
-#else
-#define _signal_t void
-#endif
-
-/* poor man's puts(), for under signal handlers */
-#define WRITES(fd, S) (void)write((fd), (S), strlen((S)))
-
-/* ARGSUSED */
-static _signal_t 
-die(int sig)
-{
-    dieing = True;
-    _exit (auth_finalize ());
-    /* NOTREACHED */
-#ifdef SIGNALRETURNSINT
-    return -1;				/* for picky compilers */
-#endif
-}
-
-static _signal_t 
-catchsig(int sig)
-{
-#ifdef SYSV
-    if (sig &gt; 0) signal (sig, die);	/* re-establish signal handler */
-#endif
-    /*
-     * fileno() might not be reentrant, avoid it if possible, and use
-     * stderr instead of stdout
-     */
-#ifdef STDERR_FILENO
-    if (verbose &amp;&amp; xauth_modified) WRITES(STDERR_FILENO, &quot;\r\n&quot;);
-#else
-    if (verbose &amp;&amp; xauth_modified) WRITES(fileno(stderr), &quot;\r\n&quot;);
-#endif
-    die (sig);
-    /* NOTREACHED */
-#ifdef SIGNALRETURNSINT
-    return -1;				/* for picky compilers */
-#endif
-}
-
-static void 
-register_signals(void)
-{
-    signal (SIGINT, catchsig);
-    signal (SIGTERM, catchsig);
-#ifdef SIGHUP
-    signal (SIGHUP, catchsig);
-#endif
-    return;
-}
-
-
-/*
- * public procedures for parsing lines of input
- */
-
-int 
-auth_initialize(char *authfilename)
-{
-    int n;
-    AuthList *head, *tail;
-    FILE *authfp;
-    Bool exists;
-
-    xauth_filename = authfilename;    /* used in cleanup, prevent race with 
-                                         signals */
-    register_signals ();
-
-    bzero ((char *) hexvalues, sizeof hexvalues);
-    hexvalues['0'] = 0;
-    hexvalues['1'] = 1;
-    hexvalues['2'] = 2;
-    hexvalues['3'] = 3;
-    hexvalues['4'] = 4;
-    hexvalues['5'] = 5;
-    hexvalues['6'] = 6;
-    hexvalues['7'] = 7;
-    hexvalues['8'] = 8;
-    hexvalues['9'] = 9;
-    hexvalues['a'] = hexvalues['A'] = 0xa;
-    hexvalues['b'] = hexvalues['B'] = 0xb;
-    hexvalues['c'] = hexvalues['C'] = 0xc;
-    hexvalues['d'] = hexvalues['D'] = 0xd;
-    hexvalues['e'] = hexvalues['E'] = 0xe;
-    hexvalues['f'] = hexvalues['F'] = 0xf;
-
-    if (break_locks &amp;&amp; verbose) {
-	printf (&quot;Attempting to break locks on authority file %s\n&quot;,
-		authfilename);
-    }
-
-    if (ignore_locks) {
-	if (break_locks) XauUnlockAuth (authfilename);
-    } else {
-	n = XauLockAuth (authfilename, XAUTH_DEFAULT_RETRIES,
-			 XAUTH_DEFAULT_TIMEOUT, 
-			 (break_locks ? 0L : XAUTH_DEFAULT_DEADTIME));
-	if (n != LOCK_SUCCESS) {
-	    char *reason = &quot;unknown error&quot;;
-	    switch (n) {
-	      case LOCK_ERROR:
-		reason = &quot;error&quot;;
-		break;
-	      case LOCK_TIMEOUT:
-		reason = &quot;timeout&quot;;
-		break;
-	    }
-	    fprintf (stderr, &quot;%s:  %s in locking authority file %s\n&quot;,
-		     ProgramName, reason, authfilename);
-	    return -1;
-	} else
-	    xauth_locked = True;
-    }
-
-    /* these checks can only be done reliably after the file is locked */
-    exists = (access (authfilename, F_OK) == 0);
-    if (exists &amp;&amp; access (authfilename, W_OK) != 0) {
-	fprintf (stderr,
-	 &quot;%s:  %s not writable, changes will be ignored\n&quot;,
-		 ProgramName, authfilename);
-	xauth_allowed = False;
-    }
-
-    original_umask = umask (0077);	/* disallow non-owner access */
-
-    authfp = fopen (authfilename, &quot;rb&quot;);
-    if (!authfp) {
-	int olderrno = errno;
-
-					/* if file there then error */
-	if (access (authfilename, F_OK) == 0) {	 /* then file does exist! */
-	    errno = olderrno;
-	    return -1;
-	}				/* else ignore it */
-	fprintf (stderr, 
-		 &quot;%s:  creating new authority file %s\n&quot;,
-		 ProgramName, authfilename);
-    } else {
-	xauth_existed = True;
-	n = read_auth_entries (authfp, False, &amp;head, &amp;tail);
-	(void) fclose (authfp);
-	if (n &lt; 0) {
-	    fprintf (stderr,
-		     &quot;%s:  unable to read auth entries from file \&quot;%s\&quot;\n&quot;,
-		     ProgramName, authfilename);
-	    return -1;
-	}
-	xauth_head = head;
-    }
-
-    n = strlen (authfilename);
-    xauth_filename = malloc (n + 1);
-    if (xauth_filename) strcpy (xauth_filename, authfilename);
-    else {
-	fprintf(stderr,&quot;cannot allocate memory\n&quot;);
-	return -1;
-    }
-    
-    xauth_modified = False;
-
-    if (verbose) {
-	printf (&quot;%s authority file %s\n&quot;, 
-		ignore_locks ? &quot;Ignoring locks on&quot; : &quot;Using&quot;, authfilename);
-    }
-    return 0;
-}
-
-static int 
-write_auth_file(char *tmp_nam)
-{
-    FILE *fp = NULL;
-    int fd;
-    AuthList *list;
-
-    /*
-     * xdm and auth spec assumes auth file is 12 or fewer characters
-     */
-    strcpy (tmp_nam, xauth_filename);
-    strcat (tmp_nam, &quot;-n&quot;);		/* for new */
-    (void) unlink (tmp_nam);
-    /* CPhipps 2000/02/12 - fix file unlink/fopen race */
-    fd = open(tmp_nam, O_WRONLY | O_CREAT | O_EXCL, 0600);
-    if (fd != -1) fp = fdopen (fd, &quot;wb&quot;);
-    if (!fp) {
-        if (fd != -1) close(fd);
-	fprintf (stderr, &quot;%s:  unable to open tmp file \&quot;%s\&quot;\n&quot;,
-		 ProgramName, tmp_nam);
-	return -1;
-    } 
-
-    /*
-     * Write MIT-MAGIC-COOKIE-1 first, because R4 Xlib knows
-     * only that and uses the first authorization it finds.
-     */
-    for (list = xauth_head; list; list = list-&gt;next) {
-	if (list-&gt;auth-&gt;name_length == 18
-	    &amp;&amp; strncmp(list-&gt;auth-&gt;name, &quot;MIT-MAGIC-COOKIE-1&quot;, 18) == 0) {
-	    if (!XauWriteAuth(fp, list-&gt;auth)) {
-		(void) fclose(fp);
-		return -1;
-	    }
-	}
-    }
-    for (list = xauth_head; list; list = list-&gt;next) {
-	if (list-&gt;auth-&gt;name_length != 18
-	    || strncmp(list-&gt;auth-&gt;name, &quot;MIT-MAGIC-COOKIE-1&quot;, 18) != 0) {
-	    if (!XauWriteAuth(fp, list-&gt;auth)) {
-		(void) fclose(fp);
-		return -1;
-	    }
-	}
-    }
-
-    (void) fclose (fp);
-    return 0;
-}
-
-int 
-auth_finalize(void)
-{
-    char temp_name[1024];	/* large filename size */
-
-    if (xauth_modified) {
-	if (dieing) {
-	    if (verbose) {
-		/*
-		 * called from a signal handler -- printf is *not* reentrant; also
-		 * fileno() might not be reentrant, avoid it if possible, and use
-		 * stderr instead of stdout
-		 */
-#ifdef STDERR_FILENO
-		WRITES(STDERR_FILENO, &quot;\nAborting changes to authority file &quot;);
-		WRITES(STDERR_FILENO, xauth_filename);
-		WRITES(STDERR_FILENO, &quot;\n&quot;);
-#else
-		WRITES(fileno(stderr), &quot;\nAborting changes to authority file &quot;);
-		WRITES(fileno(stderr), xauth_filename);
-		WRITES(fileno(stderr), &quot;\n&quot;);
-#endif
-	    }
-	} else if (!xauth_allowed) {
-	    fprintf (stderr, 
-		     &quot;%s:  %s not writable, changes ignored\n&quot;,
-		     ProgramName, xauth_filename);
-	} else {
-	    if (verbose) {
-		printf (&quot;%s authority file %s\n&quot;, 
-			ignore_locks ? &quot;Ignoring locks and writing&quot; :
-			&quot;Writing&quot;, xauth_filename);
-	    }
-	    temp_name[0] = '\0';
-	    if (write_auth_file (temp_name) == -1) {
-		fprintf (stderr,
-			 &quot;%s:  unable to write authority file %s\n&quot;,
-			 ProgramName, temp_name);
-	    } else {
-		(void) unlink (xauth_filename);
-#if defined(WIN32) || defined(__UNIXOS2__)|| defined(__CYGWIN__)
-		if (rename(temp_name, xauth_filename) == -1)
-#else
-		if (link (temp_name, xauth_filename) == -1)
-#endif
-		{
-		    fprintf (stderr,
-		     &quot;%s:  unable to link authority file %s, use %s\n&quot;,
-			     ProgramName, xauth_filename, temp_name);
-		} else {
-		    (void) unlink (temp_name);
-		}
-	    }
-	}
-    }
-
-    if (xauth_locked) {
-	XauUnlockAuth (xauth_filename);
-    }
-    (void) umask (original_umask);
-    return 0;
-}
-
-int 
-process_command(char *inputfilename, int lineno, int argc, char **argv)
-{
-    int status;
-
-    if (argc &lt; 1 || !argv || !argv[0]) return 1;
-
-    if (dispatch_command (inputfilename, lineno, argc, argv,
-			  command_table, &amp;status))
-      return status;
-
-    prefix (inputfilename, lineno);
-    fprintf (stderr, &quot;unknown command \&quot;%s\&quot;\n&quot;, argv[0]);
-    return 1;
-}
-
-
-/*
- * utility routines
- */
-
-static char * 
-bintohex(unsigned int len, char *bindata)
-{
-    char *hexdata, *starthex;
-
-    /* two chars per byte, plus null termination */
-    starthex = hexdata = (char *)malloc(2*len + 1); 
-    if (!hexdata)
-	return NULL;
-
-    for (; len &gt; 0; len--, bindata++) {
-	register char *s = hex_table[(unsigned char)*bindata];
-	*hexdata++ = s[0];
-	*hexdata++ = s[1];
-    }
-    *hexdata = '\0';
-    return starthex;
-}
-
-static void 
-fprintfhex(register FILE *fp, int len, char *cp)
-{
-    char *hex;
-
-    hex = bintohex(len, cp);
-    fprintf(fp, hex);
-    free(hex);
-}
-
-int
-dump_numeric(register FILE *fp, register Xauth *auth)
-{
-    fprintf (fp, &quot;%04x&quot;, auth-&gt;family);  /* unsigned short */
-    fprintf (fp, &quot; %04x &quot;, auth-&gt;address_length);  /* short */
-    fprintfhex (fp, auth-&gt;address_length, auth-&gt;address);
-    fprintf (fp, &quot; %04x &quot;, auth-&gt;number_length);  /* short */
-    fprintfhex (fp, auth-&gt;number_length, auth-&gt;number);
-    fprintf (fp, &quot; %04x &quot;, auth-&gt;name_length);  /* short */
-    fprintfhex (fp, auth-&gt;name_length, auth-&gt;name);
-    fprintf (fp, &quot; %04x &quot;, auth-&gt;data_length);  /* short */
-    fprintfhex (fp, auth-&gt;data_length, auth-&gt;data);
-    putc ('\n', fp);
-    return 1;
-}
-
-/* ARGSUSED */
-static int 
-dump_entry(char *inputfilename, int lineno, Xauth *auth, char *data)
-{
-    struct _list_data *ld = (struct _list_data *) data;
-    FILE *fp = ld-&gt;fp;
-
-    if (ld-&gt;numeric) {
-	dump_numeric (fp, auth);
-    } else {
-	char *dpyname = NULL;
-
-	switch (auth-&gt;family) {
-	  case FamilyLocal:
-	    fwrite (auth-&gt;address, sizeof (char), auth-&gt;address_length, fp);
-	    fprintf (fp, &quot;/unix&quot;);
-	    break;
-	  case FamilyInternet:
-	  case FamilyDECnet:
-	    dpyname = get_hostname (auth);
-	    if (dpyname) {
-		fprintf (fp, &quot;%s&quot;, dpyname);
-		break;
-	    }
-	    /* else fall through to default */
-	  default:
-	    fprintf (fp, &quot;#%04x#&quot;, auth-&gt;family);
-	    fprintfhex (fp, auth-&gt;address_length, auth-&gt;address);
-	    putc ('#', fp);
-	}
-	putc (':', fp);
-	fwrite (auth-&gt;number, sizeof (char), auth-&gt;number_length, fp);
-	putc (' ', fp);
-	putc (' ', fp);
-	fwrite (auth-&gt;name, sizeof (char), auth-&gt;name_length, fp);
-	putc (' ', fp);
-	putc (' ', fp);
-	if (!strncmp(auth-&gt;name, SECURERPC, auth-&gt;name_length) ||
-	    !strncmp(auth-&gt;name, K5AUTH, auth-&gt;name_length))
-            fwrite (auth-&gt;data, sizeof (char), auth-&gt;data_length, fp);
-	else
-	    fprintfhex (fp, auth-&gt;data_length, auth-&gt;data);
-	putc ('\n', fp);
-    }
-    return 0;
-}
-
-static int 
-extract_entry(char *inputfilename, int lineno, Xauth *auth, char *data)
-{
-    struct _extract_data *ed = (struct _extract_data *) data;
-
-    if (!ed-&gt;fp) {
-	ed-&gt;fp = open_file (&amp;ed-&gt;filename,
-			    ed-&gt;numeric ? &quot;w&quot; : &quot;wb&quot;,
-			    &amp;ed-&gt;used_stdout,
-			    inputfilename, lineno, ed-&gt;cmd);
-	if (!ed-&gt;fp) {
-	    prefix (inputfilename, lineno);
-	    fprintf (stderr,
-		     &quot;unable to open extraction file \&quot;%s\&quot;\n&quot;,
-		     ed-&gt;filename);
-	    return -1;
-	}
-    }
-    (*(ed-&gt;numeric ? dump_numeric : XauWriteAuth)) (ed-&gt;fp, auth);
-    ed-&gt;nwritten++;
-
-    return 0;
-}
-
-
-static int 
-match_auth_dpy(register Xauth *a, register Xauth *b)
-{
-    return ((a-&gt;family == b-&gt;family &amp;&amp;
-	     a-&gt;address_length == b-&gt;address_length &amp;&amp;
-	     a-&gt;number_length == b-&gt;number_length &amp;&amp;
-	     memcmp(a-&gt;address, b-&gt;address, a-&gt;address_length) == 0 &amp;&amp;
-	     memcmp(a-&gt;number, b-&gt;number, a-&gt;number_length) == 0) ? 1 : 0);
-}
-
-/* return non-zero iff display and authorization type are the same */
-
-static int 
-match_auth(register Xauth *a, register Xauth *b)
-{
-    return ((match_auth_dpy(a, b)
-	     &amp;&amp; a-&gt;name_length == b-&gt;name_length
-	     &amp;&amp; memcmp(a-&gt;name, b-&gt;name, a-&gt;name_length) == 0) ? 1 : 0);
-}
-
-
-static int 
-merge_entries(AuthList **firstp, AuthList *second, int *nnewp, int *nreplp)
-{
-    AuthList *a, *b, *first, *tail;
-    int n = 0, nnew = 0, nrepl = 0;
-
-    if (!second) return 0;
-
-    if (!*firstp) {			/* if nothing to merge into */
-	*firstp = second;
-	for (tail = *firstp, n = 1; tail-&gt;next; n++, tail = tail-&gt;next) ;
-	*nnewp = n;
-	*nreplp = 0;
-	return n;
-    }
-
-    first = *firstp;
-    /*
-     * find end of first list and stick second list on it
-     */
-    for (tail = first; tail-&gt;next; tail = tail-&gt;next) ;
-    tail-&gt;next = second;
-
-    /*
-     * run down list freeing duplicate entries; if an entry is okay, then
-     * bump the tail up to include it, otherwise, cut the entry out of
-     * the chain.
-     */
-    for (b = second; b; ) {
-	AuthList *next = b-&gt;next;	/* in case we free it */
-
-	a = first;
-	for (;;) {
-	    if (match_auth (a-&gt;auth, b-&gt;auth)) {  /* found a duplicate */
-		AuthList tmp;		/* swap it in for old one */
-		tmp = *a;
-		*a = *b;
-		*b = tmp;
-		a-&gt;next = b-&gt;next;
-		XauDisposeAuth (b-&gt;auth);
-		free ((char *) b);
-		b = NULL;
-		tail-&gt;next = next;
-		nrepl++;
-		nnew--;
-		break;
-	    }
-	    if (a == tail) break;	/* if have looked at left side */
-	    a = a-&gt;next;
-	}
-	if (b) {			/* if we didn't remove it */
-	    tail = b;			/* bump end of first list */
-	}
-	b = next;
-	n++;
-	nnew++;
-    }
-
-    *nnewp = nnew;
-    *nreplp = nrepl;
-    return n;
-
-}
-
-typedef int (*YesNoFunc)(char *, int, Xauth *, char *);
-
-static int 
-iterdpy (char *inputfilename, int lineno, int start,
-	 int argc, char *argv[], 
-	 YesNoFunc yfunc, YesNoFunc nfunc, char *data)
-{
-    int i;
-    int status;
-    int errors = 0;
-    Xauth proto;
-    AuthList *l, *next;
-
-    /*
-     * iterate
-     */
-    for (i = start; i &lt; argc; i++) {
-	char *displayname = argv[i];
-	proto.address = proto.number = NULL;
-	if (!get_displayname_auth (displayname, &amp;proto)) {
-	    prefix (inputfilename, lineno);
-	    baddisplayname (displayname, argv[0]);
-	    errors++;
-	    continue;
-	}
-	status = 0;
-	for (l = xauth_head; l; l = next) {
-	    next = l-&gt;next;
-	    if (match_auth_dpy (&amp;proto, l-&gt;auth)) {
-		if (yfunc) {
-		    status = (*yfunc) (inputfilename, lineno,
-				       l-&gt;auth, data);
-		    if (status &lt; 0) break;
-		}
-	    } else {
-		if (nfunc) {
-		    status = (*nfunc) (inputfilename, lineno,
-				       l-&gt;auth, data);
-		    if (status &lt; 0) break;
-		}
-	    }
-	}
-	if (proto.address) free (proto.address);
-	if (proto.number) free (proto.number);
-	if (status &lt; 0) {
-	    errors -= status;		/* since status is negative */
-	    break;
-	}
-    }
-
-    return errors;
-}
-
-/* ARGSUSED */
-static int 
-remove_entry(char *inputfilename, int lineno, Xauth *auth, char *data)
-{
-    int *nremovedp = (int *) data;
-    AuthList **listp = &amp;xauth_head;
-    AuthList *list;
-
-    /*
-     * unlink the auth we were asked to
-     */
-    while ((list = *listp)-&gt;auth != auth)
-	listp = &amp;list-&gt;next;
-    *listp = list-&gt;next;
-    XauDisposeAuth (list-&gt;auth);                    /* free the auth */
-    free (list);				    /* free the link */
-    xauth_modified = True;
-    (*nremovedp)++;
-    return 1;
-}
-
-/*
- * action routines
- */
-
-/*
- * help
- */
-int 
-print_help(FILE *fp, char *cmd, char *prefix)
-{
-    CommandTable *ct;
-    int n = 0;
-
-    if (!prefix) prefix = &quot;&quot;;
-
-    if (!cmd) {				/* if no cmd, print all help */
-	for (ct = command_table; ct-&gt;name; ct++) {
-	    fprintf (fp, &quot;%s%s\n&quot;, prefix, ct-&gt;helptext);
-	    n++;
-	}
-    } else {
-	int len = strlen (cmd);
-	for (ct = command_table; ct-&gt;name; ct++) {
-	    if (strncmp (cmd, ct-&gt;name, len) == 0) {
-		fprintf (fp, &quot;%s%s\n&quot;, prefix, ct-&gt;helptext);
-		n++;
-	    }
-	}
-    }
-	
-    return n;
-}
-
-static int 
-do_help(char *inputfilename, int lineno, int argc, char **argv)
-{
-    char *cmd = (argc &gt; 1 ? argv[1] : NULL);
-    int n;
-
-    n = print_help (stdout, cmd, &quot;    &quot;);  /* a nice amount */
-
-    if (n &lt; 0 || (n == 0 &amp;&amp; !cmd)) {
-	prefix (inputfilename, lineno);
-	fprintf (stderr, &quot;internal error with help&quot;);
-	if (cmd) {
-	    fprintf (stderr, &quot; on command \&quot;%s\&quot;&quot;, cmd);
-	}
-	fprintf (stderr, &quot;\n&quot;);
-	return 1;
-    }
-
-    if (n == 0) {
-	prefix (inputfilename, lineno);
-	/* already know that cmd is set in this case */
-	fprintf (stderr, &quot;no help for noexistent command \&quot;%s\&quot;\n&quot;, cmd);
-    }
-
-    return 0;
-}
-
-/*
- * questionmark
- */
-/* ARGSUSED */
-static int 
-do_questionmark(char *inputfilename, int lineno, int argc, char **argv)
-{
-    CommandTable *ct;
-    int i;
-#define WIDEST_COLUMN 72
-    int col = WIDEST_COLUMN;
-
-    printf (&quot;Commands:\n&quot;);
-    for (ct = command_table; ct-&gt;name; ct++) {
-	if ((col + ct-&gt;maxlen) &gt; WIDEST_COLUMN) {
-	    if (ct != command_table) {
-		putc ('\n', stdout);
-	    }
-	    fputs (&quot;        &quot;, stdout);
-	    col = 8;			/* length of string above */
-	}
-	fputs (ct-&gt;name, stdout);
-	col += ct-&gt;maxlen;
-	for (i = ct-&gt;maxlen; i &lt; COMMAND_NAMES_PADDED_WIDTH; i++) {
-	    putc (' ', stdout);
-	    col++;
-	}
-    }
-    if (col != 0) {
-	putc ('\n', stdout);
-    }
-
-    /* allow bad lines since this is help */
-    return 0;
-}
-
-/*
- * list [displayname ...]
- */
-static int 
-do_list (char *inputfilename, int lineno, int argc, char **argv)
-{
-    struct _list_data ld;
-
-    ld.fp = stdout;
-    ld.numeric = (argv[0][0] == 'n');
-
-    if (argc == 1) {
-	register AuthList *l;
-
-	if (xauth_head) {
-	    for (l = xauth_head; l; l = l-&gt;next) {
-		dump_entry (inputfilename, lineno, l-&gt;auth, (char *) &amp;ld);
-	    }
-	}
-	return 0;
-    }
-
-    return iterdpy (inputfilename, lineno, 1, argc, argv,
-		    dump_entry, NULL, (char *) &amp;ld);
-    
-   return 0;
-}
-
-/*
- * merge filename [filename ...]
- */
-static int 
-do_merge(char *inputfilename, int lineno, int argc, char **argv)
-{
-    int i;
-    int errors = 0;
-    AuthList *head, *tail, *listhead, *listtail;
-    int nentries, nnew, nrepl;
-    Bool numeric = False;
-
-    if (argc &lt; 2) {
-	prefix (inputfilename, lineno);
-	badcommandline (argv[0]);
-	return 1;
-    }
-
-    if (argv[0][0] == 'n') numeric = True;
-    listhead = listtail = NULL;
-
-    for (i = 1; i &lt; argc; i++) {
-	char *filename = argv[i];
-	FILE *fp;
-	Bool used_stdin = False;
-
-	fp = open_file (&amp;filename,
-			numeric ? &quot;r&quot; : &quot;rb&quot;,
-			&amp;used_stdin, inputfilename, lineno,
-			argv[0]);
-	if (!fp) {
-	    errors++;
-	    continue;
-	}
-
-	head = tail = NULL;
-	nentries = read_auth_entries (fp, numeric, &amp;head, &amp;tail);
-	if (nentries == 0) {
-	    prefix (inputfilename, lineno);
-	    fprintf (stderr, &quot;unable to read any entries from file \&quot;%s\&quot;\n&quot;,
-		     filename);
-	    errors++;
-	} else {			/* link it in */
-	    add_to_list (listhead, listtail, head);
- 	}
-
-	if (!used_stdin) (void) fclose (fp);
-    }
-
-    /*
-     * if we have new entries, merge them in (freeing any duplicates)
-     */
-    if (listhead) {
-	nentries = merge_entries (&amp;xauth_head, listhead, &amp;nnew, &amp;nrepl);
-	if (verbose) 
-	  printf (&quot;%d entries read in:  %d new, %d replacement%s\n&quot;, 
-	  	  nentries, nnew, nrepl, nrepl != 1 ? &quot;s&quot; : &quot;&quot;);
-	if (nentries &gt; 0) xauth_modified = True;
-    }
-
-    return 0;
-}
-
-/*
- * extract filename displayname [displayname ...]
- */
-static int 
-do_extract(char *inputfilename, int lineno, int argc, char **argv)
-{
-    int errors;
-    struct _extract_data ed;
-
-    if (argc &lt; 3) {
-	prefix (inputfilename, lineno);
-	badcommandline (argv[0]);
-	return 1;
-    }
-
-    ed.fp = NULL;
-    ed.filename = argv[1];
-    ed.numeric = (argv[0][0] == 'n');
-    ed.nwritten = 0;
-    ed.cmd = argv[0];
-
-    errors = iterdpy (inputfilename, lineno, 2, argc, argv, 
-		      extract_entry, NULL, (char *) &amp;ed);
-
-    if (!ed.fp) {
-	fprintf (stderr, 
-		 &quot;No matches found, authority file \&quot;%s\&quot; not written\n&quot;,
-		 ed.filename);
-    } else {
-	if (verbose) {
-	    printf (&quot;%d entries written to \&quot;%s\&quot;\n&quot;, 
-		    ed.nwritten, ed.filename);
-	}
-	if (!ed.used_stdout) {
-	    (void) fclose (ed.fp);
-	}
-    }
-
-    return errors;
-}
-
-
-/*
- * add displayname protocolname hexkey
- */
-static int 
-do_add(char *inputfilename, int lineno, int argc, char **argv)
-{ 
-    int n, nnew, nrepl;
-    int len;
-    char *dpyname;
-    char *protoname;
-    char *hexkey;
-    char *key;
-    Xauth *auth;
-    AuthList *list;
-
-    if (argc != 4 || !argv[1] || !argv[2] || !argv[3]) {
-	prefix (inputfilename, lineno);
-	badcommandline (argv[0]);
-	return 1;
-    }
-
-    dpyname = argv[1];
-    protoname = argv[2];
-    hexkey = argv[3];
-
-    len = strlen(hexkey);
-    if (hexkey[0] == '&quot;' &amp;&amp; hexkey[len-1] == '&quot;') {
-	key = malloc(len-1);
-	strncpy(key, hexkey+1, len-2);
-	len -= 2;
-    } else if (!strcmp(protoname, SECURERPC) ||
-	       !strcmp(protoname, K5AUTH)) {
-	key = malloc(len+1);
-	strcpy(key, hexkey);
-    } else {
-	len = cvthexkey (hexkey, &amp;key);
-	if (len &lt; 0) {
-	    prefix (inputfilename, lineno);
-	    fprintf (stderr,
-		     &quot;key contains odd number of or non-hex characters\n&quot;);
-	    return 1;
-	}
-    }
-
-    auth = (Xauth *) malloc (sizeof (Xauth));
-    if (!auth) {
-	prefix (inputfilename, lineno);
-	fprintf (stderr, &quot;unable to allocate %ld bytes for Xauth structure\n&quot;,
-		 (unsigned long)sizeof (Xauth));
-	free (key);
-	return 1;
-    }
-
-    if (!get_displayname_auth (dpyname, auth)) {
-	prefix (inputfilename, lineno);
-	baddisplayname (dpyname, argv[0]);
-	free (auth);
-	free (key);
-	return 1;
-    }
-
-    /*
-     * allow an abbreviation for common protocol names
-     */
-    if (strcmp (protoname, DEFAULT_PROTOCOL_ABBREV) == 0) {
-	protoname = DEFAULT_PROTOCOL;
-    }
-
-    auth-&gt;name_length = strlen (protoname);
-    auth-&gt;name = copystring (protoname, auth-&gt;name_length);
-    if (!auth-&gt;name) {
-	prefix (inputfilename, lineno);
-	fprintf (stderr, &quot;unable to allocate %d character protocol name\n&quot;,
-		 auth-&gt;name_length);
-	free (auth);
-	free (key);
-	return 1;
-    }
-    auth-&gt;data_length = len;
-    auth-&gt;data = key;
-
-    list = (AuthList *) malloc (sizeof (AuthList));
-    if (!list) {
-	prefix (inputfilename, lineno);
-	fprintf (stderr, &quot;unable to allocate %ld bytes for auth list\n&quot;,
-		 (unsigned long)sizeof (AuthList));
-	free (auth);
-	free (key);
-	free (auth-&gt;name);
-	return 1;
-    }
-
-    list-&gt;next = NULL;
-    list-&gt;auth = auth;
-
-    /*
-     * merge it in; note that merge will deal with allocation
-     */
-    n = merge_entries (&amp;xauth_head, list, &amp;nnew, &amp;nrepl);
-    if (n &lt;= 0) {
-	prefix (inputfilename, lineno);
-	fprintf (stderr, &quot;unable to merge in added record\n&quot;);
-	return 1;
-    }
-
-    xauth_modified = True;
-    return 0;
-}
-
-/*
- * remove displayname
- */
-static int 
-do_remove(char *inputfilename, int lineno, int argc, char **argv)
-{
-    int nremoved = 0;
-    int errors;
-
-    if (argc &lt; 2) {
-	prefix (inputfilename, lineno);
-	badcommandline (argv[0]);
-	return 1;
-    }
-
-    errors = iterdpy (inputfilename, lineno, 1, argc, argv,
-		      remove_entry, NULL, (char *) &amp;nremoved);
-    if (verbose) printf (&quot;%d entries removed\n&quot;, nremoved);
-    return errors;
-}
-
-/*
- * info
- */
-static int 
-do_info(char *inputfilename, int lineno, int argc, char **argv)
-{
-    int n;
-    AuthList *l;
-
-    if (argc != 1) {
-	prefix (inputfilename, lineno);
-	badcommandline (argv[0]);
-	return 1;
-    }
-
-    for (l = xauth_head, n = 0; l; l = l-&gt;next, n++) ;
-
-    printf (&quot;Authority file:       %s\n&quot;,
-	    xauth_filename ? xauth_filename : &quot;(none)&quot;);
-    printf (&quot;File new:             %s\n&quot;, xauth_existed ? No : Yes);
-    printf (&quot;File locked:          %s\n&quot;, xauth_locked ? No : Yes);
-    printf (&quot;Number of entries:    %d\n&quot;, n);
-    printf (&quot;Changes honored:      %s\n&quot;, xauth_allowed ? Yes : No);
-    printf (&quot;Changes made:         %s\n&quot;, xauth_modified ? Yes : No);
-    printf (&quot;Current input:        %s:%d\n&quot;, inputfilename, lineno);
-    return 0;
-}
-
-
-/*
- * exit
- */
-static Bool alldone = False;
-
-/* ARGSUSED */
-static int 
-do_exit(char *inputfilename, int lineno, int argc, char **argv)
-{
-    /* allow bogus stuff */
-    alldone = True;
-    return 0;
-}
-
-/*
- * quit
- */
-/* ARGSUSED */
-static int 
-do_quit(char *inputfilename, int lineno, int argc, char **argv)
-{
-    /* allow bogus stuff */
-    die (0);
-    /* NOTREACHED */
-    return -1;				/* for picky compilers */
-}
-
-
-/*
- * source filename
- */
-static int 
-do_source(char *inputfilename, int lineno, int argc, char **argv)
-{
-    char *script;
-    char buf[BUFSIZ];
-    FILE *fp;
-    Bool used_stdin = False;
-    int len;
-    int errors = 0, status;
-    int sublineno = 0;
-    char **subargv;
-    int subargc;
-    Bool prompt = False;		/* only true if reading from tty */
-
-    if (argc != 2 || !argv[1]) {
-	prefix (inputfilename, lineno);
-	badcommandline (argv[0]);
-	return 1;
-    }
-
-    script = argv[1];
-
-    fp = open_file (&amp;script, &quot;r&quot;, &amp;used_stdin, inputfilename, lineno, argv[0]);
-    if (!fp) {
-	return 1;
-    }
-
-    if (verbose &amp;&amp; used_stdin &amp;&amp; isatty (fileno (fp))) prompt = True;
-
-    while (!alldone) {
-	buf[0] = '\0';
-	if (prompt) {
-	    printf (&quot;xauth&gt; &quot;);
-	    fflush (stdout);
-	}
-	if (fgets (buf, sizeof buf, fp) == NULL) break;
-	sublineno++;
-	len = strlen (buf);
-	if (len == 0 || buf[0] == '#') continue;
-	if (buf[len-1] != '\n') {
-	    prefix (script, sublineno);
-	    fprintf (stderr, &quot;line too long\n&quot;);
-	    errors++;
-	    break;
-	}
-	buf[--len] = '\0';		/* remove new line */
-	subargv = split_into_words (buf, &amp;subargc);
-	if (subargv) {
-	    status = process_command (script, sublineno, subargc, subargv);
-	    free ((char *) subargv);
-	    errors += status;
-	} else {
-	    prefix (script, sublineno);
-	    fprintf (stderr, &quot;unable to break line into words\n&quot;);
-	    errors++;
-	}
-    }
-
-    if (!used_stdin) {
-	(void) fclose (fp);
-    }
-    return errors;
-}
-
-/*static int
-static int x_protocol_error;
-catch_x_protocol_error(Display *dpy, XErrorEvent *errevent)
-{
-    char buf[80];
-    XGetErrorText(dpy, errevent-&gt;error_code, buf, sizeof (buf));
-    fprintf(stderr, &quot;%s\n&quot;, buf);
-    x_protocol_error = errevent-&gt;error_code;
-    return 1;
-}
-*/
-/*
- * generate
- */
-/*static int 
-do_generate(char *inputfilename, int lineno, int argc, char **argv)
-{
-    char *displayname;
-    int major_version, minor_version;
-    XSecurityAuthorization id_return;
-    Xauth *auth_in, *auth_return;
-    XSecurityAuthorizationAttributes attributes;
-    unsigned long attrmask = 0;
-    Display *dpy;
-    int status;
-    char *args[4];
-    char *protoname = &quot;.&quot;;
-    int i;
-    int authdatalen = 0;
-    char *hexdata;
-    char *authdata = NULL;
-
-    if (argc &lt; 2 || !argv[1]) {
-	prefix (inputfilename, lineno);
-	badcommandline (argv[0]);
-	return 1;
-    }
-
-    displayname = argv[1];
-
-    if (argc &gt; 2) {
-	protoname = argv[2];
-    }
-
-    for (i = 3; i &lt; argc; i++) {
-	if (0 == strcmp(argv[i], &quot;timeout&quot;)) {
-	    if (++i == argc) {
-		prefix (inputfilename, lineno);
-		badcommandline (argv[i-1]);
-		return 1;
-	    } 
-	    attributes.timeout = atoi(argv[i]);
-	    attrmask |= XSecurityTimeout;
-
-	} else if (0 == strcmp(argv[i], &quot;trusted&quot;)) {
-	    attributes.trust_level = XSecurityClientTrusted;
-	    attrmask |= XSecurityTrustLevel;
-
-	} else if (0 == strcmp(argv[i], &quot;untrusted&quot;)) {
-	    attributes.trust_level = XSecurityClientUntrusted;
-	    attrmask |= XSecurityTrustLevel;
-
-	} else if (0 == strcmp(argv[i], &quot;group&quot;)) {
-	    if (++i == argc) {
-		prefix (inputfilename, lineno);
-		badcommandline (argv[i-1]);
-		return 1;
-	    } 
-	    attributes.group = atoi(argv[i]);
-	    attrmask |= XSecurityGroup;
-
-	} else if (0 == strcmp(argv[i], &quot;data&quot;)) {
-	    if (++i == argc) {
-		prefix (inputfilename, lineno);
-		badcommandline (argv[i-1]);
-		return 1;
-	    } 
-	    hexdata = argv[i];
-	    authdatalen = strlen(hexdata);
-	    if (hexdata[0] == '&quot;' &amp;&amp; hexdata[authdatalen-1] == '&quot;') {
-		authdata = malloc(authdatalen-1);
-		strncpy(authdata, hexdata+1, authdatalen-2);
-		authdatalen -= 2;
-	    } else {
-		authdatalen = cvthexkey (hexdata, &amp;authdata);
-		if (authdatalen &lt; 0) {
-		    prefix (inputfilename, lineno);
-		    fprintf (stderr,
-			     &quot;data contains odd number of or non-hex characters\n&quot;);
-		    return 1;
-		}
-	    }
-	} else {
-	    prefix (inputfilename, lineno);
-	    badcommandline (argv[i]);
-	    return 1;
-	}
-    }
-
-    // generate authorization using the Security extension /
-
-    dpy = XOpenDisplay (displayname);
-    if (!dpy) {
-	prefix (inputfilename, lineno);
-	fprintf (stderr, &quot;unable to open display \&quot;%s\&quot;.\n&quot;, displayname);
-	return 1;
-    }
-
-    status = XSecurityQueryExtension(dpy, &amp;major_version, &amp;minor_version);
-    if (!status)
-    {
-	prefix (inputfilename, lineno);
-	fprintf (stderr, &quot;couldn't query Security extension on display \&quot;%s\&quot;\n&quot;,
-		 displayname);
-        return 1;
-    }
-
-    // fill in input Xauth struct /
-
-    auth_in = XSecurityAllocXauth();
-    if (strcmp (protoname, DEFAULT_PROTOCOL_ABBREV) == 0) {
-	 auth_in-&gt;name = DEFAULT_PROTOCOL;
-    }
-    else
-	auth_in-&gt;name = protoname;
-    auth_in-&gt;name_length = strlen(auth_in-&gt;name);
-    auth_in-&gt;data = authdata;
-    auth_in-&gt;data_length = authdatalen;
-
-    x_protocol_error = 0;
-    XSetErrorHandler(catch_x_protocol_error);
-    auth_return = XSecurityGenerateAuthorization(dpy, auth_in, attrmask,
-						 &amp;attributes, &amp;id_return);
-    XSync(dpy, False);
-
-    if (!auth_return || x_protocol_error)
-    {
-	prefix (inputfilename, lineno);
-	fprintf (stderr, &quot;couldn't generate authorization\n&quot;);
-	return 1;
-    }
-
-    if (verbose)
-	printf(&quot;authorization id is %ld\n&quot;, id_return);
-
-    // create a fake input line to give to do_add /
-
-    args[0] = &quot;add&quot;;
-    args[1] = displayname;
-    args[2] = auth_in-&gt;name;
-    args[3] = bintohex(auth_return-&gt;data_length, auth_return-&gt;data);
-
-    status = do_add(inputfilename, lineno, 4, args);
-
-    if (authdata) free(authdata);
-    XSecurityFreeXauth(auth_in);
-    XSecurityFreeXauth(auth_return);
-    free(args[3]); // hex data /
-    XCloseDisplay(dpy);
-    return status;
-}
-*/
diff --git a/nx-X11/programs/nxauth/xauth.c b/nx-X11/programs/nxauth/xauth.c
deleted file mode 100644
index 5a37c34..0000000
--- a/nx-X11/programs/nxauth/xauth.c
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
- * $Xorg: xauth.c,v 1.4 2001/02/09 02:05:38 xorgcvs Exp $
- *
- * xauth - manipulate authorization file
- *
- * 
-Copyright 1989,1998  The Open Group
-
-Permission to use, copy, modify, distribute, and sell this software and its
-documentation for any purpose is hereby granted without fee, provided that
-the above copyright notice appear in all copies and that both that
-copyright notice and this permission notice appear in supporting
-documentation.
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of The Open Group shall not be
-used in advertising or otherwise to promote the sale, use or other dealings
-in this Software without prior written authorization from The Open Group.
- * *
- * Author:  Jim Fulton, MIT X Consortium
- */
-/* $XFree86: xc/programs/xauth/xauth.c,v 1.5 2001/12/14 20:01:15 dawes Exp $ */
-
-/**************************************************************************/
-/*                                                                        */
-/* Copyright (c) 2001, 2010 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
-/*                                                                        */
-/* NXAUTH, NX protocol compression and NX extensions to this software     */
-/* are copyright of NoMachine. Redistribution and use of the present      */
-/* software is allowed according to terms specified in the file LICENSE   */
-/* which comes in the source distribution.                                */
-/*                                                                        */
-/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
-/*                                                                        */
-/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
-/*                                                                        */
-/* All rights reserved.                                                   */
-/*                                                                        */
-/**************************************************************************/
-
-#include &quot;xauth.h&quot;
-
-
-/*
- * global data
- */
-char *ProgramName;			/* argv[0], set at top of main() */
-int verbose = -1;			/* print certain messages */
-Bool ignore_locks = True;		/* for error recovery */
-Bool break_locks = False;		/* for error recovery */
-
-/*
- * local data
- */
-
-static char *authfilename = NULL;	/* filename of cookie file */
-static char *defcmds[] = { &quot;source&quot;, &quot;-&quot;, NULL };  /* default command */
-static int ndefcmds = 2;
-static char *defsource = &quot;(stdin)&quot;;
-
-/*
- * utility routines
- */
-static void 
-usage(void)
-{
-    static char *prefixmsg[] = {
-&quot;&quot;,
-&quot;where options include:&quot;,
-&quot;    -f authfilename                name of authority file to use&quot;,
-&quot;    -v                             turn on extra messages&quot;,
-&quot;    -q                             turn off extra messages&quot;,
-&quot;    -i                             ignore locks on authority file&quot;,
-&quot;    -b                             break locks on authority file&quot;,
-&quot;&quot;,
-&quot;and commands have the following syntax:&quot;,
-&quot;&quot;,
-NULL };
-    static char *suffixmsg[] = {
-&quot;A dash may be used with the \&quot;merge\&quot; and \&quot;source\&quot; to read from the&quot;,
-&quot;standard input.  Commands beginning with \&quot;n\&quot; use numeric format.&quot;,
-&quot;&quot;,
-NULL };
-    char **msg;
-
-    fprintf (stderr, &quot;usage:  %s [-options ...] [command arg ...]\n&quot;,
-	     ProgramName);
-    for (msg = prefixmsg; *msg; msg++) {
-	fprintf (stderr, &quot;%s\n&quot;, *msg);
-    }
-    print_help (stderr, NULL, &quot;    &quot;);	/* match prefix indentation */
-    fprintf (stderr, &quot;\n&quot;);
-    for (msg = suffixmsg; *msg; msg++) {
-	fprintf (stderr, &quot;%s\n&quot;, *msg);
-    }
-    exit (1);
-}
-
-
-/*
- * The main routine - parses command line and calls action procedures
- */
-int
-main(int argc, char *argv[])
-{
-    int i;
-    char *sourcename = defsource;
-    char **arglist = defcmds;
-    int nargs = ndefcmds;
-    int status;
-
-    ProgramName = argv[0];
-
-    for (i = 1; i &lt; argc; i++) {
-	char *arg = argv[i];
-
-	if (arg[0] == '-') {
-	    char *flag;
-
-	    for (flag = (arg + 1); *flag; flag++) {
-		switch (*flag) {
-		  case 'f':		/* -f authfilename */
-		    if (++i &gt;= argc) usage ();
-		    authfilename = argv[i];
-		    continue;
-		  case 'v':		/* -v */
-		    verbose = 1;
-		    continue;
-		  case 'q':		/* -q */
-		    verbose = 0;
-		    continue;
-		  case 'b':		/* -b */
-		    break_locks = True;
-		    continue;
-		  case 'i':		/* -i */
-		    ignore_locks = True;
-		    continue;
-		  default:
-		    usage ();
-		}
-	    }
-	} else {
-	    sourcename = &quot;(argv)&quot;;
-	    nargs = argc - i;
-	    arglist = argv + i;
-	    if (verbose == -1) verbose = 0;
-	    break;
-	}
-    }
-
-    if (verbose == -1) {		/* set default, don't junk stdout */
-	verbose = (isatty(fileno(stdout)) != 0);
-    }
-
-    if (!authfilename) {
-	authfilename = XauFileName ();	/* static name, do not free */
-	if (!authfilename) {
-	    fprintf (stderr,
-		     &quot;%s:  unable to generate an authority file name\n&quot;,
-		     ProgramName);
-	    exit (1);
-	}
-    }
-    if (auth_initialize (authfilename) != 0) {
-	/* error message printed in auth_initialize */
-	exit (1);
-    }
-
-    status = process_command (sourcename, 1, nargs, arglist);
-
-    (void) auth_finalize ();
-    exit ((status != 0) ? 1 : 0);
-}
-
-
diff --git a/nx-X11/programs/nxauth/xauth.h b/nx-X11/programs/nxauth/xauth.h
deleted file mode 100644
index 33a6c4e..0000000
--- a/nx-X11/programs/nxauth/xauth.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * $Xorg: xauth.h,v 1.4 2001/02/09 02:05:38 xorgcvs Exp $
- *
- * 
-Copyright 1989, 1998  The Open Group
-
-Permission to use, copy, modify, distribute, and sell this software and its
-documentation for any purpose is hereby granted without fee, provided that
-the above copyright notice appear in all copies and that both that
-copyright notice and this permission notice appear in supporting
-documentation.
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of The Open Group shall not be
-used in advertising or otherwise to promote the sale, use or other dealings
-in this Software without prior written authorization from The Open Group.
- * *
- * Author:  Jim Fulton, MIT X Consortium
- */
-/* $XFree86: xc/programs/xauth/xauth.h,v 1.6 2001/12/14 20:01:15 dawes Exp $ */
-
-#include &lt;stdio.h&gt;
-#include &lt;X11/Xos.h&gt;
-#include &lt;X11/Xauth.h&gt;
-#include &lt;X11/Xfuncs.h&gt;
-
-#ifndef True
-typedef int Bool;
-#define False 0
-#define True 1
-#endif
-
-extern char *ProgramName;
-
-#include &lt;stdlib.h&gt;
-
-extern char *get_hostname ( Xauth *auth );
-extern char *get_address_info ( int family, char *fulldpyname, int prefix, char *host, int *lenp );
-extern char *copystring ( char *src, int len );
-extern char *get_local_hostname ( char *buf, int maxlen );
-extern Bool parse_displayname ( char *displayname, int *familyp, char **hostp, int *dpynump, int *scrnump, char **restp );
-extern int auth_initialize ( char *authfilename );
-extern int auth_finalize ( void );
-extern int process_command ( char *inputfilename, int lineno, int argc, char **argv );
-extern int dump_numeric ( FILE *fp, Xauth *auth );
-extern int print_help ( FILE *fp, char *cmd, char *prefix );
-extern int verbose;
-extern Bool ignore_locks;
-extern Bool break_locks;


hooks/post-receive
-- 
nx-libs.git (NX (redistributed))

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;nx-libs.git&quot; (NX (redistributed)).

</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011318.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxauth/3.4.0-3
</A></li>
	<LI>Next message: <A HREF="011325.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxagent/3.1.0-6
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11322">[ date ]</a>
              <a href="thread.html#11322">[ thread ]</a>
              <a href="subject.html#11322">[ subject ]</a>
              <a href="author.html#11322">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2Go-commits
mailing list</a><br>
</body></html>
