<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2Go-Commits] pyhoca-gui.git -	build-59a18b6e3b5d3f1dd8f07f26433d37fe5984a57d (branch)	updated: ca778d094c8e95177f2ac87b06b522413d95c79a
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2013-August/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20pyhoca-gui.git%20-%0A%09build-59a18b6e3b5d3f1dd8f07f26433d37fe5984a57d%20%28branch%29%0A%09updated%3A%20ca778d094c8e95177f2ac87b06b522413d95c79a&In-Reply-To=%3C20130827112032.E62105DB05%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010138.html">
   <LINK REL="Next"  HREF="010141.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2Go-Commits] pyhoca-gui.git -	build-59a18b6e3b5d3f1dd8f07f26433d37fe5984a57d (branch)	updated: ca778d094c8e95177f2ac87b06b522413d95c79a</H1>
    <B>X2Go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20pyhoca-gui.git%20-%0A%09build-59a18b6e3b5d3f1dd8f07f26433d37fe5984a57d%20%28branch%29%0A%09updated%3A%20ca778d094c8e95177f2ac87b06b522413d95c79a&In-Reply-To=%3C20130827112032.E62105DB05%40ymir%3E"
       TITLE="[X2Go-Commits] pyhoca-gui.git -	build-59a18b6e3b5d3f1dd8f07f26433d37fe5984a57d (branch)	updated: ca778d094c8e95177f2ac87b06b522413d95c79a">git-admin at x2go.org
       </A><BR>
    <I>Tue Aug 27 13:20:32 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="010138.html">[X2Go-Commits] pyhoca-gui.git -	build-59a18b6e3b5d3f1dd8f07f26433d37fe5984a57d (branch)	updated: 81eeb4e708475585014567bb826564641777364b
</A></li>
        <LI>Next message: <A HREF="010141.html">[X2Go-Commits] pyhoca-gui.git -	build-59a18b6e3b5d3f1dd8f07f26433d37fe5984a57d (branch)	updated: 66a75dce88b6ea0d3a5e38d2beab3dcb3eddb46e
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10139">[ date ]</a>
              <a href="thread.html#10139">[ thread ]</a>
              <a href="subject.html#10139">[ subject ]</a>
              <a href="author.html#10139">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, build-59a18b6e3b5d3f1dd8f07f26433d37fe5984a57d has been updated
       via  ca778d094c8e95177f2ac87b06b522413d95c79a (commit)
      from  66a75dce88b6ea0d3a5e38d2beab3dcb3eddb46e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
-----------------------------------------------------------------------

Summary of changes:
 SessionProfile.py |   77 +++++++++++--
 pyhoca-gui.py     |   35 ++++--
 pyx2go_client.py  |  313 -----------------------------------------------------
 x2goLogon.py      |  280 ++++++++++++++++++++++++++++-------------------
 4 files changed, 261 insertions(+), 444 deletions(-)
 delete mode 100644 pyx2go_client.py

The diff of changes is:
diff --git a/SessionProfile.py b/SessionProfile.py
index 48e2844..4a38f63 100644
--- a/SessionProfile.py
+++ b/SessionProfile.py
@@ -2,17 +2,37 @@
 #-----------------------------------------------------------------------------
 # Name:        SessionProfile.py
 # Purpose:     Define the session info coming from an ini file
-#
-# Author:      Dick Kniep
-#
-# Created:     2010/10/21
-# RCS-ID:      $Id: SessionProfile.py,v 1.2 2010/10/21 20:07:56 dick Exp $
-# Copyright:   (c) 2010 Lindix
 #-----------------------------------------------------------------------------
 
+&quot;&quot;&quot;
+    Copyright (C) 2010 by Dick Kniep &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dick.kniep at lindix.nl</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the
+    Free Software Foundation, Inc.,
+    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+    Contributors to the code of this programme:
+        J&#246;rg Sawatzki &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">joerg.sawatzki at web.de</A>&gt;
+        Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">m.gabriel at das-netzwerkteam.de</A>&gt;
+&quot;&quot;&quot;
+
 import os
 import ConfigParser
 from types import *
+import exceptions
+
+class profileError(exceptions.StandardError): pass
 
 class processINI:
     &quot;&quot;&quot;
@@ -142,6 +162,16 @@ class SessionProfiles(processINI):
     def getSection(self, section):
         return self.iniConfig.items(section)
 
+    def newProfile(self, name, **kw):
+        for key, value in kw.items():
+            if key in defaultValues:
+                self.updValue(name, key, value)
+            else:
+                raise profileError('Keyword %s not supported in profile' % key)
+
+        for key, value in defaultValues.items():
+            if key in kw: continue
+            self.storeValueTypes(name, key, value)
 
 class SingleProfile:
     def __init__(self, prof, profiles):
@@ -164,7 +194,8 @@ class SingleProfile:
         for key, retType in self.fieldList:
             self.updValue(self.prof, key, self.__dict__[key])
 
-    def Connect(self, parent, printing):
+    def Connect(self, parent):
+        printing = parent.printProfile
         geometry = str(self.width) + 'x' + str(self.height)
         self.c = x2go.X2goClient(logger=parent.liblogger)
         self.session_uuid = c.register_session(self.host, port=self.sshport,
@@ -199,7 +230,7 @@ class SingleProfile:
         self.profiles.writeIni()
 
     def isAlive(self):
-        return True
+        return self.c.session_ok(self.session_uuid)
 
 class x2goProfiles:
     def __init__(self):
@@ -216,8 +247,12 @@ class x2goProfiles:
         if len(self.profiles.SessionProfiles):
             self.current_profile = self.x2goprofs[0]
 
-    def append(self, name):
-        self.x2goprofs.append(SingleProfile(name))
+    def Append(self, name, **kw):
+        if self.profileExists(name):
+            raise profileError('Profile %s already exists' % name)
+        else:
+            self.profiles.newProfile(name, kw)
+            self.x2goprofs.append(SingleProfile(name, self.profiles))
 
     def writeIni(self):
         for s in self.x2goprofs:
@@ -238,7 +273,7 @@ class x2goProfiles:
         running = []
         for idx, profs in enumerate(self.profiles.iniConfig.sections()):
             connected = self.profiles.getValue(profs, 'connected', getType='bool')
-            if running:
+            if connected:
                 running.append(x2goprofs[idx])
         return running
 
@@ -248,4 +283,22 @@ class x2goProfiles:
         for idx, run in enumerate(running):
             if running.isAlive(): continue
             suspended.appended(run)
-        return suspended
\ No newline at end of file
+        return suspended
+
+    def anyRunningSessions(self):
+        return len(self.runningSessions()) &gt; 0
+
+    def listAllAvailableSessions(self):
+        availableSessions = []
+        for idx, profs in enumerate(self.profiles.iniConfig.sections()):
+            availableSessions.append([self.profiles.getValue(profs, 'name'), self.profiles.getValue(profs, 'connected', getType='bool')])
+        return availableSessions
+
+    def listNonRunningProfiles(self):
+        nonrunning = []
+        for idx, profs in enumerate(self.profiles.iniConfig.sections()):
+            connected = self.profiles.getValue(profs, 'connected', getType='bool')
+            if not connected:
+                nonrunning.append(self.profiles.getValue(profs,'name'))
+        return nonrunning
+
diff --git a/pyhoca-gui.py b/pyhoca-gui.py
index 67c1e70..60fafed 100644
--- a/pyhoca-gui.py
+++ b/pyhoca-gui.py
@@ -1,15 +1,34 @@
+# -*- coding: utf-8 -*-
+#!/usr/bin/env python
 #-----------------------------------------------------------------------------
 # Name:        pyhoca-gui.py
 # Purpose:     Main program to start the python x2go gui
-#
-# Author:      Dick Kniep
-#
-# Created:     2010/10/25
-# RCS-ID:      $Id: PyApp1.py $
-# Copyright:   (c) 2010 Lindix
 #-----------------------------------------------------------------------------
-#!/usr/bin/env python
-#Boa:PyApp:main
+
+&quot;&quot;&quot;
+    Copyright (C) 2010 by Dick Kniep &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dick.kniep at lindix.nl</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the
+    Free Software Foundation, Inc.,
+    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+    Contributors to the code of this programme:
+        J&#246;rg Sawatzki &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">joerg.sawatzki at web.de</A>&gt;
+        Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">m.gabriel at das-netzwerkteam.de</A>&gt;
+&quot;&quot;&quot;
+
+
 
 modules ={}
 
diff --git a/pyx2go_client.py b/pyx2go_client.py
deleted file mode 100644
index e4028d1..0000000
--- a/pyx2go_client.py
+++ /dev/null
@@ -1,313 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-&quot;&quot;&quot;
-    Copyright (C) 2010 by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">m.gabriel at das-netzwerkteam.de</A>&gt;
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the
-    Free Software Foundation, Inc.,
-    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-    Contributors to the code of this programme:
-        J&#246;rg Sawatzki &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">joerg.sawatzki at web.de</A>&gt;
-        Dick Kniep &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dick.kniep at lindix.nl</A>&gt;
-
-
-
-&quot;&quot;&quot;
-
-
-###
-### module section
-###
-
-import sys, os
-import time
-import argparse
-import getpass
-import x2go
-import paramiko
-from types import *
-import SessionProfile
-
-# for debugging
-import pprint
-
-# Python X2go provides the current local username (OS independent)
-from x2go.utils import CURRENT_LOCAL_USER as current_user
-
-# version information
-PROG_NAME = os.path.basename(sys.argv[0])
-PROG_PID  = os.getpid()
-VERSION=&quot;0.0.14&quot;
-VERSION_TEXT=&quot;&quot;&quot;
-%s[%s] - an X2go client written in Python
-----------------------------------------------------------------------
-developed by Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">m.gabriel at das-netzwerkteam.de</A>&gt;
-and Dick Kniep &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dick.kniep at lindix.nl</A>&gt;
-
-VERSION: %s
-
-&quot;&quot;&quot; % (PROG_NAME, PROG_PID, VERSION)
-
-class X2GoConnection:
-    def __init__(self):
-
-        self.x2goSession = SessionProfile.x2goSession()
-
-        # ,,constants'' needed for debugging
-        self.logger = x2go.X2goLogger(tag='MAIN')
-        self.liblogger = x2go.X2goLogger()
-        x2go_session_hash = ''
-
-        # use current_home as user home dir
-        current_home = os.path.expanduser(&quot;~&quot;)
-
-        # define and create known_hosts file (if not there)
-        ssh_known_hosts_filename = os.path.join(current_home, '.ssh', 'known_hosts')
-        if not os.path.isfile(ssh_known_hosts_filename):
-            self._touch_file(ssh_known_hosts_filename)
-        # define and create ssh_config file (if not there)
-        ssh_config_filename = os.path.join(current_home, '.ssh', 'config')
-        if not os.path.isfile(ssh_config_filename):
-            self._touch_file(ssh_config_filename)
-            
-
-    ###
-    ### beginning of code
-    ###
-
-    def _touch_file(self, filename):
-
-        if not os.path.isfile(filename):
-            f = open(filename, 'w')
-            f.close()
-
-
-    # print version text and exit
-    def version(self):
-
-        sys.stderr.write (&quot;%s\n&quot; % VERSION_TEXT)
-        sys.exit(0)
-
-
-    # sometimes we have to fail...
-    def runtime_error(self, m, parser=None, exitcode=-1):
-        if parser is not None:
-            parser.print_usage()
-        sys.stderr.write (&quot;%s: error: %s\n&quot; % (PROG_NAME, m))
-        sys.exit(exitcode)
-
-
-    def makeConnection(self):
-        
-        self.logger('preparing requested X2go session', x2go.loglevel_NOTICE, )
-        
-        x2goclient = x2go.X2goClient(logger=self.liblogger)
-        x2go_session_hash = x2goclient.register_session(self.x2goSession.server, port=int(self.x2goSession.remote_ssh_port), 
-                                                        username=self.x2goSession.username, 
-                                                        password=self.x2goSession.password,
-                                                        key_filename=self.x2goSession.ssh_privkey,
-                                                        add_to_known_hosts=self.x2goSession.add_to_known_hosts,
-                                                        profile_name = 'Pyhoca-Client_Session',
-                                                        session_type=self.x2goSession.session_type,
-                                                        link=self.x2goSession.link,
-                                                        geometry=self.x2goSession.geometry,
-                                                        pack=self.x2goSession.pack,
-                                                        cache_type='unix-kde',
-                                                        kblayout=self.x2goSession.kbd_layout,
-                                                        kbtype=self.x2goSession.kbd_type,
-                                                        snd_system=self.x2goSession.sound,
-                                                        printing=self.x2goSession.printing,
-                                                        cmd=self.x2goSession.command)
-
-        x2goclient.with_session(x2go_session_hash).load_host_keys(ssh_known_hosts_filename)
-        self.connected = False
-        force_password_auth = False
-        x2goclient.connect_session(x2go_session_hash, password=self.x2goSession.password, force_password_auth=force_password_auth)
-        self.connected = True
-
-    def checkSSHConfig(self)
-        ###
-        ### initialize SSH context
-        ###
-        # check if SERVER is in .ssh/config file, extract information from there...
-        ssh_config = paramiko.SSHConfig()
-        ssh_config_fileobj = open(ssh_config_filename)
-        ssh_config.parse(ssh_config_fileobj)
-        ssh_host = ssh_config.lookup(a.server)
-        if ssh_host:
-            if 'hostname' in ssh_host.keys():
-                a.server = ssh_host['hostname']
-            if 'port' in ssh_host.keys():
-                a.remote_ssh_port = ssh_host['port']
-        ssh_config_fileobj.close()
-        # check if ssh priv key exists
-        if a.ssh_privkey and not os.path.isfile(a.ssh_privkey):
-            runtime_error(&quot;SSH private key %s file does not exist.&quot; % a.ssh_privkey, parser=p, exitcode=30)
-        if not a.ssh_privkey and os.path.isfile('%s/.ssh/id_rsa' % current_home):
-            a.ssh_privkey = '%s/.ssh/id_rsa' % current_home
-        if not a.ssh_privkey and os.path.isfile('%s/.ssh/id_dsa' % current_home):
-            a.ssh_privkey = '%s/.ssh/id_dsa' % current_home
-
-        return p, a
-
-
-    def list_sessions(self, cli, s_hash):
-        # retrieve a session list
-        print
-        print &quot;Available runing/suspended X2go sessions&quot;
-        print &quot;========================================&quot;
-        print &quot;Hostname: [%s]:%s&quot; % cli.get_server(s_hash)
-        print &quot;Username: %s&quot; % cli.get_username(s_hash)
-        print 
-        session_infos = cli.list_sessions(s_hash)
-        for session_info in session_infos.values():
-            print &quot;Session Name: %s&quot; % session_info
-            print &quot;-------------&quot;
-            print &quot;cookie: %s&quot; % session_info.cookie
-            print &quot;agent PID: %s&quot; % session_info.agent_pid
-            print &quot;display: %s&quot; % session_info.display
-            print &quot;status: %s&quot; % session_info.status
-            print &quot;graphic port: %s&quot; % session_info.graphics_port
-            print &quot;snd port: %s&quot; % session_info.snd_port
-            print &quot;sshfs port: %s&quot; % session_info.sshfs_port
-            print &quot;username: %s&quot; % session_info.username
-            print &quot;hostname: %s&quot; % session_info.hostname
-            # TODO: turn into datetime object
-            print &quot;create date: %s&quot; % session_info.date_created
-            # TODO: turn into datetime object
-            print &quot;suspended since: %s&quot; % session_info.date_suspended
-            print
-
-
-    def clean_sessions(self, cli, s_hash):
-        # clean all sessions from X2go server
-        logger('cleaning up all running sessions from X2go server: %s' % self.x2goSession.server, x2go.loglevel_NOTICE, )
-        cli.clean_sessions(s_hash)
-
-
-    def new_session(self, cli, s_hash):
-        # start a new session and run a command
-        logger('starting a new X2go session', x2go.loglevel_INFO, )
-        logger('Command for new session is: %s' % self.x2goSession.command, x2go.loglevel_DEBUG, )
-        cli.start_session(s_hash)
-
-
-    def resume_session(self, cli, s_hash):
-        # resume a running session
-        logger('resuming X2go session: %s' % self.x2goSession.resume, x2go.loglevel_INFO, )
-        available_sessions = cli.list_sessions(s_hash)
-        if self.x2goSession.resume in available_sessions.keys():
-            cli.resume_session(s_hash, self.x2goSession.resume)
-        else:
-            runtime_error('requested session not available on X2go server [%s]:%s.' % (self.x2goSession.server, self.x2goSession.remote_ssh_port), exitcode=20)
-
-
-    def suspend_session(self, cli, s_hash):
-        # send a suspend request to a session
-        logger('requesting X2go session suspend of session: %s' % self.x2goSession.suspend, x2go.loglevel_INFO, )
-        available_sessions = cli.list_sessions(s_hash)
-        if self.x2goSession.suspend in available_sessions.keys():
-            cli.suspend_session(s_hash, self.x2goSession.suspend)
-        else:
-            runtime_error('requested session not available on X2go server [%s]:%s.' % (self.x2goSession.server, self.x2goSession.remote_ssh_port), exitcode=21)
-
-    def terminate_session(self, cli, s_hash):
-        # send a terminate request to a session
-        logger('requesting X2go session terminate of session: %s' % self.x2goSession.terminate, x2go.loglevel_INFO, )
-        available_sessions = cli.list_sessions(s_hash)
-        if self.x2goSession.terminate in available_sessions.keys():
-            cli.terminate_session(s_hash, self.x2goSession.terminate)
-        else:
-            runtime_error('requested session not available on X2go server [%s]:%s.' % (self.x2goSession.server, self.x2goSession.remote_ssh_port), exitcode=22)
-
-
-if __name__ == '__main__':
-
-
-        if self.x2goSession.clean_sessions:
-            clean_sessions(x2goclient, x2go_session_hash)
-
-        # go through the possible X2go client modes
-        if self.x2goSession.list_sessions:
-            # print a beautified session list for the user
-            list_sessions(x2goclient, x2go_session_hash)
-            sys.exit(0)
-
-        if args.resume:
-            resume_session(x2goclient, x2go_session_hash)
-
-        elif args.suspend:
-            suspend_session(x2goclient, x2go_session_hash)
-
-        elif args.terminate:
-            terminate_session(x2goclient, x2go_session_hash)
-
-        elif args.new:
-            new_session(x2goclient, x2go_session_hash)
-
-
-        if args.new or args.resume:
-            # give the session some time to come up...
-            # no CTRL-C is allowed during this phase...
-            i=0
-            logger(&quot;give the X2go session some time to come up...&quot;, x2go.loglevel_NOTICE, )
-            while i &lt; args.time_to_wait:
-                time.sleep(1)
-                i+=1
-
-            if x2goclient.session_ok(x2go_session_hash):
-
-                profile_name = x2goclient.get_profile_name(x2go_session_hash)
-                session_name = x2goclient.get_session_name(x2go_session_hash)
-                logger(&quot;X2go session is now running, the X2go client's profile name is: %s.&quot; % profile_name, x2go.loglevel_INFO, )
-                logger(&quot;X2go session name is: %s.&quot; % session_name, x2go.loglevel_INFO, )
-                logger(&quot;Press CTRL+C to suspend the running session.&quot;, x2go.loglevel_NOTICE, )
-                try:
-
-                    session_duration = 0
-                    mounted = False
-                    while x2goclient.session_ok(x2go_session_hash):
-                        time.sleep(2)
-                        session_duration +=2
-
-                        if session_duration &gt; 2 and not mounted and args.share_local_folders is not None:
-                            if x2goclient.with_session(x2go_session_hash).get_transport().reverse_tunnels['sshfs'][1] is not None:
-                                for _folder in args.share_local_folders:
-                                    x2goclient.share_local_folder(x2go_session_hash, _folder)
-                                mounted = True
-
-                    # wait a little longer before telling the user what had happened
-                    time.sleep(2)
-
-                    if x2goclient.has_terminated(x2go_session_hash):
-                        logger(&quot;X2go session %s has terminated.&quot; % session_name, x2go.loglevel_NOTICE, )
-                    elif x2goclient.is_suspended(x2go_session_hash):
-                        logger(&quot;X2go session %s has been suspended.&quot; % session_name, x2go.loglevel_NOTICE, )
-                    elif x2goclient.is_running(x2go_session_hash):
-                        logger(&quot;X2go session %s has been moved to a different screen.&quot; % session_name, x2go.loglevel_NOTICE, )
-
-                except KeyboardInterrupt:
-                    logger(&quot;Suspending X2go session %s.&quot; % session_name, x2go.loglevel_INFO, )
-                    x2goclient.suspend_session(x2go_session_hash)
-                    # giving nxproxy's SSH tunnel some time to settle
-                    time.sleep(2)
-                    logger(&quot;X2go session %s has been suspended.&quot; % session_name, x2go.loglevel_NOTICE, )
-
-        sys.exit(0)
-
-    except (KeyboardInterrupt, SystemExit), e:
-        x2go.x2go_cleanup(e)
-
diff --git a/x2goLogon.py b/x2goLogon.py
index b5f28a6..4e823cb 100644
--- a/x2goLogon.py
+++ b/x2goLogon.py
@@ -2,13 +2,30 @@
 #-----------------------------------------------------------------------------
 # Name:        x2goLogon.py
 # Purpose:     display the Logon screen for x2go
-#
-# Author:      Dick Kniep
-#
-# Created:     2010/10/21
-# Copyright:   (c) Lindix BV 2010
 #-----------------------------------------------------------------------------
 
+&quot;&quot;&quot;
+    Copyright (C) 2010 by Dick Kniep &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">dick.kniep at lindix.nl</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the
+    Free Software Foundation, Inc.,
+    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+    Contributors to the code of this programme:
+        J&#246;rg Sawatzki &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">joerg.sawatzki at web.de</A>&gt;
+        Mike Gabriel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">m.gabriel at das-netzwerkteam.de</A>&gt;
+&quot;&quot;&quot;
 
 import wx
 import time
@@ -29,61 +46,96 @@ except ImportError: # if it's not there locally, try the wxPython lib.
 import wx.lib.sized_controls as sc
 
 class menuActions(wx.Menu):
-    def __init__(self, parent, settingsProfile, SessionProfiles):
-        OPENNEWMENUTXT = &quot;Open new Session&quot;
-        RUNNINGMENUTXT = &quot;Running sessions&quot;
-        SUSPENDMENUTXT = &quot;Suspend session&quot;
-        RESUMEMENUTXT = &quot;Resume suspended session&quot;
-        UPDATEPROFMNUTEXT = &quot;Update Profile&quot;
-        EXITMENUTXT = &quot;E&amp;xit sessions&quot;
+    def __init__(self, parent):
+        self.parent = parent
+        if hasattr(parent,'logger'):
+            self.logger = self.parent.logger
+        else:
+            self.logger = self.parent.parent.logger
+        if hasattr(parent,'settingsProfile'):
+            self.settingsProfile = parent.settingsProfile
+            self.SessionProfiles = parent.SessionProfiles
+            self.printProfile = parent.printProfile
+        else:
+            self.settingsProfile = parent.parent.settingsProfile
+            self.SessionProfiles = parent.parent.SessionProfiles
+            self.printProfile = parent.parent.printProfile
+
+        ADDPROFILEMENUTXT = &quot;Add &amp;New profile&quot;
+        OPENNEWMENUTXT = &quot;&amp;Open new Session&quot;
+        RUNNINGMENUTXT = &quot;R&amp;Unning sessions&quot;
+        SUSPENDMENUTXT = &quot;&amp;Suspend session&quot;
+        RESUMEMENUTXT = &quot;&amp;Resume suspended session&quot;
+        UPDATEPROFMNUTEXT = &quot;&amp;Update current Profile&quot;
+        CLOSEMENUTXT = &quot;&amp;Close running Session&quot;
+        EXITMENUTXT = &quot;E&amp;xit&quot;
         MENU_NEWSESSION = wx.NewId()
         MENU_LISTSESSIONS = wx.NewId()
         MENU_SUSPEND = wx.NewId()
         MENU_RESUME = wx.NewId()
         MENU_EDITSESSION = wx.NewId()
+        MENU_CLOSESESSION = wx.NewId()
         MENU_EXIT = wx.NewId()
+        MENU_NEWPROFILE = wx.NewId()
         wx.Menu.__init__(self)
-        parent.logger('settingsProfile.newProfile %s' % dir(settingsProfile), x2go.loglevel_INFO, )
-        if settingsProfile.newprofile:
-            self.Append(MENU_NEWSESSION, OPENNEWMENUTXT)
-            self.Bind(wx.EVT_MENU, self.OnNewSession, id=MENU_NEWSESSION)
-        if SessionProfiles.runningSessions():
+        self.logger('settingsProfile.newProfile %s' % dir(self.settingsProfile), x2go.loglevel_INFO, )
+        self.Append(MENU_NEWSESSION, OPENNEWMENUTXT)
+        self.parent.Bind(wx.EVT_MENU, self.OnNewSession, id=MENU_NEWSESSION)
+        if self.settingsProfile.newprofile:
+            self.Append(MENU_NEWPROFILE, ADDPROFILEMENUTXT)
+            self.parent.Bind(wx.EVT_MENU, self.OnAddProfile, id=MENU_NEWPROFILE)
+        if self.SessionProfiles.runningSessions():
             self.Append(MENU_LISTSESSIONS, RUNNINGMENUTXT)
-            self.Bind(wx.EVT_MENU, self.OnListSessions, id=MENU_LISTSESSIONS)
+            self.parent.Bind(wx.EVT_MENU, self.OnListSessions, id=MENU_LISTSESSIONS)
             self.Append(MENU_SUSPEND, SUSPENDMENUTXT)
-            self.Bind(wx.EVT_MENU, self.OnSuspend, id=MENU_SUSPEND)
-        if SessionProfiles.suspendedSessions() and settingsProfile.resume:
+            self.parent.Bind(wx.EVT_MENU, self.OnSuspend, id=MENU_SUSPEND)
+        if self.SessionProfiles.suspendedSessions() and self.settingsProfile.resume:
             self.Append(MENU_RESUME, RESUMEMENUTXT)
-            self.Bind(wx.EVT_MENU, self.OnResume, id=MENU_RESUME)
-        if settingsProfile.editprofile:
+            self.parent.Bind(wx.EVT_MENU, self.OnResume, id=MENU_RESUME)
+        if self.settingsProfile.editprofile:
             self.AppendSeparator()
             self.Append(MENU_EDITSESSION, UPDATEPROFMNUTEXT)
-            self.Bind(wx.EVT_MENU, self.OnUpdateProfile, id=MENU_EDITSESSION)
+            self.parent.Bind(wx.EVT_MENU, self.OnUpdateProfile, id=MENU_EDITSESSION)
         self.AppendSeparator()
-        self.Bind(wx.EVT_CLOSE, self.OnClose)
-        self.Bind(wx.EVT_MENU, self.OnExit, id=MENU_EXIT)
+        self.Append(MENU_EXIT, EXITMENUTXT)
+        self.parent.Bind(wx.EVT_MENU, self.OnExit, id=MENU_EXIT)
+        self.parent.Bind(wx.EVT_CLOSE, self.OnClose)
+
+    def OnAddProfile(self, evt):
+        self.logger('Add Profile started', x2go.loglevel_INFO, )
 
     def OnNewSession(self, evt):
-        pass
+        self.logger('NewSession started', x2go.loglevel_INFO, )
+        X2GoChooseSessionScrn(self.parent)
 
     def OnListSessions(self, evt):
-        pass
+        self.logger('List Sessions started', x2go.loglevel_INFO, )
 
     def OnSuspend(self, evt):
-        pass
+        self.logger('Suspend Sessions started', x2go.loglevel_INFO, )
 
     def OnResume(self, evt):
-        pass
+        self.logger('Resume Sessions started', x2go.loglevel_INFO, )
 
     def OnUpdateProfile(self, evt):
-        pass
+        self.logger('Update Profile started', x2go.loglevel_INFO, )
 
     def OnExit(self, evt):
-        self.Close(True)
+        self.logger('Exit application', x2go.loglevel_INFO, )
+        self.__getFrameParent().Close(True)
 
     def OnClose(self, evt):
-        self.parent.env.exitAllChildren()
-        self.Destroy()
+        self.logger('Close application', x2go.loglevel_INFO, )
+        self.__getFrameParent().Close()
+
+    def __getFrameParent(self):
+        if isinstance(self, wx.Frame):
+            return self
+        if isinstance(self.parent, wx.Frame):
+            return self.parent
+        elif isinstance(self.parent.parent, wx.Frame):
+            return self.parent.parent
+
 
 class LogonStatusBar(wx.StatusBar):
     def __init__(self, parent):
@@ -110,41 +162,46 @@ class X2GoResumeSessions(sc.SizedFrame):
                         style=wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER)
 
 class X2GoPasswordScrn(sc.SizedFrame):
-    def __init__(self, parent, SessionProfiles, settingsProfile, printProfile, Iconize):
+    def __init__(self, parent, Iconize):
         &quot;&quot;&quot;
         Screen to enter the userid and password for the session
 
         if the screen is iconized, but an error occurs, the screen is displayed
         and the user can enter another userid/password
         &quot;&quot;&quot;
-        sc.SizedFrame.__init__(self, None, -1, &quot;X2go Password entry&quot;,
+        captionText = &quot;X2go Profile &quot; + parent.SessionProfiles.current_profile.name
+        sc.SizedFrame.__init__(self, None, -1, captionText,
                         style=wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER)
         self.CentreOnScreen()
 
         self.SetSize((350,250))
 
-        self.settingsProfile = settingsProfile
-        self.SessionProfiles = SessionProfiles
-        self.current_profile = SessionProfiles.current_profile
+        self.settingsProfile = parent.settingsProfile
+        self.SessionProfiles = parent.SessionProfiles
+        self.current_profile = parent.SessionProfiles.current_profile
+        self.printProfile = parent.printProfile
         self.parent = parent
-        parent.logger('Password entry screen started', x2go.loglevel_INFO, )
+        self.logger = parent.logger
+        self.logger('Password entry screen started', x2go.loglevel_INFO, )
         pane = self.GetContentsPane()
         pane.SetSizerType(&quot;form&quot;)
         pwScrn = self.passwordScrn(pane)
         self.Main_MenuBar = wx.MenuBar()
         self.SetMenuBar(self.Main_MenuBar)
-        self.Main_MenuBar.Append(menuActions(parent, settingsProfile, SessionProfiles), '&amp;Connection')
+        self.Main_MenuBar.Append(menuActions(self), '&amp;Connection')
         self.tb = X2GoLogonTaskBarIcon(self)
+        self.Bind(wx.EVT_CLOSE, self.OnCancel)
         if Iconize:
-            if self.IsIconized():
+            if not self.IsIconized():
                 self.Iconize(True)
             if parent.args.password and parent.args.username and parent.args.profile and SessionProfiles.profileExists(parent.args.profile):
                 self.onConnect()
-            else:
+            elif parent.args.profile:
                 Message(self, 'Not all credentials are available')
                 self.Iconize(False)
         else:
             self.Show(True)
+        self.Fit()
 
     def passwordScrn(self, pnl):
         wx.StaticText(pnl, -1, 'User'),
@@ -163,17 +220,15 @@ class X2GoPasswordScrn(sc.SizedFrame):
 
         self.CancelButton = wx.Button(pnl, -1, &quot;Cancel&quot;)
         self.CancelButton.Bind(wx.EVT_BUTTON, self.OnCancel)
-        #self.SetButtonSizer(self.CreateStdDialogButtonSizer(self.ConnectButton | self.CancelButton))
-        #self.SetButtonSizer(self.CreateStdDialogButtonSizer(wx.OK| wx.CANCEL))
 
     def OnOK(self, evt):
         username = self.username_ctl.GetValue()
         password = self.passwd_ctl.GetValue()
         if len(username) == 0:
-            self.Message(self,'Userid is invalid')
+            Message(self,'Userid is invalid')
             return
         if len(password) == 0:
-            self.Message(self,'Password is required')
+            Message(self,'Password is required')
             return
         self.current_profile.updValue('server','username',username)
         self.current_profile.password = password
@@ -182,11 +237,11 @@ class X2GoPasswordScrn(sc.SizedFrame):
     def onConnect(self):
         set_iconize = False
         try:
-            connection = x2goConnect.X2GoConnection(self.current_profile)
+            connection = self.current_profile.Connect(self)
             connection.makeConnection(self.session, self.StatusText)
             set_iconize = True
         except x2go.AuthenticationException:
-            self.Message(self,'Userid/Password verification failed')
+            Message(self,'Userid/Password verification failed')
         except x2go.BadHostKeyException:
             self.Message(self,'SSH host key verification for remote host [%s]:%s failed' % (self.current_profile.host, self.current_profile.ssh_port ))
         except x2go.SSHException, e:
@@ -196,32 +251,18 @@ class X2GoPasswordScrn(sc.SizedFrame):
         return
 
     def OnCancel(self, evt):
-        self.Close
-
+        if not self.SessionProfiles.anyRunningSessions():
+        #self.Close()
+            self.tb.Destroy()
+        self.Destroy()
 
-class Message:
-    def __init__(self, parent, message, extraCaption='', msgtype='error'):
-        if msgtype == 'warning':
-            msgstyle = wx.ICON_QUESTION|wx.STAY_ON_TOP
-            caption = 'Warning '
-        elif msgtype == 'error':
-            msgstyle = wx.ICON_QUESTION|wx.STAY_ON_TOP
-            caption = 'Error '
-        else:
-            msgstyle = wx.ICON_INFORMATION|wx.STAY_ON_TOP
-            caption = 'Information '
-        caption += extraCaption
-        md = wx.MessageDialog(parent, message, caption=caption, style=msgstyle)
-        result = md.ShowModal()
-        self.retValue = False
-        if result == wx.OK:
-            self.retValue = True
-        md.Destroy()
+class X2GoChooseSessionScrn(wx.Frame):
+    def __init__(self, parent):
+        wx.Frame.__init__(self)
+        self.logger = parent.logger
+        self.logger('Choose Session screen started', x2go.loglevel_INFO, )
 
-class X2GoChooseSessionScrn(sc.SizedDialog):
-    def __init__(self, parent, settingsProfile, printProfile):
-        parent.logger('Choose Session screen started', x2go.loglevel_INFO, )
-        pass
+        wx.SingleChoiceDialog(self, 'Choose profile', choices=parent.SessionProfiles.listNonRunningProfiles(), style=wx.CHOICEDLG_STYLE )
 
 class X2GoSessionDefScrn(sc.SizedDialog):
     SESSIONNOTEBOOK = wx.NewId()
@@ -229,7 +270,7 @@ class X2GoSessionDefScrn(sc.SizedDialog):
     CommandList = ['Internet Browser','Email client','OpenOffice','Terminal']
     ConnectList = ['Modem','ISDN','ADSL','WAN','LAN']
     CommpressionList = ['nopack','64k','256k','2m','256-rdp','32k-rdp','64k-rdp','16m-rdp','16m-rdp-compressed','64k-tight','2m-tight','4k-jpeg','16m-jpeg','64k-png-jpeg','16m-png-jpeg','64k-png','16m-png','16m-rgb','16m-rle']
-    def __init__(self, parent, SessionProfiles, settingsProfile, printProfile):
+    def __init__(self, parent):
 
         parent.logger('Session definition screen started', x2go.loglevel_INFO, )
         self.pnl = wx.Panel(self, -1)
@@ -361,11 +402,11 @@ class X2GoSessionDefScrn(sc.SizedDialog):
 
 class X2GoLogonTaskBarIcon(wx.TaskBarIcon):
 
-    def __init__(self, frame=None):
+    def __init__(self, parent=None):
         wx.TaskBarIcon.__init__(self)
-        self.frame = frame
-        self.frame.parent.logger('Start TaskBarIcon', x2go.loglevel_INFO, )
-        img = wx.Image('/usr/share/icons/hicolor/32x32/apps/x2goclient.png')
+        self.parent = parent
+        self.parent.parent.logger('Start TaskBarIcon type %s' % (wx.PlatformInfo, ), x2go.loglevel_INFO, )
+        img = wx.Image('Images/x2goclient.png')
         icon = self.MakeIcon(img)
         self.SetIcon(icon, &quot;x2go connect&quot;)
         self.imgidx = 1
@@ -377,7 +418,7 @@ class X2GoLogonTaskBarIcon(wx.TaskBarIcon):
         the menu how you want it and return it from this function,
         the base class takes care of the rest.
         &quot;&quot;&quot;
-        menu = menuActions(self.frame.parent, self.frame.settingsProfile, self.frame.SessionProfiles)
+        menu = menuActions(self)
         return menu
 
     def MakeIcon(self, img):
@@ -394,35 +435,52 @@ class X2GoLogonTaskBarIcon(wx.TaskBarIcon):
         return icon
 
     def OnTaskBarEditSession(self, evt):
-        if self.frame:
-            if self.frame.IsIconized():
-                self.frame.Iconize(False)
-            if not self.frame.IsShown():
-                self.frame.Show(True)
-            self.frame.Raise()
+        if self.parent.IsIconized():
+            self.parent.Iconize(False)
+        if not self.parent.IsShown():
+            self.parent.Show(True)
+        self.parent.Raise()
 
 
     def OnTaskBarExitSessions(self, evt):
-        if self.frame:
-            wx.CallAfter(self.frame.Close)
+        if self.parent:
+            wx.CallAfter(self.parent.Close)
 
 
-    def OnTaskBarResumeSession(self, evt):
-        names = [ &quot;WXPdemo&quot;, &quot;Mondrian&quot;, &quot;Pencil&quot;, &quot;Carrot&quot; ]
-        name = names[self.imgidx]
+    #def OnTaskBarResumeSession(self, evt):
+        #names = [ &quot;WXPdemo&quot;, &quot;Mondrian&quot;, &quot;Pencil&quot;, &quot;Carrot&quot; ]
+        #name = names[self.imgidx]
 
-        eImg = getattr(images, name)
-        self.imgidx += 1
-        if self.imgidx &gt;= len(names):
-            self.imgidx = 0
+        #eImg = getattr(images, name)
+        #self.imgidx += 1
+        #if self.imgidx &gt;= len(names):
+            #self.imgidx = 0
 
-        icon = self.MakeIcon(eImg.Image)
-        self.SetIcon(icon, &quot;This is a new icon: &quot; + name)
+        #icon = self.MakeIcon(eImg.Image)
+        #self.SetIcon(icon, &quot;This is a new icon: &quot; + name)
 
 
-    def OnTaskBarNewSession(self, evt):
-        self.RemoveIcon()
+    #def OnTaskBarNewSession(self, evt):
+        #self.RemoveIcon()
 
+class Message:
+    def __init__(self, parent, message, extraCaption='', msgtype='error'):
+        if msgtype == 'warning':
+            msgstyle = wx.ICON_QUESTION|wx.STAY_ON_TOP
+            caption = 'Warning '
+        elif msgtype == 'error':
+            msgstyle = wx.ICON_QUESTION|wx.STAY_ON_TOP
+            caption = 'Error '
+        else:
+            msgstyle = wx.ICON_INFORMATION|wx.STAY_ON_TOP
+            caption = 'Information '
+        caption += extraCaption
+        md = wx.MessageDialog(parent, message, caption=caption, style=msgstyle)
+        result = md.ShowModal()
+        self.retValue = False
+        if result == wx.OK:
+            self.retValue = True
+        md.Destroy()
 
 def checkArgs(parent, args, SessionProfiles):
     if args.profile and not SessionProfiles.profileExists(args.profile):
@@ -432,7 +490,7 @@ def checkArgs(parent, args, SessionProfiles):
 
 def startX2Go(parent):
     &quot;&quot;&quot;
-    This routine starts processing
+    This routine starts all processing
 
     If there is only one profile available, or if there is one (1) single
     profile that has the default switch, the logon screen
@@ -440,32 +498,32 @@ def startX2Go(parent):
     &quot;&quot;&quot;
     parent.logger('starting a new X2go GUI session', x2go.loglevel_INFO, )
 
-    printProfile = SessionProfile.Printing()
-    settingsProfile = SessionProfile.Settings()
-    SessionProfiles = SessionProfile.x2goProfiles()
-    noSessionsDefined = len(SessionProfiles.x2goprofs) == 0
-    moreSessionsDefined = len(SessionProfiles.x2goprofs) &gt; 1
+    parent.printProfile = SessionProfile.Printing()
+    parent.settingsProfile = SessionProfile.Settings()
+    parent.SessionProfiles = SessionProfile.x2goProfiles()
+    noSessionsDefined = len(parent.SessionProfiles.x2goprofs) == 0
+    moreSessionsDefined = len(parent.SessionProfiles.x2goprofs) &gt; 1
 
-    checkArgs(parent, parent.args, SessionProfiles)
-    sessionsSuspended = SessionProfiles.suspendedSessions()
-    if len(sessionsSuspended) and settingsProfile.autoresume:
+    #checkArgs(parent, parent.args, SessionProfiles)
+    sessionsSuspended = parent.SessionProfiles.suspendedSessions()
+    if len(sessionsSuspended) and parent.settingsProfile.autoresume:
         parent.logger('autoresume sessionsSuspended %s' % sessionsSuspended, x2go.loglevel_INFO, )
         for suspended in sessionsSuspended:
             suspended.Resume()
     elif len(sessionsSuspended):
         parent.logger('Choose SuspendedSessions %s' % sessionsSuspended, x2go.loglevel_INFO, )
-        X2GoResumeSessions(parent, sessionsSuspended, settingsProfile, printProfile)
+        X2GoResumeSessions(parent, sessionsSuspended)
     else:
         if parent.args.minimized:
             parent.logger('Start minimized', x2go.loglevel_INFO, )
-            pwScrn = X2GoPasswordScrn(parent, SessionProfiles, settingsProfile, printProfile, Iconize=True)
+            pwScrn = X2GoPasswordScrn(parent, Iconize=True)
         else:
             if not noSessionsDefined and (not moreSessionsDefined or SessionProfiles.defaultAvailable()):
                 parent.logger('Start password entry normally', x2go.loglevel_INFO, )
-                pwScrn = X2GoPasswordScrn(parent, SessionProfiles, settingsProfile, printProfile)
+                pwScrn = X2GoPasswordScrn(parent)
             elif noSessionsDefined:
                 parent.logger('Start Profile Definition', x2go.loglevel_INFO, )
-                defScrn = X2GoSessionDefScrn(parent, SessionProfiles, settingsProfile, printProfile)
+                defScrn = X2GoSessionDefScrn(parent)
             else:
                 parent.logger('Start Profile choice', x2go.loglevel_INFO, )
-                choiceScrn = X2GoChooseSessionScrn(parent, settingsProfile, printProfile)
+                choiceScrn = X2GoChooseSessionScrn(parent)


hooks/post-receive
-- 
pyhoca-gui.git (Python X2Go Client (wxPython GUI))

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;pyhoca-gui.git&quot; (Python X2Go Client (wxPython GUI)).

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010138.html">[X2Go-Commits] pyhoca-gui.git -	build-59a18b6e3b5d3f1dd8f07f26433d37fe5984a57d (branch)	updated: 81eeb4e708475585014567bb826564641777364b
</A></li>
	<LI>Next message: <A HREF="010141.html">[X2Go-Commits] pyhoca-gui.git -	build-59a18b6e3b5d3f1dd8f07f26433d37fe5984a57d (branch)	updated: 66a75dce88b6ea0d3a5e38d2beab3dcb3eddb46e
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10139">[ date ]</a>
              <a href="thread.html#10139">[ thread ]</a>
              <a href="subject.html#10139">[ subject ]</a>
              <a href="author.html#10139">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2Go-commits
mailing list</a><br>
</body></html>
