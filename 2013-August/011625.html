<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxagent/3.4.0-8
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2013-August/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-baikal%20%28branch%29%20updated%3A%0A%09nxagent/3.4.0-8&In-Reply-To=%3C20130830142345.E56C55DB37%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011624.html">
   <LINK REL="Next"  HREF="011626.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxagent/3.4.0-8</H1>
    <B>X2Go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-baikal%20%28branch%29%20updated%3A%0A%09nxagent/3.4.0-8&In-Reply-To=%3C20130830142345.E56C55DB37%40ymir%3E"
       TITLE="[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxagent/3.4.0-8">git-admin at x2go.org
       </A><BR>
    <I>Fri Aug 30 16:23:45 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="011624.html">[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxagent/3.4.0-5
</A></li>
        <LI>Next message: <A HREF="011626.html">[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxagent/3.4.0-9
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11625">[ date ]</a>
              <a href="thread.html#11625">[ thread ]</a>
              <a href="subject.html#11625">[ subject ]</a>
              <a href="author.html#11625">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, build-baikal has been updated
       via  b7494f082ad56049c24927afdf89abc852fe06bb (commit)
      from  c078024019d334eb96fbfaf922c64297c9a0c6e0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
-----------------------------------------------------------------------

Summary of changes:
 nx-X11/programs/Xserver/hw/nxagent/Atoms.c         |   28 +-
 nx-X11/programs/Xserver/hw/nxagent/Atoms.h         |    2 +-
 nx-X11/programs/Xserver/hw/nxagent/CHANGELOG       |   56 ++
 nx-X11/programs/Xserver/hw/nxagent/Events.c        |  553 ++++++++++++++++----
 nx-X11/programs/Xserver/hw/nxagent/Events.h        |    1 +
 nx-X11/programs/Xserver/hw/nxagent/Imakefile       |    3 +-
 nx-X11/programs/Xserver/hw/nxagent/Keystroke.c     |   12 +
 nx-X11/programs/Xserver/hw/nxagent/Pixels.h        |   18 +
 nx-X11/programs/Xserver/hw/nxagent/Pointer.c       |   34 ++
 nx-X11/programs/Xserver/hw/nxagent/Pointer.h       |    9 +
 nx-X11/programs/Xserver/hw/nxagent/Reconnect.c     |    4 +
 nx-X11/programs/Xserver/hw/nxagent/Render.c        |  281 +++++++++-
 nx-X11/programs/Xserver/hw/nxagent/Render.h        |    2 +
 nx-X11/programs/Xserver/hw/nxagent/Rootless.c      |   43 +-
 nx-X11/programs/Xserver/hw/nxagent/Screen.c        |  234 +--------
 nx-X11/programs/Xserver/hw/nxagent/Screen.h        |    3 -
 nx-X11/programs/Xserver/hw/nxagent/Window.c        |  269 ++--------
 nx-X11/programs/Xserver/hw/nxagent/X/NXpicture.c   |   47 +-
 .../Xserver/hw/nxagent/X/NXpicture.c.NX.original   |   47 +-
 nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c    |   58 +-
 .../Xserver/hw/nxagent/X/NXrender.c.NX.original    |   58 +-
 21 files changed, 1179 insertions(+), 583 deletions(-)

The diff of changes is:
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Atoms.c b/nx-X11/programs/Xserver/hw/nxagent/Atoms.c
index 7f12406..171df95 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Atoms.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Atoms.c
@@ -66,19 +66,21 @@ Atom nxagentAtoms[NXAGENT_NUMBER_OF_ATOMS];
 
 static char *nxagentAtomNames[NXAGENT_NUMBER_OF_ATOMS + 1] =
 {
-  &quot;NX_IDENTITY&quot;,          /* 0  */
-  &quot;WM_PROTOCOLS&quot;,         /* 1  */
-  &quot;WM_DELETE_WINDOW&quot;,     /* 2  */
-  &quot;WM_NX_READY&quot;,          /* 3  */
-  &quot;MCOPGLOBALS&quot;,          /* 4  */
-  &quot;NX_CUT_BUFFER_SERVER&quot;, /* 5  */
-  &quot;TARGETS&quot;,              /* 6  */
-  &quot;TEXT&quot;,                 /* 7  */
-  &quot;NX_AGENT_SIGNATURE&quot;,   /* 8  */
-  &quot;NXDARWIN&quot;,             /* 9  */
-  &quot;CLIPBOARD&quot;,            /* 10 */
-  &quot;TIMESTAMP&quot;,            /* 11 */
-  &quot;UTF8_STRING&quot;,          /* 12 */
+  &quot;NX_IDENTITY&quot;,              /* 0  */
+  &quot;WM_PROTOCOLS&quot;,             /* 1  */
+  &quot;WM_DELETE_WINDOW&quot;,         /* 2  */
+  &quot;WM_NX_READY&quot;,              /* 3  */
+  &quot;MCOPGLOBALS&quot;,              /* 4  */
+  &quot;NX_CUT_BUFFER_SERVER&quot;,     /* 5  */
+  &quot;TARGETS&quot;,                  /* 6  */
+  &quot;TEXT&quot;,                     /* 7  */
+  &quot;NX_AGENT_SIGNATURE&quot;,       /* 8  */
+  &quot;NXDARWIN&quot;,                 /* 9  */
+  &quot;CLIPBOARD&quot;,                /* 10 */
+  &quot;TIMESTAMP&quot;,                /* 11 */
+  &quot;UTF8_STRING&quot;,              /* 12 */
+  &quot;_NET_WM_STATE&quot;,            /* 13 */
+  &quot;_NET_WM_STATE_FULLSCREEN&quot;, /* 14 */
   NULL,
   NULL
 };
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Atoms.h b/nx-X11/programs/Xserver/hw/nxagent/Atoms.h
index d8acb94..f49f275 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Atoms.h
+++ b/nx-X11/programs/Xserver/hw/nxagent/Atoms.h
@@ -22,7 +22,7 @@
 #include &quot;../../include/window.h&quot;
 #include &quot;screenint.h&quot;
 
-#define NXAGENT_NUMBER_OF_ATOMS  14
+#define NXAGENT_NUMBER_OF_ATOMS  16
 
 extern Atom nxagentAtoms[NXAGENT_NUMBER_OF_ATOMS];
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG b/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG
index 1a82e9a..9e067d4 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG
+++ b/nx-X11/programs/Xserver/hw/nxagent/CHANGELOG
@@ -1,5 +1,61 @@
 ChangeLog:
 
+nxagent-3.4.0-8
+
+- Grab the keyboard in fullscreen mode on EnterNotify only if mode is
+  'NotifyNormal'.
+
+- Yield control in the dispatch loop in case we stop the smart sche-
+  duler timer while waiting for a reply from the remote display.
+
+nxagent-3.4.0-7
+
+- Fixed TR08D01478. The communication with the compiz window manager
+  by means of the _NET_WM_PING property was not handled properly.
+
+- Fixed a type mismatch in XKB events on 64 bit platforms.
+
+- Moved grab/ungrab keyboard from focus in/out event to enter/leave
+  notify event.
+
+- Removed nxagentIconWindow because it's not longer used.
+
+nxagent-3.4.0-6
+
+- Fixed TR09F02102. Problem was with pointer buttons map.
+
+- Fixed TR02H02327. Some KeyRelease events was discarded.
+
+- Fixed up Num and Caps locks.
+
+- Fixed TR03H02335. Emulated right mouse button for Mac clients.
+
+- Added utilities to print info about internal and remote windows.
+
+- Fixed TR01F01995. Solved a picture resource leak by destroying remo-
+  te pictures only when their reference counter returns to zero.
+
+- Fixed TR04H02337. Errors occurred because pictures with no drawable
+  were handled badly.
+
+- Implemented handling nxagent's private for gradient pictures and so-
+  lid fill picture.
+
+- Fixed BadMatch condition check in function ProcRenderComposite.
+
+- Fixed nxagentComposite() to handle situations with source picture
+  drawable pointing to NULL.
+
+- Implemented render acceleration for requests:  CreateSolidFill,
+  CreateLinearGradient, CreateRadialGradient, CreateConicalGradient.
+
+- Fixed TR03G02196. Dialogs are shown to the fore when the NX session
+  is in fullscreen mode.
+
+- Changed mechanism to switch to fullscreen mode. Now the override
+  redirect attribute is no longer used and _NET_WM_STATE_FULLSCREEN
+  hint is sent to the WM.
+
 nxagent-3.4.0-5
 
 - Updated copyright to year 2010.
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Events.c b/nx-X11/programs/Xserver/hw/nxagent/Events.c
index ca21423..33eafa5 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Events.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Events.c
@@ -76,7 +76,9 @@
 #include &quot;input.h&quot;
 #endif
 
+#define Time XlibXID
 #include &quot;XKBlib.h&quot;
+#undef Time
 
 #define GC     XlibGC
 #define Font   XlibFont
@@ -203,6 +205,8 @@ CARD32 nxagentLastEventTime     = 0;
 CARD32 nxagentLastKeyPressTime  = 0;
 Time   nxagentLastServerTime    = 0;
 
+int nxagentPointerAndKeyboardGrabbed = 0;
+
 /*
  * Used for storing windows that need to
  * receive expose events from the agent.
@@ -219,6 +223,16 @@ static void nxagentForwardRemoteExpose(void);
 static int nxagentClipAndSendExpose(WindowPtr pWin, pointer ptr);
 
 /*
+ * This is from NXproperty.c.
+ */
+
+int GetWindowProperty(WindowPtr pWin, Atom property, long longOffset,
+                          long longLength, Bool delete, Atom type,
+                              Atom *actualType, int *format, unsigned
+                                  long *nItems, unsigned long *bytesAfter,
+                                      unsigned char **propData);
+
+/*
  * Associate a resource to a drawable and
  * store the region affected by the split
  * operation.
@@ -274,6 +288,280 @@ void ProcessInputEvents()
   mieqProcessInputEvents();
 }
 
+#ifdef DEBUG_TREE
+
+/*
+ * Print ID and name of window.
+ */
+
+void nxagentRemoteWindowID(Window window, Bool newline)
+{
+#ifdef NO_I18N
+    char *winName;
+#else
+    XTextProperty tp;
+#endif
+
+  fprintf(stderr, &quot;0x%lx&quot;, window);
+
+  if (!window)
+  {
+    fprintf(stderr, &quot; (none) &quot;);
+  }
+  else
+  {
+    if (window == DefaultRootWindow(nxagentDisplay))
+    {
+      fprintf(stderr, &quot; (the root window) &quot;);
+    }
+
+#ifdef NO_I18N
+
+    if (!XFetchName(nxagentDisplay, window, &amp;winName))
+    {
+      fprintf(stderr, &quot; (has no name) &quot;);
+    }
+    else if (winName)
+    {
+      fprintf(stderr, &quot; \&quot;%s\&quot; &quot;, winName);
+      XFree(winName);
+    }
+
+#else
+
+    if (XGetWMName(nxagentDisplay, window, &amp;tp) != 0)
+    {
+      fprintf(stderr, &quot; (has no name) &quot;);
+    }
+    else if (tp.nitems &gt; 0)
+    {
+      int count = 0;
+      int i, ret;
+      char **list = NULL;
+
+      fprintf(stderr, &quot; \&quot;&quot;);
+
+      ret = XmbTextPropertyToTextList(nxagentDisplay, &amp;tp, &amp;list, &amp;count);
+
+      if ((ret == Success || ret &gt; 0) &amp;&amp; list != NULL)
+      {
+        for (i = 0; i &lt; count; i++)
+        {
+          fprintf(stderr, &quot;%s&quot;, list[i]);
+        }
+
+        XFreeStringList(list);
+      }
+      else
+      {
+        fprintf(stderr, &quot;%s&quot;, tp.value);
+      }
+
+      fprintf(stderr, &quot;\&quot; &quot;);
+    }
+
+#endif
+
+    else
+    {
+      fprintf(stderr, &quot; (has no name) &quot;);
+    }
+  }
+
+  if (newline == TRUE)
+  {
+    fprintf(stderr, &quot;\n&quot;);
+  }
+
+  return;
+}
+
+/*
+ * Print info about remote window.
+ */
+
+void nxagentRemoteWindowInfo(Window win, int indent, Bool newLine)
+{
+  XWindowAttributes attributes;
+  int i;
+
+  if (XGetWindowAttributes(nxagentDisplay, win, &amp;attributes) == 0)
+  {
+    return;
+  }
+
+  for (i = 0; i &lt; indent; i++)
+  {
+    fprintf(stderr, &quot; &quot;);
+  }
+
+  fprintf(stderr, &quot;x=%d y=%d width=%d height=%d class=%s map_state=%s &quot;
+             &quot;override_redirect=%s\n&quot;, attributes.x, attributes.y,
+                 attributes.width, attributes.height, (attributes.class == 0) ?
+                     &quot;InputOutput&quot; : &quot;InputOnly&quot;, (attributes.map_state == 0) ?
+                         &quot;IsUnmapped&quot; : (attributes.map_state == 1 ?
+                             &quot;IsUnviewable&quot; : &quot;IsViewable&quot;),
+                                 (attributes.override_redirect == 0) ?
+                                     &quot;No&quot; : &quot;Yes&quot; );
+
+  if (newLine == TRUE)
+  {
+    fprintf(stderr, &quot;\n&quot;);
+  }
+}
+
+/*
+ * Walk remote windows tree.
+ */
+
+void nxagentRemoteWindowsTree(Window window, int level)
+{
+  int i, j;
+  Window rootWin, parentWin;
+  unsigned int numChildren;
+  Window *childList;
+
+  if (!XQueryTree(nxagentDisplay, window, &amp;rootWin, &amp;parentWin, &amp;childList,
+                      &amp;numChildren))
+  {
+    fprintf(stderr, &quot;nxagentRemoteWindowsTree - XQueryTree failed.\n&quot;);
+
+    return;
+  }
+
+  if (level == 0)
+  {
+    fprintf(stderr, &quot;\n&quot;);
+
+    fprintf(stderr, &quot;  Root Window ID: &quot;);
+    nxagentRemoteWindowID(rootWin, TRUE);
+
+    fprintf(stderr, &quot;  Parent window ID: &quot;);
+    nxagentRemoteWindowID(parentWin, TRUE);
+  }
+
+  if (level == 0 || numChildren &gt; 0)
+  {
+    fprintf(stderr, &quot;     &quot;);
+
+    for (j = 0; j &lt; level; j++)
+    {
+      fprintf(stderr, &quot;    &quot;);
+    }
+
+    fprintf(stderr, &quot;%d child%s%s\n&quot;, numChildren, (numChildren == 1) ? &quot;&quot; :
+               &quot;ren&quot;, (numChildren == 1) ? &quot;:&quot; : &quot;.&quot;);
+  }
+
+  for (i = (int) numChildren - 1; i &gt;= 0; i--)
+  {
+    fprintf(stderr, &quot;      &quot;);
+
+    for (j = 0; j &lt; level; j++)
+    {
+      fprintf(stderr, &quot;     &quot;);
+    }
+
+    nxagentRemoteWindowID(childList[i], TRUE);
+
+    nxagentRemoteWindowInfo(childList[i], (level * 5) + 6, TRUE);
+
+    nxagentRemoteWindowsTree(childList[i], level + 1);
+  }
+
+  if (childList)
+  {
+    XFree((char *) childList);
+  }
+}
+
+/*
+ * Print info about internal window.
+ */
+
+void nxagentInternalWindowInfo(WindowPtr pWin, int indent, Bool newLine)
+{
+  int i;
+  int result;
+  unsigned long ulReturnItems;
+  unsigned long ulReturnBytesLeft;
+  Atom          atomReturnType;
+  int           iReturnFormat;
+  unsigned char *pszReturnData = NULL;
+
+  fprintf(stderr, &quot;Window ID=[0x%lx] Remote ID=[0x%lx] &quot;, pWin -&gt; drawable.id,
+             nxagentWindow(pWin));
+
+  result = GetWindowProperty(pWin, MakeAtom(&quot;WM_NAME&quot;, 7, False) , 0,
+                                sizeof(CARD32), False, AnyPropertyType,
+                                    &amp;atomReturnType, &amp;iReturnFormat,
+                                        &amp;ulReturnItems, &amp;ulReturnBytesLeft,
+                                            &amp;pszReturnData);
+
+  fprintf(stderr, &quot;Name: &quot;);
+
+  if (result == Success &amp;&amp; pszReturnData != NULL)
+  {
+    pszReturnData[ulReturnItems] = '\0';
+
+    fprintf(stderr, &quot;\&quot;%s\&quot;\n&quot;, (char *) pszReturnData);
+  }
+  else
+  {
+    fprintf(stderr, &quot;%s\n&quot;, &quot;( has no name )&quot;);
+  }
+
+  for (i = 0; i &lt; indent; i++)
+  {
+    fprintf(stderr, &quot; &quot;);
+  }
+
+  fprintf(stderr, &quot;x=%d y=%d width=%d height=%d class=%s map_state=%s &quot;
+             &quot;override_redirect=%s&quot;, pWin -&gt; drawable.x, pWin -&gt; drawable.y,
+                 pWin -&gt; drawable.width, pWin -&gt; drawable.height,
+                     (pWin -&gt; drawable.class == 0) ? &quot;InputOutput&quot; :
+                         &quot;InputOnly&quot;, (pWin -&gt; mapped == 0) ?
+                             &quot;IsUnmapped&quot; : (pWin -&gt; mapped == 1 ?
+                                 &quot;IsUnviewable&quot; : &quot;IsViewable&quot;),
+                                     (pWin -&gt; overrideRedirect == 0) ?
+                                         &quot;No&quot; : &quot;Yes&quot;);
+
+  if (newLine == TRUE)
+  {
+    fprintf(stderr, &quot;\n&quot;);
+  }
+}
+
+/*
+ * Walk internal windows tree.
+ */
+
+void nxagentInternalWindowsTree(WindowPtr pWin, int indent)
+{
+  WindowPtr pChild;
+  int i;
+
+  while (pWin)
+  {
+    pChild = pWin -&gt; firstChild;
+
+    for (i = 0; i &lt; indent; i++)
+    {
+      fprintf(stderr, &quot; &quot;);
+    }
+
+    nxagentInternalWindowInfo(pWin, indent, TRUE);
+
+    fprintf(stderr, &quot;\n&quot;);
+
+    nxagentInternalWindowsTree(pChild, indent + 4);
+
+    pWin = pWin -&gt; nextSib;
+  }
+}
+
+#endif /* DEBUG_TREE */
+
 void nxagentSwitchResizeMode(ScreenPtr pScreen)
 {
   XSizeHints sizeHints;
@@ -290,8 +578,11 @@ void nxagentSwitchResizeMode(ScreenPtr pScreen)
 
     nxagentLaunchDialog(DIALOG_DISABLE_DESKTOP_RESIZE_MODE);
 
-    sizeHints.max_width = nxagentOption(RootWidth);
-    sizeHints.max_height = nxagentOption(RootHeight);
+    if (nxagentOption(Fullscreen) == 0)
+    {
+      sizeHints.max_width = nxagentOption(RootWidth);
+      sizeHints.max_height = nxagentOption(RootHeight);
+    }
   }
   else
   {
@@ -299,8 +590,6 @@ void nxagentSwitchResizeMode(ScreenPtr pScreen)
 
     nxagentLaunchDialog(DIALOG_ENABLE_DESKTOP_RESIZE_MODE);
 
-    nxagentRRSetScreenConfig(pScreen, nxagentOption(Width), nxagentOption(Height));
-
     if (nxagentOption(ClientOs) == ClientOsWinnt)
     {
       NXSetExposeParameters(nxagentDisplay, 0, 0, 0);
@@ -655,6 +944,22 @@ void nxagentDispatchEvents(PredicateFuncPtr predicate)
           {
             break;
           }
+
+          #ifdef DEBUG_TREE
+
+          case doDebugTree:
+          {
+            fprintf(stderr, &quot;\n ========== nxagentRemoteWindowsTree ==========\n&quot;);
+            nxagentRemoteWindowsTree(nxagentWindow(WindowTable[0]), 0);
+
+            fprintf(stderr, &quot;\n========== nxagentInternalWindowsTree ==========\n&quot;);
+            nxagentInternalWindowsTree(WindowTable[0], 0);
+
+            break;
+          }
+
+          #endif /* DEBUG_TREE */
+
           case doCloseSession:
           {
             closeSession = TRUE;
@@ -797,7 +1102,8 @@ FIXME: Don't enqueue the KeyRelease event if the key was
        enqueued and to remove the KeyPress afterwards.
 */
 
-        if (inputInfo.keyboard -&gt; key -&gt; down[X.xkey.keycode &gt;&gt; 3] &amp; (1 &lt;&lt; (X.xkey.keycode &amp; 7)))
+        if (BitIsOn(inputInfo.keyboard -&gt; key -&gt; down,
+                       nxagentConvertKeycode(X.xkey.keycode)))
         {
           sendKey = 1;
         }
@@ -871,6 +1177,23 @@ FIXME: Don't enqueue the KeyRelease event if the key was
 
         nxagentInputEvent = 1;
 
+        if (nxagentOption(ClientOs) == ClientOsMac &amp;&amp; (X.xbutton.state &amp; ControlMask) == ControlMask)
+        {
+          x.u.u.type = ButtonPress;
+          x.u.u.detail = inputInfo.pointer -&gt; button -&gt; map[3];
+          x.u.keyButtonPointer.time = nxagentLastEventTime = GetTimeInMillis();
+
+          mieqEnqueue(&amp;x);
+
+          x.u.u.type = ButtonRelease;
+          x.u.u.detail = inputInfo.pointer -&gt; button -&gt; map[3];
+          x.u.keyButtonPointer.time = nxagentLastEventTime = GetTimeInMillis();
+
+          mieqEnqueue(&amp;x);
+
+          break;
+        }
+
         if (nxagentOption(Fullscreen))
         {
           if (nxagentMagicPixelZone(X.xbutton.x, X.xbutton.y))
@@ -917,7 +1240,7 @@ FIXME: Don't enqueue the KeyRelease event if the key was
                     X.xbutton.subwindow == None))
         {
           x.u.u.type = ButtonPress;
-          x.u.u.detail = X.xbutton.button;
+          x.u.u.detail = inputInfo.pointer -&gt; button -&gt; map[nxagentReversePointerMap[X.xbutton.button - 1]];
           x.u.keyButtonPointer.time = nxagentLastEventTime = GetTimeInMillis();
 
           if (nxagentOption(Rootless))
@@ -974,6 +1297,11 @@ FIXME: Don't enqueue the KeyRelease event if the key was
 
         nxagentInputEvent = 1;
 
+        if (nxagentOption(ClientOs) == ClientOsMac &amp;&amp; (X.xbutton.state &amp; ControlMask) == ControlMask)
+        {
+          break;
+        }
+
         if (viewportCursor)
         {
           /*
@@ -990,7 +1318,7 @@ FIXME: Don't enqueue the KeyRelease event if the key was
         if (minimize != True)
         {
           x.u.u.type = ButtonRelease;
-          x.u.u.detail = X.xbutton.button;
+          x.u.u.detail = inputInfo.pointer -&gt; button -&gt; map[nxagentReversePointerMap[X.xbutton.button - 1]];
           x.u.keyButtonPointer.time = nxagentLastEventTime = GetTimeInMillis();
 
           if (nxagentOption(Rootless))
@@ -1344,10 +1672,11 @@ FIXME: Don't enqueue the KeyRelease event if the key was
           nxagentScreenTrap = 0;
         }
 
-        if (nxagentOption(Fullscreen))
+        if (nxagentOption(Fullscreen) == 1)
         {
-          if (X.xcrossing.window == nxagentFullscreenWindow &amp;&amp;
-                  X.xcrossing.detail != NotifyInferior)
+          if (X.xcrossing.window == nxagentDefaultWindows[0] &amp;&amp;
+                  X.xcrossing.detail != NotifyInferior &amp;&amp;
+                      X.xcrossing.mode == NotifyNormal)
           {
             nxagentGrabPointerAndKeyboard(&amp;X);
           }
@@ -1399,9 +1728,9 @@ FIXME: Don't enqueue the KeyRelease event if the key was
           nxagentLastEnteredWindow = NULL;
         }
 
-        if (nxagentOption(Fullscreen))
+        if (nxagentPointerAndKeyboardGrabbed == 1)
         {
-          if (X.xcrossing.window == nxagentFullscreenWindow &amp;&amp;
+          if (X.xcrossing.window == nxagentDefaultWindows[0] &amp;&amp;
                   X.xcrossing.detail != NotifyInferior &amp;&amp;
                       X.xcrossing.mode == NotifyNormal)
           {
@@ -1660,7 +1989,7 @@ FIXME: Don't enqueue the KeyRelease event if the key was
         }
 
         if (nxagentUseNXTrans == 1 &amp;&amp; nxagentOption(Rootless) == 0 &amp;&amp;
-                nxagentOption(Nested) == 0 &amp;&amp; X.xmap.window != nxagentIconWindow)
+                nxagentOption(Nested) == 0)
         {
           nxagentVisibility = VisibilityFullyObscured;
         }
@@ -1701,12 +2030,6 @@ FIXME: Don't enqueue the KeyRelease event if the key was
 
         if (nxagentOption(Fullscreen) == 1)
         {
-          if (X.xmap.window == nxagentIconWindow)
-          {
-            pScreen = nxagentScreen(X.xmap.window);
-            nxagentMaximizeToFullScreen(pScreen);
-          }
-
           nxagentVisibility = VisibilityUnobscured;
           nxagentVisibilityStop = False;
           nxagentVisibilityTimeout = GetTimeInMillis() + 2000;
@@ -1716,10 +2039,17 @@ FIXME: Don't enqueue the KeyRelease event if the key was
       }
       case MappingNotify:
       {
+        XMappingEvent *mappingEvent = (XMappingEvent *) &X;
+
         #ifdef DEBUG
         fprintf(stderr, &quot;nxagentDispatchEvents: WARNING! Going to handle new MappingNotify event.\n&quot;);
         #endif
 
+        if (mappingEvent -&gt; request == MappingPointer)
+        {
+            nxagentInitPointerMap();
+        }
+
         break;
       }
       default:
@@ -1959,8 +2289,16 @@ int nxagentHandleKeyPress(XEvent *X, enum HandleEventResult *result)
     return 1;
   }
 
-  nxagentLastEventTime = nxagentLastKeyPressTime = GetTimeInMillis();
+  if (X -&gt; xkey.keycode == 66)
+  {
+    nxagentXkbState.Caps = (~nxagentXkbState.Caps &amp; 1);
+  }
+  else if (X -&gt; xkey.keycode == 77)
+  {
+    nxagentXkbState.Num = (~nxagentXkbState.Num &amp; 1);
+  }
 
+  nxagentLastEventTime = nxagentLastKeyPressTime = GetTimeInMillis();
   
   x.u.u.type = KeyPress;
   x.u.u.detail = nxagentConvertKeycode(X -&gt; xkey.keycode);
@@ -2270,7 +2608,6 @@ int nxagentHandleGraphicsExposeEvent(XEvent *X)
 
 int nxagentHandleClientMessageEvent(XEvent *X, enum HandleEventResult *result)
 {
-  ScreenPtr pScreen;
   WindowPtr pWin;
   xEvent x;
 
@@ -2386,19 +2723,8 @@ int nxagentHandleClientMessageEvent(XEvent *X, enum HandleEventResult *result)
         fprintf(stderr, &quot;Events: WM_DELETE_WINDOW arrived Atom = %ld.\n&quot;, wmAtom);
         #endif
 
-        if (X -&gt; xclient.window == nxagentIconWindow)
-        {
-          pScreen = nxagentScreen(X -&gt; xmap.window);
-
-          XMapRaised(nxagentDisplay, nxagentFullscreenWindow);
-
-          XIconifyWindow(nxagentDisplay, nxagentIconWindow,
-                             DefaultScreen(nxagentDisplay));
-
-        }
-
-        if (X -&gt; xclient.window == (nxagentOption(Fullscreen) ?
-              nxagentIconWindow : nxagentDefaultWindows[0]))
+        if (X -&gt; xclient.window == nxagentDefaultWindows[0] ||
+                nxagentWMIsRunning == 0)
         {
           *result = doCloseSession;
         }
@@ -2995,85 +3321,110 @@ int nxagentHandleConfigureNotify(XEvent* X)
 
     if (X -&gt; xconfigure.window == nxagentDefaultWindows[pScreen -&gt; myNum])
     {
-      if (nxagentOption(Fullscreen) == 0)
+      if (nxagentOption(DesktopResize) == 1)
       {
-        if (nxagentOption(DesktopResize) == 1)
+        if (nxagentOption(Width) != X -&gt; xconfigure.width ||
+              nxagentOption(Height) != X -&gt; xconfigure.height)
         {
-          if (nxagentOption(Width) != X -&gt; xconfigure.width ||
-                nxagentOption(Height) != X -&gt; xconfigure.height)
-          {
-            Bool newEvents = False;
+          Bool newEvents = False;
 
-            doRandR = True;
+          doRandR = True;
 
-            NXFlushDisplay(nxagentDisplay, NXFlushLink);
+          NXFlushDisplay(nxagentDisplay, NXFlushLink);
 
-            do
-            {
-              newEvents = False;
+          do
+          {
+            newEvents = False;
 
-              timeout.tv_sec  = 0;
-              timeout.tv_usec = 500 * 1000;
+            timeout.tv_sec  = 0;
+            timeout.tv_usec = 500 * 1000;
 
-              nxagentWaitEvents(nxagentDisplay, &amp;timeout);
+            nxagentWaitEvents(nxagentDisplay, &amp;timeout);
 
-              /*
-               * This should also flush
-               * the NX link for us.
-               */
+            /*
+             * This should also flush
+             * the NX link for us.
+             */
 
-              XSync(nxagentDisplay, 0);
+            XSync(nxagentDisplay, 0);
 
-              while (XCheckTypedWindowEvent(nxagentDisplay, nxagentDefaultWindows[pScreen -&gt; myNum],
-                                              ConfigureNotify, X))
-              {
-                newEvents = True;
-              }
+            while (XCheckTypedWindowEvent(nxagentDisplay, nxagentDefaultWindows[pScreen -&gt; myNum],
+                                            ConfigureNotify, X))
+            {
+              newEvents = True;
+            }
 
-            } while (newEvents);
-          }
+          } while (newEvents);
         }
+      }
 
-        if (nxagentWMIsRunning == 0 || X -&gt; xconfigure.send_event)
-        {
-          nxagentChangeOption(X, X -&gt; xconfigure.x);
-          nxagentChangeOption(Y, X -&gt; xconfigure.y);
-        }
+      if (nxagentWMIsRunning == 0 || X -&gt; xconfigure.send_event)
+      {
+        nxagentChangeOption(X, X -&gt; xconfigure.x);
+        nxagentChangeOption(Y, X -&gt; xconfigure.y);
+      }
 
-        if (nxagentOption(Shadow) == 1 &amp;&amp; nxagentOption(DesktopResize) == 1 &amp;&amp;
-                (nxagentOption(Width) != X -&gt; xconfigure.width ||
-                    nxagentOption(Height) != X -&gt; xconfigure.height))
-        {
-          nxagentShadowResize = 1;
-        }
+      if (nxagentOption(Shadow) == 1 &amp;&amp; nxagentOption(DesktopResize) == 1 &amp;&amp;
+              (nxagentOption(Width) != X -&gt; xconfigure.width ||
+                  nxagentOption(Height) != X -&gt; xconfigure.height))
+      {
+        nxagentShadowResize = 1;
+      }
 
-        nxagentChangeOption(Width, X -&gt; xconfigure.width);
-        nxagentChangeOption(Height, X -&gt; xconfigure.height);
+      nxagentChangeOption(Width, X -&gt; xconfigure.width);
+      nxagentChangeOption(Height, X -&gt; xconfigure.height);
 
-        nxagentChangeOption(ViewportXSpan, (int) X -&gt; xconfigure.width -
-                                (int) nxagentOption(RootWidth));
-        nxagentChangeOption(ViewportYSpan, (int) X -&gt; xconfigure.height -
-                                (int) nxagentOption(RootHeight));
+      nxagentChangeOption(ViewportXSpan, (int) X -&gt; xconfigure.width -
+                              (int) nxagentOption(RootWidth));
+      nxagentChangeOption(ViewportYSpan, (int) X -&gt; xconfigure.height -
+                              (int) nxagentOption(RootHeight));
 
-        nxagentMoveViewport(pScreen, 0, 0);
+      nxagentMoveViewport(pScreen, 0, 0);
 
-        if (nxagentOption(Shadow) == 1 ||
-                (nxagentOption(Width) == nxagentOption(RootWidth) &amp;&amp;
-                    nxagentOption(Height) == nxagentOption(RootHeight)))
-        {
-          doRandR = 0;
-        }
+      if (nxagentOption(Shadow) == 1 ||
+              (nxagentOption(Width) == nxagentOption(RootWidth) &amp;&amp;
+                  nxagentOption(Height) == nxagentOption(RootHeight)))
+      {
+        doRandR = 0;
+      }
 
-        if (doRandR)
-        {
-          #ifdef TEST
-          fprintf(stderr,&quot;nxagentHandleConfigureNotify: Width %d Height %d.\n&quot;,
-                      nxagentOption(Width), nxagentOption(Height));
-          #endif
+      nxagentChangeOption(Width, X -&gt; xconfigure.width);
+      nxagentChangeOption(Height, X -&gt; xconfigure.height);
 
-          nxagentRRSetScreenConfig(screenInfo.screens[DefaultScreen(nxagentDisplay)],
-                                     nxagentOption(Width), nxagentOption(Height));
-        }
+      XMoveResizeWindow(nxagentDisplay, nxagentInputWindows[0], 0, 0,
+                            X -&gt; xconfigure.width, X -&gt; xconfigure.height);
+
+      if (nxagentOption(Fullscreen) == 0)
+      {
+        nxagentMoveViewport(pScreen, 0, 0);
+      }
+      else
+      {
+        nxagentChangeOption(RootX, (nxagentOption(Width) -
+                                nxagentOption(RootWidth)) / 2);
+        nxagentChangeOption(RootY, (nxagentOption(Height) -
+                                nxagentOption(RootHeight)) / 2);
+        nxagentChangeOption(ViewportXSpan, nxagentOption(Width) -
+                                nxagentOption(RootWidth));
+        nxagentChangeOption(ViewportYSpan, nxagentOption(Height) -
+                                nxagentOption(RootHeight));
+
+        nxagentUpdateViewportFrame(0, 0, nxagentOption(RootWidth),
+                                       nxagentOption(RootHeight));
+
+        XMoveWindow(nxagentDisplay, nxagentWindow(WindowTable[pScreen -&gt; myNum]),
+                        nxagentOption(RootX), nxagentOption(RootY));
+      }
+
+      if (doRandR)
+      {
+        #ifdef TEST
+        fprintf(stderr,&quot;nxagentHandleConfigureNotify: Width %d Height %d.\n&quot;,
+                    nxagentOption(Width), nxagentOption(Height));
+        #endif
+
+        nxagentRRSetScreenConfig(screenInfo.screens[DefaultScreen(nxagentDisplay)],
+                                   nxagentOption(Width), nxagentOption(Height));
       }
 
       return 1;
@@ -3085,8 +3436,6 @@ int nxagentHandleConfigureNotify(XEvent* X)
 
 int nxagentHandleReparentNotify(XEvent* X)
 {
-  ScreenPtr pScreen = nxagentScreen(X -&gt; xreparent.window);
-
   #ifdef TEST
   fprintf(stderr, &quot;nxagentHandleReparentNotify: Going to handle a new reparent event.\n&quot;);
   #endif
@@ -3203,7 +3552,6 @@ int nxagentHandleReparentNotify(XEvent* X)
     XlibWindow *childrenReturn = NULL;
     unsigned int nchildrenReturn = 0;
     Status result;
-    XSizeHints hints;
     XWindowAttributes attributes;
     int x, y;
     int xParent, yParent;
@@ -3464,6 +3812,15 @@ void nxagentGrabPointerAndKeyboard(XEvent *X)
   XGrabKeyboard(nxagentDisplay, nxagentFullscreenWindow,
                     True, GrabModeAsync, GrabModeAsync, now);
 
+  /*
+   * The smart scheduler could be stopped while
+   * waiting for the reply. In this case we need
+   * to yield explicitly to avoid to be stuck in
+   * the dispatch loop forever.
+   */
+
+  isItTimeToYield = 1;
+
   #ifdef TEST
   fprintf(stderr, &quot;nxagentGrabPointerAndKeyboard: Going to grab the pointer in context [B2].\n&quot;);
   #endif
@@ -3491,6 +3848,8 @@ void nxagentGrabPointerAndKeyboard(XEvent *X)
     XSetInputFocus(nxagentDisplay, nxagentFullscreenWindow,
                        RevertToParent, now);
   }
+
+  nxagentPointerAndKeyboardGrabbed = 1;
 }
 
 void nxagentUngrabPointerAndKeyboard(XEvent *X)
@@ -3522,6 +3881,8 @@ void nxagentUngrabPointerAndKeyboard(XEvent *X)
   #endif
 
   XUngrabPointer(nxagentDisplay, now);
+
+  nxagentPointerAndKeyboardGrabbed = 0;
 }
 
 void nxagentDeactivatePointerGrab()
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Events.h b/nx-X11/programs/Xserver/hw/nxagent/Events.h
index 238a229..109475c 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Events.h
+++ b/nx-X11/programs/Xserver/hw/nxagent/Events.h
@@ -29,6 +29,7 @@ enum HandleEventResult
 {
   doNothing = 0,
   doMinimize,
+  doDebugTree,
   doCloseSession,
   doStartKbd,
   doSwitchFullscreen,
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Imakefile b/nx-X11/programs/Xserver/hw/nxagent/Imakefile
index 633e17a..51173e4 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Imakefile
+++ b/nx-X11/programs/Xserver/hw/nxagent/Imakefile
@@ -206,7 +206,8 @@ DEFINES = -g $(OS_DEFINES) $(EXT_DEFINES) $(UPG_DEFINES) \
           -DNXAGENT_SPLASH \
           -DNXAGENT_ARTSD \
           -UNX_DEBUG_INPUT \
-          -UPANORAMIX
+          -UPANORAMIX \
+          -UDEBUG_TREE
 
 all:: $(OBJS)
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Keystroke.c b/nx-X11/programs/Xserver/hw/nxagent/Keystroke.c
index a2e4fb0..de1da86 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Keystroke.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Keystroke.c
@@ -92,6 +92,18 @@ int nxagentCheckSpecialKeystroke(XKeyEvent *X, enum HandleEventResult *result)
   {
     switch (sym)
     {
+      #ifdef DEBUG_TREE
+
+      case XK_q:
+      case XK_Q:
+      {
+        *result = doDebugTree;
+
+        break;
+      }
+
+      #endif /* DEBUG_TREE */
+
       case XK_t:
       case XK_T:
       {
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Pixels.h b/nx-X11/programs/Xserver/hw/nxagent/Pixels.h
index e046771..ea7c375 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Pixels.h
+++ b/nx-X11/programs/Xserver/hw/nxagent/Pixels.h
@@ -108,6 +108,12 @@ FIXME: The condition checking for the render
        avoid problems with the render composi-
        te on XFree86 remote server.
 */
+/*
+FIXME: Changed macro: NXAGENT_SHOULD_DEFER_COMPOSITE
+       to handle situation, when pSrc -&gt; pDrawable
+       is NULL. This case happens with gradients
+       and solid fill.
+
 #define NXAGENT_SHOULD_DEFER_COMPOSITE(pSrc, pMask, pDst)                 \
     ((nxagentRenderVersionMajor == 0 &amp;&amp;                                   \
      nxagentRenderVersionMinor == 8 &amp;&amp;                                \
@@ -118,6 +124,18 @@ FIXME: The condition checking for the render
           nxagentOption(DeferLevel) == 1) ||               \
              (nxagentOption(DeferLevel) &gt;= 2 &amp;&amp;           \
               nxagentOption(LinkType) &lt; LINK_TYPE_ADSL))
+*/
+#define NXAGENT_SHOULD_DEFER_COMPOSITE(pSrc, pMask, pDst)                                                \
+    ((nxagentRenderVersionMajor == 0 &amp;&amp;                                                                  \
+      nxagentRenderVersionMinor == 8 &amp;&amp;                                                                  \
+      (pDst) -&gt; pDrawable -&gt; type == DRAWABLE_PIXMAP) ||                                                 \
+         (nxagentOption(DeferLevel) &gt;= 2 &amp;&amp;                                                              \
+          nxagentOption(LinkType) &lt; LINK_TYPE_ADSL) ||                                                   \
+             (nxagentOption(DeferLevel) == 1 &amp;&amp;                                                          \
+              (pDst) -&gt; pDrawable -&gt; type == DRAWABLE_PIXMAP &amp;&amp;                                          \
+              (((pSrc) -&gt; pDrawable &amp;&amp; nxagentDrawableStatus((pSrc) -&gt; pDrawable) == NotSynchronized) || \
+              ((pMask) &amp;&amp; nxagentDrawableStatus((pMask) -&gt; pDrawable) == NotSynchronized))))
+
 
 #define NXAGENT_SHOULD_DEFER_PUTIMAGE(pDrawable) \
     (nxagentSplitTrap == 0 &amp;&amp;                    \
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Pointer.c b/nx-X11/programs/Xserver/hw/nxagent/Pointer.c
index 34012d3..9c1bfaa 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Pointer.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Pointer.c
@@ -57,6 +57,13 @@ is&quot; without express or implied warranty.
 #undef  TEST
 #undef  DEBUG
 
+/*
+ * The nxagentReversePointerMap array is used to
+ * memorize remote display pointer map.
+ */
+
+unsigned char nxagentReversePointerMap[MAXBUTTONS];
+
 void nxagentChangePointerControl(DeviceIntPtr pDev, PtrCtrl *ctrl)
 {
   /*
@@ -125,6 +132,8 @@ int nxagentPointerProc(DeviceIntPtr pDev, int onoff)
         return Success;
       }
 
+      nxagentInitPointerMap();
+
       nxagentEnablePointerEvents();
 
       break;
@@ -155,3 +164,28 @@ int nxagentPointerProc(DeviceIntPtr pDev, int onoff)
 
   return Success;
 }
+
+void nxagentInitPointerMap(void)
+{
+  int numButtons;
+
+  int i;
+
+  unsigned char pointerMap[MAXBUTTONS];
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;nxagentInitPointerMap: Going to retrieve the &quot;
+              &quot;pointer map from remote display.\n&quot;);
+  #endif
+
+  numButtons = XGetPointerMapping(nxagentDisplay, pointerMap, MAXBUTTONS);
+
+  /*
+   * Computing revers pointer map.
+   */
+
+  for (i = 1; i &lt;= numButtons; i++)
+  {
+    nxagentReversePointerMap[pointerMap[i - 1] - 1] = i;
+  }
+}
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Pointer.h b/nx-X11/programs/Xserver/hw/nxagent/Pointer.h
index 0807b08..b0bb3f9 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Pointer.h
+++ b/nx-X11/programs/Xserver/hw/nxagent/Pointer.h
@@ -38,8 +38,17 @@ is&quot; without express or implied warranty.
   (ButtonPressMask | ButtonReleaseMask | PointerMotionMask | \
        EnterWindowMask | LeaveWindowMask)
 
+/*
+ * The nxagentReversePointerMap array is used to
+ * memorize remote display pointer map.
+ */
+
+extern unsigned char nxagentReversePointerMap[MAXBUTTONS];
+
 void nxagentChangePointerControl(DeviceIntPtr pDev, PtrCtrl *ctrl);
 
 int nxagentPointerProc(DeviceIntPtr pDev, int onoff);
 
+void nxagentInitPointerMap(void);
+
 #endif /* __Pointer_H__ */
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Reconnect.c b/nx-X11/programs/Xserver/hw/nxagent/Reconnect.c
index 598ffc1..e63b481 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Reconnect.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Reconnect.c
@@ -81,6 +81,8 @@ extern Bool nxagentUninstallFontServerPath(void);
 
 extern void nxagentRemoveXConnection(void);
 
+extern void nxagentInitPointerMap(void);
+
 static char *nxagentGetReconnectError(void);
 
 void nxagentInitializeRecLossyLevel(void);
@@ -584,6 +586,8 @@ Bool nxagentReconnectSession(void)
     nxagentOldKeyboard = NULL;
   }
 
+  nxagentInitPointerMap();
+
   nxagentDeactivatePointerGrab();
 
   nxagentWakeupByReconnect();
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Render.c b/nx-X11/programs/Xserver/hw/nxagent/Render.c
index 6bc54c8..4f0f764 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Render.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Render.c
@@ -147,8 +147,6 @@ void nxagentCursorPostSaveRenderInfo(CursorPtr pCursor, ScreenPtr pScreen,
 
 int nxagentCreatePicture(PicturePtr pPicture, Mask mask);
 
-void nxagentDestroyPicture(PicturePtr pPicture);
-
 int nxagentChangePictureClip(PicturePtr pPicture, int clipType, int nRects,
                                  xRectangle *rects, int xOrigin, int yOrigin);
 
@@ -1010,12 +1008,15 @@ void nxagentComposite(CARD8 op, PicturePtr pSrc, PicturePtr pMask, PicturePtr pD
 
   #ifdef DEBUG
 
-  fprintf(stderr, &quot;nxagentComposite: Source Picture [%lu][%p] with drawable [%s%s][%p].\n&quot;,
-              nxagentPicturePriv(pSrc) -&gt; picture, (void *) pSrc,
-              (pSrc -&gt; pDrawable -&gt; type == DRAWABLE_PIXMAP &amp;&amp;
-                   nxagentIsShmPixmap((PixmapPtr) pSrc -&gt; pDrawable)) ? &quot;Shared &quot; : &quot;&quot;,
-                       pSrc -&gt; pDrawable -&gt; type == DRAWABLE_PIXMAP ? &quot;Pixmap&quot; : &quot;Window&quot;,
-                           (void *) pSrc -&gt; pDrawable);
+  if (pSrc -&gt; pDrawable != NULL)
+  {
+    fprintf(stderr, &quot;nxagentComposite: Source Picture [%lu][%p] with drawable [%s%s][%p].\n&quot;,
+                nxagentPicturePriv(pSrc) -&gt; picture, (void *) pSrc,
+                (pSrc -&gt; pDrawable -&gt; type == DRAWABLE_PIXMAP &amp;&amp;
+                     nxagentIsShmPixmap((PixmapPtr) pSrc -&gt; pDrawable)) ? &quot;Shared &quot; : &quot;&quot;,
+                         pSrc -&gt; pDrawable -&gt; type == DRAWABLE_PIXMAP ? &quot;Pixmap&quot; : &quot;Window&quot;,
+                             (void *) pSrc -&gt; pDrawable);
+  }
 
   fprintf(stderr, &quot;nxagentComposite: Destination Picture [%lu][%p] with drawable [%s%s][%p].\n&quot;,
               nxagentPicturePriv(pDst) -&gt; picture, (void *) pDst,
@@ -1064,16 +1065,19 @@ void nxagentComposite(CARD8 op, PicturePtr pSrc, PicturePtr pMask, PicturePtr pD
    * the wrong data.
    */
 
-  nxagentSynchronizeShmPixmap(pSrc -&gt; pDrawable, xSrc, ySrc, width, height);
-
-  if (nxagentDrawableStatus(pSrc -&gt; pDrawable) == NotSynchronized)
+  if (pSrc -&gt; pDrawable != NULL)
   {
-    #ifdef TEST
-    fprintf(stderr, &quot;nxagentComposite: Synchronizing the source drawable [%p].\n&quot;,
-                (void *) pSrc -&gt; pDrawable);
-    #endif
+    nxagentSynchronizeShmPixmap(pSrc -&gt; pDrawable, xSrc, ySrc, width, height);
 
-    nxagentSynchronizeDrawable(pSrc -&gt; pDrawable, DO_WAIT, NEVER_BREAK, NULL);
+    if (nxagentDrawableStatus(pSrc -&gt; pDrawable) == NotSynchronized)
+    {
+      #ifdef TEST
+      fprintf(stderr, &quot;nxagentComposite: Synchronizing the source drawable [%p].\n&quot;,
+                  (void *) pSrc -&gt; pDrawable);
+      #endif
+
+      nxagentSynchronizeDrawable(pSrc -&gt; pDrawable, DO_WAIT, NEVER_BREAK, NULL);
+    }
   }
 
   if (pDst -&gt; pDrawable != pSrc -&gt; pDrawable)
@@ -2811,3 +2815,248 @@ Bool nxagentDisconnectAllPicture()
   return True;
 }
 
+void nxagentRenderCreateSolidFill(PicturePtr pPicture, xRenderColor *color)
+{
+  Picture id;
+
+  if (nxagentRenderEnable == False)
+  {
+    return;
+  }
+
+  #ifdef DEBUG
+
+  fprintf(stderr, &quot;nxagentRenderCreateSolidFill: Got called.\n&quot;);
+
+  if (pPicture == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateSolidFill: WARNING! pPicture pointer is NULL.\n&quot;);
+  }
+
+  if (color == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateSolidFill: WARNING! color pointer is NULL.\n&quot;);
+  }
+
+  #endif /* #ifdef DEBUG */
+
+  memset(&amp;(nxagentPicturePriv(pPicture) -&gt; lastServerValues), 0,
+             sizeof(XRenderPictureAttributes_));
+
+  id = XRenderCreateSolidFill(nxagentDisplay, (XRenderColor *) color);
+
+  #ifdef DEBUG
+  XSync(nxagentDisplay, 0);
+  #endif
+
+  #ifdef TEST
+  fprintf(stderr, &quot;nxagentRenderCreateSolidFill: Created solid fill xid [%lu].\n&quot;, id);
+  #endif
+
+  nxagentPicturePriv(pPicture) -&gt; picture = id;
+}
+
+void nxagentRenderCreateLinearGradient(PicturePtr pPicture, xPointFixed *p1,
+                                           xPointFixed *p2, int nStops,
+                                               xFixed *stops,
+                                                   xRenderColor *colors)
+{
+  Picture id;
+
+  XLinearGradient linearGradient;
+
+  if (nxagentRenderEnable == False)
+  {
+    return;
+  }
+
+  #ifdef DEBUG
+
+  fprintf(stderr, &quot;nxagentRenderCreateLinearGradient: Got called.\n&quot;);
+
+  if (pPicture == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateLinearGradient: WARNING! pPicture pointer is NULL.\n&quot;);
+  }
+
+  if (p1 == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateLinearGradient: WARNING! p1 pointer is NULL.\n&quot;);
+  }
+
+  if (p2 == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateLinearGradient: WARNING! p2 pointer is NULL.\n&quot;);
+  }
+
+  if (stops == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateLinearGradient: WARNING! stops pointer is NULL.\n&quot;);
+  }
+
+  if (colors == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateLinearGradient: WARNING! colors pointer is NULL.\n&quot;);
+  }
+
+  #endif /* #ifdef DEBUG */
+
+  memset(&amp;(nxagentPicturePriv(pPicture) -&gt; lastServerValues), 0,
+             sizeof(XRenderPictureAttributes_));
+
+  linearGradient.p1.x = (XFixed) p1 -&gt; x;
+  linearGradient.p1.y = (XFixed) p1 -&gt; y;
+  linearGradient.p2.x = (XFixed) p2 -&gt; x;
+  linearGradient.p2.y = (XFixed) p2 -&gt; y;
+
+  id = XRenderCreateLinearGradient(nxagentDisplay, &amp;linearGradient,
+                                      (XFixed *) stops,
+                                          (XRenderColor *) colors, nStops);
+
+  #ifdef DEBUG
+  XSync(nxagentDisplay, 0);
+  #endif
+
+  #ifdef TEST
+  fprintf(stderr, &quot;nxagentRenderCreateLinearGradient: Created linear gradient xid [%lu].\n&quot;, id);
+  #endif
+
+  nxagentPicturePriv(pPicture) -&gt; picture = id;
+}
+
+void nxagentRenderCreateRadialGradient(PicturePtr pPicture, xPointFixed *inner,
+                                           xPointFixed *outer,
+                                               xFixed innerRadius,
+                                                   xFixed outerRadius,
+                                                       int nStops,
+                                                           xFixed *stops,
+                                                               xRenderColor *colors)
+{
+  Picture id;
+
+  XRadialGradient radialGradient;
+
+  if (nxagentRenderEnable == False)
+  {
+    return;
+  }
+
+  #ifdef DEBUG
+
+  fprintf(stderr, &quot;nxagentRenderCreateRadialGradient: Got called.\n&quot;);
+
+  if (pPicture == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateRadialGradient: WARNING! pPicture pointer is NULL.\n&quot;);
+  }
+
+  if (inner == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateRadialGradient: WARNING! inner pointer is NULL.\n&quot;);
+  }
+
+  if (outer == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateRadialGradient: WARNING! outer pointer is NULL.\n&quot;);
+  }
+
+  if (stops == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateRadialGradient: WARNING! stops pointer is NULL.\n&quot;);
+  }
+
+  if (colors == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateRadialGradient: WARNING! colors pointer is NULL.\n&quot;);
+  }
+
+  #endif /* #ifdef DEBUG */
+
+  memset(&amp;(nxagentPicturePriv(pPicture) -&gt; lastServerValues), 0,
+               sizeof(XRenderPictureAttributes_));
+
+  radialGradient.inner.x = (XFixed) inner -&gt; x;
+  radialGradient.inner.y = (XFixed) inner -&gt; y;
+  radialGradient.inner.radius = (XFixed) innerRadius;
+  radialGradient.outer.x = (XFixed) outer -&gt; x;
+  radialGradient.outer.y = (XFixed) outer -&gt; y;
+  radialGradient.outer.radius = (XFixed) outerRadius;
+
+  id = XRenderCreateRadialGradient(nxagentDisplay, &amp;radialGradient,
+                                       (XFixed *) stops,
+                                           (XRenderColor *) colors, nStops);
+
+  #ifdef DEBUG
+  XSync(nxagentDisplay, 0);
+  #endif
+
+  #ifdef TEST
+  fprintf(stderr, &quot;nxagentRenderCreateRadialGradient: Created radial gradient xid [%lu].\n&quot;, id);
+  #endif
+
+  nxagentPicturePriv(pPicture) -&gt; picture = id;
+}
+
+void nxagentRenderCreateConicalGradient(PicturePtr pPicture,
+                                            xPointFixed *center,
+                                                xFixed angle, int nStops, 
+                                                    xFixed *stops, 
+                                                        xRenderColor *colors)
+{
+  Picture id;
+
+  XConicalGradient conicalGradient;
+
+  if (nxagentRenderEnable == False)
+  {
+    return;
+  }
+
+  #ifdef DEBUG
+
+  fprintf(stderr, &quot;nxagentRenderCreateConicalGradient: Got called.\n&quot;);
+
+  if (pPicture == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateConicalGradient: WARNING! pPicture pointer is NULL.\n&quot;);
+  }
+
+  if (center == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateConicalGradient: WARNING! center pointer is NULL.\n&quot;);
+  }
+
+  if (stops == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateConicalGradient: WARNING! stops pointer is NULL.\n&quot;);
+  }
+
+  if (colors == NULL)
+  {
+    fprintf(stderr, &quot;nxagentRenderCreateConicalGradient: WARNING! colors pointer is NULL.\n&quot;);
+  }
+
+  #endif /* #ifdef DEBUG */
+
+  memset(&amp;(nxagentPicturePriv(pPicture) -&gt; lastServerValues), 0,
+             sizeof(XRenderPictureAttributes_));
+
+  conicalGradient.center.x = (XFixed) center -&gt; x;
+  conicalGradient.center.y = (XFixed) center -&gt; y;
+  conicalGradient.angle = (XFixed) angle;
+
+  id = XRenderCreateConicalGradient(nxagentDisplay, &amp;conicalGradient,
+                                        (XFixed *) stops,
+                                            (XRenderColor *) colors, nStops);
+
+  #ifdef DEBUG
+  XSync(nxagentDisplay, 0);
+  #endif
+
+  #ifdef TEST
+  fprintf(stderr, &quot;nxagentRenderCreateConicalGradient: Created conical gradient xid [%lu].\n&quot;, id);
+  #endif
+
+  nxagentPicturePriv(pPicture) -&gt; picture = id;
+}
+
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Render.h b/nx-X11/programs/Xserver/hw/nxagent/Render.h
index 81ba336..4346a4e 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Render.h
+++ b/nx-X11/programs/Xserver/hw/nxagent/Render.h
@@ -105,4 +105,6 @@ void nxagentDisconnectPicture(pointer p0, XID x1, void* p2);
 
 void nxagentReconnectGlyphSet(void* p0, XID x1, void *p2);
 
+void nxagentDestroyPicture(PicturePtr pPicture);
+
 #endif /* __Render_H__ */
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Rootless.c b/nx-X11/programs/Xserver/hw/nxagent/Rootless.c
index a8ce4c7..612e71c 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Rootless.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Rootless.c
@@ -626,6 +626,7 @@ int nxagentExportProperty(pWin, property, type, format, mode, nUnits, value)
     XlibAtom *atoms = malloc(nUnits * sizeof(*atoms));
     Atom *input = value;
     int i;
+    int j = 0;
 
     freeMem = True;
     export = True;
@@ -633,16 +634,40 @@ int nxagentExportProperty(pWin, property, type, format, mode, nUnits, value)
 
     for (i = 0; i &lt; nUnits; i++)
     {
-       atoms[i] = nxagentLocalToRemoteAtom(input[i]);
-
-       if (atoms[i] == None)
-       {
-         #ifdef WARNING
-         fprintf(stderr, &quot;nxagentExportProperty: WARNING! Failed to convert local atom %ld [%s].\n&quot;,
-                     (long int) input[i], validateString(NameForAtom(input[i])));
-         #endif
-       }
+      /*
+       * Exporting the _NET_WM_PING property could
+       * result in rootless windows being grayed out
+       * when the compiz window manager is running.
+       *
+       * Better solution would probably be to handle
+       * the communication with the window manager
+       * instead of just getting rid of the property.
+       */
+
+      if (strcmp(NameForAtom(input[i]), &quot;_NET_WM_PING&quot;) != 0)
+      {
+        atoms[j] = nxagentLocalToRemoteAtom(input[i]);
+
+        if (atoms[j] == None)
+        {
+          #ifdef WARNING
+          fprintf(stderr, &quot;nxagentExportProperty: WARNING! Failed to convert local atom %ld [%s].\n&quot;,
+                      (long int) input[i], validateString(NameForAtom(input[i])));
+          #endif
+        }
+
+        j++;
+      }
+      #ifdef TEST
+      else
+      {
+        fprintf(stderr, &quot;nxagentExportProperty: WARNING! &quot;
+                    &quot;Not exporting the _NET_WM_PING property.\n&quot;);
+      }
+      #endif
     }
+
+    nUnits = j;
   }
   else if (strcmp(typeS, &quot;WINDOW&quot;) == 0)
   {
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Screen.c b/nx-X11/programs/Xserver/hw/nxagent/Screen.c
index bdd30af..3522d7e 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Screen.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Screen.c
@@ -160,7 +160,6 @@ void nxagentPropagateArtsdProperties(ScreenPtr pScreen, char *port);
 
 #endif
 
-Window nxagentIconWindow = None;
 Window nxagentFullscreenWindow = None;
 
 #ifdef VIEWPORT_FRAME
@@ -291,34 +290,17 @@ void nxagentSetPixmapFormats(ScreenInfo *screenInfo)
 void nxagentMinimizeFromFullScreen(ScreenPtr pScreen)
 {
   XUnmapWindow(nxagentDisplay, nxagentFullscreenWindow);
-
-  if(nxagentIpaq)
-  {
-    XMapWindow(nxagentDisplay, nxagentIconWindow);
-    XIconifyWindow(nxagentDisplay, nxagentIconWindow,
-                       DefaultScreen(nxagentDisplay));
-  }
-  else
-  {
-    XIconifyWindow(nxagentDisplay, nxagentIconWindow,
-                       DefaultScreen(nxagentDisplay));
-  }
 }
 
 void nxagentMaximizeToFullScreen(ScreenPtr pScreen)
 {
   if(nxagentIpaq)
   {
-    XUnmapWindow(nxagentDisplay, nxagentIconWindow);
-
     XMapWindow(nxagentDisplay, nxagentFullscreenWindow);
   }
   else
   {
 /*
-    XUnmapWindow(nxagentDisplay, nxagentIconWindow);
-*/
-/*
 FIXME: We'll chech for ReparentNotify and LeaveNotify events after XReparentWindow()
        in order to avoid the session window is iconified.
        We could avoid the sesssion window is iconified when a LeaveNotify event is received,
@@ -352,100 +334,8 @@ FIXME: We'll chech for ReparentNotify and LeaveNotify events after XReparentWind
 
     XMapRaised(nxagentDisplay, nxagentFullscreenWindow);
 
-    XIconifyWindow(nxagentDisplay, nxagentIconWindow,
-                       DefaultScreen(nxagentDisplay));
-
     while (XCheckTypedWindowEvent(nxagentDisplay, nxagentFullscreenWindow, LeaveNotify, &amp;e));
-/*
-    XMapWindow(nxagentDisplay, nxagentIconWindow);
-*/
-  }
-}
-
-Window nxagentCreateIconWindow()
-{
-  XSetWindowAttributes attributes;
-  unsigned long valuemask;
-  char* window_name;
-  XTextProperty windowName;
-  XSizeHints sizeHints;
-  XWMHints wmHints;
-  Window w;
-  Mask mask;
-
-  /*
-   * Create icon window.
-   */
-
-  attributes.override_redirect = False;
-  attributes.colormap = DefaultColormap(nxagentDisplay, DefaultScreen(nxagentDisplay));
-  attributes.background_pixmap = nxagentScreenSaverPixmap;
-  valuemask = CWOverrideRedirect | CWBackPixmap | CWColormap;
-
-  #ifdef TEST
-  fprintf(stderr, &quot;nxagentCreateIconWindow: Going to create new icon window.\n&quot;);
-  #endif
-
-  w = XCreateWindow(nxagentDisplay, DefaultRootWindow(nxagentDisplay),
-                        0, 0, 1, 1, 0,
-                            DefaultDepth(nxagentDisplay, DefaultScreen(nxagentDisplay)),
-                                InputOutput,
-                                    DefaultVisual(nxagentDisplay, DefaultScreen(nxagentDisplay)),
-                                        valuemask, &amp;attributes);
-
-  #ifdef TEST
-  fprintf(stderr, &quot;nxagentCreateIconWindow: Created new icon window with id [%ld].\n&quot;,
-              nxagentIconWindow);
-  #endif
-
-  /*
-   *  Set hints to the window manager for the icon window.
-   */
-
-  window_name = nxagentWindowName;
-  XStringListToTextProperty(&amp;window_name, 1, &amp;windowName);
-  sizeHints.flags = PMinSize | PMaxSize;
-  sizeHints.min_width = sizeHints.max_width = 1;
-  sizeHints.min_height = sizeHints.max_height = 1;
-  wmHints.flags = IconPixmapHint | IconMaskHint;
-  wmHints.initial_state = IconicState;
-  wmHints.icon_pixmap = nxagentIconPixmap;
-
-  if (useXpmIcon)
-  {
-    wmHints.icon_mask = nxagentIconShape;
-    wmHints.flags = IconPixmapHint | IconMaskHint;
   }
-  else
-  {
-    wmHints.flags = StateHint | IconPixmapHint;
-  }
-
-  XSetWMProperties(nxagentDisplay, w,
-                      &amp;windowName, &amp;windowName,
-                          NULL , 0 , &amp;sizeHints, &amp;wmHints, NULL);
-
-  /*
-   * Enable events from the icon window.
-   */
-
-  nxagentGetDefaultEventMask(&amp;mask);
-
-  XSelectInput(nxagentDisplay, w, (mask &amp; ~(KeyPressMask |
-                   KeyReleaseMask)) | StructureNotifyMask);
-
-  /*
-   * Notify to client if user closes icon window.
-   */
-
-  if (nxagentWMIsRunning &amp;&amp; !nxagentOption(Rootless))
-  {
-    XlibAtom deleteWMAtom = nxagentAtoms[2]; /* WM_DELETE_WINDOW */
-
-    XSetWMProtocols(nxagentDisplay, w, &amp;deleteWMAtom, 1);
-  }
-
-  return w;
 }
 
 Bool nxagentMagicPixelZone(int x, int y)
@@ -977,6 +867,8 @@ Bool nxagentOpenScreen(int index, ScreenPtr pScreen,
 
     nxagentChangeOption(Fullscreen, False);
 
+    nxagentFullscreenWindow = 0;
+
     resetAgentPosition = True;
   }
 
@@ -1382,8 +1274,6 @@ N/A
 
     if (nxagentOption(Fullscreen))
     {
-      attributes.override_redirect = True;
-
       /*
        * We need to disable the host's screensaver or
        * it will otherwise grab the screen even if it
@@ -1609,8 +1499,7 @@ N/A
   if (nxagentDoFullGeneration == 1 ||
           nxagentReconnectTrap == 1)
   {
-    valuemask = CWBackPixel | CWEventMask | CWColormap |
-                    (nxagentOption(Fullscreen) == 1 ? CWOverrideRedirect : 0);
+    valuemask = CWBackPixel | CWEventMask | CWColormap;
 
     attributes.background_pixel = nxagentBlackPixel;
 
@@ -1620,8 +1509,6 @@ N/A
 
     if (nxagentOption(Fullscreen) == 1)
     {
-      attributes.override_redirect = True;
-
       if (nxagentReconnectTrap)
       {
         /*
@@ -1754,7 +1641,7 @@ N/A
     sizeHints.width = nxagentOption(RootWidth);
     sizeHints.height = nxagentOption(RootHeight);
 
-    if (nxagentOption(DesktopResize) == 1)
+    if (nxagentOption(DesktopResize) == 1 || nxagentOption(Fullscreen) == 1)
     {
       sizeHints.max_width = WidthOfScreen(DefaultScreenOfDisplay(nxagentDisplay));
       sizeHints.max_height = HeightOfScreen(DefaultScreenOfDisplay(nxagentDisplay));
@@ -1799,37 +1686,6 @@ N/A
 
     XClearWindow(nxagentDisplay, nxagentDefaultWindows[pScreen-&gt;myNum]);
 
-    if (nxagentOption(Fullscreen))
-    {
-      valuemask = CWBackPixmap | CWColormap | CWOverrideRedirect;
-    }
-    else
-    {
-      valuemask = CWBackPixmap | CWColormap;
-    }
-
-    attributes.background_pixmap = nxagentScreenSaverPixmap;
-    attributes.colormap = DefaultColormap(nxagentDisplay, DefaultScreen(nxagentDisplay));
-
-    if (nxagentOption(Fullscreen))
-    {
-      attributes.override_redirect = False;
-      if (nxagentReconnectTrap)
-      {
-        XGrabKeyboard(nxagentDisplay, nxagentFullscreenWindow, True, GrabModeAsync,
-                      GrabModeAsync, CurrentTime);
-      }
-    }
-
-    if (nxagentOption(Fullscreen))
-    {
-      nxagentIconWindow = nxagentCreateIconWindow();
-    }
-    else
-    {
-      nxagentIconWindow = 0;
-    }
-
     /*
      * When we don't have window manager we grab keyboard
      * to let nxagent get keyboard events.
@@ -1880,13 +1736,6 @@ N/A
        */
 
       XSetWMProtocols(nxagentDisplay, nxagentDefaultWindows[pScreen-&gt;myNum], &amp;deleteWMatom, 1);
-
-      /*
-      if (nxagentOption(Fullscreen))
-      {
-        XSetWMProtocols(nxagentDisplay, nxagentIconWindow, &amp;deleteWMatom, 1);
-      }
-      */
     }
     else
     {
@@ -2266,13 +2115,10 @@ FIXME: We should try to restore the previously
 
   if (nxagentOption(Fullscreen))
   {
-    nxagentChangeOption(Width, WidthOfScreen(DefaultScreenOfDisplay(nxagentDisplay)));
-    nxagentChangeOption(Height, HeightOfScreen(DefaultScreenOfDisplay(nxagentDisplay)));
-
-    nxagentChangeOption(RootX, (WidthOfScreen(DefaultScreenOfDisplay(nxagentDisplay))
-                            - nxagentOption(RootWidth)) / 2);
-    nxagentChangeOption(RootY,  (HeightOfScreen(DefaultScreenOfDisplay(nxagentDisplay))
-                            - nxagentOption(RootHeight)) / 2);
+    nxagentChangeOption(RootX, (nxagentOption(Width) -
+                            nxagentOption(RootWidth)) / 2);
+    nxagentChangeOption(RootY, (nxagentOption(Height) -
+                            nxagentOption(RootHeight)) / 2);
   }
   else
   {
@@ -2284,62 +2130,6 @@ FIXME: We should try to restore the previously
   nxagentChangeOption(ViewportYSpan, nxagentOption(Height) - nxagentOption(RootHeight));
 
   /*
-   * Change agent window size and size hints.
-   */
-
-  sizeHints.flags = PPosition | PMinSize | PMaxSize;
-  sizeHints.x = nxagentOption(X);
-  sizeHints.y = nxagentOption(Y);
-
-  sizeHints.min_width = MIN_NXAGENT_WIDTH;
-  sizeHints.min_height = MIN_NXAGENT_HEIGHT;
-  sizeHints.width = width;
-  sizeHints.height = height;
-
-  if (nxagentOption(DesktopResize) == 1)
-  {
-    sizeHints.max_width = WidthOfScreen(DefaultScreenOfDisplay(nxagentDisplay));
-    sizeHints.max_height = HeightOfScreen(DefaultScreenOfDisplay(nxagentDisplay));
-  }
-  else
-  {
-    sizeHints.max_width = nxagentOption(RootWidth);
-    sizeHints.max_height = nxagentOption(RootHeight);
-  }
-
-  if (nxagentUserGeometry.flag &amp; XValue || nxagentUserGeometry.flag &amp; YValue)
-  {
-    sizeHints.flags |= USPosition;
-  }
-
-  if (nxagentUserGeometry.flag &amp; WidthValue || nxagentUserGeometry.flag &amp; HeightValue)
-  {
-    sizeHints.flags |= USSize;
-  }
-
-  XSetWMNormalHints(nxagentDisplay, nxagentDefaultWindows[pScreen-&gt;myNum], &amp;sizeHints);
-
-  if (nxagentOption(Fullscreen))
-  {
-    XResizeWindow(nxagentDisplay, nxagentDefaultWindows[pScreen-&gt;myNum],
-                      WidthOfScreen(DefaultScreenOfDisplay(nxagentDisplay)),
-                          HeightOfScreen(DefaultScreenOfDisplay(nxagentDisplay)));
-
-    XResizeWindow(nxagentDisplay, nxagentInputWindows[pScreen -&gt; myNum],
-                      WidthOfScreen(DefaultScreenOfDisplay(nxagentDisplay)),
-                          HeightOfScreen(DefaultScreenOfDisplay(nxagentDisplay)));
-  }
-  else
-  {
-    XResizeWindow(nxagentDisplay, nxagentDefaultWindows[pScreen-&gt;myNum], width, height);
-
-    if (nxagentOption(Rootless) == 0)
-    {
-      XResizeWindow(nxagentDisplay, nxagentInputWindows[pScreen -&gt; myNum], width, height);
-    }
-  }
-
-  /*
    * Set properties for the agent root window.
    */
 
@@ -2360,8 +2150,6 @@ FIXME: We should try to restore the previously
 
   (*pScreen -&gt; PositionWindow)(WindowTable[pScreen -&gt; myNum], 0, 0);
 
-  pRootWinSize = &amp;WindowTable[pScreen -&gt; myNum] -&gt; winSize;
-
   nxagentSetRootClip(pScreen, 1);
 
   XMoveWindow(nxagentDisplay, nxagentWindow(WindowTable[0]),
@@ -2369,6 +2157,12 @@ FIXME: We should try to restore the previously
 
   nxagentMoveViewport(pScreen, 0, 0);
 
+  /*
+   * Update pointer bounds.
+   */
+
+  ScreenRestructured(pScreen);
+
   #ifdef TEST
   nxagentPrintAgentGeometry(&quot;After Resize Screen&quot;, &quot;nxagentResizeScreen:&quot;);
   #endif
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Screen.h b/nx-X11/programs/Xserver/hw/nxagent/Screen.h
index 6ffebe0..3bf66b2 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Screen.h
+++ b/nx-X11/programs/Xserver/hw/nxagent/Screen.h
@@ -47,7 +47,6 @@ extern ScreenPtr nxagentDefaultScreen;
 
 extern Pixmap nxagentPixmapLogo;
 
-extern Window nxagentIconWindow;
 extern Window nxagentFullscreenWindow;
 
 extern RegionRec nxagentShadowUpdateRegion;
@@ -89,8 +88,6 @@ void nxagentSetScreenSaverTime(void);
 void nxagentMinimizeFromFullScreen(ScreenPtr pScreen);
 void nxagentMaximizeToFullScreen(ScreenPtr pScreen);
 
-Window nxagentCreateIconWindow(void);
-
 Bool nxagentMagicPixelZone(int x, int y);
 
 Bool nxagentResizeScreen(ScreenPtr pScreen, int width, int height,
diff --git a/nx-X11/programs/Xserver/hw/nxagent/Window.c b/nx-X11/programs/Xserver/hw/nxagent/Window.c
index 449458a..2403390 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/Window.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/Window.c
@@ -692,235 +692,87 @@ void nxagentRestackWindow(WindowPtr pWin, WindowPtr pOldNextSib)
 
 void nxagentSwitchFullscreen(ScreenPtr pScreen, Bool switchOn)
 {
-  Window w;
-  XSetWindowAttributes attributes;
-  unsigned long valuemask;
+  XEvent e;
+  XSizeHints sizeHints;
 
-  if (nxagentOption(Rootless))
+  if (nxagentOption(Rootless) == 1)
   {
     return;
   }
 
-  if (!switchOn)
+  if (switchOn == 0)
   {
     nxagentWMDetect();
 
-    if (!nxagentWMIsRunning)
-    {
-      #ifdef WARNING
-      fprintf(stderr, &quot;Warning: Can't switch to window mode, no window manager has been detected.\n&quot;);
-      #endif
-
-      return;
-    }
-  }
-
-  w = nxagentDefaultWindows[pScreen -&gt; myNum];
-  attributes.override_redirect = switchOn;
-  valuemask = CWOverrideRedirect;
-  XUnmapWindow(nxagentDisplay, w);
-  XChangeWindowAttributes(nxagentDisplay, w, valuemask, &amp;attributes);
-
-  if (switchOn)
-  {
-    /*
-     * Change to fullscreen mode.
-     */
-
-    struct timeval timeout;
-    int i;
-    XEvent e;
-
     /*
-     * Wait for window manager reparenting the default window.
+     * The smart scheduler could be stopped while
+     * waiting for the reply. In this case we need
+     * to yield explicitly to avoid to be stuck in
+     * the dispatch loop forever.
      */
 
-    for (i = 0; i &lt; 100 &amp;&amp; nxagentWMIsRunning; i++)
-    {
-      #ifdef TEST
-      fprintf(stderr, &quot;nxagentSwitchFullscreen: WARNING! Going to wait for the ReparentNotify event.\n&quot;);
-      #endif
-
-      if (XCheckTypedWindowEvent(nxagentDisplay, w, ReparentNotify, &amp;e))
-      {
-        break;
-      }
-
-      /*
-       * This should also flush
-       * the NX link for us.
-       */
-
-      XSync(nxagentDisplay, 0);
-
-      timeout.tv_sec  = 0;
-      timeout.tv_usec = 50 * 1000;
-
-      nxagentWaitEvents(nxagentDisplay, &amp;timeout);
-    }
-
-    if (i &lt; 100)
-    {
-      /*
-       * The window manager has done with the reparent
-       * operation. We can resize and map the window.
-       */
-
-      nxagentChangeOption(Fullscreen, True);
-
-      /*
-       * Save the window-mode configuration.
-       */
-
-      nxagentChangeOption(SavedX, nxagentOption(X));
-      nxagentChangeOption(SavedY, nxagentOption(Y));
-      nxagentChangeOption(SavedWidth, nxagentOption(Width));
-      nxagentChangeOption(SavedHeight, nxagentOption(Height));
-      nxagentChangeOption(SavedRootWidth, nxagentOption(RootWidth));
-      nxagentChangeOption(SavedRootHeight, nxagentOption(RootHeight));
-
-      /*
-       * Reconf the Default window.
-       */
-
-      nxagentChangeOption(X, 0);
-      nxagentChangeOption(Y, 0);
-      nxagentChangeOption(Width, WidthOfScreen(DefaultScreenOfDisplay(nxagentDisplay)));
-      nxagentChangeOption(Height, HeightOfScreen(DefaultScreenOfDisplay(nxagentDisplay)));
-
-      /*
-       * Move the root window.
-       */
-
-      nxagentChangeOption(RootX, (nxagentOption(Width) - nxagentOption(RootWidth)) / 2);
-      nxagentChangeOption(RootY, (nxagentOption(Height) - nxagentOption(RootHeight)) / 2);
-      nxagentChangeOption(ViewportXSpan, nxagentOption(Width) - nxagentOption(RootWidth));
-      nxagentChangeOption(ViewportYSpan, nxagentOption(Height) - nxagentOption(RootHeight));
-
-      XMoveResizeWindow(nxagentDisplay, w, nxagentOption(X), nxagentOption(Y),
-                            nxagentOption(Width), nxagentOption(Height));
-
-      nxagentUpdateViewportFrame(0, 0, nxagentOption(RootWidth), nxagentOption(RootHeight));
-
-      XMoveWindow(nxagentDisplay, nxagentWindow(WindowTable[pScreen -&gt; myNum]),
-                      nxagentOption(RootX), nxagentOption(RootY));
-
-      /*
-       * We disable the screensaver when changing
-       * mode to fullscreen. Is it really needed?
-       */
-
-      XSetScreenSaver(nxagentDisplay, 0, 0, DefaultExposures, DefaultBlanking);
+    isItTimeToYield = 1;
 
-      if (nxagentIconWindow == None)
-      {
-        nxagentIconWindow = nxagentCreateIconWindow();
-
-        XMapWindow(nxagentDisplay, nxagentIconWindow);
-      }
-
-      XMapRaised(nxagentDisplay, w);
-      XSetInputFocus(nxagentDisplay, w, RevertToParent, CurrentTime);
-      XCheckTypedWindowEvent(nxagentDisplay, w, LeaveNotify, &amp;e);
-      nxagentFullscreenWindow = w;
-
-      if (nxagentOption(DesktopResize) == 1)
-      {
-        if (nxagentOption(Shadow) == 0)
-        {
-          nxagentRRSetScreenConfig(pScreen, WidthOfScreen(DefaultScreenOfDisplay(nxagentDisplay)),
-                                       HeightOfScreen(DefaultScreenOfDisplay(nxagentDisplay)));
-        }
-        else
-        {
-          nxagentShadowAdaptToRatio();
-        }
-      }
-    }
-    else
+    if (nxagentWMIsRunning == 0)
     {
-      /*
-       * We have waited for a reparent event unsuccessfully.
-       * Something happened to the window manager.
-       */
-
       #ifdef WARNING
-      fprintf(stderr, &quot;nxagentSwitchFullscreen: WARNING! Expected ReparentNotify event missing.\n&quot;);
+      fprintf(stderr, &quot;Warning: Can't switch to window mode, no window manager &quot;
+                  &quot;has been detected.\n&quot;);
       #endif
 
-      nxagentWMIsRunning = False;
-      attributes.override_redirect = False;
-      XChangeWindowAttributes(nxagentDisplay, w, valuemask, &amp;attributes);
-      XMapWindow(nxagentDisplay, w);
+      return;
     }
   }
-  else
-  {
-    /*
-     * FIXME:
-     * It could be necessary:
-     * - To restore screensaver.
-     * - To set or reset nxagentForceBackingStore flag.
-     * - To grab keyboard.
-     * - To propagate device settings to the X server if no WM is running.
-     */
-
-    /*
-     * Change to windowed mode.
-     */
 
-    nxagentChangeOption(Fullscreen, False);
-    XDestroyWindow(nxagentDisplay, nxagentIconWindow);
-    nxagentIconWindow = nxagentFullscreenWindow = None;
+  #ifdef TEST
+  fprintf(stderr, &quot;nxagentSwitchFullscreen: Switching to %s mode.\n&quot;,
+              switchOn ? &quot;fullscreen&quot; : &quot;windowed&quot;);
+  #endif
 
-    if (nxagentOption(DesktopResize) == 1)
-    {
-      nxagentChangeOption(RootWidth, nxagentOption(SavedRootWidth));
-      nxagentChangeOption(RootHeight, nxagentOption(SavedRootHeight));
+  nxagentChangeOption(Fullscreen, switchOn);
 
-      if (nxagentOption(Shadow) == 0)
-      {
-        nxagentRRSetScreenConfig(pScreen, nxagentOption(RootWidth), nxagentOption(RootHeight));
-      }
-    }
+  if (nxagentOption(DesktopResize) == 1)
+  {
+    sizeHints.flags = PSize;
 
-    if (nxagentOption(WMBorderWidth) &gt; 0 &amp;&amp; nxagentOption(WMTitleHeight) &gt; 0)
+    if (switchOn == 1)
     {
-      nxagentChangeOption(X, nxagentOption(SavedX) -
-                              nxagentOption(WMBorderWidth));
-      nxagentChangeOption(Y, nxagentOption(SavedY) -
-                              nxagentOption(WMTitleHeight));
+      sizeHints.width =
+          WidthOfScreen(DefaultScreenOfDisplay(nxagentDisplay));
+      sizeHints.height =
+          HeightOfScreen(DefaultScreenOfDisplay(nxagentDisplay));
     }
     else
     {
-      nxagentChangeOption(X, nxagentOption(SavedX));
-      nxagentChangeOption(Y, nxagentOption(SavedY));
+      sizeHints.width = nxagentOption(RootWidth);
+      sizeHints.height = nxagentOption(RootHeight);
     }
 
-    nxagentChangeOption(Width, nxagentOption(SavedWidth));
-    nxagentChangeOption(Height, nxagentOption(SavedHeight));
-
-    if (nxagentOption(Shadow) == 1 &amp;&amp; nxagentOption(DesktopResize) == 1)
-    {
-      nxagentShadowAdaptToRatio();
-    }
+    XSetWMNormalHints(nxagentDisplay, nxagentDefaultWindows[pScreen -&gt; myNum],
+                         &amp;sizeHints);
+  }
 
-    XMoveResizeWindow(nxagentDisplay, w, nxagentOption(X), nxagentOption(Y),
-                          nxagentOption(Width), nxagentOption(Height));
+  memset(&amp;e, 0, sizeof(e));
 
-    nxagentUpdateViewportFrame(0, 0, nxagentOption(Width), nxagentOption(Height));
+  e.xclient.type = ClientMessage;
+  e.xclient.message_type = nxagentAtoms[13]; /* _NET_WM_STATE */
+  e.xclient.display = nxagentDisplay;
+  e.xclient.window = nxagentDefaultWindows[pScreen -&gt; myNum];
+  e.xclient.format = 32;
+  e.xclient.data.l[0] = nxagentOption(Fullscreen) ? 1 : 0;
+  e.xclient.data.l[1] = nxagentAtoms[14]; /* _NET_WM_STATE_FULLSCREEN */
 
-    XMoveWindow(nxagentDisplay, nxagentWindow(WindowTable[pScreen -&gt; myNum]), 0, 0);
-    XMapWindow(nxagentDisplay, w);
+  XSendEvent(nxagentDisplay, DefaultRootWindow(nxagentDisplay), False,
+                 SubstructureRedirectMask, &amp;e);
 
-    nxagentChangeOption(RootX, 0);
-    nxagentChangeOption(RootY, 0);
+  if (switchOn == 1)
+  {
+    nxagentFullscreenWindow = nxagentDefaultWindows[pScreen -&gt; myNum];
   }
-
-  XMoveResizeWindow(nxagentDisplay, nxagentInputWindows[0], 0, 0,
-                        nxagentOption(Width), nxagentOption(Height));
-
-  nxagentSetPrintGeometry(pScreen -&gt; myNum);
+  else
+  {
+    nxagentFullscreenWindow = None;
+  } 
 }
 
 #ifdef VIEWPORT_FRAME
@@ -2422,6 +2274,11 @@ void nxagentMapDefaultWindows()
         #endif
 
         XMapWindow(nxagentDisplay, nxagentDefaultWindows[pScreen-&gt;myNum]);
+
+        if (nxagentOption(Fullscreen) == 1 &amp;&amp; nxagentWMIsRunning == 1)
+        {
+          nxagentSwitchFullscreen(pScreen, 1);
+        }
       }
 
       /*
@@ -2452,26 +2309,6 @@ void nxagentMapDefaultWindows()
   }
 
   /*
-   * Map the icon window.
-   */
-
-  if (nxagentIconWindow != 0)
-  {
-    #ifdef TEST
-    fprintf(stderr, &quot;nxagentMapDefaultWindows: Mapping icon window id [%ld].\n&quot;,
-                nxagentIconWindow);
-    #endif
-
-    XMapWindow(nxagentDisplay, nxagentIconWindow);
-
-    if (nxagentIpaq != 0)
-    {
-      XIconifyWindow(nxagentDisplay, nxagentIconWindow,
-                         DefaultScreen(nxagentDisplay));
-    }
-  }
-
-  /*
    * Ensure that the fullscreen window gets the focus.
    */
 
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXpicture.c b/nx-X11/programs/Xserver/hw/nxagent/X/NXpicture.c
index 18697a5..be961c4 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXpicture.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXpicture.c
@@ -62,6 +62,7 @@
 #include &quot;Screen.h&quot;
 #include &quot;Pixmaps.h&quot;
 #include &quot;Drawable.h&quot;
+#include &quot;Render.h&quot;
 
 #define PANIC
 #define WARNING
@@ -1063,7 +1064,47 @@ static void initGradient(SourcePictPtr pGradient, int stopCount,
 static PicturePtr createSourcePicture(void)
 {
     PicturePtr pPicture;
-    pPicture = (PicturePtr) xalloc(sizeof(PictureRec));
+
+    extern int nxagentPicturePrivateIndex;
+
+    unsigned int totalPictureSize;
+
+    DevUnion *ppriv;
+
+    char *privPictureRecAddr;
+
+    int i;
+
+    /*
+     * Compute size of entire PictureRect, plus privates.
+     */
+
+    totalPictureSize = sizeof(PictureRec) +
+                           picturePrivateCount * sizeof(DevUnion) +
+                               sizeof(nxagentPrivPictureRec);
+
+    pPicture = (PicturePtr) xalloc(totalPictureSize);
+
+    if (pPicture != NULL)
+    {
+      ppriv = (DevUnion *) (pPicture + 1);
+
+      for (i = 0; i &lt; picturePrivateCount; ++i)
+      {
+        /*
+         * Other privates are inaccessible.
+         */
+
+        ppriv[i].ptr = NULL;
+      }
+
+      privPictureRecAddr = (char *) &amp;ppriv[picturePrivateCount];
+
+      ppriv[nxagentPicturePrivateIndex].ptr = (pointer) privPictureRecAddr;
+
+      pPicture -&gt; devPrivates = ppriv;
+    }
+
     pPicture-&gt;pDrawable = 0;
     pPicture-&gt;pFormat = 0;
     pPicture-&gt;pNext = 0;
@@ -1697,6 +1738,10 @@ FreePicture (pointer	value,
 
     if (--pPicture-&gt;refcnt == 0)
     {
+#ifdef NXAGENT_SERVER
+        nxagentDestroyPicture(pPicture);
+#endif
+
 	if (pPicture-&gt;transform)
 	    xfree (pPicture-&gt;transform);
         if (!pPicture-&gt;pDrawable) {
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXpicture.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXpicture.c.NX.original
index 18697a5..be961c4 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXpicture.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXpicture.c.NX.original
@@ -62,6 +62,7 @@
 #include &quot;Screen.h&quot;
 #include &quot;Pixmaps.h&quot;
 #include &quot;Drawable.h&quot;
+#include &quot;Render.h&quot;
 
 #define PANIC
 #define WARNING
@@ -1063,7 +1064,47 @@ static void initGradient(SourcePictPtr pGradient, int stopCount,
 static PicturePtr createSourcePicture(void)
 {
     PicturePtr pPicture;
-    pPicture = (PicturePtr) xalloc(sizeof(PictureRec));
+
+    extern int nxagentPicturePrivateIndex;
+
+    unsigned int totalPictureSize;
+
+    DevUnion *ppriv;
+
+    char *privPictureRecAddr;
+
+    int i;
+
+    /*
+     * Compute size of entire PictureRect, plus privates.
+     */
+
+    totalPictureSize = sizeof(PictureRec) +
+                           picturePrivateCount * sizeof(DevUnion) +
+                               sizeof(nxagentPrivPictureRec);
+
+    pPicture = (PicturePtr) xalloc(totalPictureSize);
+
+    if (pPicture != NULL)
+    {
+      ppriv = (DevUnion *) (pPicture + 1);
+
+      for (i = 0; i &lt; picturePrivateCount; ++i)
+      {
+        /*
+         * Other privates are inaccessible.
+         */
+
+        ppriv[i].ptr = NULL;
+      }
+
+      privPictureRecAddr = (char *) &amp;ppriv[picturePrivateCount];
+
+      ppriv[nxagentPicturePrivateIndex].ptr = (pointer) privPictureRecAddr;
+
+      pPicture -&gt; devPrivates = ppriv;
+    }
+
     pPicture-&gt;pDrawable = 0;
     pPicture-&gt;pFormat = 0;
     pPicture-&gt;pNext = 0;
@@ -1697,6 +1738,10 @@ FreePicture (pointer	value,
 
     if (--pPicture-&gt;refcnt == 0)
     {
+#ifdef NXAGENT_SERVER
+        nxagentDestroyPicture(pPicture);
+#endif
+
 	if (pPicture-&gt;transform)
 	    xfree (pPicture-&gt;transform);
         if (!pPicture-&gt;pDrawable) {
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c
index ffc1997..562cd2c 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c
@@ -116,7 +116,6 @@ int  nxagentCursorSaveRenderInfo(ScreenPtr, CursorPtr);
 void nxagentCursorPostSaveRenderInfo(CursorPtr, ScreenPtr, PicturePtr, int, int);
 int  nxagentRenderRealizeCursor(ScreenPtr, CursorPtr);
 int  nxagentCreatePicture(PicturePtr, Mask);
-void nxagentDestroyPicture(PicturePtr pPicture);
 void nxagentChangePicture(PicturePtr, Mask);
 int  nxagentChangePictureClip(PicturePtr, int, int, xRectangle *, int, int);
 void nxagentComposite(CARD8, PicturePtr, PicturePtr, PicturePtr, INT16, INT16,
@@ -132,6 +131,28 @@ void nxagentSetPictureFilter(PicturePtr pPicture, char *filter, int name_size,
 void nxagentTrapezoids(CARD8 op, PicturePtr pSrc, PicturePtr pDst, PictFormatPtr maskFormat,
                            INT16 xSrc, INT16 ySrc, int ntrap, xTrapezoid *traps);
 
+void nxagentRenderCreateSolidFill(PicturePtr pPicture, xRenderColor *color);
+
+void nxagentRenderCreateLinearGradient(PicturePtr pPicture, xPointFixed *p1,
+                                           xPointFixed *p2, int nStops,
+                                               xFixed *stops,
+                                                   xRenderColor *colors);
+
+void nxagentRenderCreateRadialGradient(PicturePtr pPicture, xPointFixed *inner,
+                                           xPointFixed *outer,
+                                               xFixed innerRadius,
+                                                   xFixed outerRadius,
+                                                       int nStops,
+                                                           xFixed *stops,
+                                                               xRenderColor *colors);
+
+void nxagentRenderCreateConicalGradient(PicturePtr pPicture,
+                                            xPointFixed *center,
+                                                xFixed angle, int nStops, 
+                                                    xFixed *stops, 
+                                                        xRenderColor *colors);
+
+
 /*
  * The void pointer is actually a XGlyphElt8.
  */
@@ -823,8 +844,6 @@ ProcRenderFreePicture (ClientPtr client)
     VERIFY_PICTURE (pPicture, stuff-&gt;picture, client, SecurityDestroyAccess,
 		    RenderErrBase + BadPicture);
 
-    nxagentDestroyPicture(pPicture);
-
     FreeResource (stuff-&gt;picture, RT_NONE);
     return(client-&gt;noClientException);
 }
@@ -926,9 +945,16 @@ ProcRenderComposite (ClientPtr client)
 		    RenderErrBase + BadPicture);
     VERIFY_ALPHA (pMask, stuff-&gt;mask, client, SecurityReadAccess, 
 		  RenderErrBase + BadPicture);
+/*
+FIXME: Imported change from newest version of Xorg. Changed pSrc to pDst.
+
     if ((pSrc-&gt;pDrawable &amp;&amp; pSrc-&gt;pDrawable-&gt;pScreen != pDst-&gt;pDrawable-&gt;pScreen) ||
 	(pMask &amp;&amp; pMask-&gt;pDrawable &amp;&amp; pSrc-&gt;pDrawable-&gt;pScreen != pMask-&gt;pDrawable-&gt;pScreen))
 	return BadMatch;
+*/
+    if ((pSrc-&gt;pDrawable &amp;&amp; pSrc-&gt;pDrawable-&gt;pScreen != pDst-&gt;pDrawable-&gt;pScreen) ||
+	(pMask &amp;&amp; pMask-&gt;pDrawable &amp;&amp; pDst-&gt;pDrawable-&gt;pScreen != pMask-&gt;pDrawable-&gt;pScreen))
+	return BadMatch;
 
     ValidatePicture (pSrc);
     if (pMask)
@@ -2336,6 +2362,11 @@ static int ProcRenderCreateSolidFill(ClientPtr client)
     pPicture = CreateSolidPicture(stuff-&gt;pid, &amp;stuff-&gt;color, &amp;error);
     if (!pPicture)
 	return error;
+    /* AGENT SERVER */
+
+    nxagentRenderCreateSolidFill(pPicture, &amp;stuff -&gt; color);
+
+    /* AGENT SERVER */
     if (!AddResource (stuff-&gt;pid, PictureType, (pointer)pPicture))
 	return BadAlloc;
     return Success;
@@ -2367,6 +2398,12 @@ static int ProcRenderCreateLinearGradient (ClientPtr client)
                                             stuff-&gt;nStops, stops, colors, &amp;error);
     if (!pPicture)
 	return error;
+    /* AGENT SERVER */
+
+    nxagentRenderCreateLinearGradient(pPicture, &amp;stuff-&gt;p1, &amp;stuff-&gt;p2,
+                                          stuff-&gt;nStops, stops, colors);
+
+    /* AGENT SERVER */
     if (!AddResource (stuff-&gt;pid, PictureType, (pointer)pPicture))
 	return BadAlloc;
     return Success;
@@ -2397,6 +2434,14 @@ static int ProcRenderCreateRadialGradient (ClientPtr client)
                                             stuff-&gt;nStops, stops, colors, &amp;error);
     if (!pPicture)
 	return error;
+    /* AGENT SERVER */
+
+    nxagentRenderCreateRadialGradient(pPicture, &amp;stuff-&gt;inner, &amp;stuff-&gt;outer,
+                                          stuff-&gt;inner_radius,
+                                              stuff-&gt;outer_radius, 
+                                                  stuff-&gt;nStops, stops, colors);
+
+    /* AGENT SERVER */
     if (!AddResource (stuff-&gt;pid, PictureType, (pointer)pPicture))
 	return BadAlloc;
     return Success;
@@ -2426,6 +2471,13 @@ static int ProcRenderCreateConicalGradient (ClientPtr client)
                                              stuff-&gt;nStops, stops, colors, &amp;error);
     if (!pPicture)
 	return error;
+    /* AGENT SERVER */
+
+    nxagentRenderCreateConicalGradient(pPicture, &amp;stuff-&gt;center,
+                                           stuff-&gt;angle, stuff-&gt;nStops, stops,
+                                               colors);
+
+    /* AGENT SERVER */
     if (!AddResource (stuff-&gt;pid, PictureType, (pointer)pPicture))
 	return BadAlloc;
     return Success;
diff --git a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original
index ffc1997..562cd2c 100644
--- a/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original
+++ b/nx-X11/programs/Xserver/hw/nxagent/X/NXrender.c.NX.original
@@ -116,7 +116,6 @@ int  nxagentCursorSaveRenderInfo(ScreenPtr, CursorPtr);
 void nxagentCursorPostSaveRenderInfo(CursorPtr, ScreenPtr, PicturePtr, int, int);
 int  nxagentRenderRealizeCursor(ScreenPtr, CursorPtr);
 int  nxagentCreatePicture(PicturePtr, Mask);
-void nxagentDestroyPicture(PicturePtr pPicture);
 void nxagentChangePicture(PicturePtr, Mask);
 int  nxagentChangePictureClip(PicturePtr, int, int, xRectangle *, int, int);
 void nxagentComposite(CARD8, PicturePtr, PicturePtr, PicturePtr, INT16, INT16,
@@ -132,6 +131,28 @@ void nxagentSetPictureFilter(PicturePtr pPicture, char *filter, int name_size,
 void nxagentTrapezoids(CARD8 op, PicturePtr pSrc, PicturePtr pDst, PictFormatPtr maskFormat,
                            INT16 xSrc, INT16 ySrc, int ntrap, xTrapezoid *traps);
 
+void nxagentRenderCreateSolidFill(PicturePtr pPicture, xRenderColor *color);
+
+void nxagentRenderCreateLinearGradient(PicturePtr pPicture, xPointFixed *p1,
+                                           xPointFixed *p2, int nStops,
+                                               xFixed *stops,
+                                                   xRenderColor *colors);
+
+void nxagentRenderCreateRadialGradient(PicturePtr pPicture, xPointFixed *inner,
+                                           xPointFixed *outer,
+                                               xFixed innerRadius,
+                                                   xFixed outerRadius,
+                                                       int nStops,
+                                                           xFixed *stops,
+                                                               xRenderColor *colors);
+
+void nxagentRenderCreateConicalGradient(PicturePtr pPicture,
+                                            xPointFixed *center,
+                                                xFixed angle, int nStops, 
+                                                    xFixed *stops, 
+                                                        xRenderColor *colors);
+
+
 /*
  * The void pointer is actually a XGlyphElt8.
  */
@@ -823,8 +844,6 @@ ProcRenderFreePicture (ClientPtr client)
     VERIFY_PICTURE (pPicture, stuff-&gt;picture, client, SecurityDestroyAccess,
 		    RenderErrBase + BadPicture);
 
-    nxagentDestroyPicture(pPicture);
-
     FreeResource (stuff-&gt;picture, RT_NONE);
     return(client-&gt;noClientException);
 }
@@ -926,9 +945,16 @@ ProcRenderComposite (ClientPtr client)
 		    RenderErrBase + BadPicture);
     VERIFY_ALPHA (pMask, stuff-&gt;mask, client, SecurityReadAccess, 
 		  RenderErrBase + BadPicture);
+/*
+FIXME: Imported change from newest version of Xorg. Changed pSrc to pDst.
+
     if ((pSrc-&gt;pDrawable &amp;&amp; pSrc-&gt;pDrawable-&gt;pScreen != pDst-&gt;pDrawable-&gt;pScreen) ||
 	(pMask &amp;&amp; pMask-&gt;pDrawable &amp;&amp; pSrc-&gt;pDrawable-&gt;pScreen != pMask-&gt;pDrawable-&gt;pScreen))
 	return BadMatch;
+*/
+    if ((pSrc-&gt;pDrawable &amp;&amp; pSrc-&gt;pDrawable-&gt;pScreen != pDst-&gt;pDrawable-&gt;pScreen) ||
+	(pMask &amp;&amp; pMask-&gt;pDrawable &amp;&amp; pDst-&gt;pDrawable-&gt;pScreen != pMask-&gt;pDrawable-&gt;pScreen))
+	return BadMatch;
 
     ValidatePicture (pSrc);
     if (pMask)
@@ -2336,6 +2362,11 @@ static int ProcRenderCreateSolidFill(ClientPtr client)
     pPicture = CreateSolidPicture(stuff-&gt;pid, &amp;stuff-&gt;color, &amp;error);
     if (!pPicture)
 	return error;
+    /* AGENT SERVER */
+
+    nxagentRenderCreateSolidFill(pPicture, &amp;stuff -&gt; color);
+
+    /* AGENT SERVER */
     if (!AddResource (stuff-&gt;pid, PictureType, (pointer)pPicture))
 	return BadAlloc;
     return Success;
@@ -2367,6 +2398,12 @@ static int ProcRenderCreateLinearGradient (ClientPtr client)
                                             stuff-&gt;nStops, stops, colors, &amp;error);
     if (!pPicture)
 	return error;
+    /* AGENT SERVER */
+
+    nxagentRenderCreateLinearGradient(pPicture, &amp;stuff-&gt;p1, &amp;stuff-&gt;p2,
+                                          stuff-&gt;nStops, stops, colors);
+
+    /* AGENT SERVER */
     if (!AddResource (stuff-&gt;pid, PictureType, (pointer)pPicture))
 	return BadAlloc;
     return Success;
@@ -2397,6 +2434,14 @@ static int ProcRenderCreateRadialGradient (ClientPtr client)
                                             stuff-&gt;nStops, stops, colors, &amp;error);
     if (!pPicture)
 	return error;
+    /* AGENT SERVER */
+
+    nxagentRenderCreateRadialGradient(pPicture, &amp;stuff-&gt;inner, &amp;stuff-&gt;outer,
+                                          stuff-&gt;inner_radius,
+                                              stuff-&gt;outer_radius, 
+                                                  stuff-&gt;nStops, stops, colors);
+
+    /* AGENT SERVER */
     if (!AddResource (stuff-&gt;pid, PictureType, (pointer)pPicture))
 	return BadAlloc;
     return Success;
@@ -2426,6 +2471,13 @@ static int ProcRenderCreateConicalGradient (ClientPtr client)
                                              stuff-&gt;nStops, stops, colors, &amp;error);
     if (!pPicture)
 	return error;
+    /* AGENT SERVER */
+
+    nxagentRenderCreateConicalGradient(pPicture, &amp;stuff-&gt;center,
+                                           stuff-&gt;angle, stuff-&gt;nStops, stops,
+                                               colors);
+
+    /* AGENT SERVER */
     if (!AddResource (stuff-&gt;pid, PictureType, (pointer)pPicture))
 	return BadAlloc;
     return Success;


hooks/post-receive
-- 
nx-libs.git (NX (redistributed))

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;nx-libs.git&quot; (NX (redistributed)).

</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011624.html">[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxagent/3.4.0-5
</A></li>
	<LI>Next message: <A HREF="011626.html">[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxagent/3.4.0-9
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11625">[ date ]</a>
              <a href="thread.html#11625">[ thread ]</a>
              <a href="subject.html#11625">[ subject ]</a>
              <a href="author.html#11625">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2Go-commits
mailing list</a><br>
</body></html>
