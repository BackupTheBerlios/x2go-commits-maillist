<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxcompext/3.5.0-1-61-g5e502cb
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2013-August/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-main%20%28branch%29%20updated%3A%0A%09nxcompext/3.5.0-1-61-g5e502cb&In-Reply-To=%3C20130830142228.8C1FA5DB55%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011395.html">
   <LINK REL="Next"  HREF="011371.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxcompext/3.5.0-1-61-g5e502cb</H1>
    <B>X2Go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-main%20%28branch%29%20updated%3A%0A%09nxcompext/3.5.0-1-61-g5e502cb&In-Reply-To=%3C20130830142228.8C1FA5DB55%40ymir%3E"
       TITLE="[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxcompext/3.5.0-1-61-g5e502cb">git-admin at x2go.org
       </A><BR>
    <I>Fri Aug 30 16:22:28 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="011395.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxcompshad/3.5.0-2-69-g9bfca1c
</A></li>
        <LI>Next message: <A HREF="011371.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxproxy/3.5.0-1-82-gf7e6c45
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11426">[ date ]</a>
              <a href="thread.html#11426">[ thread ]</a>
              <a href="subject.html#11426">[ subject ]</a>
              <a href="author.html#11426">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, build-main has been updated
       via  5e502cbb195be17d5d742295f4a2e6f0c603a8d7 (commit)
       via  88dace9a99687840f3fb341f0316cd94399cae9e (commit)
       via  9573b5669d4811862d24acde6a5db4db68e92b76 (commit)
       via  9ea0691391b9dda7f205ec2cc5acf531d2b427d1 (commit)
       via  f2f6dab87b8a2c066c5eb242ca73b85f2796a5c0 (commit)
       via  abf03fd2c05cbbf24cd9c40e81684706c258ea63 (commit)
       via  4ad13f4ef6bfd430432b928e72686e2ae995d175 (commit)
       via  42e72ef5f513977227328efba9482225b643697a (commit)
      from  a48361b11a5abb5a345dac5ec83a8f56c4d50b74 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
-----------------------------------------------------------------------

Summary of changes:
 nxcompext/Alpha.c                   |   42 +
 nxcompext/Alpha.h                   |   37 +
 nxcompext/Bitmap.c                  |  112 +
 nxcompext/Bitmap.h                  |   36 +
 nxcompext/CHANGELOG                 |  806 +++++
 {nx-X11 =&gt; nxcompext}/COPYING       |    0
 nxcompext/Clean.c                   |  341 +++
 nxcompext/Clean.h                   |   36 +
 nxcompext/Colormap.c                |   42 +
 nxcompext/Colormap.h                |   37 +
 nxcompext/Jpeg.c                    |  472 +++
 nxcompext/Jpeg.h                    |   38 +
 nxcompext/LICENSE                   |   21 +
 nxcompext/Makefile.in               |  162 +
 nxcompext/Mask.c                    |  794 +++++
 nxcompext/Mask.h                    |   40 +
 nxcompext/NXlib.c                   | 4770 +++++++++++++++++++++++++++++
 nxcompext/NXlib.h                   |  904 ++++++
 nxcompext/NXlibint.h                |   31 +
 nxcompext/Pgn.c                     |  722 +++++
 nxcompext/Pgn.h                     |   68 +
 nxcompext/README                    |   15 +
 nxcompext/Rgb.c                     |   43 +
 nxcompext/Rgb.h                     |   36 +
 nxcompext/Rle.c                     |   43 +
 nxcompext/Rle.h                     |   36 +
 {nxcomp =&gt; nxcompext}/VERSION       |    0
 nxcompext/Z.c                       |  301 ++
 nxcompext/Z.h                       |   52 +
 nxcompext/configure                 | 5618 +++++++++++++++++++++++++++++++++++
 nxcompext/configure.in              |  249 ++
 {nxcomp =&gt; nxcompext}/install-sh    |    0
 {nxcomp =&gt; nxcompext}/mkinstalldirs |    0
 33 files changed, 15904 insertions(+)
 create mode 100644 nxcompext/Alpha.c
 create mode 100644 nxcompext/Alpha.h
 create mode 100644 nxcompext/Bitmap.c
 create mode 100644 nxcompext/Bitmap.h
 create mode 100644 nxcompext/CHANGELOG
 copy {nx-X11 =&gt; nxcompext}/COPYING (100%)
 create mode 100644 nxcompext/Clean.c
 create mode 100644 nxcompext/Clean.h
 create mode 100644 nxcompext/Colormap.c
 create mode 100644 nxcompext/Colormap.h
 create mode 100644 nxcompext/Jpeg.c
 create mode 100644 nxcompext/Jpeg.h
 create mode 100644 nxcompext/LICENSE
 create mode 100644 nxcompext/Makefile.in
 create mode 100644 nxcompext/Mask.c
 create mode 100644 nxcompext/Mask.h
 create mode 100644 nxcompext/NXlib.c
 create mode 100644 nxcompext/NXlib.h
 create mode 100644 nxcompext/NXlibint.h
 create mode 100644 nxcompext/Pgn.c
 create mode 100644 nxcompext/Pgn.h
 create mode 100644 nxcompext/README
 create mode 100644 nxcompext/Rgb.c
 create mode 100644 nxcompext/Rgb.h
 create mode 100644 nxcompext/Rle.c
 create mode 100644 nxcompext/Rle.h
 copy {nxcomp =&gt; nxcompext}/VERSION (100%)
 create mode 100644 nxcompext/Z.c
 create mode 100644 nxcompext/Z.h
 create mode 100755 nxcompext/configure
 create mode 100644 nxcompext/configure.in
 copy {nxcomp =&gt; nxcompext}/install-sh (100%)
 copy {nxcomp =&gt; nxcompext}/mkinstalldirs (100%)

The diff of changes is:
diff --git a/nxcompext/Alpha.c b/nxcompext/Alpha.c
new file mode 100644
index 0000000..bba191f
--- /dev/null
+++ b/nxcompext/Alpha.c
@@ -0,0 +1,42 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;zlib.h&gt;
+
+#include &quot;NXlib.h&quot;
+
+#include &quot;Alpha.h&quot;
+#include &quot;Z.h&quot;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#define ALPHA_COMPRESSION_LEVEL      1
+#define ALPHA_COMPRESSION_THRESHOLD  32
+#define ALPHA_COMPRESSION_STRATEGY   Z_RLE
+
+static int alphaCompressionLevel     = ALPHA_COMPRESSION_LEVEL;
+static int alphaCompressionThreshold = ALPHA_COMPRESSION_THRESHOLD;
+static int alphaCompressionStrategy  = ALPHA_COMPRESSION_STRATEGY;
+
+char *AlphaCompressData(const char *data, unsigned int size, unsigned int *compressed_size)
+{
+  return ZCompressData(data, size, alphaCompressionThreshold, alphaCompressionLevel,
+                           alphaCompressionStrategy, compressed_size);
+}
diff --git a/nxcompext/Alpha.h b/nxcompext/Alpha.h
new file mode 100644
index 0000000..6ae9aee
--- /dev/null
+++ b/nxcompext/Alpha.h
@@ -0,0 +1,37 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Alpha_H
+#define Alpha_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+extern char *AlphaCompressData(
+#if NeedFunctionPrototypes
+    const char*       /* data */,
+    unsigned int      /* size */,
+    unsigned int*     /* compressed_size */
+#endif
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Alpha_H */
diff --git a/nxcompext/Bitmap.c b/nxcompext/Bitmap.c
new file mode 100644
index 0000000..725eaac
--- /dev/null
+++ b/nxcompext/Bitmap.c
@@ -0,0 +1,112 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &quot;NXlib.h&quot;
+
+#include &quot;Bitmap.h&quot;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+char *BitmapCompressData(XImage *image, unsigned int *size)
+{
+  if (image -&gt; bits_per_pixel != 32)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******BitmapCompressData: Nothing to do with image of [%d] bpp and size [%d].\n&quot;,
+                image -&gt; bits_per_pixel, image -&gt; bytes_per_line * image -&gt; height);
+    #endif
+
+    *size = image -&gt; bytes_per_line * image -&gt; height;
+
+    return image -&gt; data;
+  }
+  else
+  {
+    /*
+     * Remove the 4th byte from the bitmap.
+     */
+
+    char *data;
+
+    char *next_src;
+    char *next_dst;
+
+    #ifdef TEST
+
+    if (image -&gt; bytes_per_line != 4 * image -&gt; width)
+    {
+      fprintf(stderr, &quot;******BitmapCompressData: PANIC! Image as [%d] bytes per line with expected [%d].\n&quot;,
+                  image -&gt; bytes_per_line, 4 * image -&gt; width);
+
+      return NULL;
+    }
+
+    #endif
+
+    *size = image -&gt; width * image -&gt; height * 3;
+
+    data = Xmalloc(*size);
+
+    if (data == NULL)
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******BitmapCompressData: PANIC! Failed to allocate [%d] bytes for the destination.\n&quot;,
+                  *size);
+      #endif
+
+      *size = image -&gt; bytes_per_line * image -&gt; height;
+
+      return image -&gt; data;
+    }
+
+    next_src = image -&gt; data;
+    next_dst = data;
+
+    if (image -&gt; byte_order == LSBFirst)
+    {
+      while (next_src &lt; image -&gt; data +
+                 image -&gt; bytes_per_line * image -&gt; height)
+      {
+        *next_dst++ = *next_src++;
+        *next_dst++ = *next_src++;
+        *next_dst++ = *next_src++;
+
+        next_src++;
+      }
+    }
+    else
+    {
+      while (next_src &lt; image -&gt; data +
+                 image -&gt; bytes_per_line * image -&gt; height)
+      {
+        next_src++;
+
+        *next_dst++ = *next_src++;
+        *next_dst++ = *next_src++;
+        *next_dst++ = *next_src++;
+      }
+    }
+
+    return data;
+  }
+}
diff --git a/nxcompext/Bitmap.h b/nxcompext/Bitmap.h
new file mode 100644
index 0000000..974aa42
--- /dev/null
+++ b/nxcompext/Bitmap.h
@@ -0,0 +1,36 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Bitmap_H
+#define Bitmap_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+extern char *BitmapCompressData(
+#if NeedFunctionPrototypes
+    XImage*                   /* image */,
+    unsigned int*             /* compressed_size */
+#endif
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Bitmap_H */
diff --git a/nxcompext/CHANGELOG b/nxcompext/CHANGELOG
new file mode 100644
index 0000000..941e9b4
--- /dev/null
+++ b/nxcompext/CHANGELOG
@@ -0,0 +1,806 @@
+ChangeLog:
+
+nxcompext-3.5.0-1
+
+- Opened the 3.5.0 branch based on nxcompext-3.4.0-1.
+
+- Updated copyright to year 2011. 
+
+nxcompext-3.4.0-1
+
+- Opened the 3.4.0 branch based on nxcompext-3.3.0-4.
+
+- Updated version number.
+
+- Updated copyright to year 2009.
+
+nxcompext-3.3.0-4
+
+- Fixed TR03G02199. The color palette allocated for encoding an image
+  having 256 colors or less was not freed.
+
+nxcompext-3.3.0-3
+
+- Now setting the correct event serial number when sending collect
+  notifies back.
+
+nxcompext-3.3.0-2
+
+- Updated VERSION.
+
+nxcompext-3.3.0-1
+
+- Opened the 3.3.0 branch based on nxcompext-3.2.0-1.
+
+nxcompext-3.2.0-1
+
+- Opened the 3.2.0 branch based on nxcompext-3.1.0-2.
+
+nxcompext-3.1.0-2
+
+- Updated file VERSION to match the current release version.
+
+nxcompext-3.1.0-1
+
+- Opened the 3.1.0 branch based on nxcompext-3.0.0-18.
+
+nxcompext-3.0.0-18
+
+- Removed the remaining debug output.
+
+nxcompext-3.0.0-17
+
+- Changed the copyright notices at the beginning of the files that
+  were referring to NXPROXY to refer to NXCOMPEXT.
+
+nxcompext-3.0.0-16
+
+- Handle the reply failure in NXGetShmemParameters().
+
+nxcompext-3.0.0-15
+
+- Separated the functionalities made available by NXQueryDisplay()
+  in three distinct functions:
+
+  NXDisplayReadable()  Query the number of bytes readable from
+                       the display connection.
+
+  NXDisplayFlushable() Query the number of the outstanding bytes
+                       to flush to the display connection.
+
+  NXDisplayCongestion() Return a value between 0 and 9 indicating
+                        the congestion level of the NX transport.
+
+- Renamed NXQueryDisplayError() to NXDisplayError().
+
+nxcompext-3.0.0-14
+
+- Removed support for Rdp, Tight and Hextile packed images encod-
+  ing since they have been made obsolete by the new NX server.
+
+- Changed the copyright attribution from Medialogic to NoMachine.
+
+nxcompext-3.0.0-13
+
+- Allocate 1024 additional bytes for the Jpeg compression, instead
+  of 512, to avoid failures on very tiny images.
+
+- Removed support for the special *PNG_JPEG* pack method.
+
+nxcompext-3.0.0-12
+
+- Implemented the NXEncodeBitmap() method. This is a very simple
+  encoder removing the 4th byte in 32 bits-per-plane images. For
+  the other pixmap depths it simply returns a pointer to the orig-
+  inal image data, saving the copy. This encoding is intended to
+  better leverage the stream compression on low bandwidth links.
+
+- Removed the quality parameter from the RGB/RLE encoding function.
+
+nxcompext-3.0.0-11
+
+- Removed the additional parameter in the call to NXTransFlush().
+
+nxcompext-3.0.0-10
+
+- Moved the _NXRDPGlyph and _NXRDPText declarations from NXlib.h
+  to NXproto.h to force fields to be CARD32.
+
+- Fixed a typo in NXSetDisplayBuffer() that could cause a double
+  free.
+
+- Fixed a compilation error with old GCC versions.
+
+- Removed the warning issued on AMD64 when compiling with the logs
+  enabled.
+
+nxcompext-3.0.0-9
+
+- Added the NXDisplayCongestion query type to NXQueryDisplay(). It
+  returns a value between 0 and 9, with 9 meaning that the link is
+  congested and no further data can be sent.
+
+- Added the NXSetDisplayBuffer() function. It allows the caller to
+  set the display output buffer size at runtime.
+
+- Removed the congestion and synchronization callbacks.
+
+nxcompext-3.0.0-8
+
+- Removed the warnings issued when purging the collected data at
+  display reset.
+
+nxcompext-3.0.0-7
+
+- Added the NXSetDisplayWriteHandler() interface. The function
+  registers a callback that will be invoked every time more data
+  is written to the display socket.
+
+nxcompext-3.0.0-6
+
+- Made NXQueryDisplay() take into account the bytes in the display
+  buffer when queried for the bytes flushable.
+
+nxcompext-3.0.0-5
+
+- Added file COPYING.
+
+nxcompext-3.0.0-4
+
+- Updated copyright notices to the current year.
+
+nxcompext-3.0.0-3
+
+- Imported changes up to nxcompext-2.1.0-4.
+
+- Fixed TR12D01564. Changed configure script to build library with
+  -fPIC option.
+
+- Added 256 byte to the size of Jpeg destination buffer. 
+
+nxcompext-3.0.0-2
+
+- Updated the file VERSION.
+
+nxcompext-3.0.0-1
+
+- Opened the 3.0.0 branch based on nxcompext-2.0.0-33.
+
+nxcompext-2.0.0-33
+
+- Placed the inclusion of jpeglib.h after the X includes to fix a
+  possible compilation error.
+
+nxcompext-2.0.0-32
+
+- Avoid to copy the data to the scratch buffer and yield the task
+  of padding the output to _XSend() in the NXPutPackedImage(), NX-
+  SetUnpackAlpha() and NXSetUnpackColormap() requests.
+
+- Added support for the RLE pack method.
+
+nxcompext-2.0.0-31
+
+- The X_NXSetUnpackColormap and X_NXSetUnpackAlpha now carry their
+  data in compressed form. The alpha data is compressed using the
+  ZLIB RLE encoding, while the colormap data is compressed using
+  the default ZLIB deflate.
+
+- Created new message structures to handle the compatibility with
+  the old proxy versions. When connected to an old proxy version
+  the agent should use the NXSetUnpackColormapCompat() and NXSet-
+  UnpackAlpha() interfaces.
+
+nxcompext-2.0.0-30
+
+- Removed the unfriendly warning printed if a client tried to reset
+  the library multiple times.
+
+nxcompext-2.0.0-29
+
+- Made possible to compile even if makedepend is not found.
+
+nxcompext-2.0.0-28
+
+- Added the NXSetDisplaySynchronizationHandler() interface. The NX
+  transport will use the callback to report when the agent can use
+  the available bandwidth to synchronize the X objects that are
+  corrupted or incomplete.
+
+- Bytes from 14 to 24 in the NXGetControlParameters() reply report,
+  respectively, the frame timeout, the ping timeout, the preferred
+  image split mode and the split size threshold.
+
+nxcompext-2.0.0-27
+
+- Changed the image cleanup functions and the Png and Jpeg encoders
+  to be independent from the host endianess.
+
+- Enabled again the image cleanup on big endian machines.
+
+nxcompext-2.0.0-26
+
+- Added the NXAbortSplit() request.
+
+- Added information about the size of the shared memory segment used
+  by the remote proxy in the NXGetShmemParameters() reply.
+
+nxcompext-2.0.0-25
+
+- Renamed the NXGetSplitResource() and NXGetUnpackResource() utili-
+  ties to NXAllocSplit() and NXAllocUnpack(). They can be called
+  with a NXAnyResource parameter to get the first available id or
+  requre a specific resource. From this version the resource must
+  be explicitly reserved. NXFreeUnpack() and NXFreeSplit() check
+  if the resource was allocated and don't do anything if it is not
+  the case. NXAllocSplit() and NXAllocUnpack() return NXNoResource
+  if the resource can't be reserved.
+
+nxcompext-2.0.0-24
+
+- NXFlushDisplay() now verifies whether the XlibDisplayWriting flag
+  is set before flushing the display buffer. in this case, it only
+  flushes the NX link.
+
+nxcompext-2.0.0-23
+
+- Implemented a move-to-front strategy for the image cache, to mi-
+  nimize the number of lookups.
+
+- Fixed the problems imtroduced by the new cache implementation by
+  modifying the memory allocation routines in Jpeg.c and Pgn.c.
+
+- Temporarily fixed the cleanup problems on big-endian machines by
+  skipping the operation.
+
+- Added a NXSetDisplayStatisticsHandler() to let the agent include
+  arbitrary data in the transport statistics. The parameter is a
+  pointer to a pointer to a null terminated string. The pointer is
+  set at the time the handler is registered. The pointed string can
+  be filled by the agent with its statistics data.
+
+nxcompext-2.0.0-22
+
+- The NXCacheFindImage() returns a pointer to the checksum, if the
+  image is found.
+
+- The image cache uses the data passed to NXCacheAddImage() instead
+  of making a copy.
+
+- The Z stream used by the RGB encoder is allocated at initializat-
+  ion and freed at reset.
+
+nxcompext-2.0.0-21
+
+- Removed the reliance on the local byte order in the image cleanup
+  functions.
+
+nxcompext-2.0.0-20
+
+- Added the NXFinishSplit() request. It forces the proxy to comple-
+  tely transfer all the split messages for the given resource, and
+  then notify the agent.
+
+nxcompext-2.0.0-19
+
+- Enabled again the cleanup of images.
+
+- Updated to comply with the new NXTransFlush() interface.
+
+nxcompext-2.0.0-18
+
+- Moved all the declarations in Rgb.c at the beginning of the block
+  to avoid the possible compilation errors with old compilers.
+
+nxcompext-2.0.0-17
+
+- Added a new RGB image encoder. For now the encoder uses a static
+  Z stream to compress the image data in the destination buffer and
+  allows the agent to use the simplest encoding by still separating
+  the alpha channel from the image data. The new encoder can be the
+  the base for implementing color reduction by dithering or a color-
+  mapped translation of the image similar to PNG, but without the
+  PNG overhead and with the colormap being sent to the client using
+  the NXSetUnpackColormap() opcode.
+
+- Created a new NXCleanImage() function that takes a XImage pointer
+  and uses either the CleanXYImage() or the CleanZImage() routines
+  to cleanup the padding bits.
+
+nxcompext-2.0.0-16
+
+- Added a parameter to NXFlushDisplay() to specify what needs to be
+  flushed. The parameter can be one the following values, defined
+  in NXvars.h:
+
+  NXFlushBuffer   Only the Xlib buffer is to be flushed.
+
+  NXFlushLink     Flush both the Xlib buffer and any pending
+                  data encoded by the NX transport.
+
+  NXFlushIdle     Inform the NX transport that the agent is
+                  idle. This will let the NX transport encode
+                  more low-priority data, and then flush the
+                  link.
+
+- Ensured that the padding bytes are cleaned when creating a new
+  PNG image. It seems that some images are still missed. This is
+  to be investigated.
+
+nxcompext-2.0.0-15
+
+- Ensured that the packed image cache is recreated only on a size
+  change.
+
+nxcompext-2.0.0-14
+
+- Updated to get the karma delay field from the X_NXGetControlPara-
+  meters reply.
+
+nxcompext-2.0.0-13
+
+- Added the NXSetDisplayPolicy() and NXSetDisplayFlushHandler() in-
+  terfaces. The second function registers a callback that will be
+  invoked by the NX transport when the number of bytes encoded by
+  the proxy exceeds the threshold set for the scheduled write.
+
+- Added the NXFlushDisplay() and NXQueryDisplay() interfaces. They
+  are used to hide the corresponding NX transport functions to the
+  application. NXQueryDisplay() can be called with the NXDisplay-
+  Flushable or NXDisplayReadable parameters, to get, repectively,
+  the number of bytes that are queued to the NX transport and the
+  number of bytes that is possible to read.
+
+- Included the remote proxy version in the NXGetControlParameter()
+  reply.
+
+nxcompext-2.0.0-12
+
+- Added the NXGetSplitResource() and NXGetUnpackResource utilities.
+  These can be used by the client to find out the first unused id
+  available for a split or unpack operation.
+
+- Added the NXFreeSplit() request function. It makes the resource
+  available for the next operation and tells the proxy to destroy
+  all the storage associated to the split.
+
+- Renamed the NXNumberOfConnections constant to NXNumberOfResources.
+
+nxcompext-2.0.0-11
+
+- Changed NXForceDisplayError() to also shut down the NX transport
+  by calling NXTransClose().
+
+- Updated to comply with the new NX function prototypes introduced
+  in nxcomp-2.0.0-31.
+
+nxcompext-2.0.0-10
+
+- NXQueryDisplayError() now checks the predicate function only if
+  the I/O error was not encountered already.
+
+nxcompext-2.0.0-9
+
+- Added the NXSetDisplayErrorPredicate(), NXSetDisplayBlockHand-
+  ler(), NXSetDisplayCongestionHandler(), NXSetLostSequenceHand-
+  ler() interfaces to let the user set the values used internal-
+  ly. All functions return the previous handler. See ChangeLog
+  in nx-X11-2.0.0-16 and nx-X11-2.0.0-17.
+
+- Moved all the internal variables shared between Xlib, nxcompext
+  and the X server in nxcomp. Declarations and function prototypes
+  moved to NXvars.h.
+
+- Some name changes. In particular the NXContinueOnDisplayError()
+  function iss renamed NXHandleDisplayError() and NXDisplayError()
+  is now renamed NXQueryDisplayError(). To verify if the display
+  is valid, NXQueryDisplayError() will now call the _NXDisplayEr-
+  rorPredicate function, or, if the predicate function is not set,
+  will simply check the value of the XlibDisplayIOError flag.
+
+- Removed the NXGetCleanupParameters() and NXGetImageParameters()
+  interfaces and the remaining references to the unused display
+  buffer and image cleanup functions.
+
+- Updated the NoMachine copyright notice to year 2006.
+
+nxcompext-2.0.0-8
+
+- Removed the unused screen parameter from XSetUnpackGeometry().
+
+- NXSetUnpackGeometry() now fails if no visual is provided.
+
+nxcompext-2.0.0-7
+
+- Changed the LICENSE file to state that the software is only made
+  available under the version 2 of the GPL.
+
+- Removed the misplaced DXPC copyright notices from the license.
+  They were copied from NXCOMP but they don't apply in any way to
+  NXCOMPEXT.
+
+nxcompext-2.0.0-6
+
+- Added the NXSetCacheParameters() request. It tells to the local
+  proxy how to handle the X requests, namely if the next requests
+  have to be stored in the memory cache, split in smal data chunks,
+  and in the case of images, saved on disk in the persistent image
+  cache. The request will affect all X messages, including plain
+  and packed images. It can be used to tell the proxy to discard
+  images coming from some selected operations, like GLX or XVideo.
+
+nxcompext-2.0.0-5
+
+- Added the NXGetFontParameters() request and reply. If the proxy
+  has been configured accordingly, the request returns the X font
+  path that can be set by the agent to tunnel the font server con-
+  nections through the NX link.
+
+nxcompext-2.0.0-4
+
+- Initial work on font server tunneling.
+
+nxcompext-2.0.0-3
+
+- Renamed the NXSetExposeEvents request to NXSetExposeParameters.
+
+nxcompext-2.0.0-2
+
+- Modified the configure and the makefiles to support the Cygwin
+  environment.
+
+- Renamed Png.h to Pgn.h to avoid name clashes on Windows.
+
+- The distclean target now removes the autom4te.cache directory.
+
+nxcompext-2.0.0-1
+
+- Opened the 2.0.0 branch based on nxcompext-1.5.0-20.
+
+nxcompext-1.5.0-20
+
+- Removed the code installing a SIGSEGV handler before trying to
+  clean an image in NXCleanImageInPlace().
+
+nxcompext-1.5.0-19
+
+- Added the NXUnsetLibraryPath() function to specify the behaviour
+  of the Popen() in the X server. If the _NXUnsetLibraryPath flag
+  is set, the Popen() will remove the LD_LIBRARY_PATH variable from
+  the environment before running the child process. This will cause
+  the X server to run the process (for example the keyboard initia-
+  lization utilities) by using the native system libraries, instead
+  of the libraries shipped with the NX environment.
+
+nxcompext-1.5.0-18
+
+- Moved the declarations of _NXEnable* and related structures from
+  Xlibint.h to NXlibint.h.  
+
+- Use the include files from nx-X11 if the nx-X11/include directory
+  is found. The previous configure checked the presence of nx-X11/
+  exports/include, that might not be built at the time this library
+  is compiled.
+
+nxcompext-1.5.0-17
+
+- Added the -fPIC GCC flag when compiling on AMD64 architectures.
+
+- Removed all warnings when compiling with GCC4.
+
+- Small changes to configure.in to have specific CFLAGS.
+
+- Created a new configure using autoconf 2.59.
+
+nxcompext-1.5.0-16
+
+- Added the 'mode' field in the NXStartSplit() request. It determi-
+  nes the strategy that the proxy will adopt to handle the image.
+  If set to 'eager', the proxy will only split the messages whose
+  size exceeds the split threshold (the threshold can be found in
+  the NXGetControlParameters() reply). If mode is set to lazy, the
+  proxy will split any image that it is not able to find in its
+  cache.
+
+  The opcode and the two available modes are defined in NXproto.h,
+  currently:
+
+  #define NXSplitModeDefault  0
+  #define NXSplitModeEager    1
+  #define NXSplitModeLazy     2
+
+- All requests related to image streaming now carry a 'resource' id.
+  The id is currently ignored by the proxy in the case of NXCommit-
+  Split() requests.
+
+nxcompext-1.5.0-15
+
+- Removed the NXSync() and NXKarma() operations, not used anymore
+  by the NX agents.
+
+- Updated to comply with changes occurred in the numbering of the
+  notification events and in the interface to the image streaming
+  functions.
+
+nxcompext-1.5.0-14
+
+- Accounted for the missing xoffset field in clean-up of XYPixmaps.
+
+nxcompext-1.5.0-13
+
+- Added a 'commit' field in NXCommitSplit(). When zero, the remote
+  proxy will remove the message from the split store, without send-
+  ing the recomposed image to the X server.
+
+nxcompext-1.5.0-12
+
+- Added the NXContinueOnDisplayError() function to specify the be-
+  haviour of the Xlib I/O error handler. If the flag is set to true,
+  Xlib will simply return, instead of quitting the program. This
+  leaves to the application the responsibility of checking the sta-
+  te of the XlibDisplayIOError flag.
+
+- Changed NXDisplayIsValid() to NXDisplayError() and inverted the
+  logic. Now the function returns true if the display pointer is
+  NULL or the XlibDisplayIOError flag is set.
+
+- Added the NXForceDisplayError() function, to shutdown the display
+  descriptor and force Xlib to set the I/O error flag.
+
+nxcompext-1.5.0-11
+
+- Added -I../nx-X11/exports/include to CCINCLUDES in Makefile.in.
+
+nxcompext-1.5.0-10
+
+- Added FindLSB() to replace ffs() that may be not present on some
+  systems.
+
+- Some cosmetic changes.
+
+nxcompext-1.5.0-9
+
+- Fixed a printf() that prevented the code to compile if TEST was
+  enabled.
+
+nxcompext-1.5.0-8
+
+- Implemented the NXLib interface for asynchronous handling of the
+  XGetInputFocus requests and replies.
+
+nxcompext-1.5.0-7
+
+- Removed the _NXFlushSize parameter. New agents run the NX trans-
+  port in-process, so we don't get any benefit from increasing the
+  display buffer size.
+
+nxcompext-1.5.0-6
+
+- Added a NXDisplayIsValid() to check that the display is not NULL
+  and that the descriptor was not shut down after an IOError. The
+  reason a function is needed for this is that the flags field is
+  only in Xlibint and it is not visible to Xlib applications.
+
+nxcompext-1.5.0-5
+
+- Added the NXGetCollect*Resource utility functions, returning the
+  first available small integer resource id that can be used in a
+  subsequent collect request.
+
+nxcompext-1.5.0-4
+
+- Added the NXNumberOfConnections constant.
+
+nxcompext-1.5.0-3
+
+- Implemented the NXLib interface for the asynchronous handling of
+  the XGrabPointer requests and replies.
+
+- Solved an error in image cleaning that prevented the 8 bits-per-
+  pixel images to be completely cleaned. Due to the bug, only half
+  of the total lines were cleaned.
+
+- Removed a bug that prevented the cleaning of XYPixmaps images of
+  bitmap unit 32 and byte order LSB.
+
+- Renamed the NXImageCache variables to show they are global. They
+  are currently used in the nxagent code.
+
+nxcompext-1.5.0-2
+
+- Changed VERSION file.
+
+nxcompext-1.5.0-1
+
+- Opened the 1.5.0 branch.
+
+nxcompext-1.4.1-1
+
+- Removed the configure option --with-static. There are two options
+  now, --with-static-png and --with-static-jpeg, to offer a greater
+  degree of control on the resulting library.
+
+- This version differs from the 1.4.0-3-KRY1 in the way that the con-
+  figure script is generated by GNU Autoconf 2.57, the same version
+  used for nxcomp.
+
+- Opened the 1.4.1 branch.
+
+nxcompext-1.4.0-3
+
+- Updated the VERSION file to reflect the 1.4.0 status.
+
+nxcompext-1.4.0-2
+
+- Imported changes from the latest 1.3.2 development branch.
+
+- The 1.4.0 branch already had a 1.4.0-1 version. The changes from
+  the 1.4.0-1 were up to date with the 1.3.2-2 version.
+
+nxcompext-1.3.2-6
+
+- Fixed problem with icons in KDE and Mozilla on SPARC Solaris. The
+  problem was related to cleaning of one-bit XYPixmaps on big-endian
+  hosts, where shift of the cleaning mask executed in the wrong di-
+  rection.
+
+nxcompext-1.3.2-5
+
+- Changes in Clean.c to compile on Solaris.
+
+nxcompext-1.3.2-4
+
+- Fixed a bug in clean image procedures for 1bit XYPixmaps. The bug
+  caused Mozilla to trash some transparent icons in web pages and
+  the toolbar.
+
+- Added cleaning of the padding bytes at the end of the data chunk
+  inside XImage structure
+
+- Implemented handling of SIGSEGV during cleanup in case of static
+  data.
+
+- Moved image cleanup and masking code in new Clean.c and Mask.c
+  sources.
+
+- Corrected few typos in NXCollectImage code.
+
+nxcompext-1.3.2-2
+
+- Imported 1.4.0-1 changes from the 1.4.0 development branch.
+
+- Modified NXAllocColors to handle errors generated allocating
+  each requested color. A per-color result code is now returned 
+  to the caller.
+
+- Code cleanup in Png.h and Png.c.
+
+nxcompext-1.3.2-1
+
+- Opened the 1.3.2 branch.
+
+nxcompext-1.3.1-2
+
+- Removed the underline characters and added a colon in the
+  title of this ChangeLog to fully comply with format used in
+  the release notices.
+
+nxcompext-1.3.1-1
+
+- Opened the 1.3.1 branch.
+
+nxcompext-1.3.0-18
+
+- Added the _NXLostSequenceHandler function to let NX agents
+  suppress the error message and modify the default Xlib
+  behaviour when out-of-order sequence numbers are received.
+  Pointer to function is assigned to _NXLostSequenceFunction
+  in XlibInt.c.
+
+- Original output buffer size in stock XFree86 is 2048. We try
+  to reduce context switches and help stream compression by
+  increasing the maximum size of the buffer 8192. _NXFlushSize
+  determines when the display buffer is actually flushed. It is
+  set by default to 4096 in XlibInt.c and set to 0 to use the
+  maximum available size at the time NXGetControlParameters()
+  is called.
+
+nxcompext-1.3.0-17
+
+- In handling of asynchronous GetProperty replies a warning
+  message was printed in session log when a null property was
+  stored in the state structure. This message is now printed
+  only if TEST is defined.
+
+nxcompext-1.3.0-16
+
+- Added asynchronous handling of GetProperty request and reply
+  by means of the NXCollectProperty and NXGetCollectedProperty
+  requests and the NXCollectPropertyNotify event.
+
+nxcompext-1.3.0-15
+
+- Added 4 new fields to the X_NXGetControlParameters reply.
+
+nxcompext-1.3.0-14
+
+- Added request X_NXFreeUnpack to free the resources allocated
+  by the remote proxy to unpack images for the given agent's
+  client
+
+nxcompext-1.3.0-13
+
+- Modified the following requests to carry the id of the
+  agent's client in the field resource:
+
+  - X_NXSetUnpackGeometry
+  - X_NXSetUnpackColormap
+  - X_NXSetUnpackAlpha
+  - X_NXPutPackedImage
+
+nxcompext-1.3.0-11
+
+- Modified the MIT-SHM initialization procedure to always send
+  all the 3 protocol requests also in the case of early failures.
+
+nxcompext-1.3.0-10
+
+- Added handling of X_NXSetUnpackAlpha request.
+
+- It has been made possible to send both X_NXSetUnpackColormap
+  and X_NXSetUnpackAlpha messages with 0 entries to temporarily
+  disable use of the colormap or the alpha channel and free the
+  resources allocated by the remote proxy.
+
+nxcompext-1.3.0-9
+
+- Solved a compatibility problem when mixing proxy versions
+  1.2.2 and 1.3.0 due to the missing X_NXGetShmemParameters
+  request.
+
+nxcompext-1.3.0-7
+
+- Reduced the number of requests needed to setup the shared
+  segment at X server proxy from 4 to 3.
+
+- Small changes to the shared memory interface to support
+  path X agent to X client proxy.
+
+nxcompext-1.3.0-6
+
+- Implemented initial support for MIT-SHM extension in the
+  network path between the X server proxy and the real X
+  server.
+
+- Configure script now checks for the FreeBSD environment.
+
+- New configure script generated using autoconf-2.57-3.
+
+- Removed the XFree86 CCDEFINES from Makefile.in.
+
+nxcompext-1.3.0-5
+
+- Cosmetic changes.
+
+- Started to convert configure.in to the new layout adopted
+  for nxcomp.
+
+- Created file CHANGELOG.
+
+nxcompext-1.3.0-4
+
+- More fixes in image clean-up.
+
+nxcompext-1.3.0-3
+
+- Many fixes in image clean-up functions to handle differences
+  in endianess between client and X server.
+
+nxcompext-1.3.0-2
+
+- Modified configure.in to compile under Solaris.
+
+nxcompext-1.3.0-1
+
+- First 1.3.0 version based on nxcompext-1.2.2-12.
+
diff --git a/nx-X11/COPYING b/nxcompext/COPYING
similarity index 100%
copy from nx-X11/COPYING
copy to nxcompext/COPYING
diff --git a/nxcompext/Clean.c b/nxcompext/Clean.c
new file mode 100644
index 0000000..cc02200
--- /dev/null
+++ b/nxcompext/Clean.c
@@ -0,0 +1,341 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &lt;signal.h&gt;
+
+#include &quot;os.h&quot;
+
+#include &quot;NXlib.h&quot;
+
+#include &quot;Clean.h&quot;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+int CleanXYImage(XImage *image)
+{
+  int i, j, k, plane;
+
+  int bitsToClean = (image -&gt; bytes_per_line &lt;&lt; 3) - image -&gt; width - image -&gt; xoffset;
+
+  unsigned int bytesToClean = bitsToClean &gt;&gt; 3;
+
+  bitsToClean &amp;= 7;
+
+  for (k = 0; k &lt; image -&gt; depth; k++)
+  {
+    plane = k * (image -&gt; bytes_per_line * image -&gt; height);
+
+    for (i = 1; i &lt;= image -&gt; height; i++)
+    {
+      if (image -&gt; byte_order == image -&gt; bitmap_bit_order)
+      {
+        for (j = 1; j &lt;= bytesToClean; j++)
+        {
+          image -&gt; data[plane + i * (image -&gt; bytes_per_line) - j] = 0x00;
+        }
+      }
+      else
+      {
+        for (j = bytesToClean; j &gt;= 1; j--)
+        {
+          image -&gt; data[plane + i * (image -&gt; bytes_per_line) - j] = 0x00;
+        }
+      }
+
+      if (image -&gt; bitmap_bit_order == MSBFirst)
+      {
+        image -&gt; data[plane + i * (image -&gt; bytes_per_line) - j] &amp;= 0xff &lt;&lt; bitsToClean;
+      }
+      else
+      {
+        image -&gt; data[plane + i * (image -&gt; bytes_per_line) - j] &amp;= 0xff &gt;&gt; bitsToClean;
+      }
+    }
+  }
+
+  return 1;
+}
+
+int CleanZImage(XImage *image)
+{
+  unsigned int bytesToClean;
+  unsigned int j;
+  unsigned int imageLength;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;*****CleanZImage: Going to clean image of [%d] bits per pixel.\n&quot;,
+              image -&gt; bits_per_pixel);
+  #endif
+
+  switch (image -&gt; bits_per_pixel)
+  {
+    case 32:
+    {
+      /*
+       * The caller should pay attention at extracting
+       * the alpha channel prior to cleaning the image.
+       * Cleaning an image which is carrying the alpha
+       * channel will result in the image being treated
+       * as fully transparent.
+       */
+
+      register int i;
+
+      bytesToClean = image -&gt; bytes_per_line * image -&gt; height;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;*****CleanZImage: Cleaning [%d] bytes with bits per pixel [%d] &quot;
+                  &quot;width [%d] bytes per line [%d] height [%d].\n&quot;, bytesToClean,
+                      image -&gt; bits_per_pixel, image -&gt; width, image -&gt;
+                          bytes_per_line, image -&gt; height);
+      #endif
+
+      if (image -&gt; byte_order == LSBFirst)
+      {
+        for (i = 3; i &lt; bytesToClean; i += 4)
+        {
+          ((unsigned char *) image -&gt; data)[i] = 0x00;
+        }
+      }
+      else
+      {
+        for (i = 0; i &lt; bytesToClean; i += 4)
+        {
+          ((unsigned char *) image -&gt; data)[i] = 0x00;
+        }
+      }
+
+      break;
+    }
+    case 24:
+    case 15:
+    case 16:
+    case 8:
+    {
+      register int i, j;
+
+      bytesToClean = image -&gt; bytes_per_line -
+                           ((image -&gt; width * image -&gt; bits_per_pixel) &gt;&gt; 3);
+
+      for (i = 1; i &lt;= image -&gt; height; i++)
+      {
+        for (j = bytesToClean; j &gt; 0; j--)
+        {
+          ((unsigned char *) image -&gt; data)[(i * image -&gt; bytes_per_line) - j] = 0x00;
+        }
+      }
+
+      break;
+    }
+    default:
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;*****CleanZImage: PANIC! Cannot clean image with [%d] bits per pixel.\n&quot;,
+                  image -&gt; bits_per_pixel);
+      #endif
+    }
+  }
+
+  /* 
+   * Clean the padding bytes at the real
+   * end of the buffer.
+   */
+
+  imageLength = image -&gt; bytes_per_line * image -&gt; height;
+
+  bytesToClean = imageLength % 4;
+
+  for (j = 0; j &lt; bytesToClean; j++)
+  {
+    ((unsigned char *)image -&gt; data)[(imageLength + j)] = 0x00;
+  }
+
+  return 1;
+}
+
+/*
+ * Copy a clean version of src_image into dst_image.
+ * This code is not taking care of the image format.
+ * The agent doesn't use it and you have to consider
+ * it unsupported.
+ */
+
+int CopyAndCleanImage(XImage *src_image, XImage *dst_image)
+{
+  register long data_size;
+  register int i;
+
+  data_size = (src_image -&gt; bytes_per_line * src_image -&gt; height) &gt;&gt; 2;
+
+  #ifdef WARNING
+  fprintf(stderr, &quot;******CleanImage: WARNING! Function called with image of [%d] bits per pixel.\n&quot;,
+              src_image -&gt; bits_per_pixel);
+  #endif
+
+  switch (src_image -&gt; bits_per_pixel)
+  {
+    case 32:
+    {
+      unsigned int mask;
+
+      if (src_image -&gt; byte_order == MSBFirst)
+      {
+        mask = 0xffffff00;
+      }
+      else
+      {
+        mask = 0x00ffffff;
+      }
+      for (i = 0; i &lt; data_size; i++)
+      {
+        ((unsigned int *)dst_image -&gt; data)[i] = ((unsigned int *)src_image -&gt; data)[i] &amp; mask;
+      }
+
+      break;
+    }
+
+    case 24:
+    {
+      unsigned int bytes_to_clean;
+
+      for (i = 0; i &lt; data_size; i++)
+      {
+        ((unsigned int *)dst_image -&gt; data)[i] = ((unsigned int *)src_image -&gt; data)[i];
+      }
+
+      bytes_to_clean = dst_image -&gt; bytes_per_line - ((dst_image -&gt; width *
+                           dst_image -&gt; bits_per_pixel) &gt;&gt; 3);
+
+      if (bytes_to_clean)
+      {
+        register unsigned int mask = 0xffffffff;
+        register int line_size;
+        register int i;
+                
+        line_size = dst_image -&gt; bytes_per_line &gt;&gt; 2;
+
+        if (dst_image -&gt; byte_order == MSBFirst)
+        {
+          mask = mask &lt;&lt; (bytes_to_clean &lt;&lt; 3);
+        }
+        else
+        {
+          mask = mask &gt;&gt; (bytes_to_clean &lt;&lt; 3);
+        }
+
+        for (i = 0; i &lt; dst_image -&gt; height;)
+        {
+          ((unsigned char *)dst_image -&gt; data)[(++i * line_size) -1] &amp;= mask;
+        }
+      }
+
+      break;
+    }
+
+    case 15:
+    case 16:
+    {
+      for (i = 0; i &lt; data_size; i++)
+      {
+        ((unsigned int *) dst_image -&gt; data)[i] = ((unsigned int *) src_image -&gt; data)[i];
+      }
+
+      if (src_image -&gt; width &amp; 0x00000001)
+      {
+        int card32_per_line = dst_image -&gt; bytes_per_line &gt;&gt; 2;
+
+        for (i = 0; i &lt; dst_image -&gt; height;)
+        {
+          ((unsigned int *) dst_image -&gt; data)[(++i * card32_per_line) -1] &amp;= 0x0000ffff;
+        }
+      }
+
+      break;
+    }
+
+    case 8:
+    {
+      unsigned int mask = 0x00000000;
+
+      switch (dst_image -&gt; width % 4)
+      {
+        case 3:
+        {
+          mask = 0x00ffffff;
+
+          break;
+        }
+        case 2:
+        {
+          mask = 0x0000ffff;
+
+          break;
+        }
+        case 1:
+        {
+          mask = 0x000000ff;
+
+          break;
+        }
+        default:
+        {
+          /*
+           * Nothing to clean.
+           */
+
+          break;
+        }
+      }
+
+      for (i = 0; i &lt; data_size; i++)
+      {
+        ((unsigned int *) dst_image -&gt; data)[i] = ((unsigned int *) src_image -&gt; data)[i];
+      }
+
+      if (mask)
+      {
+        int card32_per_line;
+        int i;
+
+        card32_per_line = dst_image -&gt; bytes_per_line &gt;&gt; 2;
+
+        for (i = 0; i &lt; dst_image -&gt; height; i++)
+        {
+          ((unsigned int *) dst_image -&gt; data)[(++i * card32_per_line) -1] &amp;= mask;
+        }
+      }
+
+      break;
+    }
+
+    default:
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******CleanImage: PANIC! Cannot clean image of [%d] bits per pixel.\n&quot;,
+                  src_image -&gt; bits_per_pixel);
+      #endif
+
+      return 0;
+    }
+  }
+
+  return 1;
+}
diff --git a/nxcompext/Clean.h b/nxcompext/Clean.h
new file mode 100644
index 0000000..ba2a62d
--- /dev/null
+++ b/nxcompext/Clean.h
@@ -0,0 +1,36 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Clean_H
+#define Clean_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;Xlib.h&quot;
+
+int CleanXYImage(XImage *image);
+int CleanZImage(XImage *image);
+
+int CopyAndCleanImage(XImage *src_image, XImage *dst_image);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Clean_H */
diff --git a/nxcompext/Colormap.c b/nxcompext/Colormap.c
new file mode 100644
index 0000000..2e169ed
--- /dev/null
+++ b/nxcompext/Colormap.c
@@ -0,0 +1,42 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;zlib.h&gt;
+
+#include &quot;NXlib.h&quot;
+
+#include &quot;Colormap.h&quot;
+#include &quot;Z.h&quot;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#define COLORMAP_COMPRESSION_LEVEL      4
+#define COLORMAP_COMPRESSION_THRESHOLD  32
+#define COLORMAP_COMPRESSION_STRATEGY   Z_DEFAULT_STRATEGY
+
+static int colormapCompressionLevel     = COLORMAP_COMPRESSION_LEVEL;
+static int colormapCompressionThreshold = COLORMAP_COMPRESSION_THRESHOLD;
+static int colormapCompressionStrategy  = COLORMAP_COMPRESSION_STRATEGY;
+
+char *ColormapCompressData(const char *data, unsigned int size, unsigned int *compressed_size)
+{
+  return ZCompressData(data, size, colormapCompressionThreshold, colormapCompressionLevel,
+                           colormapCompressionStrategy, compressed_size);
+}
diff --git a/nxcompext/Colormap.h b/nxcompext/Colormap.h
new file mode 100644
index 0000000..42eff34
--- /dev/null
+++ b/nxcompext/Colormap.h
@@ -0,0 +1,37 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Colormap_H
+#define Colormap_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+extern char *ColormapCompressData(
+#if NeedFunctionPrototypes
+    const char*       /* data */,
+    unsigned int      /* size */,
+    unsigned int*     /* compressed_size */
+#endif
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Colormap_H */
diff --git a/nxcompext/Jpeg.c b/nxcompext/Jpeg.c
new file mode 100644
index 0000000..cb854bc
--- /dev/null
+++ b/nxcompext/Jpeg.c
@@ -0,0 +1,472 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;X11/X.h&quot;
+#include &quot;X11/Xlib.h&quot;
+#include &quot;X11/Xmd.h&quot;
+
+#include &lt;jpeglib.h&gt;
+
+#include &quot;NXlib.h&quot;
+
+#include &quot;Mask.h&quot;
+#include &quot;Jpeg.h&quot;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#define JPEG_DEST_SIZE(width, height) ((width) * 3 * (height) + 1024)
+
+/*
+ * Local function prototypes.
+ */
+
+static void PrepareRowForJpeg(CARD8 *dst, int y, int count);
+static void PrepareRowForJpeg24(CARD8 *dst, int y, int count);
+static void PrepareRowForJpeg16(CARD8 *dst, int y, int count);
+static void PrepareRowForJpeg32(CARD8 *dst, int y, int count);
+
+static int JpegEmptyOutputBuffer(j_compress_ptr cinfo);
+
+static void JpegInitDestination(j_compress_ptr cinfo);
+static void JpegTermDestination(j_compress_ptr cinfo);
+static void JpegSetDstManager(j_compress_ptr cinfo);
+
+/*
+ * Quality levels.
+ */
+
+static int jpegQuality[10] = {20, 30, 40, 50, 55, 60, 65, 70, 75, 80};
+
+/*
+ * Image characteristics.
+ */
+
+static int bytesPerLine;
+
+static CARD8 bitsPerPixel;
+static CARD16 redMax, greenMax, blueMax;
+static CARD8  redShift, greenShift, blueShift;
+static int byteOrder;
+
+/*
+ * Other variables used for the Jpeg
+ * encoding.
+ */
+
+static char *jpegBeforeBuf = NULL;
+static char *jpegCompBuf;
+static int  jpegCompBufSize;
+static int  jpegError;
+static int  jpegDstDataLen;
+
+static struct jpeg_destination_mgr jpegDstManager;
+
+/*
+ * Just for debugging purpose.
+ */
+
+#ifdef DEBUG
+
+static int  jpegId;
+static char jpegName[10];
+static FILE *jpegFile;
+
+#endif
+
+/*
+ * Function declarations
+ */
+
+char *JpegCompressData(XImage *image, int level, int *compressed_size)
+{
+  struct jpeg_compress_struct cinfo;
+  struct jpeg_error_mgr jerr;
+
+  CARD8 *srcBuf;
+  JSAMPROW rowPointer[1];
+
+  int dy, w, h;
+
+  *compressed_size = 0;
+
+  /*
+   * Initialize the image stuff
+   */
+
+  bitsPerPixel = image -&gt; bits_per_pixel;
+  bytesPerLine = image -&gt; bytes_per_line;
+  byteOrder = image -&gt; byte_order;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******JpegCompressData: Image byte order [%d] bitmap bit order [%d].\n&quot;,
+              image -&gt; byte_order, image -&gt; bitmap_bit_order);
+
+  fprintf(stderr, &quot;******JpegCompressData: Bits per pixel [%d] bytes per line [%d].\n&quot;,
+              bitsPerPixel, bytesPerLine);
+  #endif
+
+  redShift   = FindLSB(image -&gt; red_mask)   - 1;
+  greenShift = FindLSB(image -&gt; green_mask) - 1;
+  blueShift  = FindLSB(image -&gt; blue_mask)  - 1;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******JpegCompressData: Red mask [0x%lx] green mask [0x%lx] blue mask [0x%lx].\n&quot;,
+              image -&gt; red_mask, image -&gt; green_mask, image -&gt; blue_mask);
+
+  fprintf(stderr, &quot;******JpegCompressData: Red shift [%d] green shift [%d] blue shift [%d].\n&quot;,
+              redShift, greenShift, blueShift);
+  #endif
+
+  redMax   = image -&gt; red_mask   &gt;&gt; redShift;
+  greenMax = image -&gt; green_mask &gt;&gt; greenShift;
+  blueMax  = image -&gt; blue_mask  &gt;&gt; blueShift;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******JpegCompressData: Red max [0x%x] green max [0x%x] blue max [0x%x].\n&quot;,
+              redMax, greenMax, blueMax);
+  #endif
+
+  w = image -&gt; width;
+  h = image -&gt; height;
+
+  jpegBeforeBuf = image -&gt; data;
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******JpegCompressData: Width [%d] height [%d] level [%d].\n&quot;,
+              w, h, level);
+  #endif
+
+  if (bitsPerPixel == 1 ||
+          bitsPerPixel == 8)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******JpegCompressData: PANIC! Invalid bits per pixel [%d].\n&quot;,
+                bitsPerPixel);
+    #endif
+
+    return NULL;
+  }
+
+  /*
+   * Allocate space for one line of the
+   * resulting image, 3 bytes per pixel.
+   */
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******JpegCompressData: Allocating [%d] bytes for the scanline.\n&quot;,
+              w * 3);
+  #endif
+
+  srcBuf = (CARD8 *) malloc(w * 3);
+
+  if (srcBuf == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******JpegCompressData: PANIC! Cannot allocate [%d] bytes.\n&quot;,
+                w * 3);
+    #endif
+
+    return NULL;
+  }
+
+  rowPointer[0] = srcBuf;
+
+  cinfo.err = jpeg_std_error(&amp;jerr);
+
+  jpeg_create_compress(&amp;cinfo);
+
+  cinfo.image_width = w;
+  cinfo.image_height = h;
+  cinfo.input_components = 3;
+  cinfo.in_color_space = JCS_RGB;
+
+  jpeg_set_defaults(&amp;cinfo);
+  jpeg_set_quality(&amp;cinfo, jpegQuality[level], 1);
+
+  /*
+   * Allocate memory for the destination
+   * buffer.
+   */
+
+  jpegCompBufSize = JPEG_DEST_SIZE(w, h);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******JpegCompressData: Allocating [%d] bytes for the destination data.\n&quot;,
+              jpegCompBufSize);
+  #endif
+
+  jpegCompBuf = malloc(jpegCompBufSize);
+
+  if (jpegCompBuf == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******JpegCompressData: PANIC! Error allocating [%d] bytes for the Jpeg data.\n&quot;,
+                jpegCompBufSize);
+    #endif
+
+    return NULL;
+  }
+
+  JpegSetDstManager(&amp;cinfo);
+
+  jpeg_start_compress(&amp;cinfo, 1);
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******JpegCompressedData: Initialization finished.\n&quot;);
+  #endif
+
+  for (dy = 0; dy &lt; h; dy++)
+  {
+    PrepareRowForJpeg(srcBuf, dy, w);
+
+    jpeg_write_scanlines(&amp;cinfo, rowPointer, 1);
+
+    if (jpegError != 0)
+    {
+      break;
+    }
+  }
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******JpegCompressedData: Compression finished. Lines handled [%d,%d]. Error is [%d].\n&quot;,
+              dy, h, jpegError);
+  #endif
+
+  if (jpegError == 0)
+  {
+    jpeg_finish_compress(&amp;cinfo);
+  }
+
+  jpeg_destroy_compress(&amp;cinfo);
+
+  free((char *) srcBuf);
+
+  if (jpegError != 0)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******JpegCompressedData: PANIC! Compression failed. Error is [%d].\n&quot;,
+                jpegError);
+    #endif
+
+    free(jpegCompBuf);
+
+    return NULL;
+  }
+
+  /*
+   * Check the size of the resulting data.
+   */
+
+  if (jpegDstDataLen &gt; 0)
+  {
+    /*
+     * Save the image on disk to help with
+     * the debug.
+     */
+
+    #ifdef DEBUG
+
+    int i = 0;
+
+    fprintf(stderr, &quot;******JpegCompressedData: Compressed size [%d].\n&quot;,
+                jpegDstDataLen);
+
+    jpegId++;
+
+    sprintf(jpegName, &quot;jpeg%d&quot;, jpegId);
+
+    jpegFile = fopen(jpegName, &quot;w&quot;);
+
+    for (i = 0; i &lt; jpegDstDataLen; i++)
+    {
+      fprintf(jpegFile, &quot;%c&quot;, *(jpegCompBuf + i));
+    }
+
+    fclose(jpegFile);
+
+    #endif
+
+    *compressed_size = jpegDstDataLen;
+
+    return jpegCompBuf;
+  }
+  else
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******JpegCompressedData: PANIC! Invalid size of the compressed data [%d].\n&quot;,
+                jpegDstDataLen);
+    #endif
+
+    free(jpegCompBuf);
+
+    return NULL;
+  }
+}
+
+void PrepareRowForJpeg(CARD8 *dst, int y, int count)
+{
+  if (bitsPerPixel == 32)
+  {
+    if (redMax == 0xff &amp;&amp;
+            greenMax == 0xff &amp;&amp;
+                blueMax == 0xff)
+    {
+      PrepareRowForJpeg24(dst, y, count);
+    }
+    else
+    {
+      PrepareRowForJpeg32(dst, y, count);
+    }
+  }
+  else if (bitsPerPixel == 24)
+  {
+    memcpy(dst, jpegBeforeBuf + y * bytesPerLine, count * 3);
+  }
+  else
+  {
+    /*
+     * 16 bpp assumed.
+     */
+
+    PrepareRowForJpeg16(dst, y, count);
+  }
+}
+
+void PrepareRowForJpeg24(CARD8 *dst, int y, int count)
+{
+  CARD8 *fbptr;
+  CARD32 pix;
+
+  fbptr = (CARD8 *) (jpegBeforeBuf + y * bytesPerLine);
+
+  while (count--)
+  {
+    if (byteOrder == LSBFirst)
+    {
+      pix = (CARD32) *(fbptr + 2);
+      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr+1);
+      pix = (pix &lt;&lt; 8) | (CARD32) *fbptr;
+    }
+    else
+    {
+      pix = (CARD32) *(fbptr + 1);
+      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + 2);
+      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + 3);
+    }
+
+    *dst++ = (CARD8)(pix &gt;&gt; redShift);
+    *dst++ = (CARD8)(pix &gt;&gt; greenShift);
+    *dst++ = (CARD8)(pix &gt;&gt; blueShift);
+
+    fbptr+=4;
+  }
+}
+
+#define DEFINE_JPEG_GET_ROW_FUNCTION(bpp)                                   \
+                                                                            \
+void PrepareRowForJpeg##bpp(CARD8 *dst, int y, int count)                   \
+{                                                                           \
+  CARD8 *fbptr;                                                             \
+  CARD##bpp pix;                                                            \
+  int inRed, inGreen, inBlue;                                               \
+  int i;                                                                    \
+                                                                            \
+  fbptr = (CARD8 *) (jpegBeforeBuf + y * bytesPerLine);                     \
+                                                                            \
+  while (count--)                                                           \
+  {                                                                         \
+    pix = 0;                                                                \
+                                                                            \
+    if (byteOrder == LSBFirst)                                              \
+    {                                                                       \
+      for (i = (bpp &gt;&gt; 3) - 1; i &gt;= 0; i--)                                 \
+      {                                                                     \
+        pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + i);                           \
+      }                                                                     \
+    }                                                                       \
+    else                                                                    \
+    {                                                                       \
+      for (i = 0; i &lt; (bpp &gt;&gt; 3); i++)                                      \
+      {                                                                     \
+        pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + i);                           \
+      }                                                                     \
+    }                                                                       \
+                                                                            \
+    fbptr += bpp &gt;&gt; 3;                                                      \
+                                                                            \
+    inRed = (int)                                                           \
+            (pix &gt;&gt; redShift   &amp; redMax);                                   \
+    inGreen = (int)                                                         \
+            (pix &gt;&gt; greenShift &amp; greenMax);                                 \
+    inBlue  = (int)                                                         \
+            (pix &gt;&gt; blueShift  &amp; blueMax);                                  \
+                                                                            \
+    *dst++ = (CARD8)((inRed   * 255 + redMax / 2) /                         \
+                         redMax);                                           \
+    *dst++ = (CARD8)((inGreen * 255 + greenMax / 2) /                       \
+                         greenMax);                                         \
+    *dst++ = (CARD8)((inBlue  * 255 + blueMax / 2) /                        \
+                         blueMax);                                          \
+  }                                                                         \
+}
+
+DEFINE_JPEG_GET_ROW_FUNCTION(16)
+DEFINE_JPEG_GET_ROW_FUNCTION(32)
+
+/*
+ * Destination manager implementation for JPEG library.
+ */
+
+void JpegInitDestination(j_compress_ptr cinfo)
+{
+  jpegError = 0;
+
+  jpegDstManager.next_output_byte = (JOCTET *) jpegCompBuf;
+  jpegDstManager.free_in_buffer = (size_t) jpegCompBufSize;
+}
+
+int JpegEmptyOutputBuffer(j_compress_ptr cinfo)
+{
+  jpegError = 1;
+
+  jpegDstManager.next_output_byte = (JOCTET *) jpegCompBuf;
+  jpegDstManager.free_in_buffer = (size_t) jpegCompBufSize;
+
+  return 1;
+}
+
+void JpegTermDestination(j_compress_ptr cinfo)
+{
+  jpegDstDataLen = jpegCompBufSize - jpegDstManager.free_in_buffer;
+}
+
+void JpegSetDstManager(j_compress_ptr cinfo)
+{
+  jpegDstManager.init_destination = JpegInitDestination;
+  jpegDstManager.empty_output_buffer = JpegEmptyOutputBuffer;
+  jpegDstManager.term_destination = JpegTermDestination;
+
+  cinfo -&gt; dest = &jpegDstManager;
+}
+
diff --git a/nxcompext/Jpeg.h b/nxcompext/Jpeg.h
new file mode 100644
index 0000000..87740df
--- /dev/null
+++ b/nxcompext/Jpeg.h
@@ -0,0 +1,38 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Jpeg_H
+#define Jpeg_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+extern char *JpegCompressData(
+#if NeedFunctionPrototypes
+    XImage*                   /* image */,
+    int                       /* level */,
+    int*                      /* compressed_size */
+#endif
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Jpeg_H */
+
diff --git a/nxcompext/LICENSE b/nxcompext/LICENSE
new file mode 100644
index 0000000..12eb657
--- /dev/null
+++ b/nxcompext/LICENSE
@@ -0,0 +1,21 @@
+Copyright (c) 2001, 2009 NoMachine - <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>
+
+NXCOMPEXT library and NX extensions to X are copyright of NoMachine.
+Redistribution and use of this software is allowed according to the
+following terms:
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License Version 2, and
+not any other version, as published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTA-
+BILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, you can request a copy to NoMachine
+or write to the Free Software Foundation, Inc., 59 Temple Place,
+Suite 330, Boston, MA  02111-1307 USA
+
+All rights reserved.
diff --git a/nxcompext/Makefile.in b/nxcompext/Makefile.in
new file mode 100644
index 0000000..cdf0b1c
--- /dev/null
+++ b/nxcompext/Makefile.in
@@ -0,0 +1,162 @@
+############################################################################
+#                                                                          #
+#  Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com.">http://www.nomachine.com.</A>           #
+#                                                                          #
+#  NXCOMPEXT, NX protocol compression and NX extensions to this software   #
+#  are copyright of NoMachine. Redistribution and use of the present       #
+#  software is allowed according to terms specified in the file LICENSE    #
+#  which comes in the source distribution.                                 #
+#                                                                          #
+#  Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.        #
+#                                                                          #
+#  NX and NoMachine are trademarks of NoMachine S.r.l.                     #
+#                                                                          #
+#  All rights reserved.                                                    #
+#                                                                          #
+############################################################################
+
+#
+# Get values from configure script.
+#
+
+VERSION=@VERSION@
+LIBVERSION=@LIBVERSION@
+
+#
+# We want to enable really all warnings. -Wredundant-decls,
+# though, gives a warning caused by pthread.h and unistd.h.
+#
+
+CXX         = @CXX@
+CXXFLAGS    = @CXXFLAGS@ @X_CFLAGS@ @DEFS@ \
+              -Wall -Wpointer-arith -Wstrict-prototypes -Wmissing-prototypes \
+              -Wmissing-declarations -Wnested-externs
+CXXINCLUDES = -I. -I../nxcomp
+CXXDEFINES  =
+
+CC          = @CC@
+CCFLAGS     = @CFLAGS@ @X_CFLAGS@ @DEFS@ \
+              -Wall -Wpointer-arith -Wstrict-prototypes -Wmissing-prototypes \
+              -Wmissing-declarations -Wnested-externs
+CCINCLUDES  = -I. -I../nxcomp
+CCDEFINES   =
+
+LDFLAGS     = @LDFLAGS@ -L../nxcomp
+LIBS        = @LIBS@ -lz -lX11 -lXcomp
+
+#
+# Only if THREADS is defined
+#
+# LIBS = @LIBS@ -lz -ljpeg -lpthread -lX11 -lXcomp
+#
+
+srcdir      = @srcdir@
+prefix      = @prefix@
+exec_prefix = @exec_prefix@
+bindir      = @bindir@
+man1dir     = @mandir@/man1
+VPATH       = @srcdir@
+
+INSTALL         = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA    = @INSTALL_DATA@
+
+#
+# This should be autodetected.
+#
+
+MAKEDEPEND     = @MAKEDEPEND@
+DEPENDINCLUDES =  -I/usr/include/c++ -I/usr/include/g++ -I/usr/include/g++-3 
+
+.SUFFIXES: .cpp.c
+
+.cpp.o:
+	$(CXX) -c $(CXXFLAGS) $(CXXINCLUDES) $&lt;
+.c.o:
+	$(CC) -c $(CCFLAGS) $(CCINCLUDES) $&lt;
+
+LIBRARY = Xcompext
+
+LIBNAME    = lib$(LIBRARY)
+LIBFULL    = lib$(LIBRARY).so.$(VERSION)
+LIBLOAD    = lib$(LIBRARY).so.$(LIBVERSION)
+LIBSHARED  = lib$(LIBRARY).so
+LIBARCHIVE = lib$(LIBRARY).a
+
+LIBCYGSHARED  = cyg$(LIBRARY).dll
+LIBCYGARCHIVE = lib$(LIBRARY).dll.a
+
+all: depend @ALL@
+
+MSRC=
+
+CSRC=	NXlib.c		\
+	Clean.c		\
+	Mask.c		\
+	Colormap.c	\
+	Alpha.c		\
+	Jpeg.c		\
+	Pgn.c		\
+	Bitmap.c	\
+	Rgb.c		\
+	Rle.c		\
+        Z.c
+
+CXXSRC=
+
+MOBJ   = $(MSRC:.c=.o)
+COBJ   = $(CSRC:.c=.o)
+CXXOBJ = $(CXXSRC:.cpp=.o)
+
+$(LIBFULL):	 $(CXXOBJ) $(COBJ)
+		 $(CXX) -o $@ $(LDFLAGS) $(CXXOBJ) $(COBJ) $(LIBS)
+
+$(LIBLOAD):	 $(LIBFULL)
+		 rm -f $(LIBLOAD)
+		 ln -s $(LIBFULL) $(LIBLOAD)
+
+$(LIBSHARED):	 $(LIBFULL)
+		 rm -f $(LIBSHARED)
+		 ln -s $(LIBFULL) $(LIBSHARED)
+
+$(LIBARCHIVE):	 $(CXXOBJ) $(COBJ)
+		 rm -f  $(LIBARCHIVE)
+		 ar clq $(LIBARCHIVE) $(CXXOBJ) $(COBJ)
+		 ranlib $(LIBARCHIVE)
+
+$(LIBCYGSHARED): $(LIBARCHIVE)
+		 $(CC) -shared -o $(LIBCYGSHARED) \
+		 -Wl,--out-implib=$(LIBCYGARCHIVE) \
+		 -Wl,--export-all-symbols \
+		 -Wl,--enable-auto-import \
+		 -Wl,--whole-archive $(LIBARCHIVE) \
+		 -Wl,--no-whole-archive $(LIBS) \
+		 $(LDFLAGS)
+
+$(LIBCYGARCHIVE): $(LIBCYGSHARED)
+
+depends:	depend.status
+
+depend:		depend.status
+
+depend.status:	
+		if [ -x $(MAKEDEPEND) ] ; then \
+			$(MAKEDEPEND) $(CXXINCLUDES) $(CCINCLUDES) \
+                        $(DEPENDINCLUDES) -f Makefile $(MSRC) $(CSRC) \
+			$(CXXSRC) 2&gt;/dev/null; \
+		fi
+		touch depend.status
+
+install:	install.bin install.man
+
+install.bin:
+
+install.man:
+
+clean:
+		-rm -f *~ *.o *.bak *.orig *.rej st?????? core core.* *.out.* \
+		@ALL@
+
+distclean:	clean
+		-rm -rf autom4te.cache config.status config.log \
+		config.cache depend.status Makefile tags
diff --git a/nxcompext/Mask.c b/nxcompext/Mask.c
new file mode 100644
index 0000000..b04989d
--- /dev/null
+++ b/nxcompext/Mask.c
@@ -0,0 +1,794 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;stdio.h&gt;
+
+#include &quot;Xlib.h&quot;
+
+#include &quot;NXpack.h&quot;
+
+#include &quot;Mask.h&quot;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+/*
+ * Try first to reduce to a white or black
+ * pixel. If not possible, apply the mask.
+ * Note that correction is applied at the
+ * time pixel is unpacked.
+ */
+
+#define MaskPixel(red, green, blue, mask) \
+\
+if (red &gt; mask -&gt; white_threshold &amp;&amp; \
+        green &gt; mask -&gt; white_threshold &amp;&amp; \
+            blue &gt; mask -&gt; white_threshold) \
+{ \
+    red = green = blue = 0xff; \
+} \
+else if (red &lt; mask -&gt; black_threshold &amp;&amp; \
+             green &lt; mask -&gt; black_threshold &amp;&amp; \
+                 blue &lt; mask -&gt; black_threshold) \
+{ \
+    red = green = blue = 0x00; \
+} \
+else \
+{ \
+    red   = red   &amp; mask -&gt; color_mask; \
+    green = green &amp; mask -&gt; color_mask; \
+    blue  = blue  &amp; mask -&gt; color_mask; \
+}
+
+int MaskImage(const ColorMask *mask, XImage *src_image, XImage *dst_image)
+{
+  unsigned long pixel;
+
+  register unsigned int red;
+  register unsigned int green;
+  register unsigned int blue;
+
+  register unsigned long data_size;
+
+  register unsigned int i;
+
+  data_size = (src_image -&gt; bytes_per_line * src_image -&gt; height) &gt;&gt; 2;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******MaskImage: Going to mask image with [%d] bits per pixel.\n&quot;,
+              src_image -&gt; bits_per_pixel);
+  #endif
+
+  if (src_image -&gt; bits_per_pixel == 24 || src_image -&gt; bits_per_pixel == 32)
+  {
+    register unsigned char *pixel_addr;
+
+    for (i = 0; i &lt; data_size; i++)
+    {
+      pixel = ((unsigned long *) src_image -&gt; data)[i];
+
+      pixel_addr = (unsigned char *) &pixel;
+
+      red   = pixel_addr[2];
+      green = pixel_addr[1];
+      blue  = pixel_addr[0];
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskImage: 24/32 bits original R [%d] G [%d] B [%d] A [%d].\n&quot;,
+              red, green, blue, pixel_addr[3]);
+      #endif
+
+      MaskPixel(red, green, blue, mask);
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskImage: 24/32 bits masked R [%d] G [%d] B [%d] A [%d].\n&quot;,
+                  red, green, blue, pixel_addr[3]);
+      #endif
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskImage: 24/32 bits pixel 0x%lx&quot;, pixel);
+      #endif
+
+      pixel_addr[2] = red;
+      pixel_addr[1] = green;
+      pixel_addr[0] = blue;
+
+      ((unsigned long*)dst_image -&gt; data)[i] = pixel;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot; -&gt; 0x%lx\n&quot;, pixel);
+      #endif
+    }
+
+    return 1;
+  }
+  else if (src_image -&gt; bits_per_pixel == 16)
+  {
+    /* 
+     * FIXME: Masking doesn't work in 16 bpp.
+     *
+
+    unsigned long src_addr, *dst_addr;
+    unsigned short *src_pixels_addr, *dst_pixels_addr;
+
+    for (i = 0; i &lt; data_size; i++)
+    {
+      src_addr = ((unsigned long *)src_image -&gt; data)[i];
+      dst_addr = (unsigned long *)((unsigned long *)dst_image -&gt; data + i);
+
+      src_pixels_addr = ((unsigned short *) &amp;src_addr);
+      dst_pixels_addr = ((unsigned short *) dst_addr);
+
+      red   = (src_pixels_addr[0] &amp; src_image -&gt; red_mask)   &gt;&gt; 8;
+      green = (src_pixels_addr[0] &amp; src_image -&gt; green_mask) &gt;&gt; 3;
+      blue  = (src_pixels_addr[0] &amp; src_image -&gt; blue_mask)  &lt;&lt; 3;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskImage: 16 bits original R [%d] G [%d] B [%d].\n&quot;,
+              red, green, blue);
+      #endif
+
+      MaskPixel(red, green, blue, mask);
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskImage: 16 bits masked R [%d] G [%d] B [%d].\n&quot;,
+              red, green, blue);
+      #endif
+
+      dst_pixels_addr[0] = ((red &lt;&lt; 8)   &amp; src_image -&gt; red_mask)   |
+                           ((green &lt;&lt; 3) &amp; src_image -&gt; green_mask) |
+                           ((blue &gt;&gt; 3)  &amp; src_image -&gt; blue_mask);
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskImage: 16 bits pixel 0x%x&quot;, dst_pixels_addr[0]);
+      #endif
+
+      red   = (src_pixels_addr[1] &amp; src_image -&gt; red_mask)   &gt;&gt; 8;
+      green = (src_pixels_addr[1] &amp; src_image -&gt; green_mask) &gt;&gt; 3;
+      blue  = (src_pixels_addr[1] &amp; src_image -&gt; blue_mask)  &lt;&lt; 3;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskImage: 16 bits original R [%d] G [%d] B [%d].\n&quot;,
+              red, green, blue);
+      #endif
+
+      MaskPixel(red, green, blue, mask);
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskImage: 16 bits masked R [%d] G [%d] B [%d].\n&quot;,
+              red, green, blue);
+      #endif
+
+      dst_pixels_addr[1] = ((red &lt;&lt; 8)   &amp; src_image -&gt; red_mask)   |
+                           ((green &lt;&lt; 3) &amp; src_image -&gt; green_mask) |
+                           ((blue &gt;&gt; 3)  &amp; src_image -&gt; blue_mask);
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskImage: 16 bits pixel 0x%x&quot;, dst_pixels_addr[0]);
+      #endif
+    }
+
+    if (dst_image -&gt; width &amp; 0x00000001)
+    {
+      int card32_per_line;
+      int i;
+
+      card32_per_line = dst_image -&gt; bytes_per_line &gt;&gt; 2;
+
+      for (i = 0; i &lt; dst_image -&gt; height;)
+      {
+        ((CARD32 *) dst_image -&gt; data)[(++i * card32_per_line) - 1] &amp;= 0x0000ffff;
+      }
+    }
+
+    *
+    * End of FIXME.
+    */
+  }
+  else
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******MaskImage: PANIC! Cannot apply mask with [%d] bits per pixel.\n&quot;,
+                src_image -&gt; bits_per_pixel);
+    #endif
+
+    return 0;
+  }
+
+  return 1;
+}
+
+int MaskInPlaceImage(const ColorMask *mask, XImage *image)
+{
+  unsigned long pixel;
+
+  register unsigned int red;
+  register unsigned int green;
+  register unsigned int blue;
+
+  register unsigned int i;
+
+  register unsigned long data_size;
+
+  data_size = (image -&gt; bytes_per_line * image -&gt; height)&gt;&gt;2;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******MaskInPlaceImage: Going to mask image with [%d] bits per pixel.\n&quot;,
+              image -&gt; bits_per_pixel);
+  #endif
+
+  if (image -&gt; bits_per_pixel == 24 || image -&gt; bits_per_pixel == 32)
+  {
+    register unsigned char *pixel_addr;
+
+    for (i = 0; i &lt; data_size; i++)
+    {
+      pixel = ((unsigned long *) image -&gt; data)[i];
+
+      pixel_addr = (unsigned char *) &pixel;
+
+      red   = pixel_addr[2];
+      green = pixel_addr[1];
+      blue  = pixel_addr[0];
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskInPlaceImage: 24/32 bits original R [%d] G [%d] B [%d] A [%d].\n&quot;,
+                  red, green, blue, pixel_addr[3]);
+      #endif
+
+      MaskPixel(red, green, blue, mask);
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskInPlaceImage: 24/32 bits masked R [%d] G [%d] B [%d] A [%d].\n&quot;,
+                  red, green, blue, pixel_addr[3]);
+      #endif
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskInPlaceImage: 24/32 bits pixel 0x%lx&quot;, pixel);
+      #endif
+
+      pixel_addr[2] = red;
+      pixel_addr[1] = green;
+      pixel_addr[0] = blue;
+
+      ((unsigned long *) image -&gt; data)[i] = pixel;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot; -&gt; 0x%lx\n&quot;, pixel);
+      #endif
+    }
+
+    return 1;
+  }
+  else if (image -&gt; bits_per_pixel == 16)
+  {
+    /*
+     * FIXME: Mask doesn't still work for 16 bits.
+     *
+
+    unsigned long addr;
+    register unsigned short *pixels_addr;
+
+    for (i = 0; i &lt; data_size; i++)
+    {
+      addr = ((unsigned long *) image -&gt; data)[i];
+
+      pixels_addr = ((unsigned short *) &amp;addr);
+
+      red   = (pixels_addr[0] &amp; image -&gt; red_mask)   &gt;&gt; 8;
+      green = (pixels_addr[0] &amp; image -&gt; green_mask) &gt;&gt; 3;
+      blue  = (pixels_addr[0] &amp; image -&gt; blue_mask)  &lt;&lt; 3;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits original R [%d] G [%d] B [%d].\n&quot;,
+                  red, green, blue);
+      #endif
+
+      MaskPixel(red, green, blue, mask);
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits masked R [%d] G [%d] B [%d].\n&quot;,
+                  red, green, blue);
+      #endif
+
+      pixels_addr[0] = ((red &lt;&lt; 8)   &amp; image -&gt; red_mask) |
+                           ((green &lt;&lt; 3) &amp; image -&gt; green_mask) |
+                               ((blue &gt;&gt; 3)  &amp; image -&gt; blue_mask);
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits pixel 0x%x&quot;, pixels_addr[0]);
+      #endif
+
+      red   = (pixels_addr[1] &amp; image -&gt; red_mask)   &gt;&gt; 8;
+      green = (pixels_addr[1] &amp; image -&gt; green_mask) &gt;&gt; 3;
+      blue  = (pixels_addr[1] &amp; image -&gt; blue_mask)  &lt;&lt; 3;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits original R [%d] G [%d] B [%d].\n&quot;,
+                  red, green, blue);
+      #endif
+
+      MaskPixel(red, green, blue, mask);
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits masked R [%d] G [%d] B [%d].\n&quot;,
+                  red, green, blue);
+      #endif
+
+      pixels_addr[1] = ((red &lt;&lt; 8)   &amp; image -&gt; red_mask) |
+                           ((green &lt;&lt; 3) &amp; image -&gt; green_mask) |
+                               ((blue &gt;&gt; 3)  &amp; image -&gt; blue_mask);
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******MaskInPlaceImage: 16 bits pixel 0x%x&quot;, pixels_addr[1]);
+      #endif
+    }
+
+    if (image -&gt; width &amp; 0x00000001)
+    {
+      int card32_per_line;
+      int i;
+
+      card32_per_line = image -&gt; bytes_per_line &gt;&gt; 2;
+
+      for (i = 0; i &lt; image -&gt; height;)
+      {
+        ((CARD32 *) image -&gt; data)[(++i * card32_per_line) - 1] &amp;= 0x0000ffff;
+      }
+    }
+
+    *
+    * End of FIXME.
+    */
+  }
+  else
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******MaskImage: PANIC! Cannot apply mask with [%d] bits per pixel.\n&quot;,
+                image -&gt; bits_per_pixel);
+    #endif
+
+    return 0;
+  }
+
+  return 1;
+}
+
+static int Pack16To8(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
+{
+  unsigned short *src_pixel = (unsigned short *) src_image -&gt; data;
+  unsigned char  *dst_pixel = (unsigned char *)  dst_image -&gt; data;
+
+  #ifdef DEBUG
+  unsigned int counter = 0;
+  #endif
+
+  while (src_pixel &lt; ((unsigned short *) (src_image -&gt; data + src_data_size)))
+  {
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
+                counter, *src_pixel, (*src_pixel &amp; 0xc000) &gt;&gt; 8,
+                    ((*src_pixel &amp; 0x600) &gt;&gt; 3), (*src_pixel &amp; 0x18) &lt;&lt; 3);
+    #endif
+
+    if (*src_pixel == 0x0)
+    {
+      *dst_pixel = 0x0;
+    }
+    else if (*src_pixel == 0xffff)
+    {
+      *dst_pixel = 0xff;
+    }
+    else
+    {
+      *dst_pixel = ((*src_pixel &amp; 0xc000) &gt;&gt; 10) |
+                        ((*src_pixel &amp; 0x600) &gt;&gt; 7) |
+                             ((*src_pixel &amp; 0x18) &gt;&gt; 3);
+    }
+
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x].\n&quot;,
+                counter++, *dst_pixel);
+    #endif
+
+    src_pixel++;
+    dst_pixel++;
+  }
+
+  return 1;
+}
+
+static int Pack24To8(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
+{
+  unsigned char *src_pixel = (unsigned char *) src_image -&gt; data;
+  unsigned char *dst_pixel = (unsigned char *) dst_image -&gt; data;
+
+  int i;
+
+  unsigned int bytes_per_line = src_image -&gt; bytes_per_line;
+
+  unsigned char *end_of_line = (unsigned char *) (src_pixel + bytes_per_line);
+
+
+  #ifdef DEBUG
+  unsigned int counter = 0;
+  #endif
+
+  for (i = 0; i &lt; src_image -&gt; height; i++ )
+  {
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x%x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
+                counter, src_pixel[0], src_pixel[1], src_pixel[2], src_pixel[0] &amp; 0xc0,
+                    src_pixel[1] &amp; 0xc0, src_pixel[2] &amp; 0xc0);
+    #endif
+
+    while(src_pixel &lt; end_of_line - 2)
+    {
+      if (src_pixel[0] == 0x00 &amp;&amp;
+              src_pixel[1] == 0x00 &amp;&amp;
+                  src_pixel[2] == 0x00)
+      {
+        *dst_pixel = 0x0;
+      }
+      else if (src_pixel[0] == 0xff &amp;&amp;
+                   src_pixel[1] == 0xff &amp;&amp;
+                       src_pixel[2] == 0xff)
+      {
+        *dst_pixel = 0xff;
+      }
+      else
+      {
+        /*
+         * Pixel layout:
+         *
+         * 24 bit RRRRR000 GGGGG000 BBBBB000 -&gt; 8 bit 00RRGGBB
+         */
+
+        *dst_pixel = (src_pixel[0] &amp; 0xc0) &gt;&gt; 2 |
+                         ((src_pixel[1] &amp; 0xc0) &gt;&gt; 4) |
+                              ((src_pixel[2] &amp; 0xc0) &gt;&gt; 6);
+      }
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x].\n&quot;,
+                  counter++, *dst_pixel);
+      #endif
+
+      src_pixel += 3;
+      dst_pixel += 1;
+    }
+
+    src_pixel = end_of_line;
+    end_of_line += bytes_per_line;
+  }
+  
+  return 1;
+}
+
+static int Pack24To16(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
+{
+  unsigned char  *src_pixel = (unsigned char  *) src_image -&gt; data;
+  unsigned short *dst_pixel = (unsigned short *) dst_image -&gt; data;
+
+  int i;
+
+  unsigned int bytes_per_line = src_image -&gt; bytes_per_line;
+
+  unsigned char *end_of_line = (unsigned char *) (src_pixel + bytes_per_line);
+
+  #ifdef DEBUG
+  unsigned int counter = 0;
+  #endif
+
+  for (i = 0; i &lt; src_image -&gt; height; i++ )
+  {
+    while(src_pixel &lt; end_of_line - 2)
+    {
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x%x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
+                  counter, src_pixel[0], src_pixel[1], src_pixel[2], src_pixel[0] &amp; 0xf8,
+                      src_pixel[1] &amp; 0xf8, src_pixel[2] &amp; 0xf8);
+      #endif
+
+      if (src_pixel[0] == 0x00 &amp;&amp;
+              src_pixel[1] == 0x00 &amp;&amp;
+                  src_pixel[2] == 0x00)
+      {
+        *dst_pixel = 0x0;
+      }
+      else if (src_pixel[0] == 0xff &amp;&amp;
+                   src_pixel[1] == 0xff &amp;&amp;
+                       src_pixel[2] == 0xff)
+      {
+        *dst_pixel = 0xffff;
+      }
+      else
+      {
+        /*
+         * Pixel layout:
+         *
+         * 24 bit RRRRR000 GGGGG000 BBBBB000 -&gt; 16 bit 0RRRRRGG GGGBBBBB
+         */
+
+        *dst_pixel = ((src_pixel[0] &amp; 0xf8) &lt;&lt; 7) |
+                         ((src_pixel[1] &amp; 0xf8) &lt;&lt; 2) |
+                             ((src_pixel[2] &amp; 0xf8) &gt;&gt; 3);
+      }
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x].\n&quot;,
+                  counter++, *dst_pixel);
+      #endif
+
+      src_pixel += 3;
+      dst_pixel += 1;
+    }
+
+    src_pixel = end_of_line;
+    end_of_line += bytes_per_line;
+  }
+
+  return 1;
+}
+
+static int Pack32To8(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
+{
+  unsigned int  *src_pixel = (unsigned int  *) src_image -&gt; data;
+  unsigned char *dst_pixel = (unsigned char *) dst_image -&gt; data;
+
+  #ifdef DEBUG
+  unsigned int counter = 0;
+  #endif
+
+  while (src_pixel &lt; ((unsigned int  *) (src_image -&gt; data + src_data_size)))
+  {
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
+                counter, *src_pixel, (*src_pixel &amp; 0xc00000),
+                    (*src_pixel &amp; 0xc000), (*src_pixel &amp; 0xc0));
+    #endif
+
+    if (*src_pixel == 0x0)
+    {
+      *dst_pixel = 0x0;
+    }
+    else if (*src_pixel == 0xffffff)
+    {
+      *dst_pixel = 0xff;
+    }
+    else
+    {
+      *dst_pixel = ((*src_pixel &amp; 0xc00000) &gt;&gt; 18) |
+                        ((*src_pixel &amp; 0xc000) &gt;&gt; 12) |
+                             ((*src_pixel &amp; 0xc0) &gt;&gt; 6);
+    }
+
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x].\n&quot;,
+                counter++, *dst_pixel);
+    #endif
+
+    src_pixel++;
+    dst_pixel++;
+  }
+
+  return 1;
+}
+
+static int Pack32To16(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
+{
+  unsigned int   *src_pixel = (unsigned int  *)  src_image -&gt; data;
+  unsigned short *dst_pixel = (unsigned short *) dst_image -&gt; data;
+
+  #ifdef DEBUG
+  unsigned int counter = 0;
+  #endif
+
+  while (src_pixel &lt; ((unsigned int  *) (src_image -&gt; data + src_data_size)))
+  {
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
+                counter, *src_pixel, (*src_pixel &amp; 0xf80000),
+                    (*src_pixel &amp; 0xf800), (*src_pixel &amp; 0xf8));
+    #endif
+
+    if (*src_pixel == 0x0)
+    {
+      *dst_pixel = 0x0;
+    }
+    else if (*src_pixel == 0xffffff)
+    {
+      *dst_pixel = 0xffff;
+    }
+    else
+    {
+      *dst_pixel = ((*src_pixel &amp; 0xf80000) &gt;&gt; 9) |
+                        ((*src_pixel &amp; 0xf800) &gt;&gt; 6) |
+                             ((*src_pixel &amp; 0xf8) &gt;&gt; 3);
+    }
+
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x].\n&quot;,
+                counter++, *dst_pixel);
+    #endif
+
+    src_pixel++;
+    dst_pixel++;
+  }
+
+  return 1;
+}
+
+static int Pack32To24(unsigned int src_data_size, XImage *src_image, XImage *dst_image)
+{
+  unsigned int  *src_pixel = (unsigned int  *) src_image -&gt; data;
+  unsigned char *dst_pixel = (unsigned char *) dst_image -&gt; data;
+
+  #ifdef DEBUG
+  unsigned int counter = 0;
+  #endif
+
+  while (src_pixel &lt; ((unsigned int  *) (src_image -&gt; data + src_data_size)))
+  {
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******PackImage: Pixel [%d] value [0x%x] red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
+                counter, *src_pixel, ((*src_pixel &amp; 0xff0000) &gt;&gt; 16),
+                    ((*src_pixel &amp; 0x00ff00) &gt;&gt; 8), (*src_pixel &amp; 0xff));
+    #endif
+
+    if (*src_pixel == 0x0)
+    {
+      dst_pixel[0] = dst_pixel[1] = dst_pixel[2] = 0x0;
+    }
+    else if (*src_pixel == 0xffffff)
+    {
+      dst_pixel[0] = dst_pixel[1] = dst_pixel[2] = 0xff;
+    }
+    else
+    {
+      dst_pixel[0] = (*src_pixel &amp; 0xff0000) &gt;&gt; 16;
+      dst_pixel[1] = (*src_pixel &amp; 0x00ff00) &gt;&gt; 8;
+      dst_pixel[2] = (*src_pixel &amp; 0x0000ff);
+    }
+
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******PackImage: Pixel [%d] destination [0x%x], [0x%x], [0x%x].\n&quot;,
+                counter++, dst_pixel[0], dst_pixel[1], dst_pixel[2]);
+    #endif
+
+    src_pixel += 1;
+    dst_pixel += 3;
+  }
+
+  return 1;
+}
+
+int PackImage(unsigned int method, unsigned int src_data_size, XImage *src_image,
+                  unsigned int dst_data_size, XImage *dst_image)
+{
+  unsigned int src_bits_per_pixel;
+  unsigned int dst_bits_per_pixel;
+
+  src_bits_per_pixel = src_image -&gt; bits_per_pixel;
+  dst_bits_per_pixel = MethodBitsPerPixel(method);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******PackImage: Source bits per pixel [%d], destination bits per pixel [%d].\n&quot;,
+              src_bits_per_pixel, dst_bits_per_pixel);
+
+  fprintf(stderr, &quot;******PackImage: Source data size [%d], destination data size [%d].\n&quot;,
+              src_data_size, dst_data_size);
+  #endif
+
+  if (dst_bits_per_pixel &gt;= src_bits_per_pixel)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******PackImage: PANIC! Cannot pack image from [%d] to [%d] bytes per pixel.\n&quot;,
+                src_bits_per_pixel, dst_bits_per_pixel);
+    #endif
+
+    return 0;
+  }
+
+  switch (src_bits_per_pixel)
+  {
+    case 16:
+    {
+      switch (dst_bits_per_pixel)
+      {
+        case 8:
+        {
+          return Pack16To8(src_data_size, src_image, dst_image);
+        }
+        default:
+        {
+          return 0;
+        }
+      }
+    }
+    case 24:
+    {
+      switch (dst_bits_per_pixel)
+      {
+        case 8:
+        {
+          return Pack24To8(src_data_size, src_image, dst_image);
+        }
+        case 16:
+        {
+          return Pack24To16(src_data_size, src_image, dst_image);
+        }
+        default:
+        {
+          return 0;
+        }
+      }
+    }
+    case 32:
+    {
+      switch (dst_bits_per_pixel)
+      {
+        case 8:
+        {
+          return Pack32To8(src_data_size, src_image, dst_image);
+        }
+        case 16:
+        {
+          return Pack32To16(src_data_size, src_image, dst_image);
+        }
+        case 24:
+        {
+          return Pack32To24(src_data_size, src_image, dst_image);
+        }
+        default:
+        {
+          return 0;
+        }
+      }
+    }
+    default:
+    {
+      return 0;
+    }
+  }
+}
+
+/*
+ * Replace the ffs() call that may be not
+ * present on some systems.
+ */
+
+int FindLSB(int word)
+{
+  int t = word;
+
+  int m = 1;
+  int i = 0;
+
+  for (; i &lt; sizeof(word) &lt;&lt; 3; i++, m &lt;&lt;= 1)
+  {
+    if (t &amp; m)
+    {
+      return i + 1;
+    }
+  }
+
+  return 0;
+}
+
diff --git a/nxcompext/Mask.h b/nxcompext/Mask.h
new file mode 100644
index 0000000..5d6024f
--- /dev/null
+++ b/nxcompext/Mask.h
@@ -0,0 +1,40 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Mask_H
+#define Mask_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;Xlib.h&quot;
+
+extern int MaskImage(const ColorMask *mask, XImage *src_image, XImage *dst_image);
+
+extern int MaskInPlaceImage(const ColorMask *mask, XImage *image);
+
+extern int PackImage(unsigned int method, unsigned int src_data_size, XImage *src_image,
+                         unsigned int dst_data_size, XImage *dst_image);
+
+int FindLSB(int word);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Mask_H */
diff --git a/nxcompext/NXlib.c b/nxcompext/NXlib.c
new file mode 100644
index 0000000..452213b
--- /dev/null
+++ b/nxcompext/NXlib.c
@@ -0,0 +1,4770 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;sys/socket.h&gt;
+
+#ifndef __sun
+#include &lt;strings.h&gt;
+#endif
+
+#include &quot;NX.h&quot;
+
+#include &quot;dix.h&quot;
+#include &quot;os.h&quot;
+
+#define NEED_REPLIES
+
+/*
+ * Needed to enable definition of the callback
+ * functions.
+ */
+
+#define NX_TRANS_SOCKET
+
+#include &quot;Xlib.h&quot;
+#include &quot;Xutil.h&quot;
+#include &quot;Xlibint.h&quot;
+
+#include &quot;NXlib.h&quot;
+#include &quot;NXproto.h&quot;
+#include &quot;NXpack.h&quot;
+
+#include &quot;Clean.h&quot;
+#include &quot;Mask.h&quot;
+#include &quot;Colormap.h&quot;
+#include &quot;Alpha.h&quot;
+#include &quot;Bitmap.h&quot;
+#include &quot;Jpeg.h&quot;
+#include &quot;Pgn.h&quot;
+#include &quot;Rgb.h&quot;
+#include &quot;Rle.h&quot;
+#include &quot;Z.h&quot;
+
+#include &quot;MD5.h&quot;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+#undef  DUMP
+
+/*
+ * Maximum number of colors allowed in
+ * Png encoding.
+ */
+
+#define NB_COLOR_MAX          256
+
+/*
+ * Dummy error handlers used internally to catch
+ * Xlib failures in replies.
+ */
+
+static int _NXInternalReplyErrorFunction(Display *dpy, XErrorEvent *error);
+
+static void _NXInternalLostSequenceFunction(Display *dpy, unsigned long newseq,
+                                                unsigned long lastseq, unsigned int type);
+
+/*
+ * Resource ids that can be requested by
+ * the client for use in split or unpack
+ * operations.
+ */
+
+static unsigned char _NXSplitResources[NXNumberOfResources];
+static unsigned char _NXUnpackResources[NXNumberOfResources];
+
+static Display *_NXDisplayInitialized = NULL;
+
+/*
+ * Used in asynchronous handling of
+ * GetImage replies.
+ */
+
+typedef struct
+{
+  unsigned long  sequence;
+  unsigned int   resource;
+  unsigned long  mask;
+  int            format;
+  int            width;
+  int            height;
+  _XAsyncHandler *handler;
+  XImage         *image;
+} _NXCollectImageState;
+
+static _NXCollectImageState *_NXCollectedImages[NXNumberOfResources];
+
+/*
+ * Used in asynchronous handling of
+ * GetProperty replies.
+ */
+
+typedef struct
+{
+  unsigned long  sequence;
+  unsigned int   resource;
+  Window         window;
+  Atom           property;
+  Atom           type;
+  int            format;
+  unsigned long  items;
+  unsigned long  after;
+  _XAsyncHandler *handler;
+  char           *data;
+} _NXCollectPropertyState;
+
+static _NXCollectPropertyState *_NXCollectedProperties[NXNumberOfResources];
+
+/*
+ * Used in asynchronous handling of
+ * GrabPointer replies.
+ */
+
+typedef struct
+{
+  unsigned long  sequence;
+  unsigned int   resource;
+  int            status;
+  _XAsyncHandler *handler;
+} _NXCollectGrabPointerState;
+
+static _NXCollectGrabPointerState *_NXCollectedGrabPointers[NXNumberOfResources];
+
+/*
+ * Used in asynchronous handling of
+ * GetInputFocus replies.
+ */
+
+typedef struct
+{
+  unsigned long  sequence;
+  unsigned int   resource;
+  Window         focus;
+  int            revert_to;
+  _XAsyncHandler *handler;
+} _NXCollectInputFocusState;
+
+static _NXCollectInputFocusState *_NXCollectedInputFocuses[NXNumberOfResources];
+
+/*
+ * Used by functions handling cache of
+ * packed images.
+ */
+
+#define MD5_LENGTH            16
+
+typedef struct
+{
+  md5_byte_t   *md5;
+  XImage       *image;
+  unsigned int method;
+} _NXImageCacheEntry;
+
+int NXImageCacheSize = 0;
+int NXImageCacheHits = 0;
+int NXImageCacheOps  = 0;
+
+_NXImageCacheEntry *NXImageCache = NULL;
+
+#ifdef DUMP
+
+void _NXCacheDump(const char *label);
+
+void _NXDumpData(const unsigned char *buffer, unsigned int size);
+
+#endif
+
+/*
+ * From X11/PutImage.c.
+ *
+ * Cancel a GetReq operation, before doing
+ * _XSend or Data.
+ */
+
+#if (defined(__STDC__) &amp;&amp; !defined(UNIXCPP)) || defined(ANSICPP)
+#define UnGetReq(name)\
+    dpy-&gt;bufptr -= SIZEOF(x##name##Req);\
+    dpy-&gt;request--
+#else
+#define UnGetReq(name)\
+    dpy-&gt;bufptr -= SIZEOF(x/**/name/**/Req);\
+    dpy-&gt;request--
+#endif
+
+#if (defined(__STDC__) &amp;&amp; !defined(UNIXCPP)) || defined(ANSICPP)
+#define UnGetEmptyReq()\
+    dpy-&gt;bufptr -= 4;\
+    dpy-&gt;request--
+#else
+#define UnGetEmptyReq(name)\
+    dpy-&gt;bufptr -= 4;\
+    dpy-&gt;request--
+#endif
+
+/*
+ * From X11/ImUtil.c.
+ */
+
+extern int _XGetBitsPerPixel(Display *dpy, int depth);
+extern int _XGetScanlinePad(Display *dpy, int depth);
+
+#define ROUNDUP(nbytes, pad) (((nbytes) + ((pad) - 1)) &amp; \
+                                  ~(long)((pad) - 1))
+
+static unsigned int DepthOnes(unsigned long mask)
+{
+  register unsigned long y;
+
+  y = (mask &gt;&gt; 1) &amp;033333333333;
+  y = mask - y - ((y &gt;&gt;1) &amp; 033333333333);
+  return ((unsigned int) (((y + (y &gt;&gt; 3)) &amp;
+              030707070707) % 077));
+}
+
+#define CanMaskImage(image, mask) \
+\
+(image -&gt; format == ZPixmap &amp;&amp; mask != NULL &amp;&amp; \
+    (image -&gt; depth == 32 || image -&gt; depth == 24 || \
+        (image -&gt; depth == 16 &amp;&amp; (image -&gt; red_mask == 0xf800 &amp;&amp; \
+            image -&gt; green_mask == 0x7e0 &amp;&amp; image -&gt; blue_mask == 0x1f))))
+
+#define ShouldMaskImage(image, mask) (mask -&gt; color_mask != 0xff)
+
+/*
+ * Initialize and reset the internal structures.
+ */
+
+extern int _NXInternalInitResources(Display *dpy);
+extern int _NXInternalResetResources(Display *dpy);
+extern int _NXInternalInitEncoders(Display *dpy);
+extern int _NXInternalResetEncoders(Display *dpy);
+
+int NXInitDisplay(Display *dpy)
+{
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXInitDisplay: Called for display at [%p].\n&quot;, (void *) dpy);
+  #endif
+
+  if (_NXDisplayInitialized == NULL)
+  {
+    _NXInternalInitResources(dpy);
+
+    _NXInternalInitEncoders(dpy);
+
+    _NXDisplayInitialized = dpy;
+
+    return 1;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXInitDisplay: WARNING! Internal structures already initialized.\n&quot;);
+  #endif
+
+  return 0;
+}
+
+int NXResetDisplay(Display *dpy)
+{
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXResetDisplay: Called for display at [%p].\n&quot;, (void *) dpy);
+  #endif
+
+  if (_NXDisplayInitialized != NULL)
+  {
+    _NXInternalResetResources(dpy);
+
+    _NXInternalResetEncoders(dpy);
+
+    _NXDisplayInitialized = NULL;
+
+    return 1;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXResetDisplay: WARNING! Internal structures already reset.\n&quot;);
+  #endif
+
+  return 0;
+}
+
+int _NXInternalInitResources(Display *dpy)
+{
+  return _NXInternalResetResources(dpy);
+}
+
+int _NXInternalResetResources(Display *dpy)
+{
+  int i;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXInternalResetResources: Clearing all the internal structures.\n&quot;);
+  #endif
+
+  for (i = 0; i &lt; NXNumberOfResources; i++)
+  {
+    _NXSplitResources[i]  = 0;
+    _NXUnpackResources[i] = 0;
+
+    if (_NXCollectedImages[i] != NULL)
+    {
+      #ifdef TEST
+      fprintf(stderr, &quot;******_NXInternalResetResources: WARNING! Clearing collect image data &quot;
+                  &quot;for resource [%d].\n&quot;, i);
+      #endif
+
+      if (_NXCollectedImages[i] -&gt; handler != NULL)
+      {
+        DeqAsyncHandler(dpy, _NXCollectedImages[i] -&gt; handler);
+
+        Xfree(_NXCollectedImages[i] -&gt; handler);
+      }
+
+      if (_NXCollectedImages[i] -&gt; image != NULL)
+      {
+        XDestroyImage(_NXCollectedImages[i] -&gt; image);
+      }
+
+      Xfree(_NXCollectedImages[i]);
+
+      _NXCollectedImages[i] = NULL;
+    }
+
+    if (_NXCollectedProperties[i] != NULL)
+    {
+      #ifdef TEST
+      fprintf(stderr, &quot;******_NXInternalResetResources: WARNING! Clearing collect property data &quot;
+                  &quot;for resource [%d].\n&quot;, i);
+      #endif
+
+      if (_NXCollectedProperties[i] -&gt; handler != NULL)
+      {
+        DeqAsyncHandler(dpy, _NXCollectedProperties[i] -&gt; handler);
+
+        Xfree(_NXCollectedProperties[i] -&gt; handler);
+      }
+
+      if (_NXCollectedProperties[i] -&gt; data != NULL)
+      {
+        Xfree(_NXCollectedProperties[i] -&gt; data);
+      }
+
+      Xfree(_NXCollectedProperties[i]);
+
+      _NXCollectedProperties[i] = NULL;
+    }
+
+    if (_NXCollectedGrabPointers[i] != NULL)
+    {
+      #ifdef TEST
+      fprintf(stderr, &quot;******_NXInternalResetResources: WARNING! Clearing grab pointer data &quot;
+                  &quot;for resource [%d].\n&quot;, i);
+      #endif
+
+      if (_NXCollectedGrabPointers[i] -&gt; handler != NULL)
+      {
+        DeqAsyncHandler(dpy, _NXCollectedGrabPointers[i] -&gt; handler);
+
+        Xfree(_NXCollectedGrabPointers[i] -&gt; handler);
+      }
+
+      Xfree(_NXCollectedGrabPointers[i]);
+
+      _NXCollectedGrabPointers[i] = NULL;
+    }
+
+    if (_NXCollectedInputFocuses[i] != NULL)
+    {
+      #ifdef TEST
+      fprintf(stderr, &quot;******_NXInternalResetResources: WARNING! Clearing collect input focus data &quot;
+                  &quot;for resource [%d].\n&quot;, i);
+      #endif
+
+      if (_NXCollectedInputFocuses[i] -&gt; handler != NULL)
+      {
+        DeqAsyncHandler(dpy, _NXCollectedInputFocuses[i] -&gt; handler);
+
+        Xfree(_NXCollectedInputFocuses[i] -&gt; handler);
+      }
+
+      Xfree(_NXCollectedInputFocuses[i]);
+
+      _NXCollectedInputFocuses[i] = NULL;
+    }
+  }
+
+  return 1;
+}
+
+int _NXInternalInitEncoders(Display *dpy)
+{
+  ZInitEncoder();
+
+  return 1;
+}
+
+int _NXInternalResetEncoders(Display *dpy)
+{
+  ZResetEncoder();
+
+  return 1;
+}
+
+int NXSetDisplayPolicy(Display *dpy, int policy)
+{
+  if (policy == NXPolicyImmediate)
+  {
+    return NXTransPolicy(NX_FD_ANY, NX_POLICY_IMMEDIATE);
+  }
+  else
+  {
+    return NXTransPolicy(NX_FD_ANY, NX_POLICY_DEFERRED);
+  }
+}
+
+int NXSetDisplayBuffer(Display *dpy, int size)
+{
+  /*
+   * This is not multi-thread safe, so,
+   * if you have threads, be sure that
+   * they are stopped.
+   */
+
+  char *buffer;
+
+  XFlush(dpy);
+
+  if (dpy -&gt; bufmax - size == dpy -&gt; buffer)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXSetDisplayBuffer: Nothing to do with buffer size matching.\n&quot;);
+    #endif
+
+    return 1;
+  }
+  else if (dpy -&gt; bufptr != dpy -&gt; buffer)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXSetDisplayBuffer: PANIC! The display buffer is not empty.\n&quot;);
+    #endif
+
+    return -1;
+  }
+  else if ((buffer = Xcalloc(1, size)) == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXSetDisplayBuffer: PANIC! Can't allocate [%d] bytes for the buffer.\n&quot;,
+                size);
+    #endif
+
+    return -1;
+  }
+
+  if (dpy -&gt; buffer != NULL)
+  {
+    Xfree(dpy -&gt; buffer);
+  }
+
+  dpy -&gt; buffer = buffer;
+  dpy -&gt; bufptr = dpy -&gt; buffer;
+  dpy -&gt; bufmax = dpy -&gt; bufptr + size;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetDisplayBuffer: Set the display output buffer size to [%d].\n&quot;,
+              size);
+  #endif
+
+  return 1;
+}
+
+/*
+ * If set, the Popen() function in the X server
+ * wil remove the LD_LIBRARY_PATH variable from
+ * the environment before calling the execl()
+ * function on the child process.
+ */
+
+int NXUnsetLibraryPath(int value)
+{
+  int previous = _NXUnsetLibraryPath;
+
+  _NXUnsetLibraryPath = value;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXUnsetLibraryPath: Set the flag to [%d] with previous value [%d].\n&quot;,
+              value, previous);
+  #endif
+
+  return previous;
+}
+
+/*
+ * If set, the Xlib I/O error handler will simply
+ * return, instead of quitting the program. This
+ * leaves to the application the responsibility
+ * of checking the state of the XlibDisplayIOEr-
+ * ror flag.
+ */
+
+int NXHandleDisplayError(int value)
+{
+  int previous = _NXHandleDisplayError;
+
+  _NXHandleDisplayError = value;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXHandleDisplayError: Set the flag to [%d] with previous value [%d].\n&quot;,
+              value, previous);
+  #endif
+
+  return previous;
+}
+
+/*
+ * Shutdown the display descriptor and force Xlib
+ * to set the I/O error flag.
+ */
+
+Bool NXForceDisplayError(Display *dpy)
+{
+  if (dpy != NULL)
+  {
+    NXTransClose(dpy -&gt; fd);
+
+    if (!(dpy -&gt; flags &amp; XlibDisplayIOError))
+    {
+      shutdown(dpy -&gt; fd, SHUT_RDWR);
+
+      _XIOError(dpy);
+    }
+
+    return 1;
+  }
+
+  return 0;
+}
+
+/*
+ * Check if the display has become invalid. Similarly
+ * to the modified Xlib, we call the predicate funct-
+ * ion with the value of the XlibDisplayIOError flag
+ * only if the I/O error was not encountered already.
+ * The application can use this function to query the
+ * XlibDisplayIOError flag because Xlib doesn't expose
+ * the internals of the display structure to the appli-
+ * cation.
+ */
+
+int NXDisplayError(Display *dpy)
+{
+  if (dpy != NULL)
+  {
+    return (_XGetIOError(dpy) ||
+                (_NXDisplayErrorFunction != NULL &amp;&amp;
+                    (*_NXDisplayErrorFunction)(dpy, _XGetIOError(dpy))));
+  }
+
+  return 1;
+}
+
+/*
+ * Various queries related to the state of the
+ * display connection.
+ */
+
+int NXDisplayReadable(Display *dpy)
+{
+  int result;
+  int readable;
+
+  result = NXTransReadable(dpy -&gt; fd, &amp;readable);
+
+  if (result == 0)
+  {
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******NXDisplayReadable: Returning [%d] bytes readable from fd [%d].\n&quot;,
+                readable, dpy -&gt; fd);
+    #endif
+
+    return readable;
+  }
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******NXDisplayReadable: WARNING! Error detected on display fd [%d].\n&quot;,
+              dpy -&gt; fd);
+  #endif
+
+  return -1;
+}
+
+int NXDisplayFlushable(Display *dpy)
+{
+  #ifdef DEBUG
+
+  int flushable;
+
+  flushable = NXTransFlushable(dpy -&gt; fd) +
+                  (dpy -&gt; bufptr - dpy -&gt; buffer);
+
+  fprintf(stderr, &quot;******NXDisplayFlushable: Returning [%d+%d=%d] bytes flushable &quot;
+              &quot;to fd [%d].\n&quot;, (int) (dpy -&gt; bufptr - dpy -&gt; buffer),
+                  (int) (flushable - (dpy -&gt; bufptr - dpy -&gt; buffer)),
+                      flushable, dpy -&gt; fd);
+
+  return flushable;
+
+  #else
+
+  return NXTransFlushable(dpy -&gt; fd) + (dpy -&gt; bufptr - dpy -&gt; buffer);
+
+  #endif
+}
+
+int NXDisplayCongestion(Display *dpy)
+{
+  #ifdef DEBUG
+
+  int congestion = NXTransCongestion(dpy -&gt; fd);
+
+  fprintf(stderr, &quot;******NXDisplayCongestion: Returning [%d] as congestion level for fd [%d].\n&quot;,
+              congestion, dpy -&gt; fd);
+
+  return congestion;
+
+  #else
+
+  return NXTransCongestion(dpy -&gt; fd);
+
+  #endif
+}
+
+int NXFlushDisplay(Display *dpy, int what)
+{
+  if (!(dpy -&gt; flags &amp; XlibDisplayWriting) &amp;&amp;
+          dpy -&gt; bufptr - dpy -&gt; buffer &gt; 0)
+  {
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******NXFlushDisplay: Writing with [%d] bytes in the buffer.\n&quot;,
+            (int) (dpy -&gt; bufptr - dpy -&gt; buffer));
+    #endif
+
+    XFlush(dpy);
+  }
+
+  if (what == NXFlushBuffer)
+  {
+    return 0;
+  }
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******NXFlushDisplay: Flushing with [%d] bytes in the NX transport.\n&quot;,
+              NXDisplayFlushable(dpy));
+  #endif
+
+  return NXTransFlush(dpy -&gt; fd);
+}
+
+NXDisplayErrorPredicate NXSetDisplayErrorPredicate(NXDisplayErrorPredicate predicate)
+{
+  NXDisplayErrorPredicate previous = _NXDisplayErrorFunction;
+
+  _NXDisplayErrorFunction = predicate;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetDisplayErrorPredicate: Set the predicate to [%p] with previous value [%p].\n&quot;,
+              predicate, previous);
+  #endif
+
+  return previous;
+}
+
+NXDisplayBlockHandler NXSetDisplayBlockHandler(NXDisplayBlockHandler handler)
+{
+  NXDisplayBlockHandler previous = _NXDisplayBlockFunction;
+
+  _NXDisplayBlockFunction = handler;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetDisplayBlockHandler: Set the handler to [%p] with previous value [%p].\n&quot;,
+              handler, previous);
+  #endif
+
+  return previous;
+}
+
+NXDisplayWriteHandler NXSetDisplayWriteHandler(NXDisplayWriteHandler handler)
+{
+  NXDisplayWriteHandler previous = _NXDisplayWriteFunction;
+
+  _NXDisplayWriteFunction = handler;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetDisplayWriteHandler: Set the handler to [%p] with previous value [%p].\n&quot;,
+              handler, previous);
+  #endif
+
+  return previous;
+}
+
+NXDisplayFlushHandler NXSetDisplayFlushHandler(NXDisplayFlushHandler handler, Display *display)
+{
+  NXDisplayFlushHandler previous = _NXDisplayFlushFunction;
+
+  _NXDisplayFlushFunction = handler;
+
+  NXTransHandler(NX_FD_ANY, NX_HANDLER_FLUSH,
+                     (void (*)(void *, int)) handler, (void *) display);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetDisplayFlushHandler: Set the handler to [%p] with display [%p] &quot;
+              &quot;and previous value [%p].\n&quot;, handler, display, previous);
+  #endif
+
+  return previous;
+}
+
+NXDisplayStatisticsHandler NXSetDisplayStatisticsHandler(NXDisplayStatisticsHandler handler, char **buffer)
+{
+  NXDisplayStatisticsHandler previous = _NXDisplayStatisticsFunction;
+
+  _NXDisplayStatisticsFunction = handler;
+
+  /*
+   * Propagate the handler.
+   */
+
+  NXTransHandler(NX_FD_ANY, NX_HANDLER_STATISTICS,
+                     (void (*)(void *, int)) handler, (void *) buffer);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetDisplayStatisticsHandler: Set the handler to [%p] with buffer pointer [%p] &quot;
+              &quot;and previous value [%p].\n&quot;, handler, buffer, previous);
+  #endif
+
+  return previous;
+}
+
+NXLostSequenceHandler NXSetLostSequenceHandler(NXLostSequenceHandler handler)
+{
+  NXLostSequenceHandler previous = _NXLostSequenceFunction;
+
+  _NXLostSequenceFunction = handler;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetLostSequenceHandler: Set the handler to [%p] with previous value [%p].\n&quot;,
+              handler, previous);
+  #endif
+
+  return previous;
+}
+
+int _NXInternalReplyErrorFunction(Display *dpy, XErrorEvent *error)
+{
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXInternalReplyErrorFunction: Internal error handler called.\n&quot;);
+  #endif
+
+  return 0;
+}
+
+void _NXInternalLostSequenceFunction(Display *dpy, unsigned long newseq,
+                                         unsigned long lastseq, unsigned int type)
+{
+  #ifdef TEST
+
+  fprintf(stderr, &quot;******_NXInternalLostSequenceFunction: WARNING! Sequence lost with new &quot;
+              &quot;sequence %ld last request %ld.\n&quot;, newseq, dpy -&gt; request);
+
+  /*
+   * TODO: Reply or event info must be implemented.
+   *
+   * fprintf(stderr, &quot;******_NXInternalLostSequenceFunction: WARNING! Expected event or reply &quot;
+   *             &quot;was %ld with sequence %ld.\n&quot;, (long) rep -&gt; type, (long) rep -&gt; sequenceNumber);
+   */
+
+  fprintf(stderr, &quot;******_NXInternalLostSequenceFunction: WARNING! Last sequence read &quot;
+              &quot;was %ld display request is %ld.\n&quot;, lastseq &amp; 0xffff, dpy -&gt; request &amp; 0xffff);
+
+  #endif
+}
+
+Status NXGetControlParameters(Display *dpy, unsigned int *link_type, unsigned int *local_major,
+                                  unsigned int *local_minor, unsigned int *local_patch,
+                                      unsigned int *remote_major, unsigned int *remote_minor,
+                                          unsigned int *remote_patch, int *split_timeout, int *motion_timeout,
+                                              int *split_mode, int *split_size, unsigned int *pack_method,
+                                                  unsigned int *pack_quality, int *data_level, int *stream_level,
+                                                      int *delta_level, unsigned int *load_cache,
+                                                          unsigned int *save_cache, unsigned int *startup_cache)
+{
+  xNXGetControlParametersReply rep;
+
+  register xReq *req;
+
+  LockDisplay(dpy);
+
+  GetEmptyReq(NXGetControlParameters, req);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXGetControlParameters: Sending message opcode [%d].\n&quot;,
+              X_NXGetControlParameters);
+  #endif
+
+  if (_XReply(dpy, (xReply *) &amp;rep, 0, xTrue) == xFalse)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXGetControlParameters: Error receiving reply.\n&quot;);
+    #endif
+
+    UnlockDisplay(dpy);
+
+    SyncHandle();
+
+    return 0;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXGetControlParameters: Got reply with link type [%u].\n&quot;, rep.linkType);
+
+  fprintf(stderr, &quot;******NXGetControlParameters: Local protocol major [%u] minor [%u] patch [%u].\n&quot;,
+              rep.localMajor, rep.localMinor, rep.localPatch);
+
+  fprintf(stderr, &quot;******NXGetControlParameters: Remote protocol major [%u] minor [%u] patch [%u].\n&quot;,
+              rep.remoteMajor, rep.remoteMinor, rep.remotePatch);
+
+  fprintf(stderr, &quot;******NXGetControlParameters: Split timeout [%d] motion timeout [%d].\n&quot;,
+              (int) rep.splitTimeout, (int) rep.motionTimeout);
+
+  fprintf(stderr, &quot;******NXGetControlParameters: Split mode [%d] split size [%d].\n&quot;,
+              (int) rep.splitMode, (int) rep.splitSize);
+
+  fprintf(stderr, &quot;******NXGetControlParameters: Preferred pack method [%d] pack quality [%d].\n&quot;,
+              (int) rep.packMethod, (int) rep.packQuality);
+
+  fprintf(stderr, &quot;******NXGetControlParameters: Data level [%d] stream level [%d] delta level [%d].\n&quot;,
+              rep.dataLevel, rep.streamLevel, rep.deltaLevel);
+  #endif
+
+  *link_type = rep.linkType;
+
+  *local_major = rep.localMajor;
+  *local_minor = rep.localMinor;
+  *local_patch = rep.localPatch;
+
+  *remote_major = rep.remoteMajor;
+  *remote_minor = rep.remoteMinor;
+  *remote_patch = rep.remotePatch;
+
+  *split_timeout  = rep.splitTimeout;
+  *motion_timeout = rep.motionTimeout;
+
+  *split_mode = rep.splitMode;
+  *split_size = rep.splitSize;
+
+  *pack_method  = rep.packMethod;
+  *pack_quality = rep.packQuality;
+
+  *data_level   = rep.dataLevel;
+  *stream_level = rep.streamLevel;
+  *delta_level  = rep.deltaLevel;
+
+  *load_cache    = rep.loadCache;
+  *save_cache    = rep.saveCache;
+  *startup_cache = rep.startupCache;
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  /*
+   * Install our internal out-of-sync handler.
+   */
+
+  _NXLostSequenceFunction = _NXInternalLostSequenceFunction;
+
+  return 1;
+}
+
+/*
+ * Which unpack methods are supported by the
+ * remote proxy?
+ */
+
+Status NXGetUnpackParameters(Display *dpy, unsigned int *entries, unsigned char supported_methods[])
+{
+  register xNXGetUnpackParametersReq *req;
+
+  xNXGetUnpackParametersReply rep;
+
+  register unsigned n;
+
+  #ifdef TEST
+  register unsigned i;
+  #endif
+
+  if (*entries &lt; NXNumberOfPackMethods)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXGetUnpackParameters: Requested only [%d] entries while they should be [%d].\n&quot;,
+                *entries, NXNumberOfPackMethods);
+    #endif
+
+    return 0;
+  }
+
+  LockDisplay(dpy);
+
+  GetReq(NXGetUnpackParameters, req);
+
+  req -&gt; entries = *entries;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXGetUnpackParameters: Sending message opcode [%d] with [%d] requested entries.\n&quot;,
+              X_NXGetUnpackParameters, *entries);
+  #endif
+
+  if (_XReply(dpy, (xReply *) &amp;rep, 0, xFalse) == xFalse || rep.length == 0)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXGetUnpackParameters: Error receiving reply.\n&quot;);
+    #endif
+
+    UnlockDisplay(dpy);
+
+    SyncHandle();
+
+    return 0;
+  }
+
+  if ((n = rep.length &lt;&lt; 2) &gt; *entries)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXGetUnpackParameters: Got [%d] bytes of reply data while they should be [%d].\n&quot;,
+                n, *entries);
+    #endif
+
+    _XEatData(dpy, (unsigned long) n);
+
+    UnlockDisplay(dpy);
+
+    SyncHandle();
+
+    return 0;
+  }
+
+  *entries = n;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXGetUnpackParameters: Reading [%d] bytes of reply data.\n&quot;, n);
+  #endif
+
+  _XReadPad(dpy, (char *) supported_methods, n);
+
+  #ifdef TEST
+
+  fprintf(stderr, &quot;******NXGetUnpackParameters: Got reply with methods: &quot;);
+
+  for (i = 0; i &lt; n; i++)
+  {
+    if (supported_methods[i] != 0)
+    {
+      fprintf(stderr, &quot;[%d]&quot;, i);
+    }
+  }
+  
+  fprintf(stderr, &quot;.\n&quot;);
+
+  #endif
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+/*
+ * Query and enable the MIT-SHM support between the
+ * proxy and the X server. The 'enable' flags must be
+ * true if shared memory PutImages and PutPackedImages
+ * are desired. On return the flags will say if support
+ * has been successfully enabled.
+ *
+ * Note that the the client part is not useful and not
+ * implemented. The size of the segment is chosen by
+ * the proxy. The main purpose of the message is to
+ * reserve the XID that will be used by the remote.
+ */
+
+Status NXGetShmemParameters(Display *dpy, unsigned int *enable_client,
+                                unsigned int *enable_server, unsigned int *client_segment,
+                                    unsigned int *server_segment, unsigned int *client_size,
+                                        unsigned int *server_size)
+{
+  register xNXGetShmemParametersReq *req;
+
+  register int stage;
+
+  xNXGetShmemParametersReply rep;
+
+  /*
+   * Save the previous handler.
+   */
+
+  int (*handler)(Display *, XErrorEvent *) = _XErrorFunction;
+
+  *client_segment = 0;
+  *server_segment = 0;
+
+  if (*enable_client)
+  {
+    *client_segment = XAllocID(dpy);
+  }
+
+  if (*enable_server)
+  {
+    *server_segment = XAllocID(dpy);
+  }
+
+  LockDisplay(dpy);
+
+  _XErrorFunction = _NXInternalReplyErrorFunction;
+
+  for (stage = 0; stage &lt; 3; stage++)
+  {
+    GetReq(NXGetShmemParameters, req);
+
+    req -&gt; stage = stage;
+
+    req -&gt; enableClient = (*enable_client != 0 ? 1 : 0);
+    req -&gt; enableServer = (*enable_server != 0 ? 1 : 0);
+
+    req -&gt; clientSegment = *client_segment;
+    req -&gt; serverSegment = *server_segment;
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXGetShmemParameters: Sending message opcode [%d] at stage [%d].\n&quot;,
+                X_NXGetShmemParameters, stage);
+    #endif
+
+    #ifdef TEST
+
+    if (stage == 0)
+    {
+      fprintf(stderr, &quot;******NXGetShmemParameters: Enable client is [%u] enable server is [%u].\n&quot;,
+                  *enable_client, *enable_server);
+
+      fprintf(stderr, &quot;******NXGetShmemParameters: Client segment is [%u] server segment is [%u].\n&quot;,
+                  *client_segment, *server_segment);
+    }
+
+    #endif
+
+    /*
+     * There isn't X server reply in the second stage.
+     * The procedure followed at X server side is:
+     *
+     * Stage 0: Send X_QueryExtension and masquerade
+     *          the reply.
+     *
+     * Stage 1: Allocate the shared memory and send
+     *          X_ShmAttach to the X server.
+     *
+     * Stage 2: Send X_GetInputFocus and masquerade
+     *          the reply.
+     *
+     * The last message is used to force a reply and
+     * collect any X error caused by a failure in the
+     * shared memory initialization.
+     */
+
+    if (stage != 1)
+    {
+      /*
+       * We are only interested in the final reply.
+       */
+
+      if (_XReply(dpy, (xReply *) &amp;rep, 0, xTrue) == xFalse)
+      {
+        #ifdef TEST
+        fprintf(stderr, &quot;******NXGetShmemParameters: Error receiving reply.\n&quot;);
+        #endif
+
+        _XErrorFunction = handler;
+
+        UnlockDisplay(dpy);
+
+        SyncHandle();
+
+        return 0;
+      }
+    }
+  }
+
+  /*
+   * Return the settings to client.
+   */
+
+  *enable_client = rep.clientEnabled;
+  *enable_server = rep.serverEnabled;
+
+  *client_size = rep.clientSize;
+  *server_size = rep.serverSize;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXGetShmemParameters: Got final reply with enabled client [%u] and server [%u].\n&quot;,
+              *enable_client, *enable_server);
+
+  fprintf(stderr, &quot;******NXGetShmemParameters: Client segment size [%u] server segment size [%u].\n&quot;,
+              *client_size, *server_size);
+  #endif
+
+  _XErrorFunction = handler;
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+/*
+ * Get the path to the font server that can be used by the X
+ * server to tunnel the font connections across the NX link.
+ * The path actually represents the TCP port where the proxy
+ * on the NX client side is listening. The agent can tempora-
+ * rily enable the tunneling when it needs a font that is not
+ * available on the client, for example when the session is
+ * migrated from a different X server.
+ *
+ * Note that it is not advisable to use the font server chan-
+ * nel for other purposes than restoring a font that is found
+ * missing at the time the session is migrated to a different
+ * display. This is because the agent implements a caching of
+ * the list of fonts supported by the client as it needs to
+ * advertise only the fonts that can be opened at both sides.
+ */
+
+Status NXGetFontParameters(Display *dpy, unsigned int path_length, char path_data[])
+{
+  register xNXGetFontParametersReq *req;
+
+  xNXGetFontParametersReply rep;
+
+  register unsigned n;
+
+  #ifdef TEST
+  register unsigned i;
+  #endif
+
+  if (path_length &lt; 1)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXGetFontParameters: No room to store the reply.\n&quot;);
+    #endif
+
+    return 0;
+  }
+
+  *path_data = '\0';
+
+  LockDisplay(dpy);
+
+  GetReq(NXGetFontParameters, req);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXGetFontParameters: Sending message opcode [%d].\n&quot;,
+              X_NXGetFontParameters);
+  #endif
+
+  if (_XReply(dpy, (xReply *) &amp;rep, 0, xFalse) == xFalse || rep.length == 0)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXGetFontParameters: Error receiving reply.\n&quot;);
+    #endif
+
+    UnlockDisplay(dpy);
+
+    SyncHandle();
+
+    return 0;
+  }
+
+  if ((n = rep.length &lt;&lt; 2) &gt; path_length)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXGetFontParameters: Got [%d] bytes of reply data with only room for [%d].\n&quot;,
+                n, path_length);
+    #endif
+
+    _XEatData(dpy, (unsigned long) n);
+
+    UnlockDisplay(dpy);
+
+    SyncHandle();
+
+    return 0;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXGetFontParameters: Reading [%d] bytes of reply data.\n&quot;, n);
+  #endif
+
+  _XReadPad(dpy, (char *) path_data, n);
+
+  /*
+   * Check if the string can be fully
+   * contained by the buffer.
+   */
+
+  if (*path_data &gt; path_length - 1)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXGetFontParameters: Inconsistent length in the returned string.\n&quot;);
+    #endif
+
+    UnlockDisplay(dpy);
+
+    SyncHandle();
+
+    return 0;
+  }
+
+  #ifdef TEST
+
+  fprintf(stderr, &quot;******NXGetFontParameters: Got font path of [%d] bytes and value [&quot;,
+              (int) *path_data);
+
+  for (i = 0; i &lt; *path_data; i++)
+  {
+    fprintf(stderr, &quot;%c&quot;, *(path_data + i + 1));
+  }
+  
+  fprintf(stderr, &quot;].\n&quot;);
+
+  #endif
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+unsigned int NXAllocSplit(Display *dpy, unsigned int resource)
+{
+  if (resource == NXAnyResource)
+  {
+    for (resource = 0; resource &lt; NXNumberOfResources; resource++)
+    {
+      if (_NXSplitResources[resource] == 0)
+      {
+        _NXSplitResources[resource] = 1;
+
+        #ifdef TEST
+        fprintf(stderr, &quot;******NXAllocSplit: Reserved resource [%u].\n&quot;,
+                    resource);
+        #endif
+    
+        return resource;
+      }
+    }
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXAllocSplit: WARNING! Resource limit exausted.\n&quot;);
+    #endif
+
+    return NXNoResource;
+  }
+  else if (resource &gt;= 0 &amp;&amp; resource &lt; NXNumberOfResources)
+  {
+    #ifdef TEST
+
+    if (_NXSplitResources[resource] == 0)
+    {
+      fprintf(stderr, &quot;******NXAllocSplit: Reserved requested resource [%u].\n&quot;,
+                  resource);
+    }
+    else
+    {
+      fprintf(stderr, &quot;******NXAllocSplit: Requested resource [%u] already reserved.\n&quot;,
+                  resource);
+    }
+
+    #endif
+    
+    _NXSplitResources[resource] = 1;
+  }
+
+  #ifdef PANIC
+  fprintf(stderr, &quot;******NXAllocSplit: PANIC! Can't reserve requested resource [%u].\n&quot;,
+              resource);
+  #endif
+
+  return NXNoResource;
+}
+
+/*
+ * Tell the proxy to split the next messages.
+ */
+
+int NXStartSplit(Display *dpy, unsigned int resource, unsigned int mode)
+{
+  register xNXStartSplitReq *req;
+
+  LockDisplay(dpy);
+
+  GetReq(NXStartSplit, req);
+
+  req -&gt; resource = resource;
+  req -&gt; mode     = mode;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXStartSplit: Sending opcode [%d] with resource [%d] mode [%d].\n&quot;,
+              X_NXStartSplit, resource, mode);
+  #endif
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+/*
+ * Send the closure of the split sequence and
+ * tell the proxy to send the results.
+ */
+
+int NXEndSplit(Display *dpy, unsigned int resource)
+{
+  register xNXEndSplitReq *req;
+
+  LockDisplay(dpy);
+
+  GetReq(NXEndSplit, req);
+
+  req -&gt; resource = resource;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXEndSplit: Sending opcode [%d] with resource [%d].\n&quot;,
+              X_NXStartSplit, resource);
+  #endif
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+/*
+ * This message must be sent whenever the proxy notifies
+ * the client of the completion of a split. If the 'pro-
+ * pagate' field is 0, the proxy will not send the ori-
+ * ginal request to the X server, but will only free the
+ * internal state.
+ */
+
+int NXCommitSplit(Display *dpy, unsigned int resource, unsigned int propagate,
+                      unsigned char request, unsigned int position)
+{
+  register xNXCommitSplitReq *req;
+
+  LockDisplay(dpy);
+
+  GetReq(NXCommitSplit, req);
+
+  req -&gt; resource  = resource;
+  req -&gt; propagate = propagate;
+  req -&gt; request   = request;
+  req -&gt; position  = position;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXCommitSplit: Sending opcode [%d] with resource [%d] propagate [%d] &quot;
+              &quot;request [%d] position [%d].\n&quot;, X_NXCommitSplit, resource,
+                  propagate, request, position);
+  #endif
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+int NXAbortSplit(Display *dpy, unsigned int resource)
+{
+  register xNXAbortSplitReq *req;
+
+  LockDisplay(dpy);
+
+  GetReq(NXAbortSplit, req);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXAbortSplit: Sending message opcode [%d] with resource [%u].\n&quot;,
+              X_NXAbortSplit, resource);
+  #endif
+
+  req -&gt; resource = resource;
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+int NXFinishSplit(Display *dpy, unsigned int resource)
+{
+  register xNXFinishSplitReq *req;
+
+  LockDisplay(dpy);
+
+  GetReq(NXFinishSplit, req);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXFinishSplit: Sending message opcode [%d] with resource [%u].\n&quot;,
+              X_NXFinishSplit, resource);
+  #endif
+
+  req -&gt; resource = resource;
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+int NXFreeSplit(Display *dpy, unsigned int resource)
+{
+  register xNXFreeSplitReq *req;
+
+  if (_NXSplitResources[resource] != 0)
+  {
+    LockDisplay(dpy);
+
+    GetReq(NXFreeSplit, req);
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXFreeSplit: Sending message opcode [%d] with resource [%u].\n&quot;,
+                X_NXFreeSplit, resource);
+    #endif
+
+    req -&gt; resource = resource;
+
+    UnlockDisplay(dpy);
+
+    SyncHandle();
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXFreeSplit: Making the resource [%u] newly available.\n&quot;,
+                resource);
+    #endif
+
+    _NXSplitResources[resource] = 0;
+  }
+  #ifdef TEST
+  else
+  {
+    fprintf(stderr, &quot;******NXFreeSplit: Nothing to do for resource [%u].\n&quot;,
+                resource);
+  }
+  #endif
+
+  return 1;
+}
+
+/*
+ * Tell to remote proxy to discard expose events
+ * of one or more types.
+ */
+
+int NXSetExposeParameters(Display *dpy, int expose, int graphics_expose, int no_expose)
+{
+  register xNXSetExposeParametersReq *req;
+
+  LockDisplay(dpy);
+
+  GetReq(NXSetExposeParameters, req);
+
+  req -&gt; expose         = expose;
+  req -&gt; graphicsExpose = graphics_expose;
+  req -&gt; noExpose       = no_expose;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetExposeParameters: Sending message opcode [%d] with flags [%d][%d][%d].\n&quot;,
+              X_NXSetExposeParameters, req -&gt; expose, req -&gt; graphicsExpose, req -&gt; noExpose);
+  #endif
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+/*
+ * Tell to the local proxy how to handle the next requests.
+ */
+
+int NXSetCacheParameters(Display *dpy, int enable_cache, int enable_split,
+                             int enable_save, int enable_load)
+{
+  register xNXSetCacheParametersReq *req;
+
+  LockDisplay(dpy);
+
+  GetReq(NXSetCacheParameters, req);
+
+  req -&gt; enableCache = enable_cache;
+  req -&gt; enableSplit = enable_split;
+  req -&gt; enableSave  = enable_save;
+  req -&gt; enableLoad  = enable_load;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetCacheParameters: Sending message opcode [%d] with &quot;
+              &quot;flags [%d][%d][%d][%d].\n&quot;, X_NXSetCacheParameters, req -&gt; enableCache,
+                  req -&gt; enableSplit, req -&gt; enableSave, req -&gt; enableLoad);
+  #endif
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+unsigned int NXAllocUnpack(Display *dpy, unsigned int resource)
+{
+  if (resource == NXAnyResource)
+  {
+    for (resource = 0; resource &lt; NXNumberOfResources; resource++)
+    {
+      if (_NXUnpackResources[resource] == 0)
+      {
+        _NXUnpackResources[resource] = 1;
+
+        #ifdef TEST
+        fprintf(stderr, &quot;******NXAllocUnpack: Reserved resource [%u].\n&quot;,
+                    resource);
+        #endif
+    
+        return resource;
+      }
+    }
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXAllocUnpack: WARNING! Resource limit exausted.\n&quot;);
+    #endif
+
+    return NXNoResource;
+  }
+  else if (resource &gt;= 0 &amp;&amp; resource &lt; NXNumberOfResources)
+  {
+    #ifdef TEST
+
+    if (_NXUnpackResources[resource] == 0)
+    {
+      fprintf(stderr, &quot;******NXAllocUnpack: Reserved requested resource [%u].\n&quot;,
+                  resource);
+    }
+    else
+    {
+      fprintf(stderr, &quot;******NXAllocUnpack: Requested resource [%u] already reserved.\n&quot;,
+                  resource);
+    }
+
+    #endif
+    
+    _NXUnpackResources[resource] = 1;
+  }
+
+  #ifdef PANIC
+  fprintf(stderr, &quot;******NXAllocUnpack: PANIC! Can't reserve requested resource [%u].\n&quot;,
+              resource);
+  #endif
+
+  return NXNoResource;
+}
+
+int NXSetUnpackGeometry(Display *dpy, unsigned int resource, Visual *visual)
+{
+  register xNXSetUnpackGeometryReq *req;
+
+  LockDisplay(dpy);
+
+  GetReq(NXSetUnpackGeometry, req);
+
+  req -&gt; resource = resource;
+
+  req -&gt; depth1Bpp  = _XGetBitsPerPixel(dpy, 1);
+  req -&gt; depth4Bpp  = _XGetBitsPerPixel(dpy, 4);
+  req -&gt; depth8Bpp  = _XGetBitsPerPixel(dpy, 8);
+  req -&gt; depth16Bpp = _XGetBitsPerPixel(dpy, 16);
+  req -&gt; depth24Bpp = _XGetBitsPerPixel(dpy, 24);
+  req -&gt; depth32Bpp = _XGetBitsPerPixel(dpy, 32);
+
+  if (visual != NULL)
+  {
+    req -&gt; redMask   = visual -&gt; red_mask;
+    req -&gt; greenMask = visual -&gt; green_mask;
+    req -&gt; blueMask  = visual -&gt; blue_mask;
+  }
+  else
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXSetUnpackGeometry: PANIC! Can't set the geometry without a visual.\n&quot;);
+    #endif
+
+    UnGetReq(NXSetUnpackGeometry);
+
+    UnlockDisplay(dpy);
+
+    return -1;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetUnpackGeometry: Resource [%u] Depth/Bpp [1/%d][4/%d][8/%d]&quot;
+              &quot;[16/%d][24/%d][32/%d].\n&quot;, resource, req -&gt; depth1Bpp, req -&gt; depth4Bpp,
+                  req -&gt; depth8Bpp, req -&gt; depth16Bpp, req -&gt; depth24Bpp, req -&gt; depth32Bpp);
+
+  fprintf(stderr, &quot;******NXSetUnpackGeometry: red [0x%x] green [0x%x] blue [0x%x].\n&quot;,
+               (unsigned) req -&gt; redMask, (unsigned) req -&gt; greenMask, (unsigned) req -&gt; blueMask);
+  #endif
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+/*
+ * Store a colormap table on the remote side.
+ * The colormap can then be used to unpack
+ * an image.
+ */
+
+int NXSetUnpackColormap(Display *dpy, unsigned int resource, unsigned int method,
+                            unsigned int entries, const char *data, unsigned int data_length)
+{
+  register xNXSetUnpackColormapReq *req;
+
+  register int dst_data_length;
+
+  LockDisplay(dpy);
+
+  GetReq(NXSetUnpackColormap, req);
+
+  req -&gt; resource  = resource;
+  req -&gt; method    = method;
+
+  req -&gt; srcLength = data_length;
+  req -&gt; dstLength = entries &lt;&lt; 2;
+
+  dst_data_length = ROUNDUP(data_length, 4);
+
+  req -&gt; length += (dst_data_length &gt;&gt; 2);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetUnpackColormap: Resource [%u] data size [%u] destination &quot;
+              &quot;data size [%u].\n&quot;, resource, data_length, dst_data_length);
+  #endif
+
+  if (data_length &gt; 0)
+  {
+    if (dpy -&gt; bufptr + dst_data_length &lt;= dpy -&gt; bufmax)
+    {
+      /*
+       * Clean the padding bytes in the request.
+       */
+
+      *((int *) (dpy -&gt; bufptr + dst_data_length - 4)) = 0x0;
+
+      memcpy(dpy -&gt; bufptr, data, data_length);
+
+      dpy -&gt; bufptr += dst_data_length;
+    }
+    else
+    {
+      /*
+       * The _XSend() will pad the request for us.
+       */
+
+      _XSend(dpy, data, data_length);
+    }
+  }
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+/*
+ * Store data of the alpha blending channel
+ * that will be combined with the next image
+ * to be unpacked.
+ */
+
+int NXSetUnpackAlpha(Display *dpy, unsigned int resource, unsigned int method,
+                         unsigned int entries, const char *data, unsigned int data_length)
+{
+  register xNXSetUnpackAlphaReq *req;
+
+  register unsigned int dst_data_length;
+
+  LockDisplay(dpy);
+
+  GetReq(NXSetUnpackAlpha, req);
+
+  req -&gt; resource  = resource;
+  req -&gt; method    = method;
+
+  req -&gt; srcLength = data_length;
+  req -&gt; dstLength = entries;
+
+  dst_data_length = ROUNDUP(data_length, 4);
+
+  req -&gt; length += (dst_data_length &gt;&gt; 2);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetUnpackAlpha: Resource [%u] data size [%u] destination data size [%u].\n&quot;,
+              resource, data_length, dst_data_length);
+  #endif
+
+  if (data_length &gt; 0)
+  {
+    if (dpy -&gt; bufptr + dst_data_length &lt;= dpy -&gt; bufmax)
+    {
+      /*
+       * Clean the padding bytes in the request.
+       */
+
+      *((int *) (dpy -&gt; bufptr + dst_data_length - 4)) = 0x0;
+
+      memcpy(dpy -&gt; bufptr, data, data_length);
+
+      dpy -&gt; bufptr += dst_data_length;
+    }
+    else
+    {
+      /*
+       * The _XSend() will pad the request for us.
+       */
+
+      _XSend(dpy, data, data_length);
+    }
+  }
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+/*
+ * Compatibility versions to be used when
+ * connected to a 1.X.X proxy.
+ */
+
+/*
+ * These are for compatibility with the 1.X.X
+ * versions.
+ */
+
+#define sz_xNXSetUnpackColormapCompatReq        8
+
+typedef struct _NXSetUnpackColormapCompatReq {
+    CARD8  reqType;
+    CARD8  resource;
+    CARD16 length B16;
+    CARD32 entries B32;
+} xNXSetUnpackColormapCompatReq;
+
+#define X_NXSetUnpackColormapCompat  X_NXSetUnpackColormap
+
+int NXSetUnpackColormapCompat(Display *dpy, unsigned int resource,
+                                  unsigned int entries, const char *data)
+{
+  register xNXSetUnpackColormapCompatReq *req;
+
+  register char *dst_data;
+
+  register int dst_data_length;
+
+  #ifdef DUMP
+
+  int i;
+
+  #endif
+
+  LockDisplay(dpy);
+
+  GetReq(NXSetUnpackColormapCompat, req);
+
+  req -&gt; resource = resource;
+  req -&gt; entries  = entries;
+
+  dst_data_length = entries &lt;&lt; 2;
+
+  req -&gt; length += (dst_data_length &gt;&gt; 2);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetUnpackColormapCompat: Resource [%u] number of entries [%u] &quot;
+              &quot;destination data size [%u].\n&quot;, resource, entries, dst_data_length);
+  #endif
+
+  if (entries &gt; 0)
+  {
+    if ((dpy -&gt; bufptr + dst_data_length) &lt;= dpy -&gt; bufmax)
+    {
+      dst_data = dpy -&gt; bufptr;
+    }
+    else
+    {
+      if ((dst_data = _XAllocScratch(dpy, dst_data_length)) == NULL)
+      {
+        #ifdef PANIC
+        fprintf(stderr, &quot;******NXSetUnpackColormapCompat: PANIC! Cannot allocate memory.\n&quot;);
+        #endif
+
+        UnGetReq(NXSetUnpackColormapCompat);
+
+        UnlockDisplay(dpy);
+
+        return -1;
+      }
+    }
+
+    memcpy(dst_data, data, entries &lt;&lt; 2);
+
+    #ifdef DUMP
+
+    fprintf(stderr, &quot;******NXSetUnpackColormapCompat: Dumping colormap entries:\n&quot;);
+
+    for (i = 0; i &lt; entries; i++)
+    {
+      fprintf(stderr, &quot;******NXSetUnpackColormapCompat: [%d] -&gt; [0x%x].\n&quot;,
+                  i, *((int *) (dst_data + (i * 4))));
+    }
+
+    #endif
+
+    if (dst_data == dpy -&gt; bufptr)
+    {
+      dpy -&gt; bufptr += dst_data_length;
+    }
+    else
+    {
+      _XSend(dpy, dst_data, dst_data_length);
+    }
+  }
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+#define sz_xNXSetUnpackAlphaCompatReq  8
+
+typedef struct _NXSetUnpackAlphaCompatReq {
+    CARD8  reqType;
+    CARD8  resource;
+    CARD16 length B16;
+    CARD32 entries B32;
+} xNXSetUnpackAlphaCompatReq;
+
+#define X_NXSetUnpackAlphaCompat  X_NXSetUnpackAlpha
+
+int NXSetUnpackAlphaCompat(Display *dpy, unsigned int resource,
+                               unsigned int entries, const char *data)
+{
+  register xNXSetUnpackAlphaCompatReq *req;
+
+  register char *dst_data;
+
+  register unsigned int dst_data_length;
+
+  #ifdef DUMP
+
+  int i;
+
+  #endif
+
+  LockDisplay(dpy);
+
+  GetReq(NXSetUnpackAlphaCompat, req);
+
+  req -&gt; resource = resource;
+  req -&gt; entries  = entries;
+
+  dst_data_length = ROUNDUP(entries, 4);
+
+  req -&gt; length += (dst_data_length &gt;&gt; 2);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXSetUnpackAlphaCompat: Resource [%u] number of entries [%u] &quot;
+              &quot;destination data size [%u].\n&quot;, resource, entries, dst_data_length);
+  #endif
+
+  if (entries &gt; 0)
+  {
+    if ((dpy -&gt; bufptr + dst_data_length) &lt;= dpy -&gt; bufmax)
+    {
+      dst_data = dpy -&gt; bufptr;
+    }
+    else
+    {
+      if ((dst_data = _XAllocScratch(dpy, dst_data_length)) == NULL)
+      {
+        #ifdef PANIC
+        fprintf(stderr, &quot;******NXSetUnpackAlphaCompat: PANIC! Cannot allocate memory.\n&quot;);
+        #endif
+
+        UnGetReq(NXSetUnpackAlphaCompat);
+
+        UnlockDisplay(dpy);
+
+        return -1;
+      }
+    }
+
+    memcpy(dst_data, data, entries);
+
+    if (dst_data_length != entries)
+    {
+      memset(dst_data + entries, 0, dst_data_length - entries);
+    }
+
+    #ifdef DUMP
+
+    fprintf(stderr, &quot;******NXSetUnpackAlphaCompat: Dumping alpha channel data:\n&quot;);
+
+    for (i = 0; i &lt; dst_data_length; i++)
+    {
+      fprintf(stderr, &quot;******NXSetUnpackAlphaCompat: [%d] -&gt; [0x%02x].\n&quot;,
+                  i, ((unsigned int) *(dst_data + i)) &amp; 0xff);
+    }
+
+    #endif
+
+    if (dst_data == dpy -&gt; bufptr)
+    {
+      dpy -&gt; bufptr += dst_data_length;
+    }
+    else
+    {
+      _XSend(dpy, dst_data, dst_data_length);
+    }
+  }
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+/*
+ * Free any geometry, colormap and alpha channel
+ * data stored by the remote proxy to unpack the
+ * image. Resource, as usual, must be a value
+ * between 0 and 255.
+ */
+
+int NXFreeUnpack(Display *dpy, unsigned int resource)
+{
+  register xNXFreeUnpackReq *req;
+
+  if (_NXUnpackResources[resource] != 0)
+  {
+    LockDisplay(dpy);
+
+    GetReq(NXFreeUnpack, req);
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXFreeUnpack: Sending message opcode [%d] with resource [%u].\n&quot;,
+                X_NXFreeUnpack, resource);
+    #endif
+
+    req -&gt; resource = resource;
+
+    UnlockDisplay(dpy);
+
+    SyncHandle();
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXFreeUnpack: Making the resource [%u] newly available.\n&quot;,
+                resource);
+    #endif
+
+    _NXUnpackResources[resource] = 0;
+  }
+  #ifdef TEST
+  else
+  {
+    fprintf(stderr, &quot;******NXFreeUnpack: Nothing to do for resource [%u].\n&quot;,
+                resource);
+  }
+  #endif
+
+  return 1;
+}
+
+/*
+ * Wrapper of XCreateImage(). Note that we use offset
+ * field of XImage to store size of source image in
+ * packed format. Note also that method is currently
+ * not stored in the NXignored.
+ */
+
+NXPackedImage *NXCreatePackedImage(Display *dpy, Visual *visual, unsigned int method,
+                                       unsigned int depth, int format, char *data,
+                                           int data_length, unsigned int width,
+                                               unsigned int height, int bitmap_pad,
+                                                   int bytes_per_line)
+{
+  XImage* image;
+
+  image = XCreateImage(dpy, visual, depth, format, 0, data,
+                           width, height, bitmap_pad, bytes_per_line);
+
+  if (image != NULL)
+  {
+    image -&gt; xoffset = data_length;
+  }
+
+  return (NXPackedImage *) image;
+}
+
+/*
+ * Wrapper of XDestroyImage().
+ */
+
+int NXDestroyPackedImage(NXPackedImage *image)
+{
+  return XDestroyImage((XImage *) image);
+}
+
+/*
+ * Clean the image data directly in the current buffer.
+ */
+
+int NXCleanImage(XImage *image)
+{
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXCleanImage: Cleaning image with format [%d] depth [%d] &quot;
+              &quot;bits per pixel [%d].\n&quot;, image -&gt; format, image -&gt; depth,
+                  image -&gt; bits_per_pixel);
+  #endif
+
+  if (image -&gt; format == ZPixmap)
+  {
+    if (image -&gt; depth == 1)
+    {
+      return CleanXYImage(image);
+    }
+    else
+    {
+      return CleanZImage(image);
+    }
+  }
+  else
+  {
+    return CleanXYImage(image);
+  }
+}
+
+NXPackedImage *NXPackImage(Display *dpy, XImage *src_image, unsigned int method)
+{
+  XImage *dst_image;
+
+  const ColorMask *mask;
+
+  unsigned int dst_data_size;
+  unsigned int dst_packed_data_size;
+
+  unsigned int dst_bits_per_pixel;
+  unsigned int dst_packed_bits_per_pixel;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXPackImage: Going to pack a new image with method [%d].\n&quot;,
+              method);
+  #endif
+
+  /*
+   * Get the mask out of the method and 
+   * check if the visual is supported by
+   * the color reduction algorithm.
+   */
+
+  mask = MethodColorMask(method);
+
+  if (mask == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXPackImage: WARNING! No mask to apply for pack method [%d].\n&quot;,
+                method);
+    #endif
+
+    return NULL;
+  }
+  else if (CanMaskImage(src_image, mask) == 0)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXPackImage: PANIC! Invalid source with format [%d] depth [%d] bits per pixel [%d].\n&quot;,
+                src_image -&gt; format, src_image -&gt; depth, src_image -&gt; bits_per_pixel);
+
+    fprintf(stderr, &quot;******NXPackImage: PANIC! Visual colormask is red 0x%lx green 0x%lx blue 0x%lx.\n&quot;,
+                src_image -&gt; red_mask, src_image -&gt; green_mask, src_image -&gt; blue_mask);
+    #endif
+
+    return NULL;
+  }
+
+  /*
+   * Create a destination image from
+   * source and apply the color mask.
+   */
+
+  if ((dst_image = (XImage *) Xmalloc(sizeof(XImage))) == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXPackImage: PANIC! Cannot allocate [%d] bytes for the image.\n&quot;,
+                (int) sizeof(XImage));
+    #endif
+
+    return NULL;
+  }
+
+  *dst_image = *src_image;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXPackImage: Source width [%d], bytes per line [%d] with depth [%d].\n&quot;,
+              src_image -&gt; width, src_image -&gt; bytes_per_line, src_image -&gt; depth);
+  #endif
+
+  dst_data_size = src_image -&gt; bytes_per_line * src_image -&gt; height;
+
+  dst_image -&gt; data = Xmalloc(dst_data_size);
+
+  if (dst_image -&gt; data == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXPackImage: PANIC! Cannot allocate [%d] bytes for masked image data.\n&quot;,
+                dst_data_size);
+    #endif
+
+    Xfree(dst_image);
+
+    return NULL;
+  }
+
+  /*
+   * If the pixel resulting from the mask
+   * needs more bits than available, then
+   * just clean the padding bits in the
+   * image.
+   */
+
+  dst_bits_per_pixel = dst_image -&gt; bits_per_pixel;
+  dst_packed_bits_per_pixel = MethodBitsPerPixel(method);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXPackImage: Destination depth [%d], bits per pixel [%d], packed bits per pixel [%d].\n&quot;,
+             dst_image -&gt; depth, dst_bits_per_pixel, dst_packed_bits_per_pixel);
+  #endif
+
+  if (dst_packed_bits_per_pixel &gt; dst_bits_per_pixel ||
+          ShouldMaskImage(src_image, mask) == 0)
+  {
+    /*
+     * Should use the same data for source
+     * and destination to avoid the memcpy.
+     */
+
+    if (CopyAndCleanImage(src_image, dst_image) &lt;= 0)
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******NXPackImage: PANIC! Failed to clean the image.\n&quot;);
+      #endif
+
+      Xfree(dst_image -&gt; data);
+
+      Xfree(dst_image);
+
+      return NULL;
+    }
+  }
+  else if (MaskImage(mask, src_image, dst_image) &lt;= 0)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXPackImage: PANIC! Failed to apply the color mask.\n&quot;);
+    #endif
+
+    Xfree(dst_image -&gt; data);
+
+    Xfree(dst_image);
+
+    return NULL;
+  }
+
+  /*
+   * Let's pack the same pixels in fewer bytes.
+   * Note that we save a new memory allocation
+   * by using the same image as source and des-
+   * tination. This means that PackImage() must
+   * be able to handle ovelapping areas.
+   */
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXPackImage: Plain bits per pixel [%d], data size [%d].\n&quot;,
+              dst_bits_per_pixel, dst_data_size);
+  #endif
+
+  dst_packed_data_size = dst_data_size * dst_packed_bits_per_pixel /
+                              dst_bits_per_pixel;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXPackImage: Packed bits per pixel [%d], data size [%d].\n&quot;,
+              dst_packed_bits_per_pixel, dst_packed_data_size);
+  #endif
+
+  if (PackImage(method, dst_data_size, dst_image,
+                    dst_packed_data_size, dst_image) &lt;= 0)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXPackImage: PANIC! Failed to pack image from [%d] to [%d] bits per pixel.\n&quot;,
+                dst_bits_per_pixel, dst_packed_bits_per_pixel);
+    #endif
+
+    Xfree(dst_image -&gt; data);
+
+    Xfree(dst_image);
+
+    return NULL;
+  }
+
+  /*
+   * Save data size in xoffset field
+   * to comply with NX packed images.
+   */
+
+  dst_image -&gt; xoffset = dst_packed_data_size;
+
+  return dst_image;
+}
+
+/*
+ * NXInPlacePackImage creates a NXPackedImage
+ * from a XImage, sharing the same data buffer.
+ * Is up to the caller to free the data buffer
+ * only once.
+ */
+
+XImage *NXInPlacePackImage(Display *dpy, XImage *src_image, unsigned int method)
+{
+  XImage *dst_image;
+
+  const ColorMask *mask;
+
+  unsigned int dst_data_size;
+  unsigned int dst_packed_data_size;
+
+  unsigned int dst_bits_per_pixel;
+  unsigned int dst_packed_bits_per_pixel;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXInPlacePackImage: Going to pack a new image with method [%d].\n&quot;,
+              method);
+  #endif
+
+  /*
+   * Get mask out of method and check if
+   * visual is supported by current color
+   * reduction algorithm.
+   */
+
+  mask = MethodColorMask(method);
+
+  if (mask == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXInPlacePackImage: WARNING! No mask to apply for pack method [%d].\n&quot;,
+                method);
+    #endif
+
+    return NULL;
+  }
+  else if (CanMaskImage(src_image, mask) == 0)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXInPlacePackImage: PANIC! Invalid source with format [%d] depth [%d] bits per pixel [%d].\n&quot;,
+                src_image -&gt; format, src_image -&gt; depth, src_image -&gt; bits_per_pixel);
+
+    fprintf(stderr, &quot;******NXInPlacePackImage: PANIC! Visual colormask is red 0x%lx green 0x%lx blue 0x%lx.\n&quot;,
+                src_image -&gt; red_mask, src_image -&gt; green_mask, src_image -&gt; blue_mask);
+    #endif
+    return NULL;
+  }
+
+  /*
+   * Create a destination image from
+   * source and apply the color mask.
+   */
+
+  if ((dst_image = (XImage *) Xmalloc(sizeof(XImage))) == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXInPlacePackImage: PANIC! Cannot allocate [%d] bytes for the image.\n&quot;,
+                (int) sizeof(XImage));
+    #endif
+
+    return NULL;
+  }
+
+  *dst_image = *src_image;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXInPlacePackImage: Source width [%d], bytes per line [%d] with depth [%d].\n&quot;,
+              src_image -&gt; width, src_image -&gt; bytes_per_line, src_image -&gt; depth);
+  #endif
+
+  dst_data_size = src_image -&gt; bytes_per_line * src_image -&gt; height;
+
+  dst_image -&gt; data = src_image -&gt; data;
+
+  /*
+   * If pixel resulting from mask needs
+   * more bits than available, then just
+   * clean the pad bits in image.
+   */
+
+  dst_bits_per_pixel = dst_image -&gt; bits_per_pixel;
+  dst_packed_bits_per_pixel = MethodBitsPerPixel(method);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXInPlacePackImage: Destination depth [%d], bits per pixel [%d], packed bits per pixel [%d].\n&quot;,
+              dst_image -&gt; depth, dst_bits_per_pixel, dst_packed_bits_per_pixel);
+  #endif
+
+  if (dst_packed_bits_per_pixel &gt; dst_bits_per_pixel ||
+          ShouldMaskImage(src_image, mask) == 0)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXInPlacePackImage: Just clean image packed_bits_per_pixel[%d], bits_per_pixel[%d].\n&quot;,
+                dst_packed_bits_per_pixel, dst_bits_per_pixel);
+    #endif
+
+    if (NXCleanImage(dst_image) &lt;= 0)
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******NXInPlacePackImage: PANIC! Failed to clean the image.\n&quot;);
+      #endif
+
+      Xfree(dst_image);
+
+      return NULL;
+    }
+  }
+  else if (MaskInPlaceImage(mask, dst_image) &lt;= 0)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXInPlacePackImage: PANIC! Failed to apply the color mask.\n&quot;);
+    #endif
+
+    Xfree(dst_image);
+
+    return NULL;
+  }
+
+  /*
+   * Let's pack the same pixels in fewer bytes.
+   * Note that we save a new memory allocation
+   * by using the same image as source and des-
+   * tination. This means that PackImage() must
+   * be able to handle ovelapping areas.
+   */
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXInPlacePackImage: Plain bits per pixel [%d], data size [%d].\n&quot;,
+             dst_bits_per_pixel, dst_data_size);
+  #endif
+
+  dst_packed_data_size = dst_data_size * dst_packed_bits_per_pixel /
+    dst_bits_per_pixel;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXInPlacePackImage: Packed bits per pixel [%d], data size [%d].\n&quot;,
+             dst_packed_bits_per_pixel, dst_packed_data_size);
+  #endif
+
+  /*
+   * Save data size in xoffset field
+   * to comply with NX packed images.
+   */
+
+  dst_image -&gt; xoffset = dst_packed_data_size;
+
+  return dst_image;
+}
+
+int NXPutPackedImage(Display *dpy, unsigned int resource, Drawable drawable,
+                         void *gc, NXPackedImage *image, unsigned int method,
+                             unsigned int depth, int src_x, int src_y, int dst_x,
+                                 int dst_y, unsigned int width, unsigned int height)
+{
+  register xNXPutPackedImageReq *req;
+
+  register unsigned int src_data_length;
+  register unsigned int dst_data_length;
+
+  LockDisplay(dpy);
+
+  FlushGC(dpy, (GC) gc);
+
+  GetReq(NXPutPackedImage, req);
+
+  req -&gt; resource = resource;
+  req -&gt; drawable = drawable;
+  req -&gt; gc = ((GC) gc) -&gt; gid;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXPutPackedImage: Image resource [%d] drawable [%d] gc [%d].\n&quot;,
+              req -&gt; resource, (int) req -&gt; drawable, (int) req -&gt; gc);
+  #endif
+
+  /*
+   * There is no leftPad field in request. We only
+   * support a leftPad of 0. Anyway, X imposes a
+   * leftPad of 0 in case of ZPixmap format.
+   */
+
+  req -&gt; format = image -&gt; format;
+
+  /*
+   * Source depth, as well as width and height,
+   * are taken from the image structure.
+   */
+
+  req -&gt; srcDepth = image -&gt; depth;
+
+  req -&gt; srcX = src_x;
+  req -&gt; srcY = src_y;
+
+  req -&gt; srcWidth  = image -&gt; width;
+  req -&gt; srcHeight = image -&gt; height;
+
+  /*
+   * The destination depth is provided
+   * by the caller.
+   */
+
+  req -&gt; dstDepth = depth;
+
+  req -&gt; dstX = dst_x;
+  req -&gt; dstY = dst_y;
+
+  req -&gt; dstWidth  = width;
+  req -&gt; dstHeight = height;
+
+  req -&gt; method = method;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXPutPackedImage: Source image depth [%d] destination depth [%d] &quot;
+              &quot;method [%d].\n&quot;, req -&gt; srcDepth, req -&gt; dstDepth, req -&gt; method);
+  #endif
+
+  /*
+   * Source data length is the size of image in packed format,
+   * as stored in xoffset field of XImage. Destination data
+   * size is calculated according to bytes per line of target
+   * image, so the caller must provide the right depth at the
+   * time XImage structure is created.
+   */
+
+  req -&gt; srcLength = image -&gt; xoffset;
+
+  if (image -&gt; width == (int) width &amp;&amp;
+          image -&gt; height == (int) height)
+  {
+    req -&gt; dstLength = image -&gt; bytes_per_line * image -&gt; height;
+  }
+  else if (image -&gt; format == ZPixmap)
+  {
+    req -&gt; dstLength = ROUNDUP((image -&gt; bits_per_pixel * width),
+                                    image -&gt; bitmap_pad) * height &gt;&gt; 3;
+  }
+  else
+  {
+    req -&gt; dstLength = ROUNDUP(width, image -&gt; bitmap_pad) * height &gt;&gt; 3;
+  }
+
+  src_data_length = image -&gt; xoffset;
+
+  dst_data_length = ROUNDUP(src_data_length, 4);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXPutPackedImage: Source data length [%d] request data length [%d].\n&quot;,
+              src_data_length, dst_data_length);
+  #endif
+
+  req -&gt; length += (dst_data_length &gt;&gt; 2);
+
+  if (src_data_length &gt; 0)
+  {
+    if (dpy -&gt; bufptr + dst_data_length &lt;= dpy -&gt; bufmax)
+    {
+      /*
+       * Clean the padding bytes in the request.
+       */
+
+      *((int *) (dpy -&gt; bufptr + dst_data_length - 4)) = 0x0;
+
+      memcpy(dpy -&gt; bufptr, image -&gt; data, src_data_length);
+
+      dpy -&gt; bufptr += dst_data_length;
+    }
+    else
+    {
+      /*
+       * The _XSend() will pad the request for us.
+       */
+
+      _XSend(dpy, image -&gt; data, src_data_length);
+    }
+  }
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+int NXAllocColors(Display *dpy, Colormap colormap, unsigned int entries,
+                      XColor screens_in_out[], Bool results_in_out[])
+{
+  Status result = 0;
+  xAllocColorReply rep;
+  register xAllocColorReq *req;
+
+  Bool alloc_error = False;
+
+  register unsigned int i;
+
+  LockDisplay(dpy);
+
+  for (i = 0; i &lt; entries; i++)
+  {
+    GetReq(AllocColor, req);
+
+    req -&gt; cmap  = colormap;
+
+    req -&gt; red   = screens_in_out[i].red;
+    req -&gt; green = screens_in_out[i].green;
+    req -&gt; blue  = screens_in_out[i].blue;
+  }
+
+  for (i = 0; i &lt; entries; i++)
+  {
+    result = _XReply(dpy, (xReply *) &amp;rep, 0, xTrue);
+
+    if (result)
+    {
+      screens_in_out[i].pixel = rep.pixel;
+
+      screens_in_out[i].red   = rep.red;
+      screens_in_out[i].green = rep.green;
+      screens_in_out[i].blue  = rep.blue;
+      
+      results_in_out[i] = True;
+    } 
+    else 
+    {
+      results_in_out[i] = False;
+
+      alloc_error = True;
+    }
+  }
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return (alloc_error == False);
+}
+
+char *NXEncodeColormap(const char *src_data, unsigned int src_size, unsigned int *dst_size)
+{
+  return ColormapCompressData(src_data, src_size, dst_size);
+}
+
+char *NXEncodeAlpha(const char *src_data, unsigned int src_size, unsigned int *dst_size)
+{
+  return AlphaCompressData(src_data, src_size, dst_size);
+}
+
+NXPackedImage *NXEncodeRgb(XImage *src_image, unsigned int method, unsigned int quality)
+{
+  NXPackedImage *dst_image = NULL;
+
+  unsigned int dst_size;
+
+  /*
+   * Create a new image structure as a copy
+   * of the source.
+   */
+
+  if ((dst_image = (NXPackedImage *) Xmalloc(sizeof(NXPackedImage))) == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodeRgb: PANIC! Cannot allocate [%d] bytes for the image.\n&quot;,
+                (int) sizeof(XImage));
+    #endif
+
+    return NULL;
+  }
+
+  *dst_image = *src_image;
+
+  dst_image -&gt; data = RgbCompressData(src_image, &amp;dst_size);
+
+  if (dst_image -&gt; data == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodeRgb: PANIC! Rgb compression failed.\n&quot;);
+    #endif
+
+    Xfree(dst_image);
+
+    return NULL;
+  }
+
+  /*
+   * Store the Rgb size in the xoffset field.
+   */
+
+  dst_image -&gt; xoffset = dst_size;
+
+  return dst_image;
+}
+
+NXPackedImage *NXEncodeRle(XImage *src_image, unsigned int method, unsigned int quality)
+{
+  NXPackedImage *dst_image = NULL;
+
+  unsigned int dst_size;
+
+  /*
+   * Create a new image structure as a copy
+   * of the source.
+   */
+
+  if ((dst_image = (NXPackedImage *) Xmalloc(sizeof(NXPackedImage))) == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodeRle: PANIC! Cannot allocate [%d] bytes for the image.\n&quot;,
+                (int) sizeof(XImage));
+    #endif
+
+    return NULL;
+  }
+
+  *dst_image = *src_image;
+
+  dst_image -&gt; data = RleCompressData(src_image, &amp;dst_size);
+
+  if (dst_image -&gt; data == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodeRle: PANIC! Rle compression failed.\n&quot;);
+    #endif
+
+    Xfree(dst_image);
+
+    return NULL;
+  }
+
+  /*
+   * Store the Rle size in the xoffset field.
+   */
+
+  dst_image -&gt; xoffset = dst_size;
+
+  return dst_image;
+}
+
+NXPackedImage *NXEncodeBitmap(XImage *src_image, unsigned int method, unsigned int quality)
+{
+  NXPackedImage *dst_image = NULL;
+
+  unsigned int dst_size;
+
+  /*
+   * Create a new image structure as a copy
+   * of the source.
+   */
+
+  if ((dst_image = (NXPackedImage *) Xmalloc(sizeof(NXPackedImage))) == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodeBitmap: PANIC! Cannot allocate [%d] bytes for the image.\n&quot;,
+                (int) sizeof(XImage));
+    #endif
+
+    return NULL;
+  }
+
+  *dst_image = *src_image;
+
+  dst_image -&gt; data = BitmapCompressData(src_image, &amp;dst_size);
+
+  if (dst_image -&gt; data == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodeBitmap: PANIC! Bitmap compression failed.\n&quot;);
+    #endif
+
+    Xfree(dst_image);
+
+    return NULL;
+  }
+
+  /*
+   * Store the bitmap size in the xoffset field.
+   */
+
+  dst_image -&gt; xoffset = dst_size;
+
+  return dst_image;
+}
+
+NXPackedImage *NXEncodeJpeg(XImage *src_image, unsigned int method, unsigned int quality)
+{
+  NXPackedImage *dst_image = NULL;
+
+  int size;
+
+  /*
+   * Check if the bpp of the image is valid
+   * for the Jpeg compression.
+   */
+
+  if (src_image -&gt; bits_per_pixel &lt; 15)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodeJpeg: PANIC! Invalid bpp for Jpeg compression [%d]\n.&quot;,
+                src_image -&gt; bits_per_pixel);
+    #endif
+
+    return NULL;
+  }
+
+  /*
+   * Create the destination image as a copy
+   * of the source.
+   */
+
+  if ((dst_image = (NXPackedImage *) Xmalloc(sizeof(NXPackedImage))) == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodeJpeg: PANIC! Cannot allocate [%d] bytes for the Jpeg image.\n&quot;,
+                (int) sizeof(NXPackedImage));
+    #endif
+
+    return NULL;
+  }
+
+  *dst_image = *src_image;
+
+  dst_image -&gt; data = JpegCompressData(src_image, quality, &amp;size);
+
+  if (dst_image -&gt; data == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodeJpeg: PANIC! Jpeg compression failed.\n&quot;);
+    #endif
+
+    Xfree(dst_image);
+
+    return NULL;
+  }
+
+  /*
+   * Store the Jpeg size in the xoffset field.
+   */
+
+  dst_image -&gt; xoffset = size;
+
+  return dst_image;
+}
+
+NXPackedImage *NXEncodePng(XImage *src_image, unsigned int method, unsigned int quality)
+{
+  NXPackedImage *dst_image = NULL;
+
+  int size;
+
+  /*
+   * Check if the bpp of the image is valid
+   * for png compression.
+   */
+
+  if (src_image -&gt; bits_per_pixel &lt; 15)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodePng: PANIC! Invalid bpp for Png compression [%d].\n&quot;,
+                src_image -&gt; bits_per_pixel);
+    #endif
+
+    return NULL;
+  }
+
+  if ((dst_image = (NXPackedImage *) Xmalloc(sizeof(NXPackedImage))) == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodePng: PANIC! Cannot allocate [%d] bytes for the Png image.\n&quot;,
+                (int) sizeof(NXPackedImage));
+    #endif
+
+    return NULL;
+  }
+
+  *dst_image = *src_image;
+
+  dst_image -&gt; data = PngCompressData(dst_image, &amp;size);
+
+  if (dst_image -&gt; data == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXEncodePng: PANIC! Png compression failed.\n&quot;);
+    #endif
+
+    Xfree(dst_image);
+
+    return NULL;
+  }
+
+  /*
+   * Store the Png size in the xoffset field.
+   */
+
+  dst_image -&gt; xoffset = size;
+
+  return dst_image;
+}
+
+int NXEncodeColors(XImage *src_image, NXColorTable *color_table, int nb_max)
+{
+  int x, y, t, p;
+
+  long pixel;
+
+  /*
+   * We need a smarter way to extract
+   * the colors from the image and
+   * create a color table.
+   */
+
+  memset(color_table, 0, nb_max * sizeof(NXColorTable));
+
+  for (x = 0, p = 0; x &lt; src_image -&gt; width; x++)
+  {
+    for (y = 0; y &lt; src_image -&gt; height; y++)
+    {
+      pixel  = XGetPixel(src_image, x, y);
+
+      for (t = 0; t &lt; nb_max; t++)
+      {
+        if ( color_table[t].found == 0)
+        {
+          color_table[t].pixel =  pixel;
+          color_table[t].found =  1;
+
+          p++;
+
+          break;
+        }
+        else if ((color_table[t].pixel) == pixel)
+        {
+          break;
+        }
+      }
+
+      if (p == nb_max)
+      {
+        return nb_max + 1;
+      }
+    }
+  }
+
+  return p;
+}
+
+void NXMaskImage(XImage *image, unsigned int method)
+{
+  unsigned int maskMethod;
+
+  const ColorMask *mask;
+
+  /*
+   * Choose the correct mask method
+   */
+
+  switch(method)
+  {
+    case PACK_JPEG_8_COLORS:
+    case PACK_PNG_8_COLORS:
+    {
+      maskMethod = MASK_8_COLORS;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_8_COLORS\n&quot;);
+      #endif
+
+      break;
+    }
+    case PACK_JPEG_64_COLORS:
+    case PACK_PNG_64_COLORS:
+    {
+      maskMethod = MASK_64_COLORS;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_64K_COLORS\n&quot;);
+      #endif
+
+      break;
+    }
+    case PACK_JPEG_256_COLORS:
+    case PACK_PNG_256_COLORS:
+    {
+      maskMethod = MASK_256_COLORS;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_256_COLORS\n&quot;);
+      #endif
+
+      break;
+    }
+    case PACK_JPEG_512_COLORS:
+    case PACK_PNG_512_COLORS:
+    {
+      maskMethod = MASK_512_COLORS;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_512K_COLORS\n&quot;);
+      #endif
+
+      break;
+    }
+    case PACK_JPEG_4K_COLORS:
+    case PACK_PNG_4K_COLORS:
+    {
+      maskMethod = MASK_4K_COLORS;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_4K_COLORS\n&quot;);
+      #endif
+
+      break;
+    }
+    case PACK_JPEG_32K_COLORS:
+    case PACK_PNG_32K_COLORS:
+    {
+      maskMethod = MASK_32K_COLORS;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_32K_COLORS\n&quot;);
+      #endif
+
+      break;
+    }
+    case PACK_JPEG_64K_COLORS:
+    case PACK_PNG_64K_COLORS:
+    {
+      maskMethod = MASK_64K_COLORS;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_64K_COLORS\n&quot;);
+      #endif
+
+      break;
+    }
+    case PACK_JPEG_256K_COLORS:
+    case PACK_PNG_256K_COLORS:
+    {
+      maskMethod = MASK_256K_COLORS;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_256K_COLORS\n&quot;);
+      #endif
+
+      break;
+    }
+    case PACK_JPEG_2M_COLORS:
+    case PACK_PNG_2M_COLORS:
+    {
+      maskMethod = MASK_2M_COLORS;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_2M_COLORS\n&quot;);
+      #endif
+
+      break;
+    }
+    case PACK_JPEG_16M_COLORS:
+    case PACK_PNG_16M_COLORS:
+    {
+      maskMethod = MASK_16M_COLORS;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******NXMaskImage: Method is MASK_16M_COLORS\n&quot;);
+      #endif
+
+      break;
+    }
+    default:
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******NXMaskImage: PANIC! Cannot find mask method for pack method [%d]\n&quot;,
+                  method);
+      #endif
+
+      return;
+    }
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXMaskImage: packMethod[%d] =&gt; maskMethod[%d]\n&quot;,
+              method, maskMethod);
+  #endif
+
+  /*
+   * Get mask out of method and check if
+   * visual is supported by current color
+   * reduction algorithm.
+   */
+
+  mask = MethodColorMask(maskMethod);
+
+  if (mask == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXMaskImage: PANIC! No mask to apply for pack method [%d].\n&quot;,
+                method);
+    #endif
+
+    return;
+  }
+  else if (CanMaskImage(image, mask) == 0)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXMaskImage: PANIC! Invalid source with format [%d] depth [%d] bits per pixel [%d].\n&quot;,
+                image -&gt; format, image -&gt; depth, image -&gt; bits_per_pixel);
+
+    fprintf(stderr, &quot;******NXMaskImage: PANIC! Visual colormask is red 0x%lx green 0x%lx blue 0x%lx.\n&quot;,
+                image -&gt; red_mask, image -&gt; green_mask, image -&gt; blue_mask);
+    #endif
+
+    return;
+  }
+
+  /*
+   * Calling ShouldMaskImage you get 0 in the case
+   * of MASK_256_COLORS and MASK_64K_COLORS, which
+   * means that the image should not be masked.
+   */
+
+  if (ShouldMaskImage(image, mask) == 0)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******NXMaskImage: the image will not be masked\n&quot;);
+    #endif
+  }
+  else
+  {
+    if (MaskInPlaceImage(mask, image) &lt;= 0)
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******NXMaskImage: PANIC! Failed to apply the color mask in place.\n&quot;);
+      #endif
+    }
+  }
+}
+
+/*
+ * The display parameter is ignored.
+ */
+
+void NXInitCache(Display *dpy, int entries)
+{
+  if (NXImageCache != NULL &amp;&amp; NXImageCacheSize == entries)
+  {
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******NXInitCache: Nothing to do with image cache at [%p] and [%d] entries.\n&quot;,
+                NXImageCache,  NXImageCacheSize);
+    #endif
+
+    return;
+  }
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******NXInitCache: Initializing the cache with [%d] entries.\n&quot;,
+              entries);
+  #endif
+
+  NXImageCacheSize = 0;
+
+  if (NXImageCache != NULL)
+  {
+    Xfree(NXImageCache);
+
+    NXImageCache = NULL;
+  }
+
+  if (entries &gt; 0)
+  {
+    NXImageCache = Xmalloc(entries * sizeof(_NXImageCacheEntry));
+
+    if (NXImageCache != NULL)
+    {
+      memset(NXImageCache, 0, entries * sizeof(_NXImageCacheEntry));
+
+      NXImageCacheSize = entries;
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******NXInitCache: Image cache initialized with [%d] entries.\n&quot;, entries);
+      #endif
+    }
+  }
+}
+
+#ifdef DUMP
+
+void _NXCacheDump(const char *label)
+{
+  char s[MD5_LENGTH * 2 + 1];
+
+  int i;
+  int j;
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;%s: Dumping the content of image cache:\n&quot;, label);
+  #endif
+
+  for (i = 0; i &lt; NXImageCacheSize; i++)
+  {
+    if (NXImageCache[i].image == NULL)
+    {
+      break;
+    }
+
+    for (j = 0; j &lt; MD5_LENGTH; j++)
+    {
+      sprintf(s + (j * 2), &quot;%02X&quot;, ((unsigned char *) NXImageCache[i].md5)[j]);
+    }
+
+    #ifdef DEBUG
+    fprintf(stderr, &quot;%s: [%d][%s].\n&quot;, label, i, s);
+    #endif
+  }
+}
+
+#endif
+
+XImage *NXCacheFindImage(NXPackedImage *src_image, unsigned int *method, unsigned char **md5)
+{
+  md5_state_t  new_state;
+  md5_byte_t   *new_md5;
+  unsigned int data_size, i;
+
+  if (NXImageCache == NULL)
+  {
+    return NULL;
+  }
+
+  /*
+   * Will return the allocated checksum
+   * if the image is not found.
+   */
+
+  *md5 = NULL;
+
+  if ((new_md5 = Xmalloc(MD5_LENGTH)) == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCacheFindImage: Can't allocate memory for the checksum.\n&quot;);
+    #endif
+
+    return NULL;
+  }
+
+  data_size = (src_image -&gt; bytes_per_line * src_image -&gt; height);
+
+  md5_init(&amp;new_state);
+
+  md5_append(&amp;new_state, (unsigned char *) &amp;src_image -&gt; width,  sizeof(int));
+  md5_append(&amp;new_state, (unsigned char *) &amp;src_image -&gt; height, sizeof(int));
+
+  md5_append(&amp;new_state, (unsigned char *) src_image -&gt; data, data_size);
+
+  md5_finish(&amp;new_state, new_md5);
+
+  for (i = 0; i &lt; NXImageCacheSize; i++)
+  {
+    if (NXImageCache[i].image != NULL)
+    {
+      if (memcmp(NXImageCache[i].md5, new_md5, MD5_LENGTH) == 0)
+      {
+        _NXImageCacheEntry found;
+
+        found.image  = NXImageCache[i].image;
+        found.method = NXImageCache[i].method;
+        found.md5    = NXImageCache[i].md5;
+
+        *method = found.method;
+
+        NXImageCacheHits++;
+
+        #ifdef DEBUG
+        fprintf(stderr, &quot;******NXCacheFindImage: Found at position [%d] with hits [%d] and [%d] packs.\n&quot;,
+                    i, NXImageCacheHits, NXImageCacheOps);
+        #endif
+
+        Xfree(new_md5);
+
+        /*
+         * Move the images down one slot, from
+         * the head of the list, and place the
+         * image just found at top.
+         */
+
+        if (i &gt; 16)
+        {
+          #ifdef DEBUG
+          fprintf(stderr, &quot;******NXCacheFindImage: Moving the image at the head of the list.\n&quot;);
+          #endif
+
+          memmove(&amp;NXImageCache[1], &amp;NXImageCache[0], (i * sizeof(_NXImageCacheEntry)));
+
+          NXImageCache[0].image  = found.image;
+          NXImageCache[0].method = found.method;
+          NXImageCache[0].md5    = found.md5;
+
+          #ifdef DUMP
+
+          _NXCacheDump(&quot;******NXCacheFindImage&quot;);
+
+          #endif
+        }
+
+        /*
+         * Return the checksum and image
+         * structure allocated in cache.
+         */
+
+        *md5 = found.md5;
+
+        return found.image;
+      }
+    }
+    else
+    {
+      break;
+    }
+  }
+
+  *md5 = new_md5;
+
+  return NULL;
+}
+
+/*
+ * Add a packed image to the cache. A new image
+ * structure is allocated and copied, data and
+ * checksum are inherited from the passed image.
+ */
+
+int NXCacheAddImage(NXPackedImage *image, unsigned int method, unsigned char *md5)
+{
+  unsigned int i;
+
+  if (image == NULL || image -&gt; data == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCacheAddImage: PANIC! Invalid image passed to function.\n&quot;);
+    #endif
+
+    return -1;
+  }
+
+  i = (NXImageCacheOps &lt; NXImageCacheSize) ? NXImageCacheOps : NXImageCacheSize;
+
+  if (NXImageCacheOps &gt;= NXImageCacheSize)
+  {
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******NXCacheAddImage: Freeing up the oldest entry.\n&quot;);
+    #endif
+
+    i--;
+
+    Xfree(NXImageCache[NXImageCacheSize - 1].image -&gt; data);
+    Xfree(NXImageCache[NXImageCacheSize - 1].image);
+    Xfree(NXImageCache[NXImageCacheSize - 1].md5);
+  }
+
+  if (i &gt; 0)
+  {
+    memmove(&amp;NXImageCache[1], &amp;NXImageCache[0], i * sizeof(_NXImageCacheEntry));
+  }
+
+  NXImageCacheOps++;
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******NXCacheAddImage: Going to add new image with data size [%d].\n&quot;,
+              image -&gt; xoffset);
+  #endif
+
+  NXImageCache[0].image  = image;
+  NXImageCache[0].method = method;
+  NXImageCache[0].md5    = md5;
+
+  #ifdef DUMP
+
+  _NXCacheDump(&quot;******NXCacheAddImage&quot;);
+
+  #endif
+
+  return 1;
+}
+
+/*
+ * The display parameter is ignored.
+ */
+
+void NXFreeCache(Display *dpy)
+{
+  int i;
+
+  if (NXImageCache == NULL)
+  {
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******NXFreeCache: Nothing to do with a null image cache.\n&quot;);
+    #endif
+
+    return;
+  }
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******NXFreeCache: Freeing the cache with [%d] entries.\n&quot;,
+              NXImageCacheSize);
+  #endif
+
+  for (i = 0; i &lt; NXImageCacheSize; i++)
+  {
+    if (NXImageCache[i].image != NULL)
+    {
+      if (NXImageCache[i].image -&gt; data != NULL)
+      {
+        Xfree(NXImageCache[i].image -&gt; data);
+      }
+
+      Xfree(NXImageCache[i].image);
+
+      NXImageCache[i].image = NULL;
+    }
+
+    if (NXImageCache[i].md5 != NULL)
+    {
+      Xfree(NXImageCache[i].md5);
+
+      NXImageCache[i].md5 = NULL;
+    }
+  }
+
+  Xfree(NXImageCache);
+
+  NXImageCache = NULL;
+
+  NXImageCacheSize = 0;
+  NXImageCacheHits = 0;
+  NXImageCacheOps  = 0;
+}
+
+static void _NXNotifyImage(Display *dpy, int resource, Bool success)
+{
+  XEvent async_event;
+
+  /*
+   * Enqueue an event to tell client
+   * the result of GetImage.
+   */
+
+  async_event.type = ClientMessage;
+
+  async_event.xclient.serial = _NXCollectedImages[resource] -&gt; sequence;
+
+  async_event.xclient.window       = 0;
+  async_event.xclient.message_type = 0;
+  async_event.xclient.format       = 32;
+
+  async_event.xclient.data.l[0] = NXCollectImageNotify;
+  async_event.xclient.data.l[1] = resource;
+  async_event.xclient.data.l[2] = success;
+
+  XPutBackEvent(dpy, &amp;async_event);
+}
+
+static Bool _NXCollectImageHandler(Display *dpy, xReply *rep, char *buf,
+                                       int len, XPointer data)
+{
+  register _NXCollectImageState *state;
+
+  register xGetImageReply *async_rep;
+
+  char *async_head;
+  char *async_data;
+
+  int async_size;
+
+  state = (_NXCollectImageState *) data;
+
+  if ((rep -&gt; generic.sequenceNumber % 65536) !=
+          ((int)(state -&gt; sequence) % 65536))
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectImageHandler: Unmatched sequence [%d] for opcode [%d] &quot;
+                &quot;with length [%d].\n&quot;, rep -&gt; generic.sequenceNumber, rep -&gt; generic.type,
+                    (int) rep -&gt; generic.length &lt;&lt; 2);
+    #endif
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectImageHandler: Going to handle asynchronous GetImage reply.\n&quot;);
+  #endif
+
+  /*
+   * As even reply data is managed asynchronously,
+   * we can use state to get to vector and vector
+   * to get to handler. In this way, we can safely
+   * dequeue and free the handler itself.
+   */
+
+  DeqAsyncHandler(dpy, state -&gt; handler);
+
+  Xfree(state -&gt; handler);
+
+  state -&gt; handler = NULL;
+
+  if (rep -&gt; generic.type == X_Error)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectImageHandler: Error received from X server for resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyImage(dpy, state -&gt; resource, False);
+
+    _NXCollectedImages[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectImageHandler: Matched request with sequence [%ld].\n&quot;,
+              state -&gt; sequence);
+  #endif
+
+  async_size = SIZEOF(xGetImageReply);
+
+  async_head = Xmalloc(async_size);
+
+  if (async_head == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******_NXCollectImageHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyImage(dpy, state -&gt; resource, False);
+
+    _NXCollectedImages[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectImageHandler: Going to get reply with size [%d].\n&quot;,
+              (int) rep -&gt; generic.length &lt;&lt; 2);
+  #endif
+
+  async_rep = (xGetImageReply *) _XGetAsyncReply(dpy, async_head, rep, buf, len, 0, False);
+
+  if (async_rep == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******_NXCollectImageHandler: PANIC! Failed to get reply with resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyImage(dpy, state -&gt; resource, False);
+
+    _NXCollectedImages[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    Xfree(async_head);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectImageHandler: Got reply with depth [%d] visual [%d] size [%d].\n&quot;,
+              async_rep -&gt; depth, (int) async_rep -&gt; visual, (int) async_rep -&gt; length &lt;&lt; 2);
+  #endif
+
+  async_size = async_rep -&gt; length &lt;&lt; 2;
+
+  if (async_size &gt; 0)
+  {
+    async_data = Xmalloc(async_size);
+
+    if (async_data == NULL)
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******_NXCollectImageHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
+                  state -&gt; resource);
+      #endif
+
+      _NXNotifyImage(dpy, state -&gt; resource, False);
+
+      _NXCollectedImages[state -&gt; resource] = NULL;
+
+      Xfree(state);
+
+      Xfree(async_head);
+
+      return False;
+    }
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectImageHandler: Going to get data with size [%d].\n&quot;,
+                async_size);
+    #endif
+
+    _XGetAsyncData(dpy, async_data, buf, len, SIZEOF(xGetImageReply), async_size, async_size);
+
+    /*
+     * From now on we can return True, as all
+     * data has been consumed from buffer.
+     */
+
+    if (state -&gt; format == XYPixmap)
+    {
+      unsigned long depth = DepthOnes(state -&gt; mask &amp; (((unsigned long)0xFFFFFFFF) &gt;&gt;
+                                          (32 - async_rep -&gt; depth)));
+
+      state -&gt; image = XCreateImage(dpy, _XVIDtoVisual(dpy, async_rep -&gt; visual),
+                                        depth, XYPixmap, 0, async_data, state -&gt; width,
+                                            state -&gt; height, dpy -&gt; bitmap_pad, 0);
+    }
+    else
+    {
+      state -&gt; image = XCreateImage(dpy, _XVIDtoVisual(dpy, async_rep -&gt; visual),
+                                        async_rep -&gt; depth, ZPixmap, 0, async_data, state -&gt; width,
+                                            state -&gt; height, _XGetScanlinePad(dpy, async_rep -&gt; depth), 0);
+    }
+
+    if (state -&gt; image == NULL)
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******_NXCollectImageHandler: PANIC! Failed to create image for resource [%d].\n&quot;,
+                  state -&gt; resource);
+      #endif
+
+      _NXNotifyImage(dpy, state -&gt; resource, False);
+
+      _NXCollectedImages[state -&gt; resource] = NULL;
+
+      Xfree(state);
+
+      Xfree(async_head);
+      Xfree(async_data);
+
+      return True;
+    }
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectImageHandler: Successfully stored image data for resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+  }
+  #ifdef WARNING
+  else
+  {
+    fprintf(stderr, &quot;******_NXCollectImageHandler: WARNING! Null image data stored for resource [%d].\n&quot;,
+                state -&gt; resource);
+  }
+  #endif
+
+  _NXNotifyImage(dpy, state -&gt; resource, True);
+
+  Xfree(async_head);
+
+  return True;
+}
+
+int NXGetCollectImageResource(Display *dpy)
+{
+  int i;
+
+  for (i = 0; i &lt; NXNumberOfResources; i++)
+  {
+    if (_NXCollectedImages[i] == NULL)
+    {
+      return i;
+    }
+  }
+
+  return -1;
+}
+
+int NXCollectImage(Display *dpy, unsigned int resource, Drawable drawable,
+                       int src_x, int src_y, unsigned int width, unsigned int height,
+                           unsigned long plane_mask, int format)
+{
+  register xGetImageReq *req;
+
+  _NXCollectImageState *state;
+  _XAsyncHandler *handler;
+
+  if (resource &gt;= NXNumberOfResources)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectImage: PANIC! Provided resource [%u] is out of range.\n&quot;,
+                resource);
+    #endif
+
+    return -1;
+  }
+
+  state = _NXCollectedImages[resource];
+
+  if (state != NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectImage: PANIC! Having to remove previous state for resource [%u].\n&quot;,
+                resource);
+    #endif
+
+    if (state -&gt; handler != NULL)
+    {
+      DeqAsyncHandler(dpy, state -&gt; handler);
+
+      Xfree(state -&gt; handler);
+    }
+
+    if (state -&gt; image != NULL)
+    {
+      XDestroyImage(state -&gt; image);
+    }
+
+    Xfree(state);
+
+    _NXCollectedImages[resource] = NULL;
+  }
+
+  LockDisplay(dpy);
+
+  GetReq(GetImage, req);
+
+  req -&gt; format    = format;
+  req -&gt; drawable  = drawable;
+  req -&gt; x         = src_x;
+  req -&gt; y         = src_y;
+  req -&gt; width     = width;
+  req -&gt; height    = height;
+  req -&gt; planeMask = plane_mask;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXCollectImage: Sending message opcode [%d] sequence [%ld] for resource [%d].\n&quot;,
+              X_GetImage, dpy -&gt; request, resource);
+
+  fprintf(stderr, &quot;******NXCollectImage: Format [%d] drawable [%d] src_x [%d] src_y [%d].\n&quot;,
+              req -&gt; format, (int) req -&gt; drawable, req -&gt; x, req -&gt; y);
+
+  fprintf(stderr, &quot;******NXCollectImage: Width [%d] height [%d] plane_mask [%x].\n&quot;,
+              req -&gt; width, req -&gt; height, (int) req -&gt; planeMask);
+  #endif
+
+  state   = Xmalloc(sizeof(_NXCollectImageState));
+  handler = Xmalloc(sizeof(_XAsyncHandler));
+
+  if (state == NULL || handler == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectImage: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
+                resource);
+    #endif
+
+    UnGetReq(GetImage);
+
+    if (state != NULL)
+    {
+      Xfree(state);
+    }
+
+    if (handler != NULL)
+    {
+      Xfree(handler);
+    }
+
+    UnlockDisplay(dpy);
+
+    return -1;
+  }
+
+  state -&gt; sequence = dpy -&gt; request;
+  state -&gt; resource = resource;
+  state -&gt; mask     = plane_mask;
+  state -&gt; format   = format;
+  state -&gt; width    = width;
+  state -&gt; height   = height;
+  state -&gt; image    = NULL;
+
+  state -&gt; handler = handler;
+
+  handler -&gt; next = dpy -&gt; async_handlers;
+  handler -&gt; handler = _NXCollectImageHandler;
+  handler -&gt; data = (XPointer) state;
+  dpy -&gt; async_handlers = handler;
+
+  _NXCollectedImages[resource] = state;
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return 1;
+}
+
+int NXGetCollectedImage(Display *dpy, unsigned int resource, XImage **image)
+{
+  register _NXCollectImageState *state;
+
+  state = _NXCollectedImages[resource];
+
+  if (state == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXGetCollectedImage: PANIC! No image collected for resource [%u].\n&quot;,
+                resource);
+    #endif
+
+    return 0;
+  }
+
+  _NXCollectedImages[resource] = NULL;
+
+  *image = state -&gt; image;
+
+  Xfree(state);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXGetCollectedImage: Returning GetImage data for resource [%u].\n&quot;,
+              resource);
+  #endif
+
+  return 1;
+}
+
+static void _NXNotifyProperty(Display *dpy, int resource, Bool success)
+{
+  XEvent async_event;
+
+  /*
+   * Enqueue an event to tell client
+   * the result of GetProperty.
+   */
+
+  async_event.type = ClientMessage;
+
+  async_event.xclient.serial = _NXCollectedProperties[resource] -&gt; sequence;
+
+  async_event.xclient.window       = 0;
+  async_event.xclient.message_type = 0;
+  async_event.xclient.format       = 32;
+
+  async_event.xclient.data.l[0] = NXCollectPropertyNotify;
+  async_event.xclient.data.l[1] = resource;
+  async_event.xclient.data.l[2] = success;
+
+  XPutBackEvent(dpy, &amp;async_event);
+}
+
+static Bool _NXCollectPropertyHandler(Display *dpy, xReply *rep, char *buf,
+                                          int len, XPointer data)
+{
+  register _NXCollectPropertyState *state;
+
+  register xGetPropertyReply *async_rep;
+
+  char *async_head;
+  char *async_data;
+
+  int async_size;
+
+  state = (_NXCollectPropertyState *) data;
+
+  if ((rep -&gt; generic.sequenceNumber % 65536) !=
+          ((int)(state -&gt; sequence) % 65536))
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectPropertyHandler: Unmatched sequence [%d] for opcode [%d] &quot;
+                &quot;with length [%d].\n&quot;, rep -&gt; generic.sequenceNumber, rep -&gt; generic.type,
+                    (int) rep -&gt; generic.length &lt;&lt; 2);
+    #endif
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectPropertyHandler: Going to handle asynchronous GetProperty reply.\n&quot;);
+  #endif
+
+  /*
+   * Reply data is managed asynchronously. We can
+   * use state to get to vector and vector to get
+   * to handler. In this way, we can dequeue and
+   * free the handler itself.
+   */
+
+  DeqAsyncHandler(dpy, state -&gt; handler);
+
+  Xfree(state -&gt; handler);
+
+  state -&gt; handler = NULL;
+
+  if (rep -&gt; generic.type == X_Error)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectPropertyHandler: Error received from X server for resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyProperty(dpy, state -&gt; resource, False);
+
+    _NXCollectedProperties[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectPropertyHandler: Matched request with sequence [%ld].\n&quot;,
+              state -&gt; sequence);
+  #endif
+
+  async_size = SIZEOF(xGetPropertyReply);
+
+  async_head = Xmalloc(async_size);
+
+  if (async_head == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******_NXCollectPropertyHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyProperty(dpy, state -&gt; resource, False);
+
+    _NXCollectedProperties[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectPropertyHandler: Going to get reply with size [%d].\n&quot;,
+              (int) rep -&gt; generic.length &lt;&lt; 2);
+  #endif
+
+  async_rep = (xGetPropertyReply *) _XGetAsyncReply(dpy, async_head, rep, buf, len, 0, False);
+
+  if (async_rep == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******_NXCollectPropertyHandler: PANIC! Failed to get reply with resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyProperty(dpy, state -&gt; resource, False);
+
+    _NXCollectedProperties[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    Xfree(async_head);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectPropertyHandler: Got reply with format [%d] type [%d] size [%d].\n&quot;,
+              async_rep -&gt; format, (int) async_rep -&gt; propertyType, (int) async_rep -&gt; length &lt;&lt; 2);
+
+  fprintf(stderr, &quot;******_NXCollectPropertyHandler: Bytes after [%d] number of items [%d].\n&quot;,
+              (int) async_rep -&gt; bytesAfter, (int) async_rep -&gt; nItems);
+  #endif
+
+  state -&gt; format = async_rep -&gt; format;
+  state -&gt; type   = async_rep -&gt; propertyType;
+  state -&gt; items  = async_rep -&gt; nItems;
+  state -&gt; after  = async_rep -&gt; bytesAfter;
+
+  async_size = async_rep -&gt; length &lt;&lt; 2;
+
+  if (async_size &gt; 0)
+  {
+    async_data = Xmalloc(async_size);
+
+    if (async_data == NULL)
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******_NXCollectPropertyHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
+                  state -&gt; resource);
+      #endif
+
+      _NXNotifyProperty(dpy, state -&gt; resource, False);
+
+      _NXCollectedProperties[state -&gt; resource] = NULL;
+
+      Xfree(state);
+
+      Xfree(async_head);
+
+      return False;
+    }
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectPropertyHandler: Going to get data with size [%d].\n&quot;,
+                async_size);
+    #endif
+
+    _XGetAsyncData(dpy, async_data, buf, len, SIZEOF(xGetPropertyReply), async_size, async_size);
+
+    /*
+     * From now on we can return True, as all
+     * data has been consumed from buffer.
+     */
+
+    state -&gt; data = async_data;
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectPropertyHandler: Successfully stored property data for resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+  }
+  #ifdef TEST
+  else
+  {
+    fprintf(stderr, &quot;******_NXCollectPropertyHandler: WARNING! Null property data stored for resource [%d].\n&quot;,
+                state -&gt; resource);
+  }
+  #endif
+
+  _NXNotifyProperty(dpy, state -&gt; resource, True);
+
+  Xfree(async_head);
+
+  return True;
+}
+
+int NXGetCollectPropertyResource(Display *dpy)
+{
+  int i;
+
+  for (i = 0; i &lt; NXNumberOfResources; i++)
+  {
+    if (_NXCollectedProperties[i] == NULL)
+    {
+      return i;
+    }
+  }
+
+  return -1;
+}
+
+int NXCollectProperty(Display *dpy, unsigned int resource, Window window, Atom property,
+                          long long_offset, long long_length, Bool delete, Atom req_type)
+{
+  register xGetPropertyReq *req;
+
+  _NXCollectPropertyState *state;
+  _XAsyncHandler *handler;
+
+  if (resource &gt;= NXNumberOfResources)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectProperty: PANIC! Provided resource [%u] is out of range.\n&quot;,
+                resource);
+    #endif
+
+    return -1;
+  }
+
+  state = _NXCollectedProperties[resource];
+
+  if (state != NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectProperty: PANIC! Having to remove previous state for resource [%u].\n&quot;,
+                resource);
+    #endif
+
+    if (state -&gt; handler != NULL)
+    {
+      DeqAsyncHandler(dpy, state -&gt; handler);
+
+      Xfree(state -&gt; handler);
+    }
+
+    if (state -&gt; data != NULL)
+    {
+      Xfree(state -&gt; data);
+    }
+
+    Xfree(state);
+
+    _NXCollectedProperties[resource] = NULL;
+  }
+
+  LockDisplay(dpy);
+
+  GetReq(GetProperty, req);
+
+  req -&gt; delete     = delete;
+  req -&gt; window     = window;
+  req -&gt; property   = property;
+  req -&gt; type       = req_type;
+  req -&gt; longOffset = long_offset;
+  req -&gt; longLength = long_length;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXCollectProperty: Sending message opcode [%d] sequence [%ld] for resource [%d].\n&quot;,
+              X_GetProperty, dpy -&gt; request, resource);
+
+  fprintf(stderr, &quot;******NXCollectProperty: Delete [%u] window [%d] property [%d] type [%d].\n&quot;,
+              req -&gt; delete, (int) req -&gt; window, (int) req -&gt; property, (int) req -&gt; type);
+
+  fprintf(stderr, &quot;******NXCollectProperty: Long offset [%d] long length [%d].\n&quot;,
+              (int) req -&gt; longOffset, (int) req -&gt; longLength);
+  #endif
+
+  state   = Xmalloc(sizeof(_NXCollectPropertyState));
+  handler = Xmalloc(sizeof(_XAsyncHandler));
+
+  if (state == NULL || handler == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectProperty: Failed to allocate memory with resource [%d].\n&quot;,
+                resource);
+    #endif
+
+    if (state != NULL)
+    {
+      Xfree(state);
+    }
+
+    if (handler != NULL)
+    {
+      Xfree(handler);
+    }
+
+    UnGetReq(GetProperty);
+
+    UnlockDisplay(dpy);
+
+    return -1;
+  }
+
+  state -&gt; sequence = dpy -&gt; request;
+  state -&gt; resource = resource;
+  state -&gt; window   = window;
+  state -&gt; property = property;
+  state -&gt; type     = 0;
+  state -&gt; format   = 0;
+  state -&gt; items    = 0;
+  state -&gt; after    = 0;
+  state -&gt; data     = NULL;
+
+  state -&gt; handler = handler;
+
+  handler -&gt; next = dpy -&gt; async_handlers;
+  handler -&gt; handler = _NXCollectPropertyHandler;
+  handler -&gt; data = (XPointer) state;
+  dpy -&gt; async_handlers = handler;
+
+  _NXCollectedProperties[resource] = state;
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return True;
+}
+
+int NXGetCollectedProperty(Display *dpy, unsigned int resource, Atom *actual_type_return,
+                               int *actual_format_return, unsigned long *nitems_return,
+                                   unsigned long *bytes_after_return, unsigned char **data)
+{
+  register _NXCollectPropertyState *state;
+
+  state = _NXCollectedProperties[resource];
+
+  if (state == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXGetCollectedProperty: PANIC! No data collected for resource [%u].\n&quot;,
+                resource);
+    #endif
+
+    return 0;
+  }
+
+  *actual_type_return   = state -&gt; type;
+  *actual_format_return = state -&gt; format;
+  *nitems_return        = state -&gt; items;
+  *bytes_after_return   = state -&gt; after;
+
+  *data = (unsigned char *) _NXCollectedProperties[resource] -&gt; data;
+
+  Xfree(state);
+
+  _NXCollectedProperties[resource] = NULL;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXGetCollectedProperty: Returning GetProperty data for resource [%u].\n&quot;,
+              resource);
+  #endif
+
+  return True;
+}
+
+static void _NXNotifyGrabPointer(Display *dpy, int resource, Bool success)
+{
+  XEvent async_event;
+
+  async_event.type = ClientMessage;
+
+  async_event.xclient.serial = _NXCollectedGrabPointers[resource] -&gt; sequence;
+
+  async_event.xclient.window       = 0;
+  async_event.xclient.message_type = 0;
+  async_event.xclient.format       = 32;
+
+  async_event.xclient.data.l[0] = NXCollectGrabPointerNotify;
+  async_event.xclient.data.l[1] = resource;
+  async_event.xclient.data.l[2] = success;
+
+  XPutBackEvent(dpy, &amp;async_event);
+}
+
+static Bool _NXCollectGrabPointerHandler(Display *dpy, xReply *rep, char *buf,
+                                             int len, XPointer data)
+{
+  register _NXCollectGrabPointerState *state;
+
+  register xGrabPointerReply *async_rep;
+
+  char *async_head;
+
+  int async_size;
+
+  state = (_NXCollectGrabPointerState *) data;
+
+  if ((rep -&gt; generic.sequenceNumber % 65536) !=
+          ((int)(state -&gt; sequence) % 65536))
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Unmatched sequence [%d] for opcode [%d] &quot;
+                &quot;with length [%d].\n&quot;, rep -&gt; generic.sequenceNumber, rep -&gt; generic.type,
+                    (int) rep -&gt; generic.length &lt;&lt; 2);
+    #endif
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Going to handle asynchronous GrabPointer reply.\n&quot;);
+  #endif
+
+  DeqAsyncHandler(dpy, state -&gt; handler);
+
+  Xfree(state -&gt; handler);
+
+  state -&gt; handler = NULL;
+
+  if (rep -&gt; generic.type == X_Error)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Error received from X server for resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyGrabPointer(dpy, state -&gt; resource, False);
+
+    _NXCollectedGrabPointers[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Matched request with sequence [%ld].\n&quot;,
+              state -&gt; sequence);
+  #endif
+
+  async_size = SIZEOF(xGrabPointerReply);
+
+  async_head = Xmalloc(async_size);
+
+  if (async_head == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyGrabPointer(dpy, state -&gt; resource, False);
+
+    _NXCollectedGrabPointers[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Going to get reply with size [%d].\n&quot;,
+              (int) rep -&gt; generic.length &lt;&lt; 2);
+  #endif
+
+  async_rep = (xGrabPointerReply *) _XGetAsyncReply(dpy, async_head, rep, buf, len, 0, False);
+
+  if (async_rep == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: PANIC! Failed to get reply with resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyGrabPointer(dpy, state -&gt; resource, False);
+
+    _NXCollectedGrabPointers[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    Xfree(async_head);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectGrabPointerHandler: Got reply with status [%d] size [%d].\n&quot;,
+              async_rep -&gt; status, (int) async_rep -&gt; length &lt;&lt; 2);
+  #endif
+
+  state -&gt; status = async_rep -&gt; status;
+
+  _NXNotifyGrabPointer(dpy, state -&gt; resource, True);
+
+  Xfree(async_head);
+
+  return True;
+}
+
+int NXGetCollectGrabPointerResource(Display *dpy)
+{
+  int i;
+
+  for (i = 0; i &lt; NXNumberOfResources; i++)
+  {
+    if (_NXCollectedGrabPointers[i] == NULL)
+    {
+      return i;
+    }
+  }
+
+  return -1;
+}
+
+int NXCollectGrabPointer(Display *dpy, unsigned int resource, Window grab_window, Bool owner_events,
+                             unsigned int event_mask, int pointer_mode, int keyboard_mode,
+                                 Window confine_to, Cursor cursor, Time time)
+{
+  register xGrabPointerReq *req;
+
+  _NXCollectGrabPointerState *state;
+  _XAsyncHandler *handler;
+
+  if (resource &gt;= NXNumberOfResources)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectGrabPointer: PANIC! Provided resource [%u] is out of range.\n&quot;,
+                resource);
+    #endif
+
+    return -1;
+  }
+
+  state = _NXCollectedGrabPointers[resource];
+
+  if (state != NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectGrabPointer: PANIC! Having to remove previous state for resource [%u].\n&quot;,
+                resource);
+    #endif
+
+    if (state -&gt; handler != NULL)
+    {
+      DeqAsyncHandler(dpy, state -&gt; handler);
+
+      Xfree(state -&gt; handler);
+    }
+
+    Xfree(state);
+
+    _NXCollectedGrabPointers[resource] = NULL;
+  }
+
+  LockDisplay(dpy);
+
+  GetReq(GrabPointer, req);
+
+  req -&gt; grabWindow   = grab_window;
+  req -&gt; ownerEvents  = owner_events;
+  req -&gt; eventMask    = event_mask;
+  req -&gt; pointerMode  = pointer_mode;
+  req -&gt; keyboardMode = keyboard_mode;
+  req -&gt; confineTo    = confine_to;
+  req -&gt; cursor       = cursor;
+  req -&gt; time         = time;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXCollectGrabPointer: Sending message opcode [%d] sequence [%ld] &quot;
+              &quot;for resource [%d].\n&quot;, X_GrabPointer, dpy -&gt; request, resource);
+  #endif
+
+  state   = Xmalloc(sizeof(_NXCollectGrabPointerState));
+  handler = Xmalloc(sizeof(_XAsyncHandler));
+
+  if (state == NULL || handler == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectGrabPointer: Failed to allocate memory with resource [%d].\n&quot;,
+                resource);
+    #endif
+
+    if (state != NULL)
+    {
+      Xfree(state);
+    }
+
+    if (handler != NULL)
+    {
+      Xfree(handler);
+    }
+
+    UnGetReq(GrabPointer);
+
+    UnlockDisplay(dpy);
+
+    return -1;
+  }
+
+  state -&gt; sequence = dpy -&gt; request;
+  state -&gt; resource = resource;
+  state -&gt; status   = 0;
+
+  state -&gt; handler = handler;
+
+  handler -&gt; next = dpy -&gt; async_handlers;
+  handler -&gt; handler = _NXCollectGrabPointerHandler;
+  handler -&gt; data = (XPointer) state;
+  dpy -&gt; async_handlers = handler;
+
+  _NXCollectedGrabPointers[resource] = state;
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return True;
+}
+
+int NXGetCollectedGrabPointer(Display *dpy, unsigned int resource, int *status)
+{
+  register _NXCollectGrabPointerState *state;
+
+  state = _NXCollectedGrabPointers[resource];
+
+  if (state == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXGetCollectedGrabPointer: PANIC! No data collected for resource [%u].\n&quot;,
+                resource);
+    #endif
+
+    return 0;
+  }
+
+  *status = state -&gt; status;
+
+  Xfree(state);
+
+  _NXCollectedGrabPointers[resource] = NULL;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXGetCollectedGrabPointer: Returning GrabPointer data for resource [%u].\n&quot;,
+              resource);
+  #endif
+
+  return True;
+}
+
+static void _NXNotifyInputFocus(Display *dpy, int resource, Bool success)
+{
+  XEvent async_event;
+
+  async_event.type = ClientMessage;
+
+  async_event.xclient.serial = _NXCollectedInputFocuses[resource] -&gt; sequence;
+
+  async_event.xclient.window       = 0;
+  async_event.xclient.message_type = 0;
+  async_event.xclient.format       = 32;
+
+  async_event.xclient.data.l[0] = NXCollectInputFocusNotify;
+  async_event.xclient.data.l[1] = resource;
+  async_event.xclient.data.l[2] = success;
+
+  XPutBackEvent(dpy, &amp;async_event);
+}
+
+static Bool _NXCollectInputFocusHandler(Display *dpy, xReply *rep, char *buf,
+                                            int len, XPointer data)
+{
+  register _NXCollectInputFocusState *state;
+
+  register xGetInputFocusReply *async_rep;
+
+  char *async_head;
+
+  int async_size;
+
+  state = (_NXCollectInputFocusState *) data;
+
+  if ((rep -&gt; generic.sequenceNumber % 65536) !=
+          ((int)(state -&gt; sequence) % 65536))
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Unmatched sequence [%d] for opcode [%d] &quot;
+                &quot;with length [%d].\n&quot;, rep -&gt; generic.sequenceNumber, rep -&gt; generic.type,
+                    (int) rep -&gt; generic.length &lt;&lt; 2);
+    #endif
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Going to handle asynchronous GetInputFocus reply.\n&quot;);
+  #endif
+
+  DeqAsyncHandler(dpy, state -&gt; handler);
+
+  Xfree(state -&gt; handler);
+
+  state -&gt; handler = NULL;
+
+  if (rep -&gt; generic.type == X_Error)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Error received from X server for resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyInputFocus(dpy, state -&gt; resource, False);
+
+    _NXCollectedInputFocuses[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Matched request with sequence [%ld].\n&quot;,
+              state -&gt; sequence);
+  #endif
+
+  async_size = SIZEOF(xGetInputFocusReply);
+
+  async_head = Xmalloc(async_size);
+
+  if (async_head == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******_NXCollectInputFocusHandler: PANIC! Failed to allocate memory with resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyInputFocus(dpy, state -&gt; resource, False);
+
+    _NXCollectedInputFocuses[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Going to get reply with size [%d].\n&quot;,
+              (int) rep -&gt; generic.length &lt;&lt; 2);
+  #endif
+
+  async_rep = (xGetInputFocusReply *) _XGetAsyncReply(dpy, async_head, rep, buf, len, 0, False);
+
+  if (async_rep == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******_NXCollectInputFocusHandler: PANIC! Failed to get reply with resource [%d].\n&quot;,
+                state -&gt; resource);
+    #endif
+
+    _NXNotifyInputFocus(dpy, state -&gt; resource, False);
+
+    _NXCollectedInputFocuses[state -&gt; resource] = NULL;
+
+    Xfree(state);
+
+    Xfree(async_head);
+
+    return False;
+  }
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******_NXCollectInputFocusHandler: Got reply with focus [%d] revert to [%d] &quot;
+              &quot;size [%d].\n&quot;, (int) async_rep -&gt; focus, (int) async_rep -&gt; revertTo,
+                  (int) async_rep -&gt; length &lt;&lt; 2);
+  #endif
+
+  state -&gt; focus     = async_rep -&gt; focus;
+  state -&gt; revert_to = async_rep -&gt; revertTo;
+
+  _NXNotifyInputFocus(dpy, state -&gt; resource, True);
+
+  Xfree(async_head);
+
+  return True;
+}
+
+int NXGetCollectInputFocusResource(Display *dpy)
+{
+  int i;
+
+  for (i = 0; i &lt; NXNumberOfResources; i++)
+  {
+    if (_NXCollectedInputFocuses[i] == NULL)
+    {
+      return i;
+    }
+  }
+
+  return -1;
+}
+
+int NXCollectInputFocus(Display *dpy, unsigned int resource)
+{
+  register xReq *req;
+
+  _NXCollectInputFocusState *state;
+  _XAsyncHandler *handler;
+
+  if (resource &gt;= NXNumberOfResources)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectInputFocus: PANIC! Provided resource [%u] is out of range.\n&quot;,
+                resource);
+    #endif
+
+    return -1;
+  }
+
+  state = _NXCollectedInputFocuses[resource];
+
+  if (state != NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectInputFocus: PANIC! Having to remove previous state for resource [%u].\n&quot;,
+                resource);
+    #endif
+
+    if (state -&gt; handler != NULL)
+    {
+      DeqAsyncHandler(dpy, state -&gt; handler);
+
+      Xfree(state -&gt; handler);
+    }
+
+    Xfree(state);
+
+    _NXCollectedInputFocuses[resource] = NULL;
+  }
+
+  LockDisplay(dpy);
+
+  GetEmptyReq(GetInputFocus, req);
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXCollectInputFocus: Sending message opcode [%d] sequence [%ld] for resource [%d].\n&quot;,
+              X_GetInputFocus, dpy -&gt; request, resource);
+  #endif
+
+  state   = Xmalloc(sizeof(_NXCollectInputFocusState));
+  handler = Xmalloc(sizeof(_XAsyncHandler));
+
+  if (state == NULL || handler == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXCollectInputFocus: Failed to allocate memory with resource [%d].\n&quot;,
+                resource);
+    #endif
+
+    if (state != NULL)
+    {
+      Xfree(state);
+    }
+
+    if (handler != NULL)
+    {
+      Xfree(handler);
+    }
+
+    UnGetEmptyReq();
+
+    UnlockDisplay(dpy);
+
+    return -1;
+  }
+
+  state -&gt; sequence  = dpy -&gt; request;
+  state -&gt; resource  = resource;
+  state -&gt; focus     = 0;
+  state -&gt; revert_to = 0;
+
+  state -&gt; handler = handler;
+
+  handler -&gt; next = dpy -&gt; async_handlers;
+  handler -&gt; handler = _NXCollectInputFocusHandler;
+  handler -&gt; data = (XPointer) state;
+  dpy -&gt; async_handlers = handler;
+
+  _NXCollectedInputFocuses[resource] = state;
+
+  UnlockDisplay(dpy);
+
+  SyncHandle();
+
+  return True;
+}
+
+int NXGetCollectedInputFocus(Display *dpy, unsigned int resource,
+                                 Window *focus_return, int *revert_to_return)
+{
+  register _NXCollectInputFocusState *state;
+
+  state = _NXCollectedInputFocuses[resource];
+
+  if (state == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******NXGetCollectedInputFocus: PANIC! No data collected for resource [%u].\n&quot;,
+                resource);
+    #endif
+
+    return 0;
+  }
+
+  *focus_return     = state -&gt; focus;
+  *revert_to_return = state -&gt; revert_to;
+
+  Xfree(state);
+
+  _NXCollectedInputFocuses[resource] = NULL;
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******NXGetCollectedInputFocus: Returning GetInputFocus data for resource [%u].\n&quot;,
+              resource);
+  #endif
+
+  return True;
+}
+
+#ifdef DUMP
+
+void _NXDumpData(const unsigned char *buffer, unsigned int size)
+{
+  if (buffer != NULL)
+  {
+    unsigned int i = 0;
+
+    unsigned int ii;
+
+    while (i &lt; size)
+    {
+      fprintf(stderr, &quot;[%d]\t&quot;, i);
+
+      for (ii = 0; i &lt; size &amp;&amp; ii &lt; 8; i++, ii++)
+      {
+        fprintf(stderr, &quot;%d\t&quot;, (unsigned int) (buffer[i]));
+      }
+
+      fprintf(stderr, &quot;\n&quot;);
+    }
+  }
+}
+
+#endif
diff --git a/nxcompext/NXlib.h b/nxcompext/NXlib.h
new file mode 100644
index 0000000..d77ff60
--- /dev/null
+++ b/nxcompext/NXlib.h
@@ -0,0 +1,904 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef NXlib_H
+#define NXlib_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &lt;X11/X.h&gt;
+#include &lt;X11/Xlib.h&gt;
+
+#include &quot;NX.h&quot;
+#include &quot;NXpack.h&quot;
+#include &quot;NXproto.h&quot;
+#include &quot;NXvars.h&quot;
+
+/*
+ * All the NX code should use these.
+ */
+
+#define Xmalloc(size) malloc((size))
+#define Xfree(ptr)    free((ptr))
+ 
+/*
+ * Maximum number of supported pack methods.
+ */
+
+#define NXNumberOfPackMethods  128
+
+/*
+ * Assume this as the limit of resources that
+ * can be provided to the split and unpack
+ * requests.
+ */
+
+#define NXNumberOfResources    256
+
+#define NXNoResource           256 + 1
+#define NXAnyResource          256 + 2
+
+/*
+ * Initialize the internal structures used by
+ * the library. Should be executed again after
+ * having reopened the display.
+ */
+
+extern int NXInitDisplay(
+#if NeedFunctionPrototypes
+    Display*            /* display */
+#endif
+);
+
+/*
+ * Reset all the internal structures. Should be
+ * executed after closing the display.
+ */
+
+extern int NXResetDisplay(
+#if NeedFunctionPrototypes
+    Display*            /* display */
+#endif
+);
+
+/*
+ * Set the NX display flush policy. The policy can
+ * be either NXFlushDeferred or NXFlushImmediate.
+ */
+
+extern int NXSetDisplayPolicy(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    int                 /* policy */
+#endif
+);
+
+/*
+ * Set the display output buffer size.
+ */
+
+extern int NXSetDisplayBuffer(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    int                 /* size */
+#endif
+);
+
+/*
+ * If set, the Popen() function in the X server
+ * wil remove the LD_LIBRARY_PATH variable from
+ * the environment before calling the execl()
+ * function on the child process. The function
+ * returns the previous value.
+ */
+
+extern int NXUnsetLibraryPath(
+#if NeedFunctionPrototypes
+    int                 /* value */
+#endif
+);
+
+/*
+ * If the parameter is true, the Xlib I/O error
+ * handler will return, instead of quitting the
+ * program. The function returns the previous
+ * value.
+ */
+
+extern int NXHandleDisplayError(
+#if NeedFunctionPrototypes
+    int                 /* value */
+#endif
+);
+
+/*
+ * Shutdown the display descriptor and force Xlib
+ * to set the I/O error flag.
+ */
+
+extern Bool NXForceDisplayError(
+#if NeedFunctionPrototypes
+    Display*            /* display */
+#endif
+);
+
+/*
+ * Check the value of the XlibDisplayIOError flag.
+ * If not set, try to call the display error hand-
+ * ler to give to the application a chance to see
+ * whether it needs to close the connection.
+ */
+
+extern int NXDisplayError(
+#if NeedFunctionPrototypes
+    Display*            /* display */
+#endif
+);
+
+/*
+ * Query the number of bytes readable from the
+ * display connection.
+ */
+
+extern int NXDisplayReadable(
+#if NeedFunctionPrototypes
+    Display*            /* display */
+#endif
+);
+
+/*
+ * Query the number of the outstanding bytes to
+ * flush to the display connection.
+ */
+
+extern int NXDisplayFlushable(
+#if NeedFunctionPrototypes
+    Display*            /* display */
+#endif
+);
+
+/*
+ * Return a value between 0 and 9 indicating the
+ * congestion level of the NX transport based on
+ * the tokens remaining. A value of 9 means that
+ * the link is congested and no further data can
+ * be sent.
+ */
+
+extern int NXDisplayCongestion(
+#if NeedFunctionPrototypes
+    Display*            /* display */
+#endif
+);
+
+/*
+ * Flush the Xlib display buffer and/or the
+ * outstanding data accumulated by the NX
+ * transport.
+ */
+
+extern int NXFlushDisplay(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    int                 /* what */
+#endif
+);
+
+/*
+ * Public interfaces used to set the handlers.
+ * They all return the previous handler.
+ */
+
+extern NXDisplayErrorPredicate NXSetDisplayErrorPredicate(
+#if NeedFunctionPrototypes
+    NXDisplayErrorPredicate /* predicate */
+#endif
+);
+
+/*
+ * Called when the display blocks waiting to read or
+ * write more data.
+ */
+
+extern NXDisplayBlockHandler NXSetDisplayBlockHandler(
+#if NeedFunctionPrototypes
+    NXDisplayBlockHandler /* handler */
+#endif
+);
+
+/*
+ * Called after more data is written to the display.
+ * When the NX transport is running, data may be queued
+ * until an explicit flush.
+ */
+
+extern NXDisplayWriteHandler NXSetDisplayWriteHandler(
+#if NeedFunctionPrototypes
+    NXDisplayWriteHandler /* handler */
+#endif
+);
+
+/*
+ * Called after more data is sent to the remote proxy.
+ *
+ * Here the display pointer is passed as the second
+ * parameter to make clear that the function does not
+ * tie the callback to the display, but, similarly to
+ * all the Xlib error handlers, to a global variable
+ * shared by all the Xlib functions. The display
+ * pointer will be passed back by nxcomp at the time
+ * it will call the handler. This is because nxcomp
+ * doesn't have access to the display structure.
+ */
+
+extern NXDisplayFlushHandler NXSetDisplayFlushHandler(
+#if NeedFunctionPrototypes
+    NXDisplayFlushHandler      /* handler */,
+    Display*                   /* display */
+#endif
+);
+
+/*
+ * Get an arbitrary null terminated buffer to be added
+ * to the NX statistics.
+ */
+
+extern NXDisplayStatisticsHandler NXSetDisplayStatisticsHandler(
+#if NeedFunctionPrototypes
+    NXDisplayStatisticsHandler /* handler */,
+    char **                    /* buffer */
+#endif
+);
+
+/*
+ * Redefine the function called by Xlib in the case of
+ * an out-of-order sequence number received in the X
+ * protocol stream.
+ */
+ 
+extern NXLostSequenceHandler NXSetLostSequenceHandler(
+#if NeedFunctionPrototypes
+    NXLostSequenceHandler /* handler */
+#endif
+);
+
+/*
+ * The agent should get the NX parameters at startup, just after
+ * having opened the display. If the agent is not able to satisfy
+ * the pack method set by user (because a method is not applica-
+ * ble, it is not supported by the remote or it simply requires a
+ * screen depth greater than the depth available), it should fall
+ * back to the nearest method of the same type.
+ */
+
+extern Status NXGetControlParameters(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int*       /* link_type */,
+    unsigned int*       /* local_major */,
+    unsigned int*       /* local_minor */,
+    unsigned int*       /* local_patch */,
+    unsigned int*       /* remote_major */,
+    unsigned int*       /* remote_minor */,
+    unsigned int*       /* remote_patch */,
+    int*                /* frame_timeout */,
+    int*                /* ping_timeout */,
+    int*                /* split_mode */,
+    int*                /* split_size */,
+    unsigned int*       /* pack_method */,
+    unsigned int*       /* pack_quality */,
+    int*                /* data_level */,
+    int*                /* stream_level */,
+    int*                /* delta_level */,
+    unsigned int*       /* load_cache */,
+    unsigned int*       /* save_cache */,
+    unsigned int*       /* startup_cache */
+#endif
+);
+
+/*
+ * Which unpack methods are supported by the remote proxy?
+ */
+
+extern Status NXGetUnpackParameters(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int*       /* entries */,
+    unsigned char[]     /* supported_methods */
+#endif
+);
+
+/*
+ * Query and enable shared memory support on path agent to X
+ * client proxy and X server proxy to real X server. At the
+ * moment only the path proxy to real X server is implemented.
+ * On return flags will say if support has been successfully
+ * activated. Segments will contain the XID associated to the
+ * shared memory blocks. A MIT-SHM compliant protocol is used
+ * between proxy and the real server, while a simplified
+ * version is used between the agent and the client proxy to
+ * accomodate both packed images and plain X bitmaps.
+ */
+
+extern Status NXGetShmemParameters(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int*       /* enable_client  */,
+    unsigned int*       /* enable_server */,
+    unsigned int*       /* client_segment */,
+    unsigned int*       /* server_segment */,
+    unsigned int*       /* client_size */,
+    unsigned int*       /* server_size */
+#endif
+);
+
+/*
+ * Get the path to the font server that can be used by the X
+ * server to tunnel the font connections across the NX link.
+ * The path actually represents the TCP port where the proxy
+ * on the NX client side is listening. The agent can tempora-
+ * rily enable the tunneling when it needs a font that is not
+ * available on the client, for example when the session is
+ * migrated from a different X server.
+ */
+
+extern Status NXGetFontParameters(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* path_length */,
+    char[]              /* path_data */
+#endif
+);
+
+/*
+ * This set of functions is used to leverage the image stream-
+ * ing capabilities built in nxcomp. An image can be streamed
+ * by sending a start-split message, followed by the X messages
+ * that will have to be split by the proxy, followed by an end-
+ * split closure. Usually, in the middle of a start-split/end-
+ * split sequence there will be a single PutImage() or PutPack-
+ * edImage(), that, in turn, can generate multiple partial
+ * requests, like a SetUnpackColormap() and SetUnpackAlpha()
+ * that will be later used to decompress the image to its ori-
+ * ginal form. Multiple requests may be also generated because
+ * of the maximum size of a X request being exceeded, so that
+ * Xlib has to divide the single image in multiple sub-image re-
+ * quests. The agent doesn't need to take care of these details
+ * but will rather have to track the result of the split opera-
+ * tion. By monitoring the notify events sent by the proxy, the
+ * agent will have to implement its own strategy to deal with
+ * the resources. For example, it will be able to:
+ *
+ * - Mark a drawable as dirty, if the image was not sent
+ *   synchronously, in the main X oputput stream.
+ *
+ * - Choose to commit or discard the original image, at the
+ *   time it will be recomposed at the remote side. This may
+ *   include all the messages that were part of the split
+ *   (the colormap, the alpha channel, etc.)
+ *
+ * - Mark the drawable as clean again, if the image was
+ *   committed and the drawable didn't change in the mean-
+ *   while.
+ *
+ * At the time the proxy receives the end-split, it reports the
+ * result of the operation to the agent. The agent will be able
+ * to identify the original split operation (the one referenced
+ * in the start-split/end-split sequence) by the small integer
+ * number (0-255) named 'resource' sent in the events.
+ *
+ * One of the following cases may be encountered:
+ *
+ *
+ * NXNoSplitNotify      All messages were sent in the main out-
+ *                      put stream, so that no split actually
+ *                      took place.
+ *
+ * NXStartSplitNotify   One or more messages were split, so,
+ *                      at discrection of the agent, the client
+ *                      may be suspended until the transferral
+ *                      is completed.
+ *
+ * NXCommitSplitNotify  One of the requests that made up the
+ *                      split was recomposed. The agent should
+ *                      either commit the given request or tell
+ *                      the proxy to discard it.
+ *
+ * NXEndSplitNotify     The split was duly completed. The agent
+ *                      can restart the client.
+ *
+ * NXEmptySplitNotify   No more split operation are pending.
+ *                      The agent can use this information to
+ *                      implement specific strategies requiring
+ *                      that all messages have been recomposed
+ *                      at the remote end, like updating the
+ *                      drawables that were not synchronized
+ *                      because of the lazy encoding.
+ *
+ * The 'mode' field that is sent by the agent in the start-split
+ * request, determines the strategy that the proxy will adopt to
+ * deal with the image. If set to 'eager', the proxy will only
+ * split the messages whose size exceeds the split threshold (the
+ * current threshold can be found in the NXGetControlParameters()
+ * reply). If the mode is set to lazy, the proxy will split any
+ * image that would have generated an actual transfer of the data
+ * part (in practice all images that are not found in the cache).
+ * This second strategy can be leveraged by an agent to further
+ * reduce the bandwidth requirements. For example, by setting the
+ * mode to lazy and by monitoring the result, an agent can easi-
+ * ly verify if the drawable was successfully updated, mark the
+ * drawable if not, and synchronize it at later time.
+ *
+ * See NXproto.h for the definition of the available modes.
+ */
+
+extern unsigned int NXAllocSplit(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */
+#endif
+);
+
+extern int NXStartSplit(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    unsigned int        /* mode */
+#endif
+);
+
+extern int NXEndSplit(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */
+#endif
+);
+
+extern int NXCommitSplit(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    unsigned int        /* propagate */,
+    unsigned char       /* request */,
+    unsigned int        /* position */
+#endif
+);
+
+extern int NXAbortSplit(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */
+#endif
+);
+
+extern int NXFinishSplit(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */
+#endif
+);
+
+extern int NXFreeSplit(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */
+#endif
+);
+
+extern int NXSetExposeParameters(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    int                 /* expose */,
+    int                 /* graphics_expose */,
+    int                 /* no_expose */
+#endif
+);
+
+extern int NXSetCacheParameters(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    int                 /* enable_cache */,
+    int                 /* enable_split */,
+    int                 /* enable_save */,
+    int                 /* enable_load */
+#endif
+);
+
+extern unsigned int NXAllocUnpack(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */
+#endif
+);
+
+extern int NXSetUnpackGeometry(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    Visual*             /* visual */
+#endif
+);
+
+extern int NXSetUnpackColormap(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    unsigned int        /* method */,
+    unsigned int        /* entries */,
+    const char*         /* data */,
+    unsigned int        /* data_length */
+#endif
+);
+
+extern int NXSetUnpackAlpha(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    unsigned int        /* method */,
+    unsigned int        /* entries */,
+    const char*         /* data */,
+    unsigned int        /* data_length */
+#endif
+);
+
+extern int NXSetUnpackColormapCompat(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    unsigned int        /* entries */,
+    const char*         /* data */
+#endif
+);
+
+extern int NXSetUnpackAlphaCompat(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    unsigned int        /* entries */,
+    const char*         /* data */
+#endif
+);
+
+extern int NXFreeUnpack(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */
+#endif
+);
+
+/*
+ * A packed image is a XImage but with
+ * offset field containing total amount
+ * of packed image data.
+ */
+
+typedef XImage NXPackedImage;
+
+NXPackedImage *NXCreatePackedImage(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    Visual*             /* visual */,
+    unsigned int        /* method */,
+    unsigned int        /* depth */,
+    int                 /* format */,
+    char*               /* data */,
+    int                 /* data_length */,
+    unsigned int        /* width */,
+    unsigned int        /* height */,
+    int                 /* bitmap_pad */,
+    int                 /* bytes_per_line */
+#endif
+);
+
+extern int NXDestroyPackedImage(
+#if NeedFunctionPrototypes
+    NXPackedImage*      /* image */
+#endif
+);
+
+NXPackedImage *NXPackImage(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    XImage*             /* src_image */,
+    unsigned int        /* method */
+#endif
+);
+
+NXPackedImage *NXInPlacePackImage(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    XImage*             /* src_image */,
+    unsigned int        /* method */
+#endif
+);
+
+/*
+ * GC is declared void * to get rid of mess
+ * with different GC definitions in some X
+ * server code (like in nxagent).
+ */
+
+extern int NXPutPackedImage(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    Drawable            /* drawable */,
+    void*               /* gc */,
+    NXPackedImage*      /* image */,
+    unsigned int        /* method */,
+    unsigned int        /* depth */,
+    int                 /* src_x */,
+    int                 /* src_y */,
+    int                 /* dst_x */,
+    int                 /* dst_y */,
+    unsigned int        /* width */,
+    unsigned int        /* height */
+#endif
+);
+
+/*
+ * Get multiple colors with a single call by
+ * pipelining X_AllocColor requests/replies.
+ */
+
+extern int NXAllocColors(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    Colormap            /* colormap */,
+    unsigned int        /* entries */,
+    XColor[]            /* screens_in_out */,
+    Bool []             /* flags allocation errors */
+#endif
+);
+
+/*
+ * Encode the data in the given format.
+ */
+
+extern char *NXEncodeColormap(
+#if NeedFunctionPrototypes
+    const char*         /* src_data */,
+    unsigned int        /* src_size */,
+    unsigned int*       /* dst_size */
+#endif
+);
+
+extern char *NXEncodeAlpha(
+#if NeedFunctionPrototypes
+    const char*         /* src_data */,
+    unsigned int        /* src_size */,
+    unsigned int*       /* dst_size */
+#endif
+);
+
+extern NXPackedImage *NXEncodeRgb(
+#if NeedFunctionPrototypes
+    XImage*             /* src_image */,
+    unsigned int        /* method */,
+    unsigned int        /* quality */
+#endif
+);
+
+extern NXPackedImage *NXEncodeRle(
+#if NeedFunctionPrototypes
+    XImage*             /* src_image */,
+    unsigned int        /* method */,
+    unsigned int        /* quality */
+#endif
+);
+
+extern NXPackedImage *NXEncodeJpeg(
+#if NeedFunctionPrototypes
+    XImage*             /* src_image */,
+    unsigned int        /* method */,
+    unsigned int        /* quality */
+#endif
+);
+
+typedef struct
+{
+  long pixel;
+  int found;
+
+} NXColorTable;
+
+extern int NXEncodeColors(
+#if NeedFunctionPrototypes
+  XImage*                 /* src_image */,
+  NXColorTable*           /* color_table */,
+  int                     /* nb_max */
+#endif
+);
+
+extern NXPackedImage *NXEncodePng(
+#if NeedFunctionPrototypes
+    XImage*             /* src_image */,
+    unsigned int        /* method */,
+    unsigned int        /* quality */
+#endif
+);
+
+extern NXPackedImage *NXEncodeBitmap(
+#if NeedFunctionPrototypes
+    XImage*             /* src_image */,
+    unsigned int        /* method */,
+    unsigned int        /* quality */
+#endif
+);
+
+extern int NXCleanImage(
+#if NeedFunctionPrototypes
+    XImage*
+#endif
+);
+
+extern void NXMaskImage(
+#if NeedFunctionPrototypes
+    XImage*              /* pointer to image to mask */ ,
+    unsigned int         /* method */
+#endif
+);
+
+extern int NXImageCacheSize;
+
+extern void NXInitCache(
+#if NeedFunctionPrototypes
+    Display*             /* display */,
+    int                  /* entries in image cache */
+#endif
+);
+
+extern void NXFreeCache(
+#if NeedFunctionPrototypes
+    Display*             /* display */
+#endif
+);
+
+extern XImage *NXCacheFindImage(
+#if NeedFunctionPrototypes
+    NXPackedImage*       /* packed image to find */,
+    unsigned int*        /* pointer to the pack method if found */,
+    unsigned char**      /* pointer to the calculated MD5 if found */
+#endif
+);
+
+extern int NXCacheAddImage(
+#if NeedFunctionPrototypes
+    NXPackedImage*       /* packed image to be added to the cache */,
+    unsigned int         /* pack method of the image to add */,
+    unsigned char*       /* pointer to MD5 of the original unpacked image */
+#endif
+);
+
+
+extern int NXGetCollectImageResource(
+#if NeedFunctionPrototypes
+    Display*            /* display */
+#endif
+);
+
+extern int NXCollectImage(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    Drawable            /* drawable */,
+    int                 /* src_x */,
+    int                 /* src_y */,
+    unsigned int        /* width */,
+    unsigned int        /* height */,
+    unsigned long       /* plane_mask */,
+    int                 /* format */
+#endif
+);
+
+extern int NXGetCollectedImage(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    XImage**            /* image */
+#endif
+);
+
+extern int NXGetCollectPropertyResource(
+#if NeedFunctionPrototypes
+    Display*            /* display */
+#endif
+);
+
+extern int NXCollectProperty(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    Window              /* window */,
+    Atom                /* property */,
+    long                /* long_offset */,
+    long                /* long_length */,
+    Bool                /* delete */,
+    Atom                /* req_type */
+#endif
+);
+
+extern int NXGetCollectedProperty(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    Atom*               /* actual_type_return */,
+    int*                /* actual_format_return */,
+    unsigned long*      /* nitems_return */,
+    unsigned long*      /* bytes_after_return */,
+    unsigned char**     /* data */
+#endif
+);
+
+extern int NXGetCollectGrabPointerResource(
+#if NeedFunctionPrototypes
+    Display*            /* display */
+#endif
+);
+
+extern int NXCollectGrabPointer(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    Window              /* grab_window */,
+    Bool                /* owner_events */,
+    unsigned int        /* event_mask */,
+    int                 /* pointer_mode */,
+    int                 /* keyboard_mode */,
+    Window              /* confine_to */,
+    Cursor              /* cursor */,
+    Time                /* time */
+#endif
+);
+
+extern int NXGetCollectedGrabPointer(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    int*                /* status */
+#endif
+);
+
+extern int NXGetCollectInputFocusResource(
+#if NeedFunctionPrototypes
+    Display*            /* display */
+#endif
+);
+
+extern int NXCollectInputFocus(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */
+#endif
+);
+
+extern int NXGetCollectedInputFocus(
+#if NeedFunctionPrototypes
+    Display*            /* display */,
+    unsigned int        /* resource */,
+    Window*             /* focus_return */,
+    int*                /* revert_to_return */
+#endif
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NXlib_H */
diff --git a/nxcompext/NXlibint.h b/nxcompext/NXlibint.h
new file mode 100644
index 0000000..37ba637
--- /dev/null
+++ b/nxcompext/NXlibint.h
@@ -0,0 +1,31 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef NXlibint_H
+#define NXlibint_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;NXvars.h&quot;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NXlibint_H */
diff --git a/nxcompext/Pgn.c b/nxcompext/Pgn.c
new file mode 100644
index 0000000..d8fa919
--- /dev/null
+++ b/nxcompext/Pgn.c
@@ -0,0 +1,722 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;Xutil.h&quot;
+
+#include &quot;NXlib.h&quot;
+
+#include &quot;Mask.h&quot;
+#include &quot;Pgn.h&quot;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+/*
+ * Selected ZLIB compression level.
+ */
+
+#define PNG_Z_LEVEL   4
+
+/*
+ * Local function prototypes.
+ */
+
+static void PrepareRowForPng(CARD8 *dst, int y, int count);
+static void PrepareRowForPng24(CARD8 *dst, int y, int count);
+static void PrepareRowForPng16(CARD8 *dst, int y, int count);
+static void PrepareRowForPng32(CARD8 *dst, int y, int count);
+
+static void PngWriteData(png_structp png_ptr, png_bytep data, png_size_t length);
+static void PngFlushData(png_structp png_ptr);
+
+/*
+ * Image characteristics.
+ */
+
+static int bytesPerLine;
+static int byteOrder;
+
+static CARD8 bitsPerPixel;
+static CARD16 redMax, greenMax, blueMax;
+static CARD8 redShift, greenShift, blueShift;
+
+/*
+ * Other variables used for the Png
+ * encoding.
+ */
+
+png_byte    color_type;
+png_structp png_ptr;
+png_infop   info_ptr;
+png_colorp  palette;
+static char *pngCompBuf;
+static int  pngDataLen;
+static char *pngBeforeBuf = NULL;
+
+/*
+ * Allocate data for the compressed image.
+ * We need to ensure that there is enough
+ * space to include the palette and the
+ * header.
+ */
+
+#define PNG_DEST_SIZE(width, height) ((width) * 3 * (height) + 1024 + 256)
+
+/*
+ * Just for debug purposes.
+ */
+
+#ifdef DEBUG
+
+static int  pngId;
+static char pngName[10];
+static FILE *pngFile;
+
+#endif
+
+int PngCompareColorTable(NXColorTable *c1, NXColorTable *c2)
+{
+  return (c1 -&gt; pixel - c2 -&gt; pixel);
+}
+
+#define NB_COLOR_MAX 256
+
+int NXCreatePalette32(XImage *src_image, NXColorTable *color_table, CARD8 *image_index, int nb_max)
+{
+  int    x, y, t, p;
+  CARD8 *fbptr;
+  CARD32 pixel;
+
+  fbptr = (CARD8 *) (src_image -&gt; data);
+
+  /*
+   * TODO: Find a more intelligent way to
+   * estimate the number of colors.
+   */
+
+  memset(color_table, 0, nb_max * sizeof(NXColorTable));
+
+  for (x = 0, p = 0; x &lt; src_image -&gt; height; x++)
+  {
+    for (y = 0; y &lt; src_image -&gt; width; y++)
+    {
+      if (byteOrder == LSBFirst)
+      {
+        pixel = (CARD32) *(fbptr + 3);
+        pixel = (pixel &lt;&lt; 8) | (CARD32) *(fbptr + 2);
+        pixel = (pixel &lt;&lt; 8) | (CARD32) *(fbptr + 1);
+        pixel = (pixel &lt;&lt; 8) | (CARD32) *fbptr;
+      }
+      else
+      {
+        pixel = (CARD32) *fbptr;
+        pixel = (pixel &lt;&lt; 8) | (CARD32) *(fbptr + 1);
+        pixel = (pixel &lt;&lt; 8) | (CARD32) *(fbptr + 2);
+        pixel = (pixel &lt;&lt; 8) | (CARD32) *(fbptr + 3);
+      }
+
+      fbptr += 4;
+
+      for (t = 0; t &lt; nb_max; t++)
+      {
+        if (color_table[t].found == 0)
+        {
+          color_table[t].pixel =  pixel;
+          color_table[t].found =  1;
+          p++;
+          image_index[((x * src_image -&gt; width) + y)] = t;
+
+          break;
+        }
+        else if ((CARD32)(color_table[t].pixel) == pixel)
+        {
+          image_index[((x * src_image -&gt; width) + y)] = t;
+
+          break;
+        }
+      }
+
+      if (p == nb_max)
+      {
+        return nb_max + 1;
+      }
+    }
+  }
+  return p;
+}
+
+int NXCreatePalette16(XImage *src_image, NXColorTable *color_table, CARD8 *image_index, int nb_max)
+{
+  int    x, y, t, p;
+  CARD8 *fbptr;
+  CARD16 pixel;
+
+  fbptr = (CARD8 *) (src_image -&gt; data);
+
+  /*
+   * TODO: Find a more intelligent way to
+   * estimate the number of colors.
+   */
+
+  memset(color_table, 0, nb_max * sizeof(NXColorTable));
+
+  for (x = 0, p = 0; x &lt; src_image -&gt; height; x++)
+  {
+    for (y = 0; y &lt; src_image -&gt; width; y++)
+    {
+      if (byteOrder == LSBFirst)
+      {
+        pixel = (CARD16) *(fbptr + 1);
+        pixel = (pixel &lt;&lt; 8) | (CARD16) *fbptr;
+      }
+      else
+      {
+        pixel = (CARD16) *fbptr;
+        pixel = (pixel &lt;&lt; 8) | (CARD16) *(fbptr + 1);
+      }
+
+      fbptr += 2;
+
+      for (t = 0; t &lt; nb_max; t++)
+      {
+        if (color_table[t].found == 0)
+        {
+          color_table[t].pixel =  pixel;
+          color_table[t].found =  1;
+          p++;
+          image_index[((x * src_image -&gt; width) + y)] = t;
+
+          break;
+        }
+        else if ((color_table[t].pixel) == pixel)
+        {
+          image_index[((x * src_image -&gt; width) + y)] = t;
+
+          break;
+        }
+      }
+
+      /*
+       * In case the number of 16bit words is not even
+       * we have 2 padding bytes that we have to skip.
+       */
+
+      if ((y == src_image -&gt; width - 1) &amp;&amp; (src_image -&gt; width % 2 == 1)) fbptr += 2;
+
+      if (p == nb_max)
+      {
+        return nb_max + 1;
+      }
+    }
+  }
+
+  return p;
+}
+
+char *PngCompressData(XImage *image, int *compressed_size)
+{
+  unsigned int num = 0;
+  CARD8        *srcBuf;
+
+  int dy, w, h;
+
+  int nb_colors;
+
+  NXColorTable color_table[NB_COLOR_MAX];
+  CARD8       *image_index;
+
+  image_index = (CARD8 *) malloc((image -&gt; height) * (image -&gt; width) * sizeof(CARD8));
+
+  /*
+   * TODO: Be sure the padded bytes are cleaned.
+   * It would be better to set to zero the bytes
+   * that are not alligned to the word boundary
+   * at the end of the procedure.
+   */
+
+  memset(image_index, 0, (image -&gt; height) * (image -&gt; width) * sizeof(CARD8));
+
+  *compressed_size = 0;
+
+  pngDataLen = 0;
+
+  /*
+   * Initialize the image stuff.
+   */
+
+  bitsPerPixel = image -&gt; bits_per_pixel;
+  bytesPerLine = image -&gt; bytes_per_line;
+  byteOrder = image -&gt; byte_order;
+
+  if (bitsPerPixel &lt; 15)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******PngCompressData: PANIC! Can't compress images with [%d] bits per pixel.\n&quot;,
+                bitsPerPixel);
+    #endif
+
+    return NULL;
+  }
+
+  redShift   = FindLSB(image -&gt; red_mask)   - 1;
+  greenShift = FindLSB(image -&gt; green_mask) - 1;
+  blueShift  = FindLSB(image -&gt; blue_mask)  - 1;
+
+  redMax   = image -&gt; red_mask   &gt;&gt; redShift;
+  greenMax = image -&gt; green_mask &gt;&gt; greenShift;
+  blueMax  = image -&gt; blue_mask  &gt;&gt; blueShift;
+
+  w             = image -&gt; width;
+  h             = image -&gt; height;
+  pngBeforeBuf  = image -&gt; data;
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******PngCompressData: Compressing image with width [%d] height [%d].\n&quot;,
+              w, h );
+  #endif
+
+  /*
+   * Initialize the PNG stuff.
+   */
+
+  png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+
+  if (png_ptr == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******PngCompressData: PANIC! Failed creating the png_create_write_struct.\n&quot;);
+    #endif
+
+    return NULL;
+  }
+
+  info_ptr = png_create_info_struct(png_ptr);
+
+  if (info_ptr == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******PngCompressData: PANIC! Failed creating the png_create_info_struct.\n&quot;);
+    #endif
+
+    png_destroy_write_struct(&amp;png_ptr, NULL);
+
+    return NULL;
+  }
+
+  if (setjmp(png_jmpbuf(png_ptr)))
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******PngCompressData: PANIC! Error during compression initialization.\n&quot;);
+    #endif
+
+    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
+
+    return NULL;
+  }
+
+  /*
+   * Be sure we allocate enough data.
+   */
+
+  #ifdef TEST
+  fprintf(stderr, &quot;******PngCompressData: Allocating [%d] bytes for the destination data.\n&quot;,
+              PNG_DEST_SIZE(w, h));
+  #endif
+
+  pngCompBuf = malloc(PNG_DEST_SIZE(w, h));
+
+  if (pngCompBuf == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******PngCompressData: PANIC! Error allocating [%d] bytes for the Png data.\n&quot;,
+                PNG_DEST_SIZE(w, h));
+    #endif
+
+    return NULL;
+  }
+
+  png_set_write_fn(png_ptr, (void *) pngCompBuf, PngWriteData, PngFlushData);
+
+  if (setjmp(png_jmpbuf(png_ptr)))
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******PngCompressData: PANIC! Error writing the header.\n&quot;);
+    #endif
+
+    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
+
+    free(pngCompBuf);
+
+    return NULL;
+  }
+
+  png_set_compression_level(png_ptr, PNG_Z_LEVEL);
+
+  if (bitsPerPixel == 16)
+  {
+    nb_colors = NXCreatePalette16(image, color_table, image_index, NB_COLOR_MAX);
+  }
+  else
+  {
+    nb_colors = NXCreatePalette32(image, color_table, image_index, NB_COLOR_MAX);
+  }
+
+  if (nb_colors &lt;= NB_COLOR_MAX)
+  {
+    color_type = PNG_COLOR_TYPE_PALETTE;
+  }
+  else
+  {
+    color_type = PNG_COLOR_TYPE_RGB;
+  }
+
+  png_set_IHDR(png_ptr, info_ptr, w, h,
+                   8, color_type, PNG_INTERLACE_NONE,
+                       PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
+
+  if (color_type == PNG_COLOR_TYPE_PALETTE)
+  {
+    palette = png_malloc(png_ptr, sizeof(*palette) * 256);
+
+    /*
+     * TODO: Do we need to clean these bytes?
+     *
+     * memset(palette, 0, sizeof(*palette) * 256);
+     */
+
+    for (num = 0; num &lt; 256 &amp;&amp; color_table[num].found != 0; num++)
+    {
+      if (bitsPerPixel == 24)
+      {
+        palette[num].red = (color_table[num].pixel &gt;&gt; redShift) &amp; redMax;
+        palette[num].green = (color_table[num].pixel &gt;&gt; greenShift) &amp; greenMax;
+        palette[num].blue = color_table[num].pixel &gt;&gt; blueShift &amp; blueMax;
+      }
+      else
+      {
+        int inRed, inGreen, inBlue;
+
+        inRed = (color_table[num].pixel &gt;&gt; redShift) &amp; redMax;
+        inGreen = (color_table[num].pixel &gt;&gt; greenShift) &amp; greenMax;
+        inBlue = color_table[num].pixel &gt;&gt; blueShift &amp; blueMax;
+
+        palette[num].red = (CARD8)((inRed * 255 + redMax / 2) / redMax);
+        palette[num].green = (CARD8)((inGreen * 255 + greenMax / 2) / greenMax);
+        palette[num].blue = (CARD8)((inBlue * 255 + blueMax / 2) / blueMax);
+      }
+
+      #ifdef DEBUG
+      fprintf(stderr, &quot;******PngCompressData: pixel[%d] r[%d] g[%d] b[%d].\n&quot;,
+                  (int) color_table[num].pixel,palette[num].red,palette[num].green,palette[num].blue);
+      #endif
+    }
+
+    png_set_PLTE(png_ptr, info_ptr, palette, num);
+
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******PngCompressedData: Setting palette.\n&quot;);
+    #endif
+  }
+
+  /*
+   * End of palette.
+   */
+
+  png_write_info(png_ptr, info_ptr);
+
+  /*
+   * Allocate space for one line of
+   * the image, 3 bytes per pixel.
+   */
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******PngCompressedData: Initialization finished.\n&quot;);
+  #endif
+
+  if (setjmp(png_jmpbuf(png_ptr)))
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******PngCompressData: PANIC! Error while writing the image rows.\n&quot;);
+    #endif
+
+    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
+
+    free(pngCompBuf);
+
+    return NULL;
+  }
+
+  if (color_type == PNG_COLOR_TYPE_PALETTE)
+  {
+    srcBuf = (CARD8 *) malloc(w * sizeof(CARD8));
+
+    if (srcBuf == NULL)
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******PngCompressData: PANIC! Cannot allocate [%d] bytes.\n&quot;,
+                  (int) (w * sizeof(CARD8)));
+      #endif
+
+      return NULL;
+    }
+
+    /*
+     * TODO: Be sure the padded bytes are cleaned.
+     * It would be better to set to zero the bytes
+     * that are not alligned to the word boundary
+     * at the end of the procedure.
+     */
+
+    memset(srcBuf, 0, w * sizeof(CARD8));
+  }
+  else
+  {
+    srcBuf = (CARD8 *) malloc(w * 3 * sizeof(CARD8));
+
+    /*
+     * TODO: See above.
+     */
+
+    memset(srcBuf, 0, w * 3 * sizeof(CARD8));
+  }
+
+  if (srcBuf == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******PngCompressData: PANIC! Cannot allocate [%d] bytes.\n&quot;,
+                w * 3);
+    #endif
+
+    free(pngCompBuf);
+
+    return NULL;
+  }
+
+  for (dy = 0; dy &lt; h; dy++)
+  {
+    if (color_type == PNG_COLOR_TYPE_RGB)
+    {
+      PrepareRowForPng(srcBuf, dy, w);
+    }
+    else
+    {
+      memcpy(srcBuf, image_index + (dy * w), w);
+    }
+
+    png_write_row(png_ptr, srcBuf);
+  }
+
+  #ifdef DEBUG
+  fprintf(stderr, &quot;******PngCompressedData: Compression finished. Lines handled [%d,%d].\n&quot;,
+              dy, h);
+  #endif
+
+  free(srcBuf);
+  free(image_index);
+
+  if (setjmp(png_jmpbuf(png_ptr)))
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******PngCompressData: PANIC! error during end of write.\n&quot;);
+    #endif
+
+    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
+
+    free(pngCompBuf);
+
+    return NULL;
+  }
+
+  png_write_end(png_ptr, NULL);
+
+  if (color_type == PNG_COLOR_TYPE_PALETTE)
+  {
+    png_free(png_ptr, palette);
+  }
+
+  png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
+
+  /*
+   * Check the size of the resulting data.
+   */
+
+  if (pngDataLen &gt; 0)
+  {
+    #ifdef DEBUG
+
+    int i = 0;
+
+    fprintf(stderr, &quot;******PngCompressedData: Compressed size [%d].\n&quot;,
+                pngDataLen);
+
+    pngId++;
+    sprintf(pngName, &quot;png%d&quot;, pngId);
+    pngFile = fopen(pngName, &quot;w&quot;);
+
+    for (i = 0; i &lt; pngDataLen; i++)
+    {
+      fprintf(pngFile, &quot;%c&quot;, *(pngCompBuf + i));
+    }
+
+    fclose(pngFile);
+
+    #endif
+
+    *compressed_size = pngDataLen;
+
+    return pngCompBuf;
+  }
+  else
+  {
+    #ifdef DEBUG
+    fprintf(stderr, &quot;******PngCompressedData: PANIC! Invalid size of the compressed data [%d].\n&quot;,
+                pngDataLen);
+    #endif
+
+    free(pngCompBuf);
+
+    return NULL;
+  }
+}
+
+static void PngWriteData(png_structp png_ptr, png_bytep data, png_size_t length)
+{
+  memcpy(((char *) png_get_io_ptr(png_ptr) + pngDataLen), data, length);
+
+  pngDataLen += length;
+}
+
+static void PngFlushData(png_structp png_ptr)
+{
+}
+
+void PrepareRowForPng(CARD8 *dst, int y, int count)
+{
+  if (bitsPerPixel == 32)
+  {
+    if (redMax == 0xff &amp;&amp;
+           greenMax == 0xff &amp;&amp;
+               blueMax == 0xff)
+    {
+      PrepareRowForPng24(dst, y, count);
+    }
+    else
+    {
+      PrepareRowForPng32(dst, y, count);
+    }
+  }
+  else if (bitsPerPixel == 24)
+  {
+    memcpy(dst, pngBeforeBuf + y * bytesPerLine, count * 3);
+  }
+  else
+  {
+    /*
+     * 16 bpp assumed.
+     */
+
+    PrepareRowForPng16(dst, y, count);
+  }
+}
+
+
+
+void PrepareRowForPng24(CARD8 *dst, int y, int count)
+{
+  CARD8 *fbptr;
+  CARD32 pix;
+
+  fbptr = (CARD8 *) (pngBeforeBuf + y * bytesPerLine);
+
+  while (count--)
+  {
+    if (byteOrder == LSBFirst)
+    {
+      pix = (CARD32) *(fbptr + 2);
+      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr+1);
+      pix = (pix &lt;&lt; 8) | (CARD32) *fbptr;
+    }
+    else
+    {
+      pix = (CARD32) *(fbptr + 1);
+      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + 2);
+      pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + 3);
+    }
+
+    *dst++ = (CARD8)(pix &gt;&gt; redShift);
+    *dst++ = (CARD8)(pix &gt;&gt; greenShift);
+    *dst++ = (CARD8)(pix &gt;&gt; blueShift);
+
+    fbptr+=4;
+  }
+}
+
+#define DEFINE_PNG_GET_ROW_FUNCTION(bpp)                                    \
+                                                                            \
+void PrepareRowForPng##bpp(CARD8 *dst, int y, int count)                    \
+{                                                                           \
+  CARD8 *fbptr;                                                             \
+  CARD##bpp pix;                                                            \
+  int inRed, inGreen, inBlue;                                               \
+  int i;                                                                    \
+                                                                            \
+  fbptr = (CARD8 *) (pngBeforeBuf + y * bytesPerLine);                      \
+                                                                            \
+  while (count--)                                                           \
+  {                                                                         \
+    pix = 0;                                                                \
+                                                                            \
+    if (byteOrder == LSBFirst)                                              \
+    {                                                                       \
+      for (i = (bpp &gt;&gt; 3) - 1; i &gt;= 0; i--)                                 \
+      {                                                                     \
+        pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + i);                           \
+      }                                                                     \
+    }                                                                       \
+    else                                                                    \
+    {                                                                       \
+      for (i = 0; i &lt; (bpp &gt;&gt; 3); i++)                                      \
+      {                                                                     \
+        pix = (pix &lt;&lt; 8) | (CARD32) *(fbptr + i);                           \
+      }                                                                     \
+    }                                                                       \
+                                                                            \
+    fbptr += (bpp &gt;&gt; 3);                                                    \
+                                                                            \
+    inRed = (int)                                                           \
+            (pix &gt;&gt; redShift   &amp; redMax);                                   \
+    inGreen = (int)                                                         \
+            (pix &gt;&gt; greenShift &amp; greenMax);                                 \
+    inBlue  = (int)                                                         \
+            (pix &gt;&gt; blueShift  &amp; blueMax);                                  \
+    *dst++ = (CARD8)((inRed   * 255 + redMax / 2) /                         \
+                         redMax);                                           \
+    *dst++ = (CARD8)((inGreen * 255 + greenMax / 2) /                       \
+                         greenMax);                                         \
+    *dst++ = (CARD8)((inBlue  * 255 + blueMax / 2) /                        \
+                         blueMax);                                          \
+  }                                                                         \
+}
+
+DEFINE_PNG_GET_ROW_FUNCTION(16)
+DEFINE_PNG_GET_ROW_FUNCTION(32)
diff --git a/nxcompext/Pgn.h b/nxcompext/Pgn.h
new file mode 100644
index 0000000..999e8ea
--- /dev/null
+++ b/nxcompext/Pgn.h
@@ -0,0 +1,68 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Pgn_H
+#define Pgn_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;X11/X.h&quot;
+#include &quot;X11/Xlib.h&quot;
+#include &quot;X11/Xmd.h&quot;
+
+#include &lt;png.h&gt; 
+
+extern int PngCompareColorTable(
+#if NeedFunctionPrototypes
+  NXColorTable*     /* color_table_1 */,
+  NXColorTable*     /* color_table_2 */
+#endif
+);
+
+extern char *PngCompressData(
+#if NeedFunctionPrototypes
+    XImage*          /* image */,
+    int*             /* compressed_size */
+#endif
+);
+
+int NXCreatePalette16(
+#if NeedFunctionPrototypes
+    XImage*          /* src_image */,
+    NXColorTable*    /* color_table */,
+    CARD8*           /* image_index */,
+    int              /* nb_max */
+#endif
+);
+
+int NXCreatePalette32(
+#if NeedFunctionPrototypes
+    XImage*          /* src_image */,
+    NXColorTable*    /* color_table */,
+    CARD8*           /* image_index */,
+    int              /* nb_max */
+#endif
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Pgn_H */
+
diff --git a/nxcompext/README b/nxcompext/README
new file mode 100644
index 0000000..39648e7
--- /dev/null
+++ b/nxcompext/README
@@ -0,0 +1,15 @@
+README
+------
+
+1. To compile:
+
+   &gt; tar zxvf nxcompext-X.Y.Z-N.tar.gz
+   &gt; cd nxcompext
+   &gt; ./configure
+   &gt; make
+
+   You'll have to run gmake under Solaris.
+
+2. The 'make install' target is not currently supported
+   in the Makefile, but it should be simple to fix.
+
diff --git a/nxcompext/Rgb.c b/nxcompext/Rgb.c
new file mode 100644
index 0000000..d6cecb4
--- /dev/null
+++ b/nxcompext/Rgb.c
@@ -0,0 +1,43 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;zlib.h&gt;
+
+#include &quot;NXlib.h&quot;
+
+#include &quot;Rgb.h&quot;
+#include &quot;Z.h&quot;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#define RGB_COMPRESSION_LEVEL      4
+#define RGB_COMPRESSION_THRESHOLD  32
+#define RGB_COMPRESSION_STRATEGY   Z_DEFAULT_STRATEGY
+
+static int rgbCompressionLevel     = RGB_COMPRESSION_LEVEL;
+static int rgbCompressionThreshold = RGB_COMPRESSION_THRESHOLD;
+static int rgbCompressionStrategy  = RGB_COMPRESSION_STRATEGY;
+
+char *RgbCompressData(XImage *image, unsigned int *size)
+{
+  return ZCompressData(image -&gt; data, image -&gt; bytes_per_line * image -&gt; height,
+                           rgbCompressionThreshold, rgbCompressionLevel,
+                               rgbCompressionStrategy, size);
+}
diff --git a/nxcompext/Rgb.h b/nxcompext/Rgb.h
new file mode 100644
index 0000000..931ee6a
--- /dev/null
+++ b/nxcompext/Rgb.h
@@ -0,0 +1,36 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Rgb_H
+#define Rgb_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+extern char *RgbCompressData(
+#if NeedFunctionPrototypes
+    XImage*                   /* image */,
+    unsigned int*             /* compressed_size */
+#endif
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Rgb_H */
diff --git a/nxcompext/Rle.c b/nxcompext/Rle.c
new file mode 100644
index 0000000..b647dbb
--- /dev/null
+++ b/nxcompext/Rle.c
@@ -0,0 +1,43 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;zlib.h&gt;
+
+#include &quot;NXlib.h&quot;
+
+#include &quot;Rle.h&quot;
+#include &quot;Z.h&quot;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#define RLE_COMPRESSION_LEVEL      1
+#define RLE_COMPRESSION_THRESHOLD  32
+#define RLE_COMPRESSION_STRATEGY   Z_RLE
+
+static int rleCompressionLevel     = RLE_COMPRESSION_LEVEL;
+static int rleCompressionThreshold = RLE_COMPRESSION_THRESHOLD;
+static int rleCompressionStrategy  = RLE_COMPRESSION_STRATEGY;
+
+char *RleCompressData(XImage *image, unsigned int *size)
+{
+  return ZCompressData(image -&gt; data, image -&gt; bytes_per_line * image -&gt; height,
+                           rleCompressionThreshold, rleCompressionLevel,
+                               rleCompressionStrategy, size);
+}
diff --git a/nxcompext/Rle.h b/nxcompext/Rle.h
new file mode 100644
index 0000000..7125d2f
--- /dev/null
+++ b/nxcompext/Rle.h
@@ -0,0 +1,36 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Rle_H
+#define Rle_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+extern char *RleCompressData(
+#if NeedFunctionPrototypes
+    XImage*                   /* image */,
+    unsigned int*             /* compressed_size */
+#endif
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Rle_H */
diff --git a/nxcomp/VERSION b/nxcompext/VERSION
similarity index 100%
copy from nxcomp/VERSION
copy to nxcompext/VERSION
diff --git a/nxcompext/Z.c b/nxcompext/Z.c
new file mode 100644
index 0000000..d6ed3d1
--- /dev/null
+++ b/nxcompext/Z.c
@@ -0,0 +1,301 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;zlib.h&gt;
+
+#include &quot;NXlib.h&quot;
+
+#include &quot;Z.h&quot;
+
+#define PANIC
+#define WARNING
+#undef  TEST
+#undef  DEBUG
+
+#define Z_COMPRESSION_LEVEL      4
+#define Z_COMPRESSION_THRESHOLD  32
+#define Z_COMPRESSION_STRATEGY   Z_DEFAULT_STRATEGY
+
+static int zCompressionLevel    = Z_COMPRESSION_LEVEL;
+static int zCompressionStrategy = Z_COMPRESSION_STRATEGY;
+
+static z_stream *zStream;
+
+static int zInitialized;
+
+static int ZConfigure(int level, int strategy);
+
+static int ZDeflate(char *dest, unsigned int *destLen,
+                        const char *source, unsigned int sourceLen);
+
+char *ZCompressData(const char *plainData, unsigned int plainSize, int threshold,
+                        int level, int strategy, unsigned int *compressedSize)
+{
+  char *compressedData;
+
+  /*
+   * Determine the size of the source image
+   * data and make sure there is enough
+   * space in the destination buffer.
+   */
+
+  *compressedSize = plainSize + (plainSize / 1000) + 12 + 1;
+
+  compressedData = Xmalloc(*compressedSize);
+
+  if (compressedData == NULL)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******ZCompressData: PANIC! Failed to allocate [%d] bytes for the destination.\n&quot;,
+                *compressedSize);
+    #endif
+
+    *compressedSize = 0;
+
+    return NULL;
+  }
+
+  if (level == Z_NO_COMPRESSION || plainSize &lt; threshold)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******ZCompressData: Not compressing [%d] bytes with level [%d] and &quot;
+	    &quot;threshold [%d].\n&quot;, plainSize, level, threshold);
+    #endif
+
+    /*
+     * Tell in the first byte of the buffer
+     * if the remaining data is compressed
+     * or not. This same byte can be used
+     * in future to store some other flag.
+     */
+
+    *compressedData = 0;
+
+    memcpy(compressedData + 1, plainData, plainSize);
+
+    *compressedSize = plainSize + 1;
+
+    return compressedData;
+  }
+  else
+  {
+    int result;
+
+    /*
+     * Reconfigure the stream if needed.
+     */
+
+    if (zCompressionLevel != level ||
+            zCompressionStrategy != strategy)
+    {
+      ZConfigure(level, strategy);
+
+      zCompressionLevel    = level;
+      zCompressionStrategy = strategy;
+    }
+
+    result = ZDeflate(compressedData + 1, compressedSize, plainData, plainSize);
+
+    if (result != Z_OK)
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******ZCompressData: PANIC! Failed to compress [%d] bytes with error [%s].\n&quot;,
+                  plainSize, zError(result));
+      #endif
+
+      Xfree(compressedData);
+
+      *compressedSize = 0;
+
+      return NULL;
+    }
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******ZCompressData: Source data of [%d] bytes compressed to [%d].\n&quot;,
+                plainSize, *compressedSize);
+    #endif
+
+    *compressedData = 1;
+
+    *compressedSize = *compressedSize + 1;
+
+    return compressedData;
+  }
+}
+
+int ZConfigure(int level, int strategy)
+{
+  /*
+   * ZLIB wants the avail_out to be
+   * non zero, even if the stream was
+   * already flushed.
+   */
+
+  unsigned char dest[1];
+
+  zStream -&gt; next_out  = dest;
+  zStream -&gt; avail_out = 1;
+
+  if (deflateParams(zStream, level, strategy) != Z_OK)
+  {
+    #ifdef PANIC
+    fprintf(stderr, &quot;******ZConfigure: PANIC! Failed to set level to [%d] and strategy to [%d].\n&quot;,
+                level, strategy);
+    #endif
+
+    return -1;
+  }
+  #ifdef TEST
+  else
+  {
+    fprintf(stderr, &quot;******ZConfigure: Reconfigured the stream with level [%d] and strategy [%d].\n&quot;,
+                level, strategy);
+  }
+  #endif
+
+  return 1;
+}
+
+int ZDeflate(char *dest, unsigned int *destLen, const char *source, unsigned int sourceLen)
+{
+  int saveOut;
+  int result;
+
+  /*
+   * Deal with the possible overflow.
+   */
+
+  if (zStream -&gt; total_out &amp; 0x80000000)
+  {
+    #ifdef TEST
+    fprintf(stderr, &quot;******ZDeflate: Reset Z stream counters with total in [%ld] total out [%ld].\n&quot;,
+                zStream -&gt; total_in, zStream -&gt; total_out);
+    #endif
+
+    zStream -&gt; total_in  = 0;
+    zStream -&gt; total_out = 0;
+  }
+
+  saveOut = zStream -&gt; total_out;
+
+  zStream -&gt; next_in  = (Bytef *) source;
+  zStream -&gt; avail_in = (uInt) sourceLen;
+
+  #ifdef MAXSEG_64K
+
+  /*
+   * Check if the source is greater
+   * than 64K on a 16-bit machine.
+   */
+
+  if ((uLong) zStream -&gt; avail_in != sourceLen) return Z_BUF_ERROR;
+
+  #endif
+
+  zStream -&gt; next_out  = (unsigned char *) dest;
+  zStream -&gt; avail_out = (uInt) *destLen;
+
+  if ((uLong) zStream -&gt; avail_out != *destLen) return Z_BUF_ERROR;
+
+  result = deflate(zStream, Z_FINISH);
+
+  if (result != Z_STREAM_END)
+  {
+    deflateReset(zStream);
+
+    return (result == Z_OK ? Z_BUF_ERROR : result);
+  }
+
+  *destLen = zStream -&gt; total_out - saveOut;
+
+  result = deflateReset(zStream);
+
+  return result;
+}
+
+int ZInitEncoder()
+{
+  if (zInitialized == 0)
+  {
+    int result;
+
+    zStream = Xmalloc(sizeof(z_stream));
+
+    if (zStream == NULL)
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******ZInitEncoder: PANIC! Failed to allocate memory for the stream.\n&quot;);
+      #endif
+
+      return -1;
+    }
+
+    zStream -&gt; zalloc = (alloc_func) 0;
+    zStream -&gt; zfree  = (free_func) 0;
+    zStream -&gt; opaque = (voidpf) 0;
+
+    #ifdef TEST
+    fprintf(stderr, &quot;******ZInitEncoder: Initializing compressor with level [%d] and startegy [%d].\n&quot;,
+                zCompressionLevel, zCompressionStrategy);
+    #endif
+
+    result = deflateInit2(zStream, zCompressionLevel, Z_DEFLATED,
+                              15, 9, zCompressionStrategy);
+
+    if (result != Z_OK)
+    {
+      #ifdef PANIC
+      fprintf(stderr, &quot;******ZInitEncoder: Failed to initialize the compressor with error [%s].\n&quot;,
+                  zError(result));
+      #endif
+
+      return -1;
+    }
+
+    zInitialized = 1;
+  }
+
+  return zInitialized;
+}
+
+int ZResetEncoder()
+{
+  int result;
+
+  if (zInitialized == 1)
+  {
+    result = deflateEnd(zStream);
+
+    if (result != Z_OK)
+    {
+      #ifdef WARNING
+      fprintf(stderr, &quot;******ZResetEncoder: WARNING! Failed to deinitialize the compressor with error [%s].\n&quot;,
+                  zError(result));
+      #endif
+    }
+
+    Xfree(zStream);
+  }
+
+  zInitialized = 0;
+
+  return 1;
+}
diff --git a/nxcompext/Z.h b/nxcompext/Z.h
new file mode 100644
index 0000000..b6733c6
--- /dev/null
+++ b/nxcompext/Z.h
@@ -0,0 +1,52 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2007 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NXCOMPEXT, NX protocol compression and NX extensions to this software  */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of NoMachine S.r.l.                    */
+/*                                                                        */
+/* All rigths reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef Z_H
+#define Z_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+int ZInitEncoder(
+#if NeedFunctionPrototypes
+void
+#endif
+);
+
+int ZResetEncoder(
+#if NeedFunctionPrototypes
+void
+#endif
+);
+
+extern char *ZCompressData(
+#if NeedFunctionPrototypes
+    const char*     /* data */,
+    unsigned int    /* size */,
+    int             /* threshold */,
+    int             /* level */,
+    int             /* strategy */,
+    unsigned int*   /* compressed_size */
+#endif
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* Z_H */
diff --git a/nxcompext/configure b/nxcompext/configure
new file mode 100755
index 0000000..87d630e
--- /dev/null
+++ b/nxcompext/configure
@@ -0,0 +1,5618 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.59.
+#
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n &quot;${ZSH_VERSION+set}&quot; &amp;&amp; (emulate sh) &gt;/dev/null 2&gt;&amp;1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+&quot;$@&quot;}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+&quot;$@&quot;}'='&quot;$@&quot;'
+elif test -n &quot;${BASH_VERSION+set}&quot; &amp;&amp; (set -o posix) &gt;/dev/null 2&gt;&amp;1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) &gt;/dev/null 2&gt;&amp;1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='&gt; '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z &quot;`(eval $as_var=C; export $as_var) 2&gt;&amp;1`&quot;); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' &gt;/dev/null 2&gt;&amp;1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) &gt;/dev/null 2&gt;&amp;1 &amp;&amp; test &quot;X`basename / 2&gt;&amp;1`&quot; = &quot;X/&quot;; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename &quot;$0&quot; ||
+$as_expr X/&quot;$0&quot; : '.*/\([^/][^/]*\)/*$' \| \
+	 X&quot;$0&quot; : 'X\(//\)$' \| \
+	 X&quot;$0&quot; : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2&gt;/dev/null ||
+echo X/&quot;$0&quot; |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test &quot;${PATH_SEPARATOR+set}&quot; != set; then
+  echo &quot;#! /bin/sh&quot; &gt;conf$$.sh
+  echo  &quot;exit 0&quot;   &gt;&gt;conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH=&quot;/nonexistent;.&quot;; conf$$.sh) &gt;/dev/null 2&gt;&amp;1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2&gt;/dev/null`
+  test &quot;x$as_lineno_1&quot; != &quot;x$as_lineno_2&quot; &amp;&amp;
+  test &quot;x$as_lineno_3&quot;  = &quot;x$as_lineno_2&quot;  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  test -r &quot;$as_dir/$0&quot; &amp;&amp; as_myself=$as_dir/$0 &amp;&amp; break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test &quot;x$as_myself&quot; = x; then
+    as_myself=$0
+  fi
+  if test ! -f &quot;$as_myself&quot;; then
+    { echo &quot;$as_me: error: cannot find myself; rerun with an absolute path&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if (&quot;$as_dir/$as_base&quot; -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2&gt;/dev/null`
+  test &quot;x$as_lineno_1&quot; != &quot;x$as_lineno_2&quot; &amp;&amp;
+  test &quot;x$as_lineno_3&quot;  = &quot;x$as_lineno_2&quot; ') 2&gt;/dev/null; then
+	     $as_unset BASH_ENV || test &quot;${BASH_ENV+set}&quot; != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test &quot;${ENV+set}&quot; != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec &quot;$CONFIG_SHELL&quot; &quot;$0&quot; ${1+&quot;$@&quot;}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' &lt;$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' &gt;$as_me.lineno &amp;&amp;
+  chmod +x $as_me.lineno ||
+    { echo &quot;$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo &quot;testing\c&quot;; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' &gt;/dev/null 2&gt;&amp;1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo &gt;conf$$.file
+if ln -s conf$$.file conf$$ 2&gt;/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2&gt;/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2&gt;/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p &amp;&amp; rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p=&quot;test -f&quot;
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp=&quot;eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'&quot;
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh=&quot;eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'&quot;
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=&quot; 	$as_nl&quot;
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2&gt;/dev/null | sed 1q`
+
+exec 6&gt;&amp;1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file=&quot;NXlib.h&quot;
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CXX CXXFLAGS LDFLAGS CPPFLAGS ac_ct_CXX EXEEXT OBJEXT CC CFLAGS ac_ct_CC INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CXXCPP X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS LIBVERSION VERSION MAKEDEPEND ALL LIBOBJS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can &quot;make install exec_prefix=/foo&quot;
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n &quot;$ac_prev&quot;; then
+    eval &quot;$ac_prev=\$ac_option&quot;
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr &quot;x$ac_option&quot; : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr &quot;x$ac_option&quot; : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr &quot;x$ac_feature&quot; : &quot;.*[^-_$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      { echo &quot;$as_me: error: invalid feature name: $ac_feature&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval &quot;enable_$ac_feature=no&quot; ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr &quot;x$ac_option&quot; : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr &quot;x$ac_feature&quot; : &quot;.*[^-_$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      { echo &quot;$as_me: error: invalid feature name: $ac_feature&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo &quot;$ac_optarg&quot; | sed &quot;s/'/'\\\\\\\\''/g&quot;`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval &quot;enable_$ac_feature='$ac_optarg'&quot; ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr &quot;x$ac_option&quot; : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr &quot;x$ac_package&quot; : &quot;.*[^-_$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      { echo &quot;$as_me: error: invalid package name: $ac_package&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo &quot;$ac_optarg&quot; | sed &quot;s/'/'\\\\\\\\''/g&quot;`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval &quot;with_$ac_package='$ac_optarg'&quot; ;;
+
+  -without-* | --without-*)
+    ac_package=`expr &quot;x$ac_option&quot; : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr &quot;x$ac_package&quot; : &quot;.*[^-_$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      { echo &quot;$as_me: error: invalid package name: $ac_package&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval &quot;with_$ac_package=no&quot; ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo &quot;$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information.&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr &quot;x$ac_option&quot; : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr &quot;x$ac_envvar&quot; : &quot;.*[^_$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      { echo &quot;$as_me: error: invalid variable name: $ac_envvar&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo &quot;$ac_optarg&quot; | sed &quot;s/'/'\\\\\\\\''/g&quot;`
+    eval &quot;$ac_envvar='$ac_optarg'&quot;
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo &quot;$as_me: WARNING: you should use --build, --host, --target&quot; &gt;&amp;2
+    expr &quot;x$ac_option&quot; : &quot;.*[^-._$as_cr_alnum]&quot; &gt;/dev/null &amp;&amp;
+      echo &quot;$as_me: WARNING: invalid host type: $ac_option&quot; &gt;&amp;2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n &quot;$ac_prev&quot;; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo &quot;$as_me: error: missing argument to $ac_option&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo &quot;$as_me: error: expected an absolute directory name for --$ac_var: $ac_val&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo &quot;$as_me: error: expected an absolute directory name for --$ac_var: $ac_val&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test &quot;x$host_alias&quot; != x; then
+  if test &quot;x$build_alias&quot; = x; then
+    cross_compiling=maybe
+    echo &quot;$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used.&quot; &gt;&amp;2
+  elif test &quot;x$build_alias&quot; != &quot;x$host_alias&quot;; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n &quot;$host_alias&quot; &amp;&amp; ac_tool_prefix=$host_alias-
+
+test &quot;$silent&quot; = yes &amp;&amp; exec 6&gt;/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z &quot;$srcdir&quot;; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname &quot;$0&quot;) 2&gt;/dev/null ||
+$as_expr X&quot;$0&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X&quot;$0&quot; : 'X\(//\)[^/]' \| \
+	 X&quot;$0&quot; : 'X\(//\)$' \| \
+	 X&quot;$0&quot; : 'X\(/\)' \| \
+	 .     : '\(.\)' 2&gt;/dev/null ||
+echo X&quot;$0&quot; |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test &quot;$ac_srcdir_defaulted&quot; = yes; then
+    { echo &quot;$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or ..&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+  else
+    { echo &quot;$as_me: error: cannot find sources ($ac_unique_file) in $srcdir&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir &amp;&amp; test -r ./$ac_unique_file) 2&gt;/dev/null ||
+  { echo &quot;$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work&quot; &gt;&amp;2
+   { (exit 1); exit 1; }; }
+srcdir=`echo &quot;$srcdir&quot; | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+ac_env_CXX_set=${CXX+set}
+ac_env_CXX_value=$CXX
+ac_cv_env_CXX_set=${CXX+set}
+ac_cv_env_CXX_value=$CXX
+ac_env_CXXFLAGS_set=${CXXFLAGS+set}
+ac_env_CXXFLAGS_value=$CXXFLAGS
+ac_cv_env_CXXFLAGS_set=${CXXFLAGS+set}
+ac_cv_env_CXXFLAGS_value=$CXXFLAGS
+ac_env_LDFLAGS_set=${LDFLAGS+set}
+ac_env_LDFLAGS_value=$LDFLAGS
+ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
+ac_cv_env_LDFLAGS_value=$LDFLAGS
+ac_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_env_CPPFLAGS_value=$CPPFLAGS
+ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_cv_env_CPPFLAGS_value=$CPPFLAGS
+ac_env_CC_set=${CC+set}
+ac_env_CC_value=$CC
+ac_cv_env_CC_set=${CC+set}
+ac_cv_env_CC_value=$CC
+ac_env_CFLAGS_set=${CFLAGS+set}
+ac_env_CFLAGS_value=$CFLAGS
+ac_cv_env_CFLAGS_set=${CFLAGS+set}
+ac_cv_env_CFLAGS_value=$CFLAGS
+ac_env_CXXCPP_set=${CXXCPP+set}
+ac_env_CXXCPP_value=$CXXCPP
+ac_cv_env_CXXCPP_set=${CXXCPP+set}
+ac_cv_env_CXXCPP_value=$CXXCPP
+
+#
+# Report the --help message.
+#
+if test &quot;$ac_init_help&quot; = &quot;long&quot;; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat &lt;&lt;_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat &lt;&lt;_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat &lt;&lt;\_ACEOF
+
+X features:
+  --x-includes=DIR    X include files are in DIR
+  --x-libraries=DIR   X library files are in DIR
+_ACEOF
+fi
+
+if test -n &quot;$ac_init_help&quot;; then
+
+  cat &lt;&lt;\_ACEOF
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-x                use the X Window System
+
+Some influential environment variables:
+  CXX         C++ compiler command
+  CXXFLAGS    C++ compiler flags
+  LDFLAGS     linker flags, e.g. -L&lt;lib dir&gt; if you have libraries in a
+              nonstandard directory &lt;lib dir&gt;
+  CPPFLAGS    C/C++ preprocessor flags, e.g. -I&lt;include dir&gt; if you have
+              headers in a nonstandard directory &lt;include dir&gt;
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  CXXCPP      C++ preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+_ACEOF
+fi
+
+if test &quot;$ac_init_help&quot; = &quot;recursive&quot;; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test &quot;x$ac_dir&quot; = x: &amp;&amp; continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test &quot;$ac_dir&quot; != .; then
+  ac_dir_suffix=/`echo &quot;$ac_dir&quot; | sed 's,^\.[\\/],,'`
+  # A &quot;../&quot; for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo &quot;$ac_dir_suffix&quot; | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z &quot;$ac_top_builddir&quot;; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo &amp;&amp; pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir=&quot;$ac_dir&quot;;;
+*)
+  case &quot;$ac_dir&quot; in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir=&quot;$ac_dir&quot;;;
+  *) ac_abs_builddir=`pwd`/&quot;$ac_dir&quot;;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo &quot;$as_me: WARNING: no configuration information is in $ac_dir&quot; &gt;&amp;2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n &quot;$ac_init_help&quot; &amp;&amp; exit 0
+if $ac_init_version; then
+  cat &lt;&lt;\_ACEOF
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5&gt;config.log
+cat &gt;&amp;5 &lt;&lt;_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat &lt;&lt;_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2&gt;/dev/null | sed 1q`
+uname -m = `(uname -m) 2&gt;/dev/null || echo unknown`
+uname -r = `(uname -r) 2&gt;/dev/null || echo unknown`
+uname -s = `(uname -s) 2&gt;/dev/null || echo unknown`
+uname -v = `(uname -v) 2&gt;/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2&gt;/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2&gt;/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2&gt;/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2&gt;/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2&gt;/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2&gt;/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2&gt;/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2&gt;/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2&gt;/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  echo &quot;PATH: $as_dir&quot;
+done
+
+} &gt;&amp;5
+
+cat &gt;&amp;5 &lt;&lt;_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *&quot; &quot;*|*&quot;	&quot;*|*[\[\]\~\#\$\^\&amp;\*\(\)\{\}\\\|\;\&lt;\&gt;\?\&quot;\']*)
+      ac_arg=`echo &quot;$ac_arg&quot; | sed &quot;s/'/'\\\\\\\\''/g&quot;` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0=&quot;$ac_configure_args0 '$ac_arg'&quot; ;;
+    2)
+      ac_configure_args1=&quot;$ac_configure_args1 '$ac_arg'&quot;
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case &quot;$ac_configure_args0 &quot; in
+	      &quot;$ac_configure_args1&quot;*&quot; '$ac_arg' &quot;* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args=&quot;$ac_configure_args$ac_sep'$ac_arg'&quot;
+      # Get rid of the leading space.
+      ac_sep=&quot; &quot;
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test &quot;${ac_configure_args0+set}&quot; != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test &quot;${ac_configure_args1+set}&quot; != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat &lt;&lt;\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2&gt;&amp;1 |
+    case `(ac_space='&quot;'&quot;' '&quot;'&quot;'; set | grep ac_space) 2&gt;&amp;1` in
+    *ac_space=\ *)
+      sed -n \
+	&quot;s/'&quot;'&quot;'/'&quot;'&quot;'\\\\'&quot;'&quot;''&quot;'&quot;'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='&quot;'&quot;'\\2'&quot;'&quot;'/p&quot;
+      ;;
+    *)
+      sed -n \
+	&quot;s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p&quot;
+      ;;
+    esac;
+}
+    echo
+
+    cat &lt;&lt;\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo &quot;$ac_var='&quot;'&quot;'$ac_val'&quot;'&quot;'&quot;
+    done | sort
+    echo
+
+    if test -n &quot;$ac_subst_files&quot;; then
+      cat &lt;&lt;\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+	echo &quot;$ac_var='&quot;'&quot;'$ac_val'&quot;'&quot;'&quot;
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat &lt;&lt;\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed &quot;/^$/d&quot; confdefs.h | sort
+      echo
+    fi
+    test &quot;$ac_signal&quot; != 0 &amp;&amp;
+      echo &quot;$as_me: caught signal $ac_signal&quot;
+    echo &quot;$as_me: exit $exit_status&quot;
+  } &gt;&amp;5
+  rm -f core *.core &amp;&amp;
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &amp;&amp;
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo &gt;confdefs.h
+
+# Predefined preprocessor variables.
+
+cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF
+#define PACKAGE_NAME &quot;$PACKAGE_NAME&quot;
+_ACEOF
+
+
+cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF
+#define PACKAGE_TARNAME &quot;$PACKAGE_TARNAME&quot;
+_ACEOF
+
+
+cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF
+#define PACKAGE_VERSION &quot;$PACKAGE_VERSION&quot;
+_ACEOF
+
+
+cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF
+#define PACKAGE_STRING &quot;$PACKAGE_STRING&quot;
+_ACEOF
+
+
+cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF
+#define PACKAGE_BUGREPORT &quot;$PACKAGE_BUGREPORT&quot;
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z &quot;$CONFIG_SITE&quot;; then
+  if test &quot;x$prefix&quot; != xNONE; then
+    CONFIG_SITE=&quot;$prefix/share/config.site $prefix/etc/config.site&quot;
+  else
+    CONFIG_SITE=&quot;$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site&quot;
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r &quot;$ac_site_file&quot;; then
+    { echo &quot;$as_me:$LINENO: loading site script $ac_site_file&quot; &gt;&amp;5
+echo &quot;$as_me: loading site script $ac_site_file&quot; &gt;&amp;6;}
+    sed 's/^/| /' &quot;$ac_site_file&quot; &gt;&amp;5
+    . &quot;$ac_site_file&quot;
+  fi
+done
+
+if test -r &quot;$cache_file&quot;; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f &quot;$cache_file&quot;; then
+    { echo &quot;$as_me:$LINENO: loading cache $cache_file&quot; &gt;&amp;5
+echo &quot;$as_me: loading cache $cache_file&quot; &gt;&amp;6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo &quot;$as_me:$LINENO: creating cache $cache_file&quot; &gt;&amp;5
+echo &quot;$as_me: creating cache $cache_file&quot; &gt;&amp;6;}
+  &gt;$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2&gt;&amp;1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=&quot;\$ac_cv_env_${ac_var}_value&quot;
+  eval ac_new_val=&quot;\$ac_env_${ac_var}_value&quot;
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo &quot;$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run&quot; &gt;&amp;5
+echo &quot;$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run&quot; &gt;&amp;2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo &quot;$as_me:$LINENO: error: \`$ac_var' was not set in the previous run&quot; &gt;&amp;5
+echo &quot;$as_me: error: \`$ac_var' was not set in the previous run&quot; &gt;&amp;2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test &quot;x$ac_old_val&quot; != &quot;x$ac_new_val&quot;; then
+	{ echo &quot;$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:&quot; &gt;&amp;5
+echo &quot;$as_me: error: \`$ac_var' has changed since the previous run:&quot; &gt;&amp;2;}
+	{ echo &quot;$as_me:$LINENO:   former value:  $ac_old_val&quot; &gt;&amp;5
+echo &quot;$as_me:   former value:  $ac_old_val&quot; &gt;&amp;2;}
+	{ echo &quot;$as_me:$LINENO:   current value: $ac_new_val&quot; &gt;&amp;5
+echo &quot;$as_me:   current value: $ac_new_val&quot; &gt;&amp;2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test &quot;$ac_new_set&quot; = set; then
+    case $ac_new_val in
+    *&quot; &quot;*|*&quot;	&quot;*|*[\[\]\~\#\$\^\&amp;\*\(\)\{\}\\\|\;\&lt;\&gt;\?\&quot;\']*)
+      ac_arg=$ac_var=`echo &quot;$ac_new_val&quot; | sed &quot;s/'/'\\\\\\\\''/g&quot;` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case &quot; $ac_configure_args &quot; in
+      *&quot; '$ac_arg' &quot;*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args=&quot;$ac_configure_args '$ac_arg'&quot; ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo &quot;$as_me:$LINENO: error: changes in the environment can compromise the build&quot; &gt;&amp;5
+echo &quot;$as_me: error: changes in the environment can compromise the build&quot; &gt;&amp;2;}
+  { { echo &quot;$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over&quot; &gt;&amp;5
+echo &quot;$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+CXXFLAGS=&quot;-O3&quot;
+CFLAGS=&quot;-O3&quot;
+
+
+LIBSTATIC=&quot;&quot;
+LIBSHARED=&quot;&quot;
+
+
+if test -d &quot;../nx-X11/include&quot; ; then
+    CXXFLAGS=&quot;$CXXFLAGS -I../nx-X11/exports/include -I../nx-X11/lib/X11 \
+                        -I../nx-X11/include -I../nx-X11/programs/Xserver/include&quot;
+    CFLAGS=&quot;$CFLAGS -I../nx-X11/exports/include -I../nx-X11/lib/X11 \
+                    -I../nx-X11/include -I../nx-X11/programs/Xserver/include&quot;
+    LDFLAGS=&quot;$LDFLAGS -L../nx-X11/exports/lib&quot;
+fi
+
+
+ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -n &quot;$ac_tool_prefix&quot;; then
+  for ac_prog in $CCC g++ c++ gpp aCC CC cxx cc++ cl FCC KCC RCC xlC_r xlC
+  do
+    # Extract the first word of &quot;$ac_tool_prefix$ac_prog&quot;, so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_CXX+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$CXX&quot;; then
+  ac_cv_prog_CXX=&quot;$CXX&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_CXX=&quot;$ac_tool_prefix$ac_prog&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CXX=$ac_cv_prog_CXX
+if test -n &quot;$CXX&quot;; then
+  echo &quot;$as_me:$LINENO: result: $CXX&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CXX&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+    test -n &quot;$CXX&quot; &amp;&amp; break
+  done
+fi
+if test -z &quot;$CXX&quot;; then
+  ac_ct_CXX=$CXX
+  for ac_prog in $CCC g++ c++ gpp aCC CC cxx cc++ cl FCC KCC RCC xlC_r xlC
+do
+  # Extract the first word of &quot;$ac_prog&quot;, so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_ac_ct_CXX+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$ac_ct_CXX&quot;; then
+  ac_cv_prog_ac_ct_CXX=&quot;$ac_ct_CXX&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_ac_ct_CXX=&quot;$ac_prog&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
+if test -n &quot;$ac_ct_CXX&quot;; then
+  echo &quot;$as_me:$LINENO: result: $ac_ct_CXX&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_ct_CXX&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  test -n &quot;$ac_ct_CXX&quot; &amp;&amp; break
+done
+test -n &quot;$ac_ct_CXX&quot; || ac_ct_CXX=&quot;g++&quot;
+
+  CXX=$ac_ct_CXX
+fi
+
+
+# Provide some information about the compiler.
+echo &quot;$as_me:$LINENO:&quot; \
+     &quot;checking for C++ compiler version&quot; &gt;&amp;5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler --version &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler --version &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler -v &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler -v &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler -V &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler -V &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files=&quot;$ac_clean_files a.out a.exe b.out&quot;
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+echo &quot;$as_me:$LINENO: checking for C++ compiler default output file name&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for C++ compiler default output file name... $ECHO_C&quot; &gt;&amp;6
+ac_link_default=`echo &quot;$ac_link&quot; | sed 's/ -o *conftest[^ ]*//'`
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link_default\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link_default) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; then
+  # Find the output, starting from the most likely.  This scheme is
+# not robust to junk in `.', hence go to wildcards (a.*) only as a last
+# resort.
+
+# Be careful to initialize this variable, since it used to be cached.
+# Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
+ac_cv_exeext=
+# b.out is created by i960 compilers.
+for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
+do
+  test -f &quot;$ac_file&quot; || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
+	;;
+    conftest.$ac_ext )
+	# This is the source file.
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	ac_cv_exeext=`expr &quot;$ac_file&quot; : '[^.]*\(\..*\)'`
+	# FIXME: I believe we export ac_cv_exeext for Libtool,
+	# but it would be cool to find out if it's true.  Does anybody
+	# maintain Libtool? --akim.
+	export ac_cv_exeext
+	break;;
+    * )
+	break;;
+  esac
+done
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+{ { echo &quot;$as_me:$LINENO: error: C++ compiler cannot create executables
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: C++ compiler cannot create executables
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 77); exit 77; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+echo &quot;$as_me:$LINENO: result: $ac_file&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_file&quot; &gt;&amp;6
+
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo &quot;$as_me:$LINENO: checking whether the C++ compiler works&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether the C++ compiler works... $ECHO_C&quot; &gt;&amp;6
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test &quot;$cross_compiling&quot; != yes; then
+  if { ac_try='./$ac_file'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test &quot;$cross_compiling&quot; = maybe; then
+	cross_compiling=yes
+    else
+	{ { echo &quot;$as_me:$LINENO: error: cannot run C++ compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot run C++ compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+fi
+echo &quot;$as_me:$LINENO: result: yes&quot; &gt;&amp;5
+echo &quot;${ECHO_T}yes&quot; &gt;&amp;6
+
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo &quot;$as_me:$LINENO: checking whether we are cross compiling&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether we are cross compiling... $ECHO_C&quot; &gt;&amp;6
+echo &quot;$as_me:$LINENO: result: $cross_compiling&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$cross_compiling&quot; &gt;&amp;6
+
+echo &quot;$as_me:$LINENO: checking for suffix of executables&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for suffix of executables... $ECHO_C&quot; &gt;&amp;6
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f &quot;$ac_file&quot; || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr &quot;$ac_file&quot; : '[^.]*\(\..*\)'`
+	  export ac_cv_exeext
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { echo &quot;$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+echo &quot;$as_me:$LINENO: result: $ac_cv_exeext&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_exeext&quot; &gt;&amp;6
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+echo &quot;$as_me:$LINENO: checking for suffix of object files&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for suffix of object files... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_objext+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; then
+  for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2&gt;/dev/null`; do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
+    *) ac_cv_objext=`expr &quot;$ac_file&quot; : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+{ { echo &quot;$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_objext&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_objext&quot; &gt;&amp;6
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+echo &quot;$as_me:$LINENO: checking whether we are using the GNU C++ compiler&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether we are using the GNU C++ compiler... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_cxx_compiler_gnu+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_cxx_compiler_gnu&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_cxx_compiler_gnu&quot; &gt;&amp;6
+GXX=`test $ac_compiler_gnu = yes &amp;&amp; echo yes`
+ac_test_CXXFLAGS=${CXXFLAGS+set}
+ac_save_CXXFLAGS=$CXXFLAGS
+CXXFLAGS=&quot;-g&quot;
+echo &quot;$as_me:$LINENO: checking whether $CXX accepts -g&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether $CXX accepts -g... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_cxx_g+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cxx_g=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_prog_cxx_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_prog_cxx_g&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_prog_cxx_g&quot; &gt;&amp;6
+if test &quot;$ac_test_CXXFLAGS&quot; = set; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test &quot;$GXX&quot; = yes; then
+    CXXFLAGS=&quot;-g -O2&quot;
+  else
+    CXXFLAGS=&quot;-g&quot;
+  fi
+else
+  if test &quot;$GXX&quot; = yes; then
+    CXXFLAGS=&quot;-O2&quot;
+  else
+    CXXFLAGS=
+  fi
+fi
+for ac_declaration in \
+   '' \
+   'extern &quot;C&quot; void std::exit (int) throw (); using std::exit;' \
+   'extern &quot;C&quot; void std::exit (int); using std::exit;' \
+   'extern &quot;C&quot; void exit (int) throw ();' \
+   'extern &quot;C&quot; void exit (int);' \
+   'void exit (int);'
+do
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+#include &lt;stdlib.h&gt;
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n &quot;$ac_declaration&quot;; then
+  echo '#ifdef __cplusplus' &gt;&gt;confdefs.h
+  echo $ac_declaration      &gt;&gt;confdefs.h
+  echo '#endif'             &gt;&gt;confdefs.h
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n &quot;$ac_tool_prefix&quot;; then
+  # Extract the first word of &quot;${ac_tool_prefix}gcc&quot;, so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$CC&quot;; then
+  ac_cv_prog_CC=&quot;$CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_CC=&quot;${ac_tool_prefix}gcc&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n &quot;$CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+fi
+if test -z &quot;$ac_cv_prog_CC&quot;; then
+  ac_ct_CC=$CC
+  # Extract the first word of &quot;gcc&quot;, so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_ac_ct_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$ac_ct_CC&quot;; then
+  ac_cv_prog_ac_ct_CC=&quot;$ac_ct_CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_ac_ct_CC=&quot;gcc&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n &quot;$ac_ct_CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $ac_ct_CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_ct_CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC=&quot;$ac_cv_prog_CC&quot;
+fi
+
+if test -z &quot;$CC&quot;; then
+  if test -n &quot;$ac_tool_prefix&quot;; then
+  # Extract the first word of &quot;${ac_tool_prefix}cc&quot;, so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$CC&quot;; then
+  ac_cv_prog_CC=&quot;$CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_CC=&quot;${ac_tool_prefix}cc&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n &quot;$CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+fi
+if test -z &quot;$ac_cv_prog_CC&quot;; then
+  ac_ct_CC=$CC
+  # Extract the first word of &quot;cc&quot;, so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_ac_ct_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$ac_ct_CC&quot;; then
+  ac_cv_prog_ac_ct_CC=&quot;$ac_ct_CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_ac_ct_CC=&quot;cc&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n &quot;$ac_ct_CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $ac_ct_CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_ct_CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC=&quot;$ac_cv_prog_CC&quot;
+fi
+
+fi
+if test -z &quot;$CC&quot;; then
+  # Extract the first word of &quot;cc&quot;, so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$CC&quot;; then
+  ac_cv_prog_CC=&quot;$CC&quot; # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    if test &quot;$as_dir/$ac_word$ac_exec_ext&quot; = &quot;/usr/ucb/cc&quot;; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC=&quot;cc&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC=&quot;$as_dir/$ac_word${1+' '}$@&quot;
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n &quot;$CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+fi
+if test -z &quot;$CC&quot;; then
+  if test -n &quot;$ac_tool_prefix&quot;; then
+  for ac_prog in cl
+  do
+    # Extract the first word of &quot;$ac_tool_prefix$ac_prog&quot;, so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$CC&quot;; then
+  ac_cv_prog_CC=&quot;$CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_CC=&quot;$ac_tool_prefix$ac_prog&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n &quot;$CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+    test -n &quot;$CC&quot; &amp;&amp; break
+  done
+fi
+if test -z &quot;$CC&quot;; then
+  ac_ct_CC=$CC
+  for ac_prog in cl
+do
+  # Extract the first word of &quot;$ac_prog&quot;, so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo &quot;$as_me:$LINENO: checking for $ac_word&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $ac_word... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_ac_ct_CC+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  if test -n &quot;$ac_ct_CC&quot;; then
+  ac_cv_prog_ac_ct_CC=&quot;$ac_ct_CC&quot; # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p &quot;$as_dir/$ac_word$ac_exec_ext&quot;; then
+    ac_cv_prog_ac_ct_CC=&quot;$ac_prog&quot;
+    echo &quot;$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext&quot; &gt;&amp;5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n &quot;$ac_ct_CC&quot;; then
+  echo &quot;$as_me:$LINENO: result: $ac_ct_CC&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_ct_CC&quot; &gt;&amp;6
+else
+  echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+fi
+
+  test -n &quot;$ac_ct_CC&quot; &amp;&amp; break
+done
+
+  CC=$ac_ct_CC
+fi
+
+fi
+
+
+test -z &quot;$CC&quot; &amp;&amp; { { echo &quot;$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+
+# Provide some information about the compiler.
+echo &quot;$as_me:$LINENO:&quot; \
+     &quot;checking for C compiler version&quot; &gt;&amp;5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler --version &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler --version &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler -v &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler -v &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+{ (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler -V &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compiler -V &lt;/dev/null &gt;&amp;5) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }
+
+echo &quot;$as_me:$LINENO: checking whether we are using the GNU C compiler&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether we are using the GNU C compiler... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_c_compiler_gnu+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_c_compiler_gnu&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_c_compiler_gnu&quot; &gt;&amp;6
+GCC=`test $ac_compiler_gnu = yes &amp;&amp; echo yes`
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+CFLAGS=&quot;-g&quot;
+echo &quot;$as_me:$LINENO: checking whether $CC accepts -g&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether $CC accepts -g... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_cc_g+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_g=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_prog_cc_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_prog_cc_g&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_prog_cc_g&quot; &gt;&amp;6
+if test &quot;$ac_test_CFLAGS&quot; = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test &quot;$GCC&quot; = yes; then
+    CFLAGS=&quot;-g -O2&quot;
+  else
+    CFLAGS=&quot;-g&quot;
+  fi
+else
+  if test &quot;$GCC&quot; = yes; then
+    CFLAGS=&quot;-O2&quot;
+  else
+    CFLAGS=
+  fi
+fi
+echo &quot;$as_me:$LINENO: checking for $CC option to accept ANSI C&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for $CC option to accept ANSI C... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_prog_cc_stdc+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_cv_prog_cc_stdc=no
+ac_save_CC=$CC
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std1 is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std1.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in &quot;&quot; -qlanglvl=ansi -std1 -Ae &quot;-Aa -D_HPUX_SOURCE&quot; &quot;-Xc -D__EXTENSIONS__&quot;
+do
+  CC=&quot;$ac_save_CC $ac_arg&quot;
+  rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_stdc=$ac_arg
+break
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+fi
+rm -f conftest.err conftest.$ac_objext
+done
+rm -f conftest.$ac_ext conftest.$ac_objext
+CC=$ac_save_CC
+
+fi
+
+case &quot;x$ac_cv_prog_cc_stdc&quot; in
+  x|xno)
+    echo &quot;$as_me:$LINENO: result: none needed&quot; &gt;&amp;5
+echo &quot;${ECHO_T}none needed&quot; &gt;&amp;6 ;;
+  *)
+    echo &quot;$as_me:$LINENO: result: $ac_cv_prog_cc_stdc&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_prog_cc_stdc&quot; &gt;&amp;6
+    CC=&quot;$CC $ac_cv_prog_cc_stdc&quot; ;;
+esac
+
+# Some people use a C++ compiler to compile C.  Since we use `exit',
+# in C++ we need to declare it.  In case someone uses the same compiler
+# for both compiling C and C++ we need to have the C++ compiler decide
+# the declaration of exit, since it's the most demanding environment.
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+#ifndef __cplusplus
+  choke me
+#endif
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  for ac_declaration in \
+   '' \
+   'extern &quot;C&quot; void std::exit (int) throw (); using std::exit;' \
+   'extern &quot;C&quot; void std::exit (int); using std::exit;' \
+   'extern &quot;C&quot; void exit (int) throw ();' \
+   'extern &quot;C&quot; void exit (int);' \
+   'void exit (int);'
+do
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+#include &lt;stdlib.h&gt;
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_c_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n &quot;$ac_declaration&quot;; then
+  echo '#ifdef __cplusplus' &gt;&gt;confdefs.h
+  echo $ac_declaration      &gt;&gt;confdefs.h
+  echo '#endif'             &gt;&gt;confdefs.h
+fi
+
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+
+
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh=&quot;$ac_aux_dir/install-sh -c&quot;
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh=&quot;$ac_aux_dir/install.sh -c&quot;
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh=&quot;$ac_aux_dir/shtool install -c&quot;
+    break
+  fi
+done
+if test -z &quot;$ac_aux_dir&quot;; then
+  { { echo &quot;$as_me:$LINENO: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../..&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../..&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess=&quot;$SHELL $ac_aux_dir/config.guess&quot;
+ac_config_sub=&quot;$SHELL $ac_aux_dir/config.sub&quot;
+ac_configure=&quot;$SHELL $ac_aux_dir/configure&quot; # This should be Cygnus configure.
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group &quot;staff&quot;
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+echo &quot;$as_me:$LINENO: checking for a BSD-compatible install&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for a BSD-compatible install... $ECHO_C&quot; &gt;&amp;6
+if test -z &quot;$INSTALL&quot;; then
+if test &quot;${ac_cv_path_install+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if $as_executable_p &quot;$as_dir/$ac_prog$ac_exec_ext&quot;; then
+	  if test $ac_prog = install &amp;&amp;
+	    grep dspmsg &quot;$as_dir/$ac_prog$ac_exec_ext&quot; &gt;/dev/null 2&gt;&amp;1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &amp;&amp;
+	    grep pwplus &quot;$as_dir/$ac_prog$ac_exec_ext&quot; &gt;/dev/null 2&gt;&amp;1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install=&quot;$as_dir/$ac_prog$ac_exec_ext -c&quot;
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+
+
+fi
+  if test &quot;${ac_cv_path_install+set}&quot; = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL=$ac_install_sh
+  fi
+fi
+echo &quot;$as_me:$LINENO: result: $INSTALL&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$INSTALL&quot; &gt;&amp;6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z &quot;$INSTALL_PROGRAM&quot; &amp;&amp; INSTALL_PROGRAM='${INSTALL}'
+
+test -z &quot;$INSTALL_SCRIPT&quot; &amp;&amp; INSTALL_SCRIPT='${INSTALL}'
+
+test -z &quot;$INSTALL_DATA&quot; &amp;&amp; INSTALL_DATA='${INSTALL} -m 644'
+
+
+
+
+ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+echo &quot;$as_me:$LINENO: checking how to run the C++ preprocessor&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking how to run the C++ preprocessor... $ECHO_C&quot; &gt;&amp;6
+if test -z &quot;$CXXCPP&quot;; then
+  if test &quot;${ac_cv_prog_CXXCPP+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+      # Double quotes because CXXCPP needs to be expanded
+    for CXXCPP in &quot;$CXX -E&quot; &quot;/lib/cpp&quot;
+    do
+      ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+  # &lt;limits.h&gt; exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. &quot;Syntax error&quot; is here to catch this case.
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_cpp conftest.$ac_ext\&quot;&quot;) &gt;&amp;5
+  (eval $ac_cpp conftest.$ac_ext) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &gt;/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z &quot;$ac_cpp_err&quot;; then
+  :
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;ac_nonexistent.h&gt;
+_ACEOF
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_cpp conftest.$ac_ext\&quot;&quot;) &gt;&amp;5
+  (eval $ac_cpp conftest.$ac_ext) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &gt;/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z &quot;$ac_cpp_err&quot;; then
+  # Broken: success on invalid input.
+continue
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CXXCPP=$CXXCPP
+
+fi
+  CXXCPP=$ac_cv_prog_CXXCPP
+else
+  ac_cv_prog_CXXCPP=$CXXCPP
+fi
+echo &quot;$as_me:$LINENO: result: $CXXCPP&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$CXXCPP&quot; &gt;&amp;6
+ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+  # &lt;limits.h&gt; exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. &quot;Syntax error&quot; is here to catch this case.
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_cpp conftest.$ac_ext\&quot;&quot;) &gt;&amp;5
+  (eval $ac_cpp conftest.$ac_ext) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &gt;/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z &quot;$ac_cpp_err&quot;; then
+  :
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;ac_nonexistent.h&gt;
+_ACEOF
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_cpp conftest.$ac_ext\&quot;&quot;) &gt;&amp;5
+  (eval $ac_cpp conftest.$ac_ext) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &gt;/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z &quot;$ac_cpp_err&quot;; then
+  # Broken: success on invalid input.
+continue
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo &quot;$as_me:$LINENO: error: C++ preprocessor \&quot;$CXXCPP\&quot; fails sanity check
+See \`config.log' for more details.&quot; &gt;&amp;5
+echo &quot;$as_me: error: C++ preprocessor \&quot;$CXXCPP\&quot; fails sanity check
+See \`config.log' for more details.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext &gt;&amp;5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS &gt;&amp;5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+
+echo &quot;$as_me:$LINENO: checking for X&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for X... $ECHO_C&quot; &gt;&amp;6
+
+
+# Check whether --with-x or --without-x was given.
+if test &quot;${with_x+set}&quot; = set; then
+  withval=&quot;$with_x&quot;
+
+fi;
+# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
+if test &quot;x$with_x&quot; = xno; then
+  # The user explicitly disabled X.
+  have_x=disabled
+else
+  if test &quot;x$x_includes&quot; != xNONE &amp;&amp; test &quot;x$x_libraries&quot; != xNONE; then
+    # Both variables are already set.
+    have_x=yes
+  else
+    if test &quot;${ac_cv_have_x+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  # One or both of the vars are not set, and there is no cached value.
+ac_x_includes=no ac_x_libraries=no
+rm -fr conftest.dir
+if mkdir conftest.dir; then
+  cd conftest.dir
+  # Make sure to not put &quot;make&quot; in the Imakefile rules, since we grep it out.
+  cat &gt;Imakefile &lt;&lt;'_ACEOF'
+acfindx:
+	@echo 'ac_im_incroot=&quot;${INCROOT}&quot;; ac_im_usrlibdir=&quot;${USRLIBDIR}&quot;; ac_im_libdir=&quot;${LIBDIR}&quot;'
+_ACEOF
+  if (xmkmf) &gt;/dev/null 2&gt;/dev/null &amp;&amp; test -f Makefile; then
+    # GNU make sometimes prints &quot;make[1]: Entering...&quot;, which would confuse us.
+    eval `${MAKE-make} acfindx 2&gt;/dev/null | grep -v make`
+    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
+    for ac_extension in a so sl; do
+      if test ! -f $ac_im_usrlibdir/libX11.$ac_extension &amp;&amp;
+	 test -f $ac_im_libdir/libX11.$ac_extension; then
+	ac_im_usrlibdir=$ac_im_libdir; break
+      fi
+    done
+    # Screen out bogus values from the imake configuration.  They are
+    # bogus both because they are the default anyway, and because
+    # using them would break gcc on systems where it needs fixed includes.
+    case $ac_im_incroot in
+	/usr/include) ;;
+	*) test -f &quot;$ac_im_incroot/X11/Xos.h&quot; &amp;&amp; ac_x_includes=$ac_im_incroot;;
+    esac
+    case $ac_im_usrlibdir in
+	/usr/lib | /lib) ;;
+	*) test -d &quot;$ac_im_usrlibdir&quot; &amp;&amp; ac_x_libraries=$ac_im_usrlibdir ;;
+    esac
+  fi
+  cd ..
+  rm -fr conftest.dir
+fi
+
+# Standard set of common directories for X headers.
+# Check X11 before X11Rn because it is often a symlink to the current release.
+ac_x_header_dirs='
+/usr/X11/include
+/usr/X11R6/include
+/usr/X11R5/include
+/usr/X11R4/include
+
+/usr/include/X11
+/usr/include/X11R6
+/usr/include/X11R5
+/usr/include/X11R4
+
+/usr/local/X11/include
+/usr/local/X11R6/include
+/usr/local/X11R5/include
+/usr/local/X11R4/include
+
+/usr/local/include/X11
+/usr/local/include/X11R6
+/usr/local/include/X11R5
+/usr/local/include/X11R4
+
+/usr/X386/include
+/usr/x386/include
+/usr/XFree86/include/X11
+
+/usr/include
+/usr/local/include
+/usr/unsupported/include
+/usr/athena/include
+/usr/local/x11r5/include
+/usr/lpp/Xamples/include
+
+/usr/openwin/include
+/usr/openwin/share/include'
+
+if test &quot;$ac_x_includes&quot; = no; then
+  # Guess where to find include files, by looking for Intrinsic.h.
+  # First, try using that file with no special directory specified.
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;X11/Intrinsic.h&gt;
+_ACEOF
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_cpp conftest.$ac_ext\&quot;&quot;) &gt;&amp;5
+  (eval $ac_cpp conftest.$ac_ext) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &gt;/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z &quot;$ac_cpp_err&quot;; then
+  # We can compile using X headers with no special include directory.
+ac_x_includes=
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+  for ac_dir in $ac_x_header_dirs; do
+  if test -r &quot;$ac_dir/X11/Intrinsic.h&quot;; then
+    ac_x_includes=$ac_dir
+    break
+  fi
+done
+fi
+rm -f conftest.err conftest.$ac_ext
+fi # $ac_x_includes = no
+
+if test &quot;$ac_x_libraries&quot; = no; then
+  # Check for the libraries.
+  # See if we find them without any special options.
+  # Don't add to $LIBS permanently.
+  ac_save_LIBS=$LIBS
+  LIBS=&quot;-lXt $LIBS&quot;
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+#include &lt;X11/Intrinsic.h&gt;
+int
+main ()
+{
+XtMalloc (0)
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  LIBS=$ac_save_LIBS
+# We can link X programs with no special library path.
+ac_x_libraries=
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+LIBS=$ac_save_LIBS
+for ac_dir in `echo &quot;$ac_x_includes $ac_x_header_dirs&quot; | sed s/include/lib/g`
+do
+  # Don't even attempt the hair of trying to link an X program!
+  for ac_extension in a so sl; do
+    if test -r $ac_dir/libXt.$ac_extension; then
+      ac_x_libraries=$ac_dir
+      break 2
+    fi
+  done
+done
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi # $ac_x_libraries = no
+
+if test &quot;$ac_x_includes&quot; = no || test &quot;$ac_x_libraries&quot; = no; then
+  # Didn't find X anywhere.  Cache the known absence of X.
+  ac_cv_have_x=&quot;have_x=no&quot;
+else
+  # Record where we found X for the cache.
+  ac_cv_have_x=&quot;have_x=yes \
+		ac_x_includes=$ac_x_includes ac_x_libraries=$ac_x_libraries&quot;
+fi
+fi
+
+  fi
+  eval &quot;$ac_cv_have_x&quot;
+fi # $with_x != no
+
+if test &quot;$have_x&quot; != yes; then
+  echo &quot;$as_me:$LINENO: result: $have_x&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$have_x&quot; &gt;&amp;6
+  no_x=yes
+else
+  # If each of the values was on the command line, it overrides each guess.
+  test &quot;x$x_includes&quot; = xNONE &amp;&amp; x_includes=$ac_x_includes
+  test &quot;x$x_libraries&quot; = xNONE &amp;&amp; x_libraries=$ac_x_libraries
+  # Update the cache value to reflect the command line values.
+  ac_cv_have_x=&quot;have_x=yes \
+		ac_x_includes=$x_includes ac_x_libraries=$x_libraries&quot;
+  echo &quot;$as_me:$LINENO: result: libraries $x_libraries, headers $x_includes&quot; &gt;&amp;5
+echo &quot;${ECHO_T}libraries $x_libraries, headers $x_includes&quot; &gt;&amp;6
+fi
+
+if test &quot;$no_x&quot; = yes; then
+  # Not all programs may use this symbol, but it does not hurt to define it.
+
+cat &gt;&gt;confdefs.h &lt;&lt;\_ACEOF
+#define X_DISPLAY_MISSING 1
+_ACEOF
+
+  X_CFLAGS= X_PRE_LIBS= X_LIBS= X_EXTRA_LIBS=
+else
+  if test -n &quot;$x_includes&quot;; then
+    X_CFLAGS=&quot;$X_CFLAGS -I$x_includes&quot;
+  fi
+
+  # It would also be nice to do this for all -L options, not just this one.
+  if test -n &quot;$x_libraries&quot;; then
+    X_LIBS=&quot;$X_LIBS -L$x_libraries&quot;
+    # For Solaris; some versions of Sun CC require a space after -R and
+    # others require no space.  Words are not sufficient . . . .
+    case `(uname -sr) 2&gt;/dev/null` in
+    &quot;SunOS 5&quot;*)
+      echo &quot;$as_me:$LINENO: checking whether -R must be followed by a space&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking whether -R must be followed by a space... $ECHO_C&quot; &gt;&amp;6
+      ac_xsave_LIBS=$LIBS; LIBS=&quot;$LIBS -R$x_libraries&quot;
+      cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_R_nospace=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_R_nospace=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+      if test $ac_R_nospace = yes; then
+	echo &quot;$as_me:$LINENO: result: no&quot; &gt;&amp;5
+echo &quot;${ECHO_T}no&quot; &gt;&amp;6
+	X_LIBS=&quot;$X_LIBS -R$x_libraries&quot;
+      else
+	LIBS=&quot;$ac_xsave_LIBS -R $x_libraries&quot;
+	cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_R_space=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_R_space=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	if test $ac_R_space = yes; then
+	  echo &quot;$as_me:$LINENO: result: yes&quot; &gt;&amp;5
+echo &quot;${ECHO_T}yes&quot; &gt;&amp;6
+	  X_LIBS=&quot;$X_LIBS -R $x_libraries&quot;
+	else
+	  echo &quot;$as_me:$LINENO: result: neither works&quot; &gt;&amp;5
+echo &quot;${ECHO_T}neither works&quot; &gt;&amp;6
+	fi
+      fi
+      LIBS=$ac_xsave_LIBS
+    esac
+  fi
+
+  # Check for system-dependent libraries X programs must link with.
+  # Do this before checking for the system-independent R6 libraries
+  # (-lICE), since we may need -lsocket or whatever for X linking.
+
+  if test &quot;$ISC&quot; = yes; then
+    X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -lnsl_s -linet&quot;
+  else
+    # Martyn Johnson says this is needed for Ultrix, if the X
+    # libraries were built with DECnet support.  And Karl Berry says
+    # the Alpha needs dnet_stub (dnet does not exist).
+    ac_xsave_LIBS=&quot;$LIBS&quot;; LIBS=&quot;$LIBS $X_LIBS -lX11&quot;
+    cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char XOpenDisplay ();
+int
+main ()
+{
+XOpenDisplay ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+echo &quot;$as_me:$LINENO: checking for dnet_ntoa in -ldnet&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for dnet_ntoa in -ldnet... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_dnet_dnet_ntoa+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-ldnet  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dnet_ntoa ();
+int
+main ()
+{
+dnet_ntoa ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dnet_dnet_ntoa=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_dnet_dnet_ntoa=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_dnet_dnet_ntoa&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_dnet_dnet_ntoa&quot; &gt;&amp;6
+if test $ac_cv_lib_dnet_dnet_ntoa = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -ldnet&quot;
+fi
+
+    if test $ac_cv_lib_dnet_dnet_ntoa = no; then
+      echo &quot;$as_me:$LINENO: checking for dnet_ntoa in -ldnet_stub&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for dnet_ntoa in -ldnet_stub... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_dnet_stub_dnet_ntoa+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-ldnet_stub  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dnet_ntoa ();
+int
+main ()
+{
+dnet_ntoa ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dnet_stub_dnet_ntoa=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_dnet_stub_dnet_ntoa=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_dnet_stub_dnet_ntoa&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_dnet_stub_dnet_ntoa&quot; &gt;&amp;6
+if test $ac_cv_lib_dnet_stub_dnet_ntoa = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -ldnet_stub&quot;
+fi
+
+    fi
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+    LIBS=&quot;$ac_xsave_LIBS&quot;
+
+    # <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">msh at cis.ufl.edu</A> says -lnsl (and -lsocket) are needed for his 386/AT,
+    # to get the SysV transport functions.
+    # Chad R. Larson says the Pyramis MIS-ES running DC/OSx (SVR4)
+    # needs -lnsl.
+    # The nsl library prevents programs from opening the X display
+    # on Irix 5.2, according to T.E. Dickey.
+    # The functions gethostbyname, getservbyname, and inet_addr are
+    # in -lbsd on LynxOS 3.0.1/i386, according to Lars Hecking.
+    echo &quot;$as_me:$LINENO: checking for gethostbyname&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for gethostbyname... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_func_gethostbyname+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+/* Define gethostbyname to an innocuous variant, in case &lt;limits.h&gt; declares gethostbyname.
+   For example, HP-UX 11i &lt;limits.h&gt; declares gettimeofday.  */
+#define gethostbyname innocuous_gethostbyname
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char gethostbyname (); below.
+    Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+    &lt;limits.h&gt; exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+
+#undef gethostbyname
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_gethostbyname) || defined (__stub___gethostbyname)
+choke me
+#else
+char (*f) () = gethostbyname;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != gethostbyname;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_func_gethostbyname=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_func_gethostbyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_func_gethostbyname&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_func_gethostbyname&quot; &gt;&amp;6
+
+    if test $ac_cv_func_gethostbyname = no; then
+      echo &quot;$as_me:$LINENO: checking for gethostbyname in -lnsl&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for gethostbyname in -lnsl... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_nsl_gethostbyname+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lnsl  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_nsl_gethostbyname&quot; &gt;&amp;6
+if test $ac_cv_lib_nsl_gethostbyname = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -lnsl&quot;
+fi
+
+      if test $ac_cv_lib_nsl_gethostbyname = no; then
+	echo &quot;$as_me:$LINENO: checking for gethostbyname in -lbsd&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for gethostbyname in -lbsd... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_bsd_gethostbyname+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lbsd  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_bsd_gethostbyname=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_bsd_gethostbyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_bsd_gethostbyname&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_bsd_gethostbyname&quot; &gt;&amp;6
+if test $ac_cv_lib_bsd_gethostbyname = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -lbsd&quot;
+fi
+
+      fi
+    fi
+
+    # <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">lieder at skyler.mavd.honeywell.com</A> says without -lsocket,
+    # socket/setsockopt and other routines are undefined under SCO ODT
+    # 2.0.  But -lsocket is broken on IRIX 5.2 (and is not necessary
+    # on later versions), says Simon Leinen: it contains gethostby*
+    # variants that don't use the name server (or something).  -lsocket
+    # must be given before -lnsl if both are needed.  We assume that
+    # if connect needs -lnsl, so does gethostbyname.
+    echo &quot;$as_me:$LINENO: checking for connect&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for connect... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_func_connect+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+/* Define connect to an innocuous variant, in case &lt;limits.h&gt; declares connect.
+   For example, HP-UX 11i &lt;limits.h&gt; declares gettimeofday.  */
+#define connect innocuous_connect
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char connect (); below.
+    Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+    &lt;limits.h&gt; exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+
+#undef connect
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char connect ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_connect) || defined (__stub___connect)
+choke me
+#else
+char (*f) () = connect;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != connect;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_func_connect=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_func_connect=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_func_connect&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_func_connect&quot; &gt;&amp;6
+
+    if test $ac_cv_func_connect = no; then
+      echo &quot;$as_me:$LINENO: checking for connect in -lsocket&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for connect in -lsocket... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_socket_connect+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lsocket $X_EXTRA_LIBS $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char connect ();
+int
+main ()
+{
+connect ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_socket_connect=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_socket_connect=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_socket_connect&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_socket_connect&quot; &gt;&amp;6
+if test $ac_cv_lib_socket_connect = yes; then
+  X_EXTRA_LIBS=&quot;-lsocket $X_EXTRA_LIBS&quot;
+fi
+
+    fi
+
+    # Guillermo Gomez says -lposix is necessary on A/UX.
+    echo &quot;$as_me:$LINENO: checking for remove&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for remove... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_func_remove+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+/* Define remove to an innocuous variant, in case &lt;limits.h&gt; declares remove.
+   For example, HP-UX 11i &lt;limits.h&gt; declares gettimeofday.  */
+#define remove innocuous_remove
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char remove (); below.
+    Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+    &lt;limits.h&gt; exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+
+#undef remove
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char remove ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_remove) || defined (__stub___remove)
+choke me
+#else
+char (*f) () = remove;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != remove;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_func_remove=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_func_remove=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_func_remove&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_func_remove&quot; &gt;&amp;6
+
+    if test $ac_cv_func_remove = no; then
+      echo &quot;$as_me:$LINENO: checking for remove in -lposix&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for remove in -lposix... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_posix_remove+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lposix  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char remove ();
+int
+main ()
+{
+remove ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_posix_remove=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_posix_remove=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_posix_remove&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_posix_remove&quot; &gt;&amp;6
+if test $ac_cv_lib_posix_remove = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -lposix&quot;
+fi
+
+    fi
+
+    # BSDI BSD/OS 2.1 needs -lipc for XOpenDisplay.
+    echo &quot;$as_me:$LINENO: checking for shmat&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for shmat... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_func_shmat+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+/* Define shmat to an innocuous variant, in case &lt;limits.h&gt; declares shmat.
+   For example, HP-UX 11i &lt;limits.h&gt; declares gettimeofday.  */
+#define shmat innocuous_shmat
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char shmat (); below.
+    Prefer &lt;limits.h&gt; to &lt;assert.h&gt; if __STDC__ is defined, since
+    &lt;limits.h&gt; exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include &lt;limits.h&gt;
+#else
+# include &lt;assert.h&gt;
+#endif
+
+#undef shmat
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char shmat ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_shmat) || defined (__stub___shmat)
+choke me
+#else
+char (*f) () = shmat;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != shmat;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_func_shmat=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_func_shmat=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_func_shmat&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_func_shmat&quot; &gt;&amp;6
+
+    if test $ac_cv_func_shmat = no; then
+      echo &quot;$as_me:$LINENO: checking for shmat in -lipc&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for shmat in -lipc... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_ipc_shmat+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lipc  $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char shmat ();
+int
+main ()
+{
+shmat ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_ipc_shmat=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_ipc_shmat=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_ipc_shmat&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_ipc_shmat&quot; &gt;&amp;6
+if test $ac_cv_lib_ipc_shmat = yes; then
+  X_EXTRA_LIBS=&quot;$X_EXTRA_LIBS -lipc&quot;
+fi
+
+    fi
+  fi
+
+  # Check for libraries that X11R6 Xt/Xaw programs need.
+  ac_save_LDFLAGS=$LDFLAGS
+  test -n &quot;$x_libraries&quot; &amp;&amp; LDFLAGS=&quot;$LDFLAGS -L$x_libraries&quot;
+  # SM needs ICE to (dynamically) link under SunOS 4.x (so we have to
+  # check for ICE first), but we must link in the order -lSM -lICE or
+  # we get undefined symbols.  So assume we have SM if we have ICE.
+  # These have to be linked with before -lX11, unlike the other
+  # libraries we check for below, so use a different variable.
+  # John Interrante, Karl Berry
+  echo &quot;$as_me:$LINENO: checking for IceConnectionNumber in -lICE&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for IceConnectionNumber in -lICE... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${ac_cv_lib_ICE_IceConnectionNumber+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS=&quot;-lICE $X_EXTRA_LIBS $LIBS&quot;
+cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char IceConnectionNumber ();
+int
+main ()
+{
+IceConnectionNumber ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_link\&quot;&quot;) &gt;&amp;5
+  (eval $ac_link) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_ICE_IceConnectionNumber=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+ac_cv_lib_ICE_IceConnectionNumber=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo &quot;$as_me:$LINENO: result: $ac_cv_lib_ICE_IceConnectionNumber&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$ac_cv_lib_ICE_IceConnectionNumber&quot; &gt;&amp;6
+if test $ac_cv_lib_ICE_IceConnectionNumber = yes; then
+  X_PRE_LIBS=&quot;$X_PRE_LIBS -lSM -lICE&quot;
+fi
+
+  LDFLAGS=$ac_save_LDFLAGS
+
+fi
+
+
+ac_help=&quot;$ac_help
+  --with-symbols          add the -g flag to produce the debug symbols
+  --with-info             enable basic log output to trace the program
+  --with-valgrind         clean up allocated buffers to avoid valgrind warnings
+  --with-version          use this version for produced libraries
+
+  --with-static-png       enable static linking of PNG library
+  --with-static-jpeg      enable static linking of JPEG library&quot;
+
+
+
+
+
+echo &quot;$as_me:$LINENO: checking for Cygwin32 environment&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for Cygwin32 environment... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${nxproxy_cv_cygwin32+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+return __CYGWIN32__;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  nxproxy_cv_cygwin32=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+nxproxy_cv_cygwin32=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest*
+fi
+echo &quot;$as_me:$LINENO: result: $nxproxy_cv_cygwin32&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxproxy_cv_cygwin32&quot; &gt;&amp;6
+CYGWIN32=
+test &quot;$nxproxy_cv_cygwin32&quot; = yes &amp;&amp; CYGWIN32=yes
+if test &quot;$CYGWIN32&quot; = yes; then
+    LIBS=&quot;$LIBS -mwindows -lstdc++&quot;
+fi
+
+
+
+echo &quot;$as_me:$LINENO: checking for Amd64 environment&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for Amd64 environment... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${nxconf_cv_amd64+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+return (__amd64__ || __x86_64__);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  nxconf_cv_amd64=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+nxconf_cv_amd64=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest*
+fi
+echo &quot;$as_me:$LINENO: result: $nxconf_cv_amd64&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxconf_cv_amd64&quot; &gt;&amp;6
+AMD64=
+test &quot;$nxconf_cv_amd64&quot; = yes &amp;&amp; AMD64=yes
+
+
+
+echo &quot;$as_me:$LINENO: checking for SunOS environment&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for SunOS environment... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${nxconf_cv_sun+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+return __sun;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  nxconf_cv_sun=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+nxconf_cv_sun=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest*
+fi
+echo &quot;$as_me:$LINENO: result: $nxconf_cv_sun&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxconf_cv_sun&quot; &gt;&amp;6
+SUN=
+test &quot;$nxconf_cv_sun&quot; = yes &amp;&amp; SUN=yes
+
+if test &quot;$SUN&quot; = yes; then
+  CFLAGS=&quot;$CFLAGS -I/usr/sfw/include&quot;
+fi
+
+if test &quot;$SUN&quot; = yes; then
+  LDFLAGS=&quot;$LDFLAGS -G -h \$(LIBLOAD) -L/usr/sfw/lib&quot;
+else
+  LDFLAGS=&quot;$LDFLAGS -shared -Wl,-soname,\$(LIBLOAD)&quot;
+fi
+
+
+
+echo &quot;$as_me:$LINENO: checking for FreeBSD environment&quot; &gt;&amp;5
+echo $ECHO_N &quot;checking for FreeBSD environment... $ECHO_C&quot; &gt;&amp;6
+if test &quot;${nxconf_cv_freebsd+set}&quot; = set; then
+  echo $ECHO_N &quot;(cached) $ECHO_C&quot; &gt;&amp;6
+else
+  cat &gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h &gt;&gt;conftest.$ac_ext
+cat &gt;&gt;conftest.$ac_ext &lt;&lt;_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+return __FreeBSD__;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compile\&quot;&quot;) &gt;&amp;5
+  (eval $ac_compile) 2&gt;conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 &gt;conftest.err
+  rm -f conftest.er1
+  cat conftest.err &gt;&amp;5
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); } &amp;&amp;
+	 { ac_try='test -z &quot;$ac_cxx_werror_flag&quot;
+			 || test ! -s conftest.err'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; } &amp;&amp;
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_try\&quot;&quot;) &gt;&amp;5
+  (eval $ac_try) 2&gt;&amp;5
+  ac_status=$?
+  echo &quot;$as_me:$LINENO: \$? = $ac_status&quot; &gt;&amp;5
+  (exit $ac_status); }; }; then
+  nxconf_cv_freebsd=yes
+else
+  echo &quot;$as_me: failed program was:&quot; &gt;&amp;5
+sed 's/^/| /' conftest.$ac_ext &gt;&amp;5
+
+nxconf_cv_freebsd=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest*
+fi
+echo &quot;$as_me:$LINENO: result: $nxconf_cv_freebsd&quot; &gt;&amp;5
+echo &quot;${ECHO_T}$nxconf_cv_freebsd&quot; &gt;&amp;6
+FreeBSD=
+test &quot;$nxconf_cv_freebsd&quot; = yes &amp;&amp; FreeBSD=yes
+
+
+if test &quot;$CYGWIN32&quot; != yes -a &quot;$DARWIN&quot; != yes; then
+  CXXFLAGS=&quot;$CXXFLAGS -fPIC&quot;
+  CFLAGS=&quot;$CFLAGS -fPIC&quot;
+fi
+
+
+if test &quot;$FreeBSD&quot; = yes; then
+  LIBS=&quot;$LIBS  -L/usr/local/lib&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -I/usr/local/include&quot;
+  CFLAGS=&quot;$CFLAGS -I/usr/local/include&quot;
+fi
+
+
+if test &quot;${with_static_png}&quot; = yes; then
+  echo -e &quot;enabling static linking of PNG library&quot;
+  if test &quot;$CYGWIN32&quot; = yes; then
+    LIBS=&quot;$LIBSTATIC -static -lpng&quot;
+  else
+    if test -f &quot;/usr/lib/libpng.a&quot; ; then
+      LIBS=&quot;/usr/lib/libpng.a $LIBS&quot;
+    else
+      if test -f &quot;/usr/local/lib/libpng.a&quot; ; then
+        echo -e &quot;assuming libpng.a in /usr/local/lib&quot;
+        LIBS=&quot;/usr/local/lib/libpng.a $LIBS&quot;
+      else
+        echo -e &quot;assuming libpng.a in default linker path&quot;
+        LIBS=&quot;libpng.a $LIBS&quot;
+      fi
+    fi
+  fi
+else
+  echo -e &quot;enabling dynamic linking of PNG library&quot;
+  LIBS=&quot;-lpng $LIBS&quot;
+fi
+
+if test &quot;${with_static_jpeg}&quot; = yes; then
+  echo -e &quot;enabling static linking of JPEG library&quot;
+  if test &quot;$CYGWIN32&quot; = yes; then
+    LIBSTATIC=&quot;$LIBS -static -ljpeg&quot;
+  else
+    if test -f &quot;/usr/lib/libjpeg.a&quot; ; then
+      LIBS=&quot;/usr/lib/libjpeg.a $LIBS&quot;
+    else
+      if test -f &quot;/usr/local/lib/libjpeg.a&quot; ; then
+        echo -e &quot;assuming libjpeg.a in /usr/local/lib&quot;
+        LIBS=&quot;/usr/local/lib/libjpeg.a $LIBS&quot;
+      else
+        echo -e &quot;assuming libjpeg.a in default linker path&quot;
+        LIBS=&quot;libjpeg.a $LIBS&quot;
+      fi
+    fi
+  fi
+else
+  echo -e &quot;enabling dynamic linking of JPEG library&quot;
+  LIBS=&quot;-ljpeg $LIBS&quot;
+fi
+
+if test &quot;${with_symbols}&quot; = yes; then
+  echo -e &quot;enabling production of debug symbols&quot;
+  CXXFLAGS=&quot;-g $CXXFLAGS&quot;
+  CFLAGS=&quot;-g $CFLAGS&quot;
+else
+  echo -e &quot;disabling production of debug symbols&quot;
+fi
+
+if test &quot;${with_info}&quot; = yes; then
+  echo -e &quot;enabling info output in the log file&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DINFO&quot;
+  CFLAGS=&quot;$CFLAGS -DINFO&quot;
+else
+  echo -e &quot;disabling info output in the log file&quot;
+fi
+
+if test &quot;${with_valgrind}&quot; = yes; then
+  echo -e &quot;enabling valgrind memory checker workarounds&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DVALGRIND&quot;
+  CFLAGS=&quot;$CFLAGS -DVALGRIND&quot;
+else
+  echo -e &quot;disabling valgrind memory checker workarounds&quot;
+fi
+
+
+
+if test &quot;${with_version}&quot; = yes; then
+  VERSION=${ac_option}
+else
+  VERSION=`cat VERSION`
+fi
+echo -e &quot;compiling version ${VERSION}&quot;
+
+LIBVERSION=`echo ${VERSION} | cut -d '.' -f 1`
+
+CXXFLAGS=&quot;$CXXFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+CFLAGS=&quot;$CFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+
+
+
+
+if test -x &quot;../nx-X11/config/makedepend/makedepend&quot; ; then
+  MAKEDEPEND=../nx-X11/config/makedepend/makedepend
+else
+  if test -x &quot;/usr/X11R6/bin/makedepend&quot; ; then
+    MAKEDEPEND=/usr/X11R6/bin/makedepend
+  else
+    if test -x &quot;/usr/openwin/bin/makedepend&quot; ; then
+      MAKEDEPEND=/usr/openwin/bin/makedepend
+    else
+      MAKEDEPEND=/usr/bin/makedepend
+    fi
+  fi
+fi
+
+
+
+
+if test &quot;$CYGWIN32&quot; = yes; then
+    ALL=&quot;\$(LIBCYGARCHIVE) \$(LIBCYGSHARED) \$(LIBARCHIVE)&quot;
+else
+    ALL=&quot;\$(LIBFULL) \$(LIBLOAD) \$(LIBSHARED) \$(LIBARCHIVE)&quot;
+fi
+
+          ac_config_files=&quot;$ac_config_files Makefile&quot;
+cat &gt;confcache &lt;&lt;\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2&gt;&amp;1 |
+    case `(ac_space=' '; set | grep ac_space) 2&gt;&amp;1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	&quot;s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p&quot;
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+	&quot;s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p&quot;
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test &quot;${\1+set}&quot; = set || &amp;/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' &gt;&gt;confcache
+if diff $cache_file confcache &gt;/dev/null 2&gt;&amp;1; then :; else
+  if test -w $cache_file; then
+    test &quot;x$cache_file&quot; != &quot;x/dev/null&quot; &amp;&amp; echo &quot;updating cache $cache_file&quot;
+    cat confcache &gt;$cache_file
+  else
+    echo &quot;not updating unwritable cache $cache_file&quot;
+  fi
+fi
+rm -f confcache
+
+test &quot;x$prefix&quot; = xNONE &amp;&amp; prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test &quot;x$exec_prefix&quot; = xNONE &amp;&amp; exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is &quot;.&quot;, strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test &quot;x$srcdir&quot; = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
+# Transform confdefs.h into DEFS.
+# Protect against shell expansion while executing Makefile rules.
+# Protect against Makefile macro expansion.
+#
+# If the first sed substitution is executed (which looks for macros that
+# take arguments), then we branch to the quote section.  Otherwise,
+# look for a macro that doesn't take arguments.
+cat &gt;confdef2opt.sed &lt;&lt;\_ACEOF
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+d
+: quote
+s,[	 `~#$^&amp;*(){}\\|;'&quot;&lt;&gt;?],\\&amp;,g
+s,\[,\\&amp;,g
+s,\],\\&amp;,g
+s,\$,$$,g
+p
+_ACEOF
+# We use echo to avoid assuming a particular line-breaking character.
+# The extra dot is to prevent the shell from consuming trailing
+# line-breaks from the sub-command output.  A line-break within
+# single-quotes doesn't work because, if this script is created in a
+# platform that uses two characters for line-breaks (e.g., DOS), tr
+# would break.
+ac_LF_and_DOT=`echo; echo .`
+DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr &quot;$ac_LF_and_DOT&quot; ' .'`
+rm -f confdef2opt.sed
+
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test &quot;x$ac_i&quot; = x: &amp;&amp; continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo &quot;$ac_i&quot; |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs=&quot;$ac_libobjs $ac_i\$U.$ac_objext&quot;
+  ac_ltlibobjs=&quot;$ac_ltlibobjs $ac_i&quot;'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files=&quot;$ac_clean_files $CONFIG_STATUS&quot;
+{ echo &quot;$as_me:$LINENO: creating $CONFIG_STATUS&quot; &gt;&amp;5
+echo &quot;$as_me: creating $CONFIG_STATUS&quot; &gt;&amp;6;}
+cat &gt;$CONFIG_STATUS &lt;&lt;_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n &quot;${ZSH_VERSION+set}&quot; &amp;&amp; (emulate sh) &gt;/dev/null 2&gt;&amp;1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+&quot;$@&quot;}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+&quot;$@&quot;}'='&quot;$@&quot;'
+elif test -n &quot;${BASH_VERSION+set}&quot; &amp;&amp; (set -o posix) &gt;/dev/null 2&gt;&amp;1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) &gt;/dev/null 2&gt;&amp;1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='&gt; '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z &quot;`(eval $as_var=C; export $as_var) 2&gt;&amp;1`&quot;); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' &gt;/dev/null 2&gt;&amp;1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) &gt;/dev/null 2&gt;&amp;1 &amp;&amp; test &quot;X`basename / 2&gt;&amp;1`&quot; = &quot;X/&quot;; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename &quot;$0&quot; ||
+$as_expr X/&quot;$0&quot; : '.*/\([^/][^/]*\)/*$' \| \
+	 X&quot;$0&quot; : 'X\(//\)$' \| \
+	 X&quot;$0&quot; : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2&gt;/dev/null ||
+echo X/&quot;$0&quot; |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test &quot;${PATH_SEPARATOR+set}&quot; != set; then
+  echo &quot;#! /bin/sh&quot; &gt;conf$$.sh
+  echo  &quot;exit 0&quot;   &gt;&gt;conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH=&quot;/nonexistent;.&quot;; conf$$.sh) &gt;/dev/null 2&gt;&amp;1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2&gt;/dev/null`
+  test &quot;x$as_lineno_1&quot; != &quot;x$as_lineno_2&quot; &amp;&amp;
+  test &quot;x$as_lineno_3&quot;  = &quot;x$as_lineno_2&quot;  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  test -r &quot;$as_dir/$0&quot; &amp;&amp; as_myself=$as_dir/$0 &amp;&amp; break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test &quot;x$as_myself&quot; = x; then
+    as_myself=$0
+  fi
+  if test ! -f &quot;$as_myself&quot;; then
+    { { echo &quot;$as_me:$LINENO: error: cannot find myself; rerun with an absolute path&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot find myself; rerun with an absolute path&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if (&quot;$as_dir/$as_base&quot; -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2&gt;/dev/null`
+  test &quot;x$as_lineno_1&quot; != &quot;x$as_lineno_2&quot; &amp;&amp;
+  test &quot;x$as_lineno_3&quot;  = &quot;x$as_lineno_2&quot; ') 2&gt;/dev/null; then
+	     $as_unset BASH_ENV || test &quot;${BASH_ENV+set}&quot; != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test &quot;${ENV+set}&quot; != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec &quot;$CONFIG_SHELL&quot; &quot;$0&quot; ${1+&quot;$@&quot;}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' &lt;$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' &gt;$as_me.lineno &amp;&amp;
+  chmod +x $as_me.lineno ||
+    { { echo &quot;$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo &quot;testing\c&quot;; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' &gt;/dev/null 2&gt;&amp;1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo &gt;conf$$.file
+if ln -s conf$$.file conf$$ 2&gt;/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2&gt;/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2&gt;/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p &amp;&amp; rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p=&quot;test -f&quot;
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp=&quot;eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'&quot;
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh=&quot;eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'&quot;
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=&quot; 	$as_nl&quot;
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6&gt;&amp;1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5&gt;&gt;config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' &lt;&lt;_ASBOX
+## Running $as_me. ##
+_ASBOX
+} &gt;&amp;5
+cat &gt;&amp;5 &lt;&lt;_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo &quot;on `(hostname || uname -n) 2&gt;/dev/null | sed 1q`&quot; &gt;&amp;5
+echo &gt;&amp;5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n &quot;$ac_config_files&quot;; then
+  echo &quot;config_files=\&quot;$ac_config_files\&quot;&quot; &gt;&gt;$CONFIG_STATUS
+fi
+
+if test -n &quot;$ac_config_headers&quot;; then
+  echo &quot;config_headers=\&quot;$ac_config_headers\&quot;&quot; &gt;&gt;$CONFIG_STATUS
+fi
+
+if test -n &quot;$ac_config_links&quot;; then
+  echo &quot;config_links=\&quot;$ac_config_links\&quot;&quot; &gt;&gt;$CONFIG_STATUS
+fi
+
+if test -n &quot;$ac_config_commands&quot;; then
+  echo &quot;config_commands=\&quot;$ac_config_commands\&quot;&quot; &gt;&gt;$CONFIG_STATUS
+fi
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+
+ac_cs_usage=&quot;\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Report bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">bug-autoconf at gnu.org</A>&gt;.&quot;
+_ACEOF
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;_ACEOF
+ac_cs_version=&quot;\\
+config.status
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\&quot;`echo &quot;$ac_configure_args&quot; | sed 's/[\\&quot;&quot;\`\$]/\\\\&amp;/g'`\\&quot;
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.&quot;
+srcdir=$srcdir
+INSTALL=&quot;$INSTALL&quot;
+_ACEOF
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr &quot;x$1&quot; : 'x\([^=]*\)='`
+    ac_optarg=`expr &quot;x$1&quot; : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo &quot;$ac_cs_version&quot;; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo &quot;$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information.&quot; &gt;&amp;5
+echo &quot;$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo &quot;$ac_cs_usage&quot;; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES=&quot;$CONFIG_FILES $ac_optarg&quot;
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS=&quot;$CONFIG_HEADERS $ac_optarg&quot;
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo &quot;$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information.&quot; &gt;&amp;5
+echo &quot;$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information.&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets=&quot;$ac_config_targets $1&quot; ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6&gt;/dev/null
+  ac_configure_extra_args=&quot;$ac_configure_extra_args --silent&quot;
+fi
+
+_ACEOF
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;_ACEOF
+if \$ac_cs_recheck; then
+  echo &quot;running $SHELL $0 &quot; $ac_configure_args \$ac_configure_extra_args &quot; --no-create --no-recursion&quot; &gt;&amp;6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case &quot;$ac_config_target&quot; in
+  # Handling of arguments.
+  &quot;Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES Makefile&quot; ;;
+  *) { { echo &quot;$as_me:$LINENO: error: invalid argument: $ac_config_target&quot; &gt;&amp;5
+echo &quot;$as_me: error: invalid argument: $ac_config_target&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test &quot;${CONFIG_FILES+set}&quot; = set || CONFIG_FILES=$config_files
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp &amp;&amp; exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 &amp;&amp; mktemp -d -q &quot;./confstatXXXXXX&quot;) 2&gt;/dev/null` &amp;&amp;
+  test -n &quot;$tmp&quot; &amp;&amp; test -d &quot;$tmp&quot;
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 &amp;&amp; mkdir $tmp)
+} ||
+{
+   echo &quot;$me: cannot create a temporary directory in .&quot; &gt;&amp;2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n &quot;\$CONFIG_FILES&quot;; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&amp;,]/\\\\&amp;/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' &gt;\$tmp/subs.sed &lt;&lt;\\CEOF
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at SHELL</A>@,$SHELL,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PATH_SEPARATOR</A>@,$PATH_SEPARATOR,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PACKAGE_NAME</A>@,$PACKAGE_NAME,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PACKAGE_TARNAME</A>@,$PACKAGE_TARNAME,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PACKAGE_VERSION</A>@,$PACKAGE_VERSION,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PACKAGE_STRING</A>@,$PACKAGE_STRING,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at PACKAGE_BUGREPORT</A>@,$PACKAGE_BUGREPORT,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at exec_prefix</A>@,$exec_prefix,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at prefix</A>@,$prefix,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at program_transform_name</A>@,$program_transform_name,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at bindir</A>@,$bindir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at sbindir</A>@,$sbindir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at libexecdir</A>@,$libexecdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at datadir</A>@,$datadir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at sysconfdir</A>@,$sysconfdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at sharedstatedir</A>@,$sharedstatedir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at localstatedir</A>@,$localstatedir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at libdir</A>@,$libdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at includedir</A>@,$includedir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at oldincludedir</A>@,$oldincludedir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at infodir</A>@,$infodir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at mandir</A>@,$mandir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at build_alias</A>@,$build_alias,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at host_alias</A>@,$host_alias,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at target_alias</A>@,$target_alias,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at DEFS</A>@,$DEFS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at ECHO_C</A>@,$ECHO_C,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at ECHO_N</A>@,$ECHO_N,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at ECHO_T</A>@,$ECHO_T,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at LIBS</A>@,$LIBS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CXX</A>@,$CXX,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CXXFLAGS</A>@,$CXXFLAGS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at LDFLAGS</A>@,$LDFLAGS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CPPFLAGS</A>@,$CPPFLAGS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at ac_ct_CXX</A>@,$ac_ct_CXX,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at EXEEXT</A>@,$EXEEXT,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at OBJEXT</A>@,$OBJEXT,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CC</A>@,$CC,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CFLAGS</A>@,$CFLAGS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at ac_ct_CC</A>@,$ac_ct_CC,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at INSTALL_PROGRAM</A>@,$INSTALL_PROGRAM,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at INSTALL_SCRIPT</A>@,$INSTALL_SCRIPT,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at INSTALL_DATA</A>@,$INSTALL_DATA,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at CXXCPP</A>@,$CXXCPP,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at X_CFLAGS</A>@,$X_CFLAGS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at X_PRE_LIBS</A>@,$X_PRE_LIBS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at X_LIBS</A>@,$X_LIBS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at X_EXTRA_LIBS</A>@,$X_EXTRA_LIBS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at LIBVERSION</A>@,$LIBVERSION,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at VERSION</A>@,$VERSION,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at MAKEDEPEND</A>@,$MAKEDEPEND,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at ALL</A>@,$ALL,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at LIBOBJS</A>@,$LIBOBJS,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at LTLIBOBJS</A>@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed &quot;1,${ac_beg}d; ${ac_end}q&quot; $tmp/subs.sed &gt;$tmp/subs.frag
+    else
+      sed &quot;${ac_end}q&quot; $tmp/subs.sed &gt;$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' &amp;&amp; cat $tmp/subs.frag) &gt;$tmp/subs-$ac_sed_frag.sed
+      if test -z &quot;$ac_sed_cmds&quot;; then
+	ac_sed_cmds=&quot;sed -f $tmp/subs-$ac_sed_frag.sed&quot;
+      else
+	ac_sed_cmds=&quot;$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed&quot;
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z &quot;$ac_sed_cmds&quot;; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n &quot;$CONFIG_FILES&quot;
+
+_ACEOF
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+for ac_file in : $CONFIG_FILES; do test &quot;x$ac_file&quot; = x: &amp;&amp; continue
+  # Support &quot;outfile[:infile[:infile...]]&quot;, defaulting infile=&quot;outfile.in&quot;.
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat &gt;$tmp/stdin
+	ac_file_in=`echo &quot;$ac_file&quot; | sed 's,[^:]*:,,'`
+	ac_file=`echo &quot;$ac_file&quot; | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo &quot;$ac_file&quot; | sed 's,[^:]*:,,'`
+	ac_file=`echo &quot;$ac_file&quot; | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname &quot;$ac_file&quot;) 2&gt;/dev/null ||
+$as_expr X&quot;$ac_file&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X&quot;$ac_file&quot; : 'X\(//\)[^/]' \| \
+	 X&quot;$ac_file&quot; : 'X\(//\)$' \| \
+	 X&quot;$ac_file&quot; : 'X\(/\)' \| \
+	 .     : '\(.\)' 2&gt;/dev/null ||
+echo X&quot;$ac_file&quot; |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p &quot;$ac_dir&quot;
+  else
+    as_dir=&quot;$ac_dir&quot;
+    as_dirs=
+    while test ! -d &quot;$as_dir&quot;; do
+      as_dirs=&quot;$as_dir $as_dirs&quot;
+      as_dir=`(dirname &quot;$as_dir&quot;) 2&gt;/dev/null ||
+$as_expr X&quot;$as_dir&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X&quot;$as_dir&quot; : 'X\(//\)[^/]' \| \
+	 X&quot;$as_dir&quot; : 'X\(//\)$' \| \
+	 X&quot;$as_dir&quot; : 'X\(/\)' \| \
+	 .     : '\(.\)' 2&gt;/dev/null ||
+echo X&quot;$as_dir&quot; |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n &quot;$as_dirs&quot; || mkdir $as_dirs
+  fi || { { echo &quot;$as_me:$LINENO: error: cannot create directory \&quot;$ac_dir\&quot;&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot create directory \&quot;$ac_dir\&quot;&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test &quot;$ac_dir&quot; != .; then
+  ac_dir_suffix=/`echo &quot;$ac_dir&quot; | sed 's,^\.[\\/],,'`
+  # A &quot;../&quot; for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo &quot;$ac_dir_suffix&quot; | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z &quot;$ac_top_builddir&quot;; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo &amp;&amp; pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir=&quot;$ac_dir&quot;;;
+*)
+  case &quot;$ac_dir&quot; in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir=&quot;$ac_dir&quot;;;
+  *) ac_abs_builddir=`pwd`/&quot;$ac_dir&quot;;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x&quot;$ac_file&quot; != x-; then
+    { echo &quot;$as_me:$LINENO: creating $ac_file&quot; &gt;&amp;5
+echo &quot;$as_me: creating $ac_file&quot; &gt;&amp;6;}
+    rm -f &quot;$ac_file&quot;
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x&quot;$ac_file&quot; = x-; then
+    configure_input=
+  else
+    configure_input=&quot;$ac_file.  &quot;
+  fi
+  configure_input=$configure_input&quot;Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure.&quot;
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f &quot;$f&quot; || { { echo &quot;$as_me:$LINENO: error: cannot find input file: $f&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot find input file: $f&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+	 echo &quot;$f&quot;;;
+      *) # Relative
+	 if test -f &quot;$f&quot;; then
+	   # Build tree
+	   echo &quot;$f&quot;
+	 elif test -f &quot;$srcdir/$f&quot;; then
+	   # Source tree
+	   echo &quot;$srcdir/$f&quot;
+	 else
+	   # /dev/null tree
+	   { { echo &quot;$as_me:$LINENO: error: cannot find input file: $f&quot; &gt;&amp;5
+echo &quot;$as_me: error: cannot find input file: $f&quot; &gt;&amp;2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;_ACEOF
+  sed &quot;$ac_vpsub
+$extrasub
+_ACEOF
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at configure_input</A>@,$configure_input,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at srcdir</A>@,$ac_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at abs_srcdir</A>@,$ac_abs_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at top_srcdir</A>@,$ac_top_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at abs_top_srcdir</A>@,$ac_abs_top_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at builddir</A>@,$ac_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at abs_builddir</A>@,$ac_abs_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at top_builddir</A>@,$ac_top_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at abs_top_builddir</A>@,$ac_abs_top_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+s, at INSTALL</A>@,$ac_INSTALL,;t t
+&quot; $ac_file_inputs | (eval &quot;$ac_sed_cmds&quot;) &gt;$tmp/out
+  rm -f $tmp/stdin
+  if test x&quot;$ac_file&quot; != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+
+cat &gt;&gt;$CONFIG_STATUS &lt;&lt;\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test &quot;$no_create&quot; != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test &quot;$silent&quot; = yes &amp;&amp;
+    ac_config_status_args=&quot;$ac_config_status_args --quiet&quot;
+  exec 5&gt;/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5&gt;&gt;config.log
+  # Use ||, not &amp;&amp;, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
diff --git a/nxcompext/configure.in b/nxcompext/configure.in
new file mode 100644
index 0000000..fe5abf7
--- /dev/null
+++ b/nxcompext/configure.in
@@ -0,0 +1,249 @@
+dnl Process this file with autoconf to produce a configure script.
+
+dnl Prolog
+
+AC_INIT(NXlib.h)
+AC_PREREQ(2.13)
+
+dnl Reset default compilation flags.
+
+CXXFLAGS=&quot;-O3&quot;
+CFLAGS=&quot;-O3&quot;
+
+dnl Reset default linking directives.
+
+LIBSTATIC=&quot;&quot;
+LIBSHARED=&quot;&quot;
+
+dnl Prefer headers and libraries from nx-X11, if present.
+
+if test -d &quot;../nx-X11/include&quot; ; then
+    CXXFLAGS=&quot;$CXXFLAGS -I../nx-X11/exports/include -I../nx-X11/lib/X11 \
+                        -I../nx-X11/include -I../nx-X11/programs/Xserver/include&quot;
+    CFLAGS=&quot;$CFLAGS -I../nx-X11/exports/include -I../nx-X11/lib/X11 \
+                    -I../nx-X11/include -I../nx-X11/programs/Xserver/include&quot;
+    LDFLAGS=&quot;$LDFLAGS -L../nx-X11/exports/lib&quot;
+fi
+
+dnl Check for programs.
+
+AC_PROG_CXX
+AC_PROG_CC
+AC_LANG_CPLUSPLUS
+
+dnl Check for BSD compatible install.
+
+AC_PROG_INSTALL
+
+dnl Check for extra header files.
+
+AC_PATH_XTRA
+
+dnl Custom addition.
+ac_help=&quot;$ac_help
+  --with-symbols          add the -g flag to produce the debug symbols
+  --with-info             enable basic log output to trace the program
+  --with-valgrind         clean up allocated buffers to avoid valgrind warnings
+  --with-version          use this version for produced libraries
+
+  --with-static-png       enable static linking of PNG library
+  --with-static-jpeg      enable static linking of JPEG library&quot;
+
+dnl Check to see if we're running under Cygwin32.
+
+AC_DEFUN(nxproxy_CYGWIN32,
+[AC_CACHE_CHECK(for Cygwin32 environment, nxproxy_cv_cygwin32,
+[AC_TRY_COMPILE(,[return __CYGWIN32__;],
+nxproxy_cv_cygwin32=yes, nxproxy_cv_cygwin32=no)
+rm -f conftest*])
+CYGWIN32=
+test &quot;$nxproxy_cv_cygwin32&quot; = yes &amp;&amp; CYGWIN32=yes])
+
+dnl CygWin32 requires the stdc++ library explicitly linked.
+
+nxproxy_CYGWIN32
+if test &quot;$CYGWIN32&quot; = yes; then
+    LIBS=&quot;$LIBS -mwindows -lstdc++&quot;
+fi
+
+dnl Check whether we're building on a AMD64.
+
+AC_DEFUN(nxconf_AMD64,
+[AC_CACHE_CHECK(for Amd64 environment, nxconf_cv_amd64,
+[AC_TRY_COMPILE(,[return (__amd64__ || __x86_64__);],
+nxconf_cv_amd64=yes, nxconf_cv_amd64=no)
+rm -f conftest*])
+AMD64=
+test &quot;$nxconf_cv_amd64&quot; = yes &amp;&amp; AMD64=yes])
+nxconf_AMD64
+
+dnl Check to see if we're running under Solaris.
+
+AC_DEFUN(nxconf_SUN,
+[AC_CACHE_CHECK(for SunOS environment, nxconf_cv_sun,
+[AC_TRY_COMPILE(,[return __sun;],
+nxconf_cv_sun=yes, nxconf_cv_sun=no)
+rm -f conftest*])
+SUN=
+test &quot;$nxconf_cv_sun&quot; = yes &amp;&amp; SUN=yes])
+nxconf_SUN
+
+if test &quot;$SUN&quot; = yes; then
+  CFLAGS=&quot;$CFLAGS -I/usr/sfw/include&quot;
+fi
+
+if test &quot;$SUN&quot; = yes; then
+  LDFLAGS=&quot;$LDFLAGS -G -h \$(LIBLOAD) -L/usr/sfw/lib&quot; 
+else
+  LDFLAGS=&quot;$LDFLAGS -shared -Wl,-soname,\$(LIBLOAD)&quot;
+fi
+
+dnl Check to see if we're running under FreeBSD.
+
+AC_DEFUN(nxconf_FreeBSD,
+[AC_CACHE_CHECK(for FreeBSD environment, nxconf_cv_freebsd,
+[AC_TRY_COMPILE(,[return __FreeBSD__;],
+nxconf_cv_freebsd=yes, nxconf_cv_freebsd=no)
+rm -f conftest*])
+FreeBSD=
+test &quot;$nxconf_cv_freebsd&quot; = yes &amp;&amp; FreeBSD=yes])
+nxconf_FreeBSD
+
+dnl Build PIC libraries.
+
+if test &quot;$CYGWIN32&quot; != yes -a &quot;$DARWIN&quot; != yes; then
+  CXXFLAGS=&quot;$CXXFLAGS -fPIC&quot;
+  CFLAGS=&quot;$CFLAGS -fPIC&quot;
+fi
+
+dnl On FreeBSD search libraries and includes under /usr/local.
+
+if test &quot;$FreeBSD&quot; = yes; then
+  LIBS=&quot;$LIBS  -L/usr/local/lib&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -I/usr/local/include&quot;
+  CFLAGS=&quot;$CFLAGS -I/usr/local/include&quot;
+fi
+
+dnl Check whether --with-static-png  was
+dnl given and add -lpng or libpng.a to linking.
+
+if test &quot;${with_static_png}&quot; = yes; then
+  echo -e &quot;enabling static linking of PNG library&quot;
+  if test &quot;$CYGWIN32&quot; = yes; then
+    LIBS=&quot;$LIBSTATIC -static -lpng&quot;
+  else
+    if test -f &quot;/usr/lib/libpng.a&quot; ; then
+      LIBS=&quot;/usr/lib/libpng.a $LIBS&quot;
+    else
+      if test -f &quot;/usr/local/lib/libpng.a&quot; ; then
+        echo -e &quot;assuming libpng.a in /usr/local/lib&quot;
+        LIBS=&quot;/usr/local/lib/libpng.a $LIBS&quot;
+      else
+        echo -e &quot;assuming libpng.a in default linker path&quot;
+        LIBS=&quot;libpng.a $LIBS&quot;
+      fi
+    fi
+  fi
+else
+  echo -e &quot;enabling dynamic linking of PNG library&quot;
+  LIBS=&quot;-lpng $LIBS&quot;
+fi
+
+dnl Check whether --with-static-jpeg  was
+dnl given and add -ljpeg or libjpeg.a to linking.
+if test &quot;${with_static_jpeg}&quot; = yes; then
+  echo -e &quot;enabling static linking of JPEG library&quot;
+  if test &quot;$CYGWIN32&quot; = yes; then
+    LIBSTATIC=&quot;$LIBS -static -ljpeg&quot;
+  else
+    if test -f &quot;/usr/lib/libjpeg.a&quot; ; then
+      LIBS=&quot;/usr/lib/libjpeg.a $LIBS&quot;
+    else
+      if test -f &quot;/usr/local/lib/libjpeg.a&quot; ; then
+        echo -e &quot;assuming libjpeg.a in /usr/local/lib&quot;
+        LIBS=&quot;/usr/local/lib/libjpeg.a $LIBS&quot;
+      else
+        echo -e &quot;assuming libjpeg.a in default linker path&quot;
+        LIBS=&quot;libjpeg.a $LIBS&quot;
+      fi
+    fi
+  fi
+else
+  echo -e &quot;enabling dynamic linking of JPEG library&quot;
+  LIBS=&quot;-ljpeg $LIBS&quot;
+fi
+
+dnl Check whether --with-symbols or --without-symbols was
+dnl given and set the required optimization level.
+if test &quot;${with_symbols}&quot; = yes; then
+  echo -e &quot;enabling production of debug symbols&quot;
+  CXXFLAGS=&quot;-g $CXXFLAGS&quot;
+  CFLAGS=&quot;-g $CFLAGS&quot;
+else
+  echo -e &quot;disabling production of debug symbols&quot;
+fi
+
+dnl Check whether --with-info or --without-info was given.
+if test &quot;${with_info}&quot; = yes; then
+  echo -e &quot;enabling info output in the log file&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DINFO&quot;
+  CFLAGS=&quot;$CFLAGS -DINFO&quot;
+else
+  echo -e &quot;disabling info output in the log file&quot;
+fi
+
+dnl Check whether --with-valgrind or --without-valgrind was given.
+if test &quot;${with_valgrind}&quot; = yes; then
+  echo -e &quot;enabling valgrind memory checker workarounds&quot;
+  CXXFLAGS=&quot;$CXXFLAGS -DVALGRIND&quot;
+  CFLAGS=&quot;$CFLAGS -DVALGRIND&quot;
+else
+  echo -e &quot;disabling valgrind memory checker workarounds&quot;
+fi
+
+dnl Check whether --with-version was given.
+AC_SUBST(LIBVERSION)
+AC_SUBST(VERSION)
+if test &quot;${with_version}&quot; = yes; then
+  VERSION=${ac_option}
+else
+  VERSION=`cat VERSION`
+fi
+echo -e &quot;compiling version ${VERSION}&quot;
+
+LIBVERSION=`echo ${VERSION} | cut -d '.' -f 1`
+
+CXXFLAGS=&quot;$CXXFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+CFLAGS=&quot;$CFLAGS -DVERSION=\\\&quot;${VERSION}\\\&quot;&quot;
+
+dnl Find makedepend somewhere.
+
+AC_SUBST(MAKEDEPEND)
+
+if test -x &quot;../nx-X11/config/makedepend/makedepend&quot; ; then
+  MAKEDEPEND=../nx-X11/config/makedepend/makedepend
+else
+  if test -x &quot;/usr/X11R6/bin/makedepend&quot; ; then
+    MAKEDEPEND=/usr/X11R6/bin/makedepend
+  else
+    if test -x &quot;/usr/openwin/bin/makedepend&quot; ; then
+      MAKEDEPEND=/usr/openwin/bin/makedepend
+    else
+      MAKEDEPEND=/usr/bin/makedepend
+    fi
+  fi
+fi
+
+dnl Determine what to build based on the platform.
+dnl Override the LIBS settings on Cygwin32 so that
+dnl we always link with the exact set of libraries.
+
+AC_SUBST(ALL)
+
+if test &quot;$CYGWIN32&quot; = yes; then
+    ALL=&quot;\$(LIBCYGARCHIVE) \$(LIBCYGSHARED) \$(LIBARCHIVE)&quot;
+else
+    ALL=&quot;\$(LIBFULL) \$(LIBLOAD) \$(LIBSHARED) \$(LIBARCHIVE)&quot;
+fi
+
+AC_OUTPUT(Makefile)
diff --git a/nxcomp/install-sh b/nxcompext/install-sh
similarity index 100%
copy from nxcomp/install-sh
copy to nxcompext/install-sh
diff --git a/nxcomp/mkinstalldirs b/nxcompext/mkinstalldirs
similarity index 100%
copy from nxcomp/mkinstalldirs
copy to nxcompext/mkinstalldirs


hooks/post-receive
-- 
nx-libs.git (NX (redistributed))

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;nx-libs.git&quot; (NX (redistributed)).

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011395.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxcompshad/3.5.0-2-69-g9bfca1c
</A></li>
	<LI>Next message: <A HREF="011371.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	nxproxy/3.5.0-1-82-gf7e6c45
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11426">[ date ]</a>
              <a href="thread.html#11426">[ thread ]</a>
              <a href="subject.html#11426">[ subject ]</a>
              <a href="author.html#11426">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2Go-commits
mailing list</a><br>
</body></html>
