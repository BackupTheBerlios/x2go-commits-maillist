<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxagent/3.5.0-5-27-g9997e13
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/x2go-commits/2013-August/index.html" >
   <LINK REL="made" HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-baikal%20%28branch%29%20updated%3A%0A%09nxagent/3.5.0-5-27-g9997e13&In-Reply-To=%3C20130830142353.6DF8A5DB3E%40ymir%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011663.html">
   <LINK REL="Next"  HREF="011656.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxagent/3.5.0-5-27-g9997e13</H1>
    <B>X2Go dev team</B> 
    <A HREF="mailto:x2go-commits%40lists.berlios.de?Subject=Re%3A%20%5BX2Go-Commits%5D%20nx-libs.git%20-%20build-baikal%20%28branch%29%20updated%3A%0A%09nxagent/3.5.0-5-27-g9997e13&In-Reply-To=%3C20130830142353.6DF8A5DB3E%40ymir%3E"
       TITLE="[X2Go-Commits] nx-libs.git - build-baikal (branch) updated:	nxagent/3.5.0-5-27-g9997e13">git-admin at x2go.org
       </A><BR>
    <I>Fri Aug 30 16:23:52 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="011663.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	redist-client/3.5.0.15-2-ge3ba4bd
</A></li>
        <LI>Next message: <A HREF="011656.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	redist-client/3.5.0.15-7-g380d239
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11694">[ date ]</a>
              <a href="thread.html#11694">[ thread ]</a>
              <a href="subject.html#11694">[ subject ]</a>
              <a href="author.html#11694">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch, build-baikal has been updated
       via  9997e13bb583de4012914006c7507839a4e11227 (commit)
       via  15cee47a496ef891923949ade073cf4ffabb9c73 (commit)
      from  5b4ca0f93c44d7bbc8d6a3eebdd5c458e3a84c14 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
-----------------------------------------------------------------------

Summary of changes:
 nx-X11/CHANGELOG                                   |    6 +
 nx-X11/CHANGELOG.NX.original                       |   12 +
 nx-X11/lib/X11/XKBMAlloc.c                         |   29 +
 .../X11/{XKBMAlloc.c =&gt; XKBMAlloc.c.NX.original}   |   29 +
 .../X11/{XKBMAlloc.c =&gt; XKBMAlloc.c.X.original}    |    0
 .../Xserver/{randr =&gt; randr.X.original}/Imakefile  |    0
 .../Xserver/{randr =&gt; randr.X.original}/mirandr.c  |    0
 .../Xserver/{randr =&gt; randr.X.original}/randr.c    |    0
 .../Xserver/{randr =&gt; randr.X.original}/randrstr.h |    0
 nx-X11/programs/Xserver/randr/Imakefile            |   22 +-
 .../programs/Xserver/randr/Imakefile.NX.original   |   36 +
 .../Xserver/randr/Imakefile.X.original}            |    0
 nx-X11/programs/Xserver/randr/Makefile.am          |   28 +
 nx-X11/programs/Xserver/randr/Makefile.in          |  698 +++++++++++
 nx-X11/programs/Xserver/randr/mirandr.c            |  174 ++-
 .../Xserver/randr}/panoramiXproto.h                |    0
 .../Xserver/randr/panoramiXproto.h.NX.original}    |    0
 .../Xserver/randr/panoramiXproto.h.X.original}     |    0
 nx-X11/programs/Xserver/randr/randr.c              | 1320 ++++----------------
 nx-X11/programs/Xserver/randr/randr.c.NX.original  |  521 ++++++++
 nx-X11/programs/Xserver/randr/randr.c.X.original   |  487 ++++++++
 nx-X11/programs/Xserver/randr/randr.h              |  141 +++
 nx-X11/programs/Xserver/randr/randr.h.NX.original  |  141 +++
 .../Xserver/randr/randr.h.X.original}              |    0
 nx-X11/programs/Xserver/randr/randrproto.h         |  655 ++++++++++
 .../Xserver/randr/randrproto.h.NX.original         |  655 ++++++++++
 .../Xserver/randr/randrproto.h.X.original}         |    0
 nx-X11/programs/Xserver/randr/randrstr.h           |  820 +++++++++++-
 nx-X11/programs/Xserver/randr/registry.h           |   64 +
 .../programs/Xserver/randr/registry.h.NX.original  |   64 +
 .../Xserver/randr/registry.h.X.original}           |    0
 nx-X11/programs/Xserver/randr/rrcrtc.c             |  984 +++++++++++++++
 nx-X11/programs/Xserver/randr/rrcrtc.c.NX.original |  984 +++++++++++++++
 nx-X11/programs/Xserver/randr/rrcrtc.c.X.original  |  960 ++++++++++++++
 nx-X11/programs/Xserver/randr/rrdispatch.c         |  219 ++++
 .../programs/Xserver/randr/rrdispatch.c.X.original |  214 ++++
 nx-X11/programs/Xserver/randr/rrinfo.c             |  335 +++++
 nx-X11/programs/Xserver/randr/rrmode.c             |  420 +++++++
 nx-X11/programs/Xserver/randr/rrmode.c.NX.original |  420 +++++++
 nx-X11/programs/Xserver/randr/rrmode.c.X.original  |  398 ++++++
 nx-X11/programs/Xserver/randr/rroutput.c           |  535 ++++++++
 nx-X11/programs/Xserver/randr/rrpointer.c          |  145 +++
 nx-X11/programs/Xserver/randr/rrproperty.c         |  736 +++++++++++
 nx-X11/programs/Xserver/randr/rrscreen.c           | 1030 +++++++++++++++
 .../programs/Xserver/randr/rrscreen.c.NX.original  | 1030 +++++++++++++++
 .../programs/Xserver/randr/rrscreen.c.X.original   |  981 +++++++++++++++
 nx-X11/programs/Xserver/randr/rrsdispatch.c        |  398 ++++++
 nx-X11/programs/Xserver/randr/rrxinerama.c         |  490 ++++++++
 .../Xserver/randr/rrxinerama.c.NX.original         |  490 ++++++++
 .../programs/Xserver/randr/rrxinerama.c.X.original |  454 +++++++
 50 files changed, 15966 insertions(+), 1159 deletions(-)
 copy nx-X11/lib/X11/{XKBMAlloc.c =&gt; XKBMAlloc.c.NX.original} (96%)
 copy nx-X11/lib/X11/{XKBMAlloc.c =&gt; XKBMAlloc.c.X.original} (100%)
 copy nx-X11/programs/Xserver/{randr =&gt; randr.X.original}/Imakefile (100%)
 copy nx-X11/programs/Xserver/{randr =&gt; randr.X.original}/mirandr.c (100%)
 copy nx-X11/programs/Xserver/{randr =&gt; randr.X.original}/randr.c (100%)
 copy nx-X11/programs/Xserver/{randr =&gt; randr.X.original}/randrstr.h (100%)
 create mode 100644 nx-X11/programs/Xserver/randr/Imakefile.NX.original
 copy nx-X11/{CHANGELOG.X.original =&gt; programs/Xserver/randr/Imakefile.X.original} (100%)
 create mode 100644 nx-X11/programs/Xserver/randr/Makefile.am
 create mode 100644 nx-X11/programs/Xserver/randr/Makefile.in
 copy nx-X11/{include/extensions =&gt; programs/Xserver/randr}/panoramiXproto.h (100%)
 copy nx-X11/{include/extensions/panoramiXproto.h =&gt; programs/Xserver/randr/panoramiXproto.h.NX.original} (100%)
 copy nx-X11/{CHANGELOG.X.original =&gt; programs/Xserver/randr/panoramiXproto.h.X.original} (100%)
 create mode 100644 nx-X11/programs/Xserver/randr/randr.c.NX.original
 create mode 100644 nx-X11/programs/Xserver/randr/randr.c.X.original
 create mode 100644 nx-X11/programs/Xserver/randr/randr.h
 create mode 100644 nx-X11/programs/Xserver/randr/randr.h.NX.original
 copy nx-X11/{CHANGELOG.X.original =&gt; programs/Xserver/randr/randr.h.X.original} (100%)
 create mode 100644 nx-X11/programs/Xserver/randr/randrproto.h
 create mode 100644 nx-X11/programs/Xserver/randr/randrproto.h.NX.original
 copy nx-X11/{CHANGELOG.X.original =&gt; programs/Xserver/randr/randrproto.h.X.original} (100%)
 create mode 100644 nx-X11/programs/Xserver/randr/registry.h
 create mode 100644 nx-X11/programs/Xserver/randr/registry.h.NX.original
 copy nx-X11/{CHANGELOG.X.original =&gt; programs/Xserver/randr/registry.h.X.original} (100%)
 create mode 100644 nx-X11/programs/Xserver/randr/rrcrtc.c
 create mode 100644 nx-X11/programs/Xserver/randr/rrcrtc.c.NX.original
 create mode 100644 nx-X11/programs/Xserver/randr/rrcrtc.c.X.original
 create mode 100644 nx-X11/programs/Xserver/randr/rrdispatch.c
 create mode 100644 nx-X11/programs/Xserver/randr/rrdispatch.c.X.original
 create mode 100644 nx-X11/programs/Xserver/randr/rrinfo.c
 create mode 100644 nx-X11/programs/Xserver/randr/rrmode.c
 create mode 100644 nx-X11/programs/Xserver/randr/rrmode.c.NX.original
 create mode 100644 nx-X11/programs/Xserver/randr/rrmode.c.X.original
 create mode 100644 nx-X11/programs/Xserver/randr/rroutput.c
 create mode 100644 nx-X11/programs/Xserver/randr/rrpointer.c
 create mode 100644 nx-X11/programs/Xserver/randr/rrproperty.c
 create mode 100644 nx-X11/programs/Xserver/randr/rrscreen.c
 create mode 100644 nx-X11/programs/Xserver/randr/rrscreen.c.NX.original
 create mode 100644 nx-X11/programs/Xserver/randr/rrscreen.c.X.original
 create mode 100644 nx-X11/programs/Xserver/randr/rrsdispatch.c
 create mode 100644 nx-X11/programs/Xserver/randr/rrxinerama.c
 create mode 100644 nx-X11/programs/Xserver/randr/rrxinerama.c.NX.original
 create mode 100644 nx-X11/programs/Xserver/randr/rrxinerama.c.X.original

The diff of changes is:
diff --git a/nx-X11/CHANGELOG b/nx-X11/CHANGELOG
index 4327026..ffbbe0a 100644
--- a/nx-X11/CHANGELOG
+++ b/nx-X11/CHANGELOG
@@ -1,5 +1,11 @@
 ChangeLog:
 
+nx-X11-3.5.0-2
+
+- Fixed TR0202420. XKB utility functions wrote out of bounds.
+
+- Upgraded RandR server extension to version 1.2.
+
 nx-X11-3.5.0-1
 
 - Opened the 3.5.0 branch based on nx-X11-3.4.0-4.
diff --git a/nx-X11/CHANGELOG.NX.original b/nx-X11/CHANGELOG.NX.original
index 4faf2ad..ffbbe0a 100644
--- a/nx-X11/CHANGELOG.NX.original
+++ b/nx-X11/CHANGELOG.NX.original
@@ -1,5 +1,17 @@
 ChangeLog:
 
+nx-X11-3.5.0-2
+
+- Fixed TR0202420. XKB utility functions wrote out of bounds.
+
+- Upgraded RandR server extension to version 1.2.
+
+nx-X11-3.5.0-1
+
+- Opened the 3.5.0 branch based on nx-X11-3.4.0-4.
+
+- Updated copyright to year 2011.
+
 nx-X11-3.4.0-4
 
 - Fixed TR06H02359. Removed compiler warnings.
diff --git a/nx-X11/lib/X11/XKBMAlloc.c b/nx-X11/lib/X11/XKBMAlloc.c
index 91d87d5..d57d9a5 100644
--- a/nx-X11/lib/X11/XKBMAlloc.c
+++ b/nx-X11/lib/X11/XKBMAlloc.c
@@ -738,8 +738,13 @@ int	tmp;
 		    _XkbFree(prev_key_sym_map);
 		    return BadAlloc;
 		}
+#ifdef NXAGENT_SERVER
+                bzero((char *)&amp;xkb-&gt;map-&gt;key_sym_map[xkb-&gt;max_key_code+1],
+                                        tmp*sizeof(XkbSymMapRec));
+#else
 		bzero((char *)&amp;xkb-&gt;map-&gt;key_sym_map[xkb-&gt;max_key_code],
 					tmp*sizeof(XkbSymMapRec));
+#endif
 		if (changes) {
 		    changes-&gt;map.changed= _ExtendRange(changes-&gt;map.changed,
 		    				XkbKeySymsMask,maxKC,
@@ -756,7 +761,11 @@ int	tmp;
 		    _XkbFree(prev_modmap);
 		    return BadAlloc;
 		}
+#ifdef NXAGENT_SERVER
+                bzero((char *)&amp;xkb-&gt;map-&gt;modmap[xkb-&gt;max_key_code+1],tmp);
+#else
 		bzero((char *)&amp;xkb-&gt;map-&gt;modmap[xkb-&gt;max_key_code],tmp);
+#endif
 		if (changes) {
 		    changes-&gt;map.changed= _ExtendRange(changes-&gt;map.changed,
 		    				XkbModifierMapMask,maxKC,
@@ -775,8 +784,13 @@ int	tmp;
 		    _XkbFree(prev_behaviors);
 		    return BadAlloc;
 		}
+#ifdef NXAGENT_SERVER
+                bzero((char *)&amp;xkb-&gt;server-&gt;behaviors[xkb-&gt;max_key_code+1],
+                                                tmp*sizeof(XkbBehavior));
+#else
 		bzero((char *)&amp;xkb-&gt;server-&gt;behaviors[xkb-&gt;max_key_code],
 						tmp*sizeof(XkbBehavior));
+#endif
 		if (changes) {
 		    changes-&gt;map.changed= _ExtendRange(changes-&gt;map.changed,
 		    			XkbKeyBehaviorsMask,maxKC,
@@ -793,8 +807,13 @@ int	tmp;
 		    _XkbFree(prev_key_acts);
 		    return BadAlloc;
 		}
+#ifdef NXAGENT_SERVER
+                bzero((char *)&amp;xkb-&gt;server-&gt;key_acts[xkb-&gt;max_key_code+1],
+                                                tmp*sizeof(unsigned short));
+#else
 		bzero((char *)&amp;xkb-&gt;server-&gt;key_acts[xkb-&gt;max_key_code],
 						tmp*sizeof(unsigned short));
+#endif
 		if (changes) {
 		    changes-&gt;map.changed= _ExtendRange(changes-&gt;map.changed,
 		    			XkbKeyActionsMask,maxKC,
@@ -811,8 +830,13 @@ int	tmp;
 		    _XkbFree(prev_vmodmap);
 		    return BadAlloc;
 		}
+#ifdef NXAGENT_SERVER
+                bzero((char *)&amp;xkb-&gt;server-&gt;vmodmap[xkb-&gt;max_key_code+1],
+                                                tmp*sizeof(unsigned short));
+#else
 		bzero((char *)&amp;xkb-&gt;server-&gt;vmodmap[xkb-&gt;max_key_code],
 						tmp*sizeof(unsigned short));
+#endif
 		if (changes) {
 		    changes-&gt;map.changed= _ExtendRange(changes-&gt;map.changed,
 		    			XkbVirtualModMapMask,maxKC,
@@ -830,8 +854,13 @@ int	tmp;
 		_XkbFree(prev_keys);
 		return BadAlloc;
 	    }
+#ifdef NXAGENT_SERVER
+            bzero((char *)&amp;xkb-&gt;names-&gt;keys[xkb-&gt;max_key_code+1],
+                                                tmp*sizeof(XkbKeyNameRec));
+#else
 	    bzero((char *)&amp;xkb-&gt;names-&gt;keys[xkb-&gt;max_key_code],
 	    					tmp*sizeof(XkbKeyNameRec));
+#endif
 	    if (changes) {
 		changes-&gt;names.changed= _ExtendRange(changes-&gt;names.changed,
 					XkbKeyNamesMask,maxKC,
diff --git a/nx-X11/lib/X11/XKBMAlloc.c b/nx-X11/lib/X11/XKBMAlloc.c.NX.original
similarity index 96%
copy from nx-X11/lib/X11/XKBMAlloc.c
copy to nx-X11/lib/X11/XKBMAlloc.c.NX.original
index 91d87d5..d57d9a5 100644
--- a/nx-X11/lib/X11/XKBMAlloc.c
+++ b/nx-X11/lib/X11/XKBMAlloc.c.NX.original
@@ -738,8 +738,13 @@ int	tmp;
 		    _XkbFree(prev_key_sym_map);
 		    return BadAlloc;
 		}
+#ifdef NXAGENT_SERVER
+                bzero((char *)&amp;xkb-&gt;map-&gt;key_sym_map[xkb-&gt;max_key_code+1],
+                                        tmp*sizeof(XkbSymMapRec));
+#else
 		bzero((char *)&amp;xkb-&gt;map-&gt;key_sym_map[xkb-&gt;max_key_code],
 					tmp*sizeof(XkbSymMapRec));
+#endif
 		if (changes) {
 		    changes-&gt;map.changed= _ExtendRange(changes-&gt;map.changed,
 		    				XkbKeySymsMask,maxKC,
@@ -756,7 +761,11 @@ int	tmp;
 		    _XkbFree(prev_modmap);
 		    return BadAlloc;
 		}
+#ifdef NXAGENT_SERVER
+                bzero((char *)&amp;xkb-&gt;map-&gt;modmap[xkb-&gt;max_key_code+1],tmp);
+#else
 		bzero((char *)&amp;xkb-&gt;map-&gt;modmap[xkb-&gt;max_key_code],tmp);
+#endif
 		if (changes) {
 		    changes-&gt;map.changed= _ExtendRange(changes-&gt;map.changed,
 		    				XkbModifierMapMask,maxKC,
@@ -775,8 +784,13 @@ int	tmp;
 		    _XkbFree(prev_behaviors);
 		    return BadAlloc;
 		}
+#ifdef NXAGENT_SERVER
+                bzero((char *)&amp;xkb-&gt;server-&gt;behaviors[xkb-&gt;max_key_code+1],
+                                                tmp*sizeof(XkbBehavior));
+#else
 		bzero((char *)&amp;xkb-&gt;server-&gt;behaviors[xkb-&gt;max_key_code],
 						tmp*sizeof(XkbBehavior));
+#endif
 		if (changes) {
 		    changes-&gt;map.changed= _ExtendRange(changes-&gt;map.changed,
 		    			XkbKeyBehaviorsMask,maxKC,
@@ -793,8 +807,13 @@ int	tmp;
 		    _XkbFree(prev_key_acts);
 		    return BadAlloc;
 		}
+#ifdef NXAGENT_SERVER
+                bzero((char *)&amp;xkb-&gt;server-&gt;key_acts[xkb-&gt;max_key_code+1],
+                                                tmp*sizeof(unsigned short));
+#else
 		bzero((char *)&amp;xkb-&gt;server-&gt;key_acts[xkb-&gt;max_key_code],
 						tmp*sizeof(unsigned short));
+#endif
 		if (changes) {
 		    changes-&gt;map.changed= _ExtendRange(changes-&gt;map.changed,
 		    			XkbKeyActionsMask,maxKC,
@@ -811,8 +830,13 @@ int	tmp;
 		    _XkbFree(prev_vmodmap);
 		    return BadAlloc;
 		}
+#ifdef NXAGENT_SERVER
+                bzero((char *)&amp;xkb-&gt;server-&gt;vmodmap[xkb-&gt;max_key_code+1],
+                                                tmp*sizeof(unsigned short));
+#else
 		bzero((char *)&amp;xkb-&gt;server-&gt;vmodmap[xkb-&gt;max_key_code],
 						tmp*sizeof(unsigned short));
+#endif
 		if (changes) {
 		    changes-&gt;map.changed= _ExtendRange(changes-&gt;map.changed,
 		    			XkbVirtualModMapMask,maxKC,
@@ -830,8 +854,13 @@ int	tmp;
 		_XkbFree(prev_keys);
 		return BadAlloc;
 	    }
+#ifdef NXAGENT_SERVER
+            bzero((char *)&amp;xkb-&gt;names-&gt;keys[xkb-&gt;max_key_code+1],
+                                                tmp*sizeof(XkbKeyNameRec));
+#else
 	    bzero((char *)&amp;xkb-&gt;names-&gt;keys[xkb-&gt;max_key_code],
 	    					tmp*sizeof(XkbKeyNameRec));
+#endif
 	    if (changes) {
 		changes-&gt;names.changed= _ExtendRange(changes-&gt;names.changed,
 					XkbKeyNamesMask,maxKC,
diff --git a/nx-X11/lib/X11/XKBMAlloc.c b/nx-X11/lib/X11/XKBMAlloc.c.X.original
similarity index 100%
copy from nx-X11/lib/X11/XKBMAlloc.c
copy to nx-X11/lib/X11/XKBMAlloc.c.X.original
diff --git a/nx-X11/programs/Xserver/randr/Imakefile b/nx-X11/programs/Xserver/randr.X.original/Imakefile
similarity index 100%
copy from nx-X11/programs/Xserver/randr/Imakefile
copy to nx-X11/programs/Xserver/randr.X.original/Imakefile
diff --git a/nx-X11/programs/Xserver/randr/mirandr.c b/nx-X11/programs/Xserver/randr.X.original/mirandr.c
similarity index 100%
copy from nx-X11/programs/Xserver/randr/mirandr.c
copy to nx-X11/programs/Xserver/randr.X.original/mirandr.c
diff --git a/nx-X11/programs/Xserver/randr/randr.c b/nx-X11/programs/Xserver/randr.X.original/randr.c
similarity index 100%
copy from nx-X11/programs/Xserver/randr/randr.c
copy to nx-X11/programs/Xserver/randr.X.original/randr.c
diff --git a/nx-X11/programs/Xserver/randr/randrstr.h b/nx-X11/programs/Xserver/randr.X.original/randrstr.h
similarity index 100%
copy from nx-X11/programs/Xserver/randr/randrstr.h
copy to nx-X11/programs/Xserver/randr.X.original/randrstr.h
diff --git a/nx-X11/programs/Xserver/randr/Imakefile b/nx-X11/programs/Xserver/randr/Imakefile
index 73b0dfb..2eff07f 100644
--- a/nx-X11/programs/Xserver/randr/Imakefile
+++ b/nx-X11/programs/Xserver/randr/Imakefile
@@ -1,15 +1,33 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
 XCOMM $XFree86: xc/programs/Xserver/randr/Imakefile,v 1.1 2001/05/23 03:29:44 keithp Exp $
 #include &lt;Server.tmpl&gt;
 
-       SRCS =	randr.c mirandr.c
+       SRCS =	mirandr.c randr.c rrcrtc.c rrdispatch.c rrinfo.c rrmode.c rroutput.c rrpointer.c rrproperty.c rrscreen.c rrsdispatch.c rrxinerama.c
 
-       OBJS =	randr.o mirandr.o
+       OBJS =	mirandr.o randr.o rrcrtc.o rrdispatch.o rrinfo.o rrmode.o rroutput.o rrpointer.o rrproperty.o rrscreen.o rrsdispatch.o rrxinerama.o
 
    INCLUDES = -I../include -I../mi -I../../../include/fonts \
 		-I../fb -I../hw/kdrive -I$(EXTINCSRC) -I$(XINCLUDESRC) \
 		-I$(FONTINCSRC) -I../render
    LINTLIBS = ../dix/llib-ldix.ln ../os/llib-los.ln
 
+    DEFINES = -DNXAGENT_SERVER
+
 NormalLibraryTarget(randr,$(OBJS))
 NormalLibraryObjectRule()
 LintLibraryTarget(randr,$(SRCS))
diff --git a/nx-X11/programs/Xserver/randr/Imakefile.NX.original b/nx-X11/programs/Xserver/randr/Imakefile.NX.original
new file mode 100644
index 0000000..2eff07f
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/Imakefile.NX.original
@@ -0,0 +1,36 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+XCOMM $XFree86: xc/programs/Xserver/randr/Imakefile,v 1.1 2001/05/23 03:29:44 keithp Exp $
+#include &lt;Server.tmpl&gt;
+
+       SRCS =	mirandr.c randr.c rrcrtc.c rrdispatch.c rrinfo.c rrmode.c rroutput.c rrpointer.c rrproperty.c rrscreen.c rrsdispatch.c rrxinerama.c
+
+       OBJS =	mirandr.o randr.o rrcrtc.o rrdispatch.o rrinfo.o rrmode.o rroutput.o rrpointer.o rrproperty.o rrscreen.o rrsdispatch.o rrxinerama.o
+
+   INCLUDES = -I../include -I../mi -I../../../include/fonts \
+		-I../fb -I../hw/kdrive -I$(EXTINCSRC) -I$(XINCLUDESRC) \
+		-I$(FONTINCSRC) -I../render
+   LINTLIBS = ../dix/llib-ldix.ln ../os/llib-los.ln
+
+    DEFINES = -DNXAGENT_SERVER
+
+NormalLibraryTarget(randr,$(OBJS))
+NormalLibraryObjectRule()
+LintLibraryTarget(randr,$(SRCS))
+NormalLintTarget($(SRCS))
+
+DependTarget()
diff --git a/nx-X11/CHANGELOG.X.original b/nx-X11/programs/Xserver/randr/Imakefile.X.original
similarity index 100%
copy from nx-X11/CHANGELOG.X.original
copy to nx-X11/programs/Xserver/randr/Imakefile.X.original
diff --git a/nx-X11/programs/Xserver/randr/Makefile.am b/nx-X11/programs/Xserver/randr/Makefile.am
new file mode 100644
index 0000000..20b0f72
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/Makefile.am
@@ -0,0 +1,28 @@
+noinst_LTLIBRARIES = librandr.la
+
+AM_CFLAGS = $(DIX_CFLAGS)
+
+XINERAMA_SRCS = rrxinerama.c
+
+if XORG
+sdk_HEADERS = randrstr.h
+endif
+
+librandr_la_SOURCES =	\
+	mirandr.c	\
+	randr.c		\
+	randrstr.h	\
+	rrcrtc.c	\
+	rrdispatch.c	\
+	rrinfo.c	\
+	rrmode.c	\
+	rroutput.c	\
+	rrpointer.c	\
+	rrproperty.c	\
+	rrscreen.c	\
+	rrsdispatch.c
+
+if XINERAMA
+librandr_la_SOURCES += ${XINERAMA_SRCS}
+endif
+
diff --git a/nx-X11/programs/Xserver/randr/Makefile.in b/nx-X11/programs/Xserver/randr/Makefile.in
new file mode 100644
index 0000000..447f6cb
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/Makefile.in
@@ -0,0 +1,698 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at SET_MAKE</A>@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH=&quot;$${ZSH_VERSION+.}$(PATH_SEPARATOR)&quot; &amp;&amp; cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at XINERAMA_TRUE</A>@am__append_1 = ${XINERAMA_SRCS}
+subdir = randr
+DIST_COMMON = $(am__sdk_HEADERS_DIST) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/include/do-not-use-config.h \
+	$(top_builddir)/include/xorg-server.h \
+	$(top_builddir)/include/dix-config.h \
+	$(top_builddir)/include/xgl-config.h \
+	$(top_builddir)/include/xorg-config.h \
+	$(top_builddir)/include/xkb-config.h \
+	$(top_builddir)/include/xwin-config.h \
+	$(top_builddir)/include/kdrive-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+librandr_la_LIBADD =
+am__librandr_la_SOURCES_DIST = mirandr.c randr.c randrstr.h rrcrtc.c \
+	rrdispatch.c rrinfo.c rrmode.c rroutput.c rrpointer.c \
+	rrproperty.c rrscreen.c rrsdispatch.c rrxinerama.c
+am__objects_1 = rrxinerama.lo
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at XINERAMA_TRUE</A>@am__objects_2 = $(am__objects_1)
+am_librandr_la_OBJECTS = mirandr.lo randr.lo rrcrtc.lo rrdispatch.lo \
+	rrinfo.lo rrmode.lo rroutput.lo rrpointer.lo rrproperty.lo \
+	rrscreen.lo rrsdispatch.lo $(am__objects_2)
+librandr_la_OBJECTS = $(am_librandr_la_OBJECTS)
+DEFAULT_INCLUDES = <A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">-I. at am__isrc</A>@ -I$(top_builddir)/include
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(librandr_la_SOURCES)
+DIST_SOURCES = $(am__librandr_la_SOURCES_DIST)
+am__sdk_HEADERS_DIST = randrstr.h
+am__vpath_adj_setup = srcdirstrip=`echo &quot;$(srcdir)&quot; | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo &quot;$$p&quot; | sed &quot;s|^$$srcdirstrip/||&quot;`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = &quot;$(DESTDIR)$(sdkdir)&quot;
+sdkHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(sdk_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ADMIN_MAN_DIR = @ADMIN_MAN_DIR@
+ADMIN_MAN_SUFFIX = @ADMIN_MAN_SUFFIX@
+ALLOCA = @ALLOCA@
+AMTAR = @AMTAR@
+APPDEFAULTDIR = @APPDEFAULTDIR@
+APPLE_APPLICATIONS_DIR = @APPLE_APPLICATIONS_DIR@
+APP_MAN_DIR = @APP_MAN_DIR@
+APP_MAN_SUFFIX = @APP_MAN_SUFFIX@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BASE_FONT_PATH = @BASE_FONT_PATH@
+BUILD_DATE = @BUILD_DATE@
+BUILD_TIME = @BUILD_TIME@
+CC = @CC@
+CCAS = @CCAS@
+CCASDEPMODE = @CCASDEPMODE@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+COMPILEDDEFAULTFONTPATH = @COMPILEDDEFAULTFONTPATH@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DARWIN_LIBS = @DARWIN_LIBS@
+DBUS_CFLAGS = @DBUS_CFLAGS@
+DBUS_LIBS = @DBUS_LIBS@
+DEFAULT_LIBRARY_PATH = @DEFAULT_LIBRARY_PATH@
+DEFAULT_LOGPREFIX = @DEFAULT_LOGPREFIX@
+DEFAULT_MODULE_PATH = @DEFAULT_MODULE_PATH@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DGA_CFLAGS = @DGA_CFLAGS@
+DGA_LIBS = @DGA_LIBS@
+DIX_CFLAGS = @DIX_CFLAGS@
+DLLTOOL = @DLLTOOL@
+DMXEXAMPLES_DEP_CFLAGS = @DMXEXAMPLES_DEP_CFLAGS@
+DMXEXAMPLES_DEP_LIBS = @DMXEXAMPLES_DEP_LIBS@
+DMXMODULES_CFLAGS = @DMXMODULES_CFLAGS@
+DMXMODULES_LIBS = @DMXMODULES_LIBS@
+DMXXIEXAMPLES_DEP_CFLAGS = @DMXXIEXAMPLES_DEP_CFLAGS@
+DMXXIEXAMPLES_DEP_LIBS = @DMXXIEXAMPLES_DEP_LIBS@
+DMXXMUEXAMPLES_DEP_CFLAGS = @DMXXMUEXAMPLES_DEP_CFLAGS@
+DMXXMUEXAMPLES_DEP_LIBS = @DMXXMUEXAMPLES_DEP_LIBS@
+DRI2PROTO_CFLAGS = @DRI2PROTO_CFLAGS@
+DRI2PROTO_LIBS = @DRI2PROTO_LIBS@
+DRIPROTO_CFLAGS = @DRIPROTO_CFLAGS@
+DRIPROTO_LIBS = @DRIPROTO_LIBS@
+DRIVER_MAN_DIR = @DRIVER_MAN_DIR@
+DRIVER_MAN_SUFFIX = @DRIVER_MAN_SUFFIX@
+DRI_DRIVER_PATH = @DRI_DRIVER_PATH@
+DSYMUTIL = @DSYMUTIL@
+DTRACE = @DTRACE@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+FILE_MAN_DIR = @FILE_MAN_DIR@
+FILE_MAN_SUFFIX = @FILE_MAN_SUFFIX@
+FREETYPE_CFLAGS = @FREETYPE_CFLAGS@
+FREETYPE_LIBS = @FREETYPE_LIBS@
+GLX_ARCH_DEFINES = @GLX_ARCH_DEFINES@
+GLX_DEFINES = @GLX_DEFINES@
+GL_CFLAGS = @GL_CFLAGS@
+GL_LIBS = @GL_LIBS@
+GREP = @GREP@
+HAL_CFLAGS = @HAL_CFLAGS@
+HAL_LIBS = @HAL_LIBS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+KDRIVE_CFLAGS = @KDRIVE_CFLAGS@
+KDRIVE_INCS = @KDRIVE_INCS@
+KDRIVE_LIBS = @KDRIVE_LIBS@
+KDRIVE_LOCAL_LIBS = @KDRIVE_LOCAL_LIBS@
+KDRIVE_PURE_INCS = @KDRIVE_PURE_INCS@
+KDRIVE_PURE_LIBS = @KDRIVE_PURE_LIBS@
+LAUNCHD = @LAUNCHD@
+LDFLAGS = @LDFLAGS@
+LD_EXPORT_SYMBOLS_FLAG = @LD_EXPORT_SYMBOLS_FLAG@
+LEX = @LEX@
+LEXLIB = @LEXLIB@
+LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
+LIBDRM_CFLAGS = @LIBDRM_CFLAGS@
+LIBDRM_LIBS = @LIBDRM_LIBS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIB_MAN_DIR = @LIB_MAN_DIR@
+LIB_MAN_SUFFIX = @LIB_MAN_SUFFIX@
+LINUXDOC = @LINUXDOC@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MAKE_HTML = @MAKE_HTML@
+MAKE_PDF = @MAKE_PDF@
+MAKE_PS = @MAKE_PS@
+MAKE_TEXT = @MAKE_TEXT@
+MESA_SOURCE = @MESA_SOURCE@
+MISC_MAN_DIR = @MISC_MAN_DIR@
+MISC_MAN_SUFFIX = @MISC_MAN_SUFFIX@
+MKDIR_P = @MKDIR_P@
+MKFONTDIR = @MKFONTDIR@
+MKFONTSCALE = @MKFONTSCALE@
+NMEDIT = @NMEDIT@
+OBJC = @OBJC@
+OBJCCLD = @OBJCCLD@
+OBJCDEPMODE = @OBJCDEPMODE@
+OBJCFLAGS = @OBJCFLAGS@
+OBJCLINK = @OBJCLINK@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OPENSSL_CFLAGS = @OPENSSL_CFLAGS@
+OPENSSL_LIBS = @OPENSSL_LIBS@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PCIACCESS_CFLAGS = @PCIACCESS_CFLAGS@
+PCIACCESS_LIBS = @PCIACCESS_LIBS@
+PCI_TXT_IDS_PATH = @PCI_TXT_IDS_PATH@
+PERL = @PERL@
+PKG_CONFIG = @PKG_CONFIG@
+PROJECTROOT = @PROJECTROOT@
+PS2PDF = @PS2PDF@
+RANLIB = @RANLIB@
+RAWCPP = @RAWCPP@
+RAWCPPFLAGS = @RAWCPPFLAGS@
+SED = @SED@
+SERVER_MISC_CONFIG_PATH = @SERVER_MISC_CONFIG_PATH@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SOLARIS_ASM_CFLAGS = @SOLARIS_ASM_CFLAGS@
+SOLARIS_INOUT_ARCH = @SOLARIS_INOUT_ARCH@
+STRIP = @STRIP@
+TSLIB_CFLAGS = @TSLIB_CFLAGS@
+TSLIB_LIBS = @TSLIB_LIBS@
+UTILS_SYS_LIBS = @UTILS_SYS_LIBS@
+VENDOR_MAN_VERSION = @VENDOR_MAN_VERSION@
+VENDOR_NAME = @VENDOR_NAME@
+VENDOR_NAME_SHORT = @VENDOR_NAME_SHORT@
+VENDOR_RELEASE = @VENDOR_RELEASE@
+VERSION = @VERSION@
+X11APP_ARCHS = @X11APP_ARCHS@
+X11EXAMPLES_DEP_CFLAGS = @X11EXAMPLES_DEP_CFLAGS@
+X11EXAMPLES_DEP_LIBS = @X11EXAMPLES_DEP_LIBS@
+XDMCP_CFLAGS = @XDMCP_CFLAGS@
+XDMCP_LIBS = @XDMCP_LIBS@
+XDMXCONFIG_DEP_CFLAGS = @XDMXCONFIG_DEP_CFLAGS@
+XDMXCONFIG_DEP_LIBS = @XDMXCONFIG_DEP_LIBS@
+XDMX_CFLAGS = @XDMX_CFLAGS@
+XDMX_LIBS = @XDMX_LIBS@
+XDMX_SYS_LIBS = @XDMX_SYS_LIBS@
+XEGLMODULES_CFLAGS = @XEGLMODULES_CFLAGS@
+XEGL_LIBS = @XEGL_LIBS@
+XEGL_SYS_LIBS = @XEGL_SYS_LIBS@
+XEPHYR_CFLAGS = @XEPHYR_CFLAGS@
+XEPHYR_DRI_LIBS = @XEPHYR_DRI_LIBS@
+XEPHYR_INCS = @XEPHYR_INCS@
+XEPHYR_LIBS = @XEPHYR_LIBS@
+XF86CONFIGFILE = @XF86CONFIGFILE@
+XF86MISC_CFLAGS = @XF86MISC_CFLAGS@
+XF86MISC_LIBS = @XF86MISC_LIBS@
+XF86VIDMODE_CFLAGS = @XF86VIDMODE_CFLAGS@
+XF86VIDMODE_LIBS = @XF86VIDMODE_LIBS@
+XGLMODULES_CFLAGS = @XGLMODULES_CFLAGS@
+XGLMODULES_LIBS = @XGLMODULES_LIBS@
+XGLXMODULES_CFLAGS = @XGLXMODULES_CFLAGS@
+XGLXMODULES_LIBS = @XGLXMODULES_LIBS@
+XGLX_LIBS = @XGLX_LIBS@
+XGLX_SYS_LIBS = @XGLX_SYS_LIBS@
+XGL_LIBS = @XGL_LIBS@
+XGL_MODULE_PATH = @XGL_MODULE_PATH@
+XGL_SYS_LIBS = @XGL_SYS_LIBS@
+XKB_BASE_DIRECTORY = @XKB_BASE_DIRECTORY@
+XKB_BIN_DIRECTORY = @XKB_BIN_DIRECTORY@
+XKB_COMPILED_DIR = @XKB_COMPILED_DIR@
+XKM_OUTPUT_DIR = @XKM_OUTPUT_DIR@
+XLIB_CFLAGS = @XLIB_CFLAGS@
+XLIB_LIBS = @XLIB_LIBS@
+XNESTMODULES_CFLAGS = @XNESTMODULES_CFLAGS@
+XNESTMODULES_LIBS = @XNESTMODULES_LIBS@
+XNEST_LIBS = @XNEST_LIBS@
+XNEST_SYS_LIBS = @XNEST_SYS_LIBS@
+XORGCFG_DEP_CFLAGS = @XORGCFG_DEP_CFLAGS@
+XORGCFG_DEP_LIBS = @XORGCFG_DEP_LIBS@
+XORGCONFIG_DEP_CFLAGS = @XORGCONFIG_DEP_CFLAGS@
+XORGCONFIG_DEP_LIBS = @XORGCONFIG_DEP_LIBS@
+XORG_CFLAGS = @XORG_CFLAGS@
+XORG_INCS = @XORG_INCS@
+XORG_LIBS = @XORG_LIBS@
+XORG_MODULES_CFLAGS = @XORG_MODULES_CFLAGS@
+XORG_MODULES_LIBS = @XORG_MODULES_LIBS@
+XORG_OS = @XORG_OS@
+XORG_OS_SUBDIR = @XORG_OS_SUBDIR@
+XORG_SYS_LIBS = @XORG_SYS_LIBS@
+XPRINTMODULES_CFLAGS = @XPRINTMODULES_CFLAGS@
+XPRINTMODULES_LIBS = @XPRINTMODULES_LIBS@
+XPRINTPROTO_CFLAGS = @XPRINTPROTO_CFLAGS@
+XPRINTPROTO_LIBS = @XPRINTPROTO_LIBS@
+XPRINT_CFLAGS = @XPRINT_CFLAGS@
+XPRINT_LIBS = @XPRINT_LIBS@
+XPRINT_SYS_LIBS = @XPRINT_SYS_LIBS@
+XRESEXAMPLES_DEP_CFLAGS = @XRESEXAMPLES_DEP_CFLAGS@
+XRESEXAMPLES_DEP_LIBS = @XRESEXAMPLES_DEP_LIBS@
+XSDL_INCS = @XSDL_INCS@
+XSDL_LIBS = @XSDL_LIBS@
+XSERVERCFLAGS_CFLAGS = @XSERVERCFLAGS_CFLAGS@
+XSERVERCFLAGS_LIBS = @XSERVERCFLAGS_LIBS@
+XSERVERLIBS_CFLAGS = @XSERVERLIBS_CFLAGS@
+XSERVERLIBS_LIBS = @XSERVERLIBS_LIBS@
+XSERVER_LIBS = @XSERVER_LIBS@
+XSERVER_SYS_LIBS = @XSERVER_SYS_LIBS@
+XTSTEXAMPLES_DEP_CFLAGS = @XTSTEXAMPLES_DEP_CFLAGS@
+XTSTEXAMPLES_DEP_LIBS = @XTSTEXAMPLES_DEP_LIBS@
+XVFB_LIBS = @XVFB_LIBS@
+XVFB_SYS_LIBS = @XVFB_SYS_LIBS@
+XWINMODULES_CFLAGS = @XWINMODULES_CFLAGS@
+XWINMODULES_LIBS = @XWINMODULES_LIBS@
+XWIN_LIBS = @XWIN_LIBS@
+XWIN_SERVER_NAME = @XWIN_SERVER_NAME@
+XWIN_SYS_LIBS = @XWIN_SYS_LIBS@
+YACC = @YACC@
+YFLAGS = @YFLAGS@
+__XCONFIGFILE__ = @__XCONFIGFILE__@
+abi_ansic = @abi_ansic@
+abi_extension = @abi_extension@
+abi_font = @abi_font@
+abi_videodrv = @abi_videodrv@
+abi_xinput = @abi_xinput@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+driverdir = @driverdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+extdir = @extdir@
+ft_config = @ft_config@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+launchagentsdir = @launchagentsdir@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+logdir = @logdir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sdkdir = @sdkdir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+xglmoduledir = @xglmoduledir@
+xpconfigdir = @xpconfigdir@
+noinst_LTLIBRARIES = librandr.la
+AM_CFLAGS = $(DIX_CFLAGS)
+XINERAMA_SRCS = rrxinerama.c
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at XORG_TRUE</A>@sdk_HEADERS = randrstr.h
+librandr_la_SOURCES = mirandr.c randr.c randrstr.h rrcrtc.c \
+	rrdispatch.c rrinfo.c rrmode.c rroutput.c rrpointer.c \
+	rrproperty.c rrscreen.c rrsdispatch.c $(am__append_1)
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&amp;&amp; exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) &amp;&amp; $(AUTOMAKE) --foreign  randr/Makefile'; \
+	cd $(top_srcdir) &amp;&amp; \
+	  $(AUTOMAKE) --foreign  randr/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z &quot;$(noinst_LTLIBRARIES)&quot; || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir=&quot;`echo $$p | sed -e 's|/[^/]*$$||'`&quot;; \
+	  test &quot;$$dir&quot; != &quot;$$p&quot; || dir=.; \
+	  echo &quot;rm -f \&quot;$${dir}/so_locations\&quot;&quot;; \
+	  rm -f &quot;$${dir}/so_locations&quot;; \
+	done
+librandr.la: $(librandr_la_OBJECTS) $(librandr_la_DEPENDENCIES) 
+	$(LINK)  $(librandr_la_OBJECTS) $(librandr_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mirandr.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">randr.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">rrcrtc.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">rrdispatch.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">rrinfo.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">rrmode.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">rroutput.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">rrpointer.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">rrproperty.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">rrscreen.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">rrsdispatch.Plo at am__quote</A>@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__include@ @<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">am__quote at .</A>/$(DEPDIR)/<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">rrxinerama.Plo at am__quote</A>@
+
+.c.o:
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at am__fastdepCC_TRUE</A>@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $&lt;
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at am__fastdepCC_TRUE</A>@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__fastdepCC_FALSE@	source='$&lt;' object='$@' libtool=no @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at am__fastdepCC_FALSE</A>@	$(COMPILE) -c $&lt;
+
+.c.obj:
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at am__fastdepCC_TRUE</A>@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$&lt;'`
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at am__fastdepCC_TRUE</A>@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__fastdepCC_FALSE@	source='$&lt;' object='$@' libtool=no @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at am__fastdepCC_FALSE</A>@	$(COMPILE) -c `$(CYGPATH_W) '$&lt;'`
+
+.c.lo:
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at am__fastdepCC_TRUE</A>@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $&lt;
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at am__fastdepCC_TRUE</A>@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__fastdepCC_FALSE@	source='$&lt;' object='$@' libtool=yes @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at AMDEP_TRUE</A>@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">+ at am__fastdepCC_FALSE</A>@	$(LTCOMPILE) -c -o $@ $&lt;
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-sdkHEADERS: $(sdk_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z &quot;$(sdkdir)&quot; || $(MKDIR_P) &quot;$(DESTDIR)$(sdkdir)&quot;
+	@list='$(sdk_HEADERS)'; for p in $$list; do \
+	  if test -f &quot;$$p&quot;; then d=; else d=&quot;$(srcdir)/&quot;; fi; \
+	  f=$(am__strip_dir) \
+	  echo &quot; $(sdkHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(sdkdir)/$$f'&quot;; \
+	  $(sdkHEADERS_INSTALL) &quot;$$d$$p&quot; &quot;$(DESTDIR)$(sdkdir)/$$f&quot;; \
+	done
+
+uninstall-sdkHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(sdk_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo &quot; rm -f '$(DESTDIR)$(sdkdir)/$$f'&quot;; \
+	  rm -f &quot;$(DESTDIR)$(sdkdir)/$$f&quot;; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z &quot;$(ETAGS_ARGS)$$tags$$unique&quot;; then :; else \
+	  test -n &quot;$$unique&quot; || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z &quot;$(CTAGS_ARGS)$$tags$$unique&quot; \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) &amp;&amp; pwd` \
+	  &amp;&amp; cd $(top_srcdir) \
+	  &amp;&amp; gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo &quot;$(srcdir)&quot; | sed 's/[].[^$$\\*]/\\\\&amp;/g'`; \
+	topsrcdirstrip=`echo &quot;$(top_srcdir)&quot; | sed 's/[].[^$$\\*]/\\\\&amp;/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e &quot;s|^$$srcdirstrip/||;t&quot; \
+	      -e &quot;s|^$$topsrcdirstrip/|$(top_builddir)/|;t&quot;`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo &quot;$$dist_files&quot; | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo &quot;/$$file&quot; | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file &amp;&amp; test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+	for dir in &quot;$(DESTDIR)$(sdkdir)&quot;; do \
+	  test -z &quot;$$dir&quot; || $(MKDIR_P) &quot;$$dir&quot;; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; \
+	  install_sh_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo &quot;INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'&quot;` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z &quot;$(CONFIG_CLEAN_FILES)&quot; || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo &quot;This command is intended for maintainers to use&quot;
+	@echo &quot;it deletes files that may require special tools to rebuild.&quot;
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-sdkHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-sdkHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-sdkHEADERS install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-sdkHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/nx-X11/programs/Xserver/randr/mirandr.c b/nx-X11/programs/Xserver/randr/mirandr.c
index b1e19a7..3c4991e 100644
--- a/nx-X11/programs/Xserver/randr/mirandr.c
+++ b/nx-X11/programs/Xserver/randr/mirandr.c
@@ -1,76 +1,42 @@
 /*
- * $XFree86: xc/programs/Xserver/randr/mirandr.c,v 1.5 2001/06/04 09:45:40 keithp Exp $
- *
- * Copyright &#169; 2000, Compaq Computer Corporation, 
- * Copyright &#169; 2002, Hewlett Packard, Inc.
+ * Copyright &#169; 2000 Compaq Computer Corporation
+ * Copyright &#169; 2002 Hewlett-Packard Company
+ * Copyright &#169; 2006 Intel Corporation
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
- * the above copyright notice appear in all copies and that both that
- * copyright notice and this permission notice appear in supporting
- * documentation, and that the name of Compaq or HP not be used in advertising
- * or publicity pertaining to distribution of the software without specific,
- * written prior permission.  HP makes no representations about the
- * suitability of this software for any purpose.  It is provided &quot;as is&quot;
- * without express or implied warranty.
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
  *
- * HP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL HP
- * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
  *
- * Author:  Jim Gettys, HP Labs, Hewlett-Packard, Inc.
+ * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
+ *	    Keith Packard, Intel Corporation
  */
 
-
 #ifdef HAVE_DIX_CONFIG_H
 #include &lt;dix-config.h&gt;
 #endif
 
 #include &quot;scrnintstr.h&quot;
 #include &quot;mi.h&quot;
-#include &lt;X11/extensions/randr.h&gt;
 #include &quot;randrstr.h&quot;
 #include &lt;stdio.h&gt;
 
-/*
- * This function assumes that only a single depth can be
- * displayed at a time, but that all visuals of that depth
- * can be displayed simultaneously.  It further assumes that
- * only a single size is available.  Hardware providing
- * additional capabilties should use different code.
- * XXX what to do here....
- */
-
 Bool
 miRRGetInfo (ScreenPtr pScreen, Rotation *rotations)
 {
-    int	i;
-    Bool setConfig = FALSE;
-    
-    *rotations = RR_Rotate_0;
-    for (i = 0; i &lt; pScreen-&gt;numDepths; i++)
-    {
-	if (pScreen-&gt;allowedDepths[i].numVids)
-	{
-		RRScreenSizePtr		pSize;
-
-		pSize = RRRegisterSize (pScreen,
-					pScreen-&gt;width,
-					pScreen-&gt;height,
-					pScreen-&gt;mmWidth,
-					pScreen-&gt;mmHeight);
-		if (!pSize)
-		    return FALSE;
-		if (!setConfig)
-		{
-		    RRSetCurrentConfig (pScreen, RR_Rotate_0, 0, pSize);
-		    setConfig = TRUE;
-		}
-	}
-    }
     return TRUE;
 }
 
@@ -79,24 +45,110 @@ miRRGetInfo (ScreenPtr pScreen, Rotation *rotations)
  * different here
  */
 Bool
-miRRSetConfig (ScreenPtr	pScreen,
-	       Rotation		rotation,
-	       int		rate,
-	       RRScreenSizePtr	pSize)
+miRRCrtcSet (ScreenPtr	pScreen,
+	     RRCrtcPtr	crtc,
+	     RRModePtr	mode,
+	     int	x,
+	     int	y,
+	     Rotation	rotation,
+	     int	numOutput,
+	     RROutputPtr *outputs)
 {
     return TRUE;
 }
 
+static Bool
+miRRCrtcSetGamma (ScreenPtr	pScreen,
+		  RRCrtcPtr	crtc)
+{
+    return TRUE;
+}
+
+Bool
+miRROutputSetProperty (ScreenPtr	    pScreen,
+		       RROutputPtr	    output,
+		       Atom		    property,
+		       RRPropertyValuePtr   value)
+{
+    return TRUE;
+}
+
+Bool
+miRROutputValidateMode (ScreenPtr	    pScreen,
+			RROutputPtr	    output,
+			RRModePtr	    mode)
+{
+    return FALSE;
+}
+
+void
+miRRModeDestroy (ScreenPtr  pScreen,
+		 RRModePtr  mode)
+{
+}
+
+/*
+ * This function assumes that only a single depth can be
+ * displayed at a time, but that all visuals of that depth
+ * can be displayed simultaneously.  It further assumes that
+ * only a single size is available.  Hardware providing
+ * additional capabilties should use different code.
+ * XXX what to do here....
+ */
 
 Bool
 miRandRInit (ScreenPtr pScreen)
 {
-    rrScrPrivPtr    rp;
+    rrScrPrivPtr    pScrPriv;
+#if RANDR_12_INTERFACE
+    RRModePtr	mode;
+    RRCrtcPtr	crtc;
+    RROutputPtr	output;
+    xRRModeInfo modeInfo;
+    char	name[64];
+#endif
     
     if (!RRScreenInit (pScreen))
 	return FALSE;
-    rp = rrGetScrPriv(pScreen);
-    rp-&gt;rrGetInfo = miRRGetInfo;
-    rp-&gt;rrSetConfig = miRRSetConfig;
+    pScrPriv = rrGetScrPriv(pScreen);
+    pScrPriv-&gt;rrGetInfo = miRRGetInfo;
+#if RANDR_12_INTERFACE
+    pScrPriv-&gt;rrCrtcSet = miRRCrtcSet;
+    pScrPriv-&gt;rrCrtcSetGamma = miRRCrtcSetGamma;
+    pScrPriv-&gt;rrOutputSetProperty = miRROutputSetProperty;
+    pScrPriv-&gt;rrOutputValidateMode = miRROutputValidateMode;
+    pScrPriv-&gt;rrModeDestroy = miRRModeDestroy;
+    
+    RRScreenSetSizeRange (pScreen,
+			  pScreen-&gt;width, pScreen-&gt;height,
+			  pScreen-&gt;width, pScreen-&gt;height);
+
+    sprintf (name, &quot;%dx%d&quot;, pScreen-&gt;width, pScreen-&gt;height);
+    memset (&amp;modeInfo, '\0', sizeof (modeInfo));
+    modeInfo.width = pScreen-&gt;width;
+    modeInfo.height = pScreen-&gt;height;
+    modeInfo.nameLength = strlen (name);
+    
+    mode = RRModeGet (&amp;modeInfo, name);
+    if (!mode)
+	return FALSE;
+    
+    crtc = RRCrtcCreate (pScreen, NULL);
+    if (!crtc)
+	return FALSE;
+    
+    output = RROutputCreate (pScreen, &quot;screen&quot;, 6, NULL);
+    if (!output)
+	return FALSE;
+    if (!RROutputSetClones (output, NULL, 0))
+	return FALSE;
+    if (!RROutputSetModes (output, &amp;mode, 1, 0))
+	return FALSE;
+    if (!RROutputSetCrtcs (output, &amp;crtc, 1))
+	return FALSE;
+    if (!RROutputSetConnection (output, RR_Connected))
+	return FALSE;
+    RRCrtcNotify (crtc, mode, 0, 0, RR_Rotate_0, 1, &amp;output);
+#endif
     return TRUE;
 }
diff --git a/nx-X11/include/extensions/panoramiXproto.h b/nx-X11/programs/Xserver/randr/panoramiXproto.h
similarity index 100%
copy from nx-X11/include/extensions/panoramiXproto.h
copy to nx-X11/programs/Xserver/randr/panoramiXproto.h
diff --git a/nx-X11/include/extensions/panoramiXproto.h b/nx-X11/programs/Xserver/randr/panoramiXproto.h.NX.original
similarity index 100%
copy from nx-X11/include/extensions/panoramiXproto.h
copy to nx-X11/programs/Xserver/randr/panoramiXproto.h.NX.original
diff --git a/nx-X11/CHANGELOG.X.original b/nx-X11/programs/Xserver/randr/panoramiXproto.h.X.original
similarity index 100%
copy from nx-X11/CHANGELOG.X.original
copy to nx-X11/programs/Xserver/randr/panoramiXproto.h.X.original
diff --git a/nx-X11/programs/Xserver/randr/randr.c b/nx-X11/programs/Xserver/randr/randr.c
index 3911a34..81df406 100644
--- a/nx-X11/programs/Xserver/randr/randr.c
+++ b/nx-X11/programs/Xserver/randr/randr.c
@@ -1,29 +1,46 @@
 /*
- * $XFree86: xc/programs/Xserver/randr/randr.c,v 1.21tsi Exp $
- *
- * Copyright &#169; 2000, Compaq Computer Corporation, 
- * Copyright &#169; 2002, Hewlett Packard, Inc.
+ * Copyright &#169; 2000 Compaq Computer Corporation
+ * Copyright &#169; 2002 Hewlett-Packard Company
+ * Copyright &#169; 2006 Intel Corporation
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
- * the above copyright notice appear in all copies and that both that
- * copyright notice and this permission notice appear in supporting
- * documentation, and that the name of Compaq or HP not be used in advertising
- * or publicity pertaining to distribution of the software without specific,
- * written prior permission.  HP makes no representations about the
- * suitability of this software for any purpose.  It is provided &quot;as is&quot;
- * without express or implied warranty.
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
  *
- * HP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL HP
- * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
  *
- * Author:  Jim Gettys, HP Labs, Hewlett-Packard, Inc.
+ * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
+ *	    Keith Packard, Intel Corporation
  */
 
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
 
 #define NEED_REPLIES
 #define NEED_EVENTS
@@ -31,28 +48,7 @@
 #include &lt;dix-config.h&gt;
 #endif
 
-#include &lt;X11/X.h&gt;
-#include &lt;X11/Xproto.h&gt;
-#include &quot;misc.h&quot;
-#include &quot;os.h&quot;
-#include &quot;dixstruct.h&quot;
-#include &quot;resource.h&quot;
-#include &quot;scrnintstr.h&quot;
-#include &quot;windowstr.h&quot;
-#include &quot;pixmapstr.h&quot;
-#include &quot;extnsionst.h&quot;
-#include &quot;servermd.h&quot;
-#include &lt;X11/extensions/randr.h&gt;
-#include &lt;X11/extensions/randrproto.h&gt;
 #include &quot;randrstr.h&quot;
-#ifdef RENDER
-#include &lt;X11/extensions/render.h&gt; 	/* we share subpixel order information */
-#include &quot;picturestr.h&quot;
-#endif
-#include &lt;X11/Xfuncproto.h&gt;
-#ifdef EXTMODULE
-#include &quot;xf86_ansic.h&quot;
-#endif
 
 /* From render.h */
 #ifndef SubPixelUnknown
@@ -60,13 +56,7 @@
 #endif
 
 #define RR_VALIDATE
-int	RRGeneration;
-int	RRNScreens;
-
-static int ProcRRQueryVersion (ClientPtr pClient);
-static int ProcRRDispatch (ClientPtr pClient);
-static int SProcRRDispatch (ClientPtr pClient);
-static int SProcRRQueryVersion (ClientPtr pClient);
+static int	RRNScreens;
 
 #define wrap(priv,real,mem,func) {\
     priv-&gt;mem = real-&gt;mem; \
@@ -77,56 +67,20 @@ static int SProcRRQueryVersion (ClientPtr pClient);
     real-&gt;mem = priv-&gt;mem; \
 }
 
-#if 0
-static CARD8	RRReqCode;
-static int	RRErrBase;
-#endif
-static int	RREventBase;
-static RESTYPE ClientType, EventType; /* resource types for event masks */
-static int	RRClientPrivateIndex;
-
-typedef struct _RRTimes {
-    TimeStamp	setTime;
-    TimeStamp	configTime;
-} RRTimesRec, *RRTimesPtr;
-
-typedef struct _RRClient {
-    int		major_version;
-    int		minor_version;
-/*  RRTimesRec	times[0]; */
-} RRClientRec, *RRClientPtr;
-
-/*
- * each window has a list of clients requesting
- * RRNotify events.  Each client has a resource
- * for each window it selects RRNotify input for,
- * this resource is used to delete the RRNotifyRec
- * entry from the per-window queue.
- */
-
-typedef struct _RREvent *RREventPtr;
+static int ProcRRDispatch (ClientPtr pClient);
+static int SProcRRDispatch (ClientPtr pClient);
 
-typedef struct _RREvent {
-    RREventPtr  next;
-    ClientPtr	client;
-    WindowPtr	window;
-    XID		clientResource;
-    int		mask;
-} RREventRec;
+int	RREventBase;
+int	RRErrorBase;
+RESTYPE RRClientType, RREventType; /* resource types for event masks */
 
+#ifndef NXAGENT_SERVER
+DevPrivateKey RRClientPrivateKey = &RRClientPrivateKey;
+DevPrivateKey rrPrivKey = &rrPrivKey;
+#else
+int	RRClientPrivateIndex;
 int	rrPrivIndex = -1;
-
-#define GetRRClient(pClient)    ((RRClientPtr) (pClient)-&gt;devPrivates[RRClientPrivateIndex].ptr)
-#define rrClientPriv(pClient)	RRClientPtr pRRClient = GetRRClient(pClient)
-
-static Bool
-RRClientKnowsRates (ClientPtr	pClient)
-{
-    rrClientPriv(pClient);
-
-    return (pRRClient-&gt;major_version &gt; 1 ||
-	    (pRRClient-&gt;major_version == 1 &amp;&amp; pRRClient-&gt;minor_version &gt;= 1));
-}
+#endif
 
 static void
 RRClientCallback (CallbackListPtr	*list,
@@ -163,10 +117,14 @@ static Bool
 RRCloseScreen (int i, ScreenPtr pScreen)
 {
     rrScrPriv(pScreen);
+    int		    j;
 
     unwrap (pScrPriv, pScreen, CloseScreen);
-    if (pScrPriv-&gt;pSizes)
-	xfree (pScrPriv-&gt;pSizes);
+    for (j = pScrPriv-&gt;numCrtcs - 1; j &gt;= 0; j--)
+	RRCrtcDestroy (pScrPriv-&gt;crtcs[j]);
+    for (j = pScrPriv-&gt;numOutputs - 1; j &gt;= 0; j--)
+	RROutputDestroy (pScrPriv-&gt;outputs[j]);
+    
     xfree (pScrPriv);
     RRNScreens -= 1;	/* ok, one fewer screen with RandR running */
     return (*pScreen-&gt;CloseScreen) (i, pScreen);    
@@ -191,18 +149,105 @@ SRRScreenChangeNotifyEvent(xRRScreenChangeNotifyEvent *from,
     cpswaps(from-&gt;subpixelOrder, to-&gt;subpixelOrder);
 }
 
-Bool RRScreenInit(ScreenPtr pScreen)
+static void
+SRRCrtcChangeNotifyEvent(xRRCrtcChangeNotifyEvent *from,
+			 xRRCrtcChangeNotifyEvent *to)
 {
-    rrScrPrivPtr   pScrPriv;
+    to-&gt;type = from-&gt;type;
+    to-&gt;subCode = from-&gt;subCode;
+    cpswaps(from-&gt;sequenceNumber, to-&gt;sequenceNumber);
+    cpswapl(from-&gt;timestamp, to-&gt;timestamp);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswapl(from-&gt;crtc, to-&gt;crtc);
+    cpswapl(from-&gt;mode, to-&gt;mode);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswaps(from-&gt;rotation, to-&gt;rotation);
+    cpswaps(from-&gt;x, to-&gt;x);
+    cpswaps(from-&gt;y, to-&gt;y);
+    cpswaps(from-&gt;width, to-&gt;width);
+    cpswaps(from-&gt;height, to-&gt;height);
+}
 
+static void
+SRROutputChangeNotifyEvent(xRROutputChangeNotifyEvent *from,
+			   xRROutputChangeNotifyEvent *to)
+{
+    to-&gt;type = from-&gt;type;
+    to-&gt;subCode = from-&gt;subCode;
+    cpswaps(from-&gt;sequenceNumber, to-&gt;sequenceNumber);
+    cpswapl(from-&gt;timestamp, to-&gt;timestamp);
+    cpswapl(from-&gt;configTimestamp, to-&gt;configTimestamp);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswapl(from-&gt;output, to-&gt;output);
+    cpswapl(from-&gt;crtc, to-&gt;crtc);
+    cpswapl(from-&gt;mode, to-&gt;mode);
+    cpswaps(from-&gt;rotation, to-&gt;rotation);
+}
+
+static void
+SRROutputPropertyNotifyEvent(xRROutputPropertyNotifyEvent *from,
+			     xRROutputPropertyNotifyEvent *to)
+{
+    to-&gt;type = from-&gt;type;
+    to-&gt;subCode = from-&gt;subCode;
+    cpswaps(from-&gt;sequenceNumber, to-&gt;sequenceNumber);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswapl(from-&gt;output, to-&gt;output);
+    cpswapl(from-&gt;atom, to-&gt;atom);
+    cpswapl(from-&gt;timestamp, to-&gt;timestamp);
+}
+
+static void
+SRRNotifyEvent (xEvent *from,
+		xEvent *to)
+{
+    switch (from-&gt;u.u.detail) {
+    case RRNotify_CrtcChange:
+	SRRCrtcChangeNotifyEvent ((xRRCrtcChangeNotifyEvent *) from,
+				  (xRRCrtcChangeNotifyEvent *) to);
+	break;
+    case RRNotify_OutputChange:
+	SRROutputChangeNotifyEvent ((xRROutputChangeNotifyEvent *) from,
+				    (xRROutputChangeNotifyEvent *) to);
+	break;
+    case RRNotify_OutputProperty:
+	SRROutputPropertyNotifyEvent ((xRROutputPropertyNotifyEvent *) from,
+				      (xRROutputPropertyNotifyEvent *) to);
+	break;
+    default:
+	break;
+    }
+}
+
+static int RRGeneration;
+
+Bool RRInit (void)
+{
     if (RRGeneration != serverGeneration)
     {
+        #ifdef NXAGENT_SERVER
 	if ((rrPrivIndex = AllocateScreenPrivateIndex()) &lt; 0)
 	    return FALSE;
+        #endif
+	if (!RRModeInit ())
+	    return FALSE;
+	if (!RRCrtcInit ())
+	    return FALSE;
+	if (!RROutputInit ())
+	    return FALSE;
 	RRGeneration = serverGeneration;
     }
+    return TRUE;
+}
+
+Bool RRScreenInit(ScreenPtr pScreen)
+{
+    rrScrPrivPtr   pScrPriv;
 
-    pScrPriv = (rrScrPrivPtr) xalloc (sizeof (rrScrPrivRec));
+    if (!RRInit ())
+	return FALSE;
+
+    pScrPriv = (rrScrPrivPtr) xcalloc (1, sizeof (rrScrPrivRec));
     if (!pScrPriv)
 	return FALSE;
 
@@ -211,8 +256,31 @@ Bool RRScreenInit(ScreenPtr pScreen)
     /*
      * Calling function best set these function vectors
      */
-    pScrPriv-&gt;rrSetConfig = 0;
     pScrPriv-&gt;rrGetInfo = 0;
+    pScrPriv-&gt;maxWidth = pScrPriv-&gt;minWidth = pScreen-&gt;width;
+    pScrPriv-&gt;maxHeight = pScrPriv-&gt;minHeight = pScreen-&gt;height;
+    
+    pScrPriv-&gt;width = pScreen-&gt;width;
+    pScrPriv-&gt;height = pScreen-&gt;height;
+    pScrPriv-&gt;mmWidth = pScreen-&gt;mmWidth;
+    pScrPriv-&gt;mmHeight = pScreen-&gt;mmHeight;
+#if RANDR_12_INTERFACE
+    pScrPriv-&gt;rrScreenSetSize = NULL;
+    pScrPriv-&gt;rrCrtcSet = NULL;
+    pScrPriv-&gt;rrCrtcSetGamma = NULL;
+#endif
+#if RANDR_10_INTERFACE    
+    pScrPriv-&gt;rrSetConfig = 0;
+    pScrPriv-&gt;rotations = RR_Rotate_0;
+    pScrPriv-&gt;reqWidth = pScreen-&gt;width;
+    pScrPriv-&gt;reqHeight = pScreen-&gt;height;
+    pScrPriv-&gt;nSizes = 0;
+    pScrPriv-&gt;pSizes = NULL;
+    pScrPriv-&gt;rotation = RR_Rotate_0;
+    pScrPriv-&gt;rate = 0;
+    pScrPriv-&gt;size = 0;
+#endif
+    
     /*
      * This value doesn't really matter -- any client must call
      * GetScreenInfo before reading it which will automatically update
@@ -223,14 +291,10 @@ Bool RRScreenInit(ScreenPtr pScreen)
     
     wrap (pScrPriv, pScreen, CloseScreen, RRCloseScreen);
 
-    pScrPriv-&gt;rotations = RR_Rotate_0;
-    
-    pScrPriv-&gt;nSizes = 0;
-    pScrPriv-&gt;nSizesInUse = 0;
-    pScrPriv-&gt;pSizes = 0;
-    
-    pScrPriv-&gt;rotation = RR_Rotate_0;
-    pScrPriv-&gt;size = -1;
+    pScrPriv-&gt;numOutputs = 0;
+    pScrPriv-&gt;outputs = NULL;
+    pScrPriv-&gt;numCrtcs = 0;
+    pScrPriv-&gt;crtcs = NULL;
     
     RRNScreens += 1;	/* keep count of screens that implement randr */
     return TRUE;
@@ -246,7 +310,7 @@ RRFreeClient (pointer data, XID id)
 
     pRREvent = (RREventPtr) data;
     pWin = pRREvent-&gt;window;
-    pHead = (RREventPtr *) LookupIDByType(pWin-&gt;drawable.id, EventType);
+    pHead = (RREventPtr *) LookupIDByType(pWin-&gt;drawable.id, RREventType);
     if (pHead) {
 	pPrev = 0;
 	for (pCur = *pHead; pCur &amp;&amp; pCur != pRREvent; pCur=pCur-&gt;next)
@@ -272,7 +336,7 @@ RRFreeEvents (pointer data, XID id)
     pHead = (RREventPtr *) data;
     for (pCur = *pHead; pCur; pCur = pNext) {
 	pNext = pCur-&gt;next;
-	FreeResource (pCur-&gt;clientResource, ClientType);
+	FreeResource (pCur-&gt;clientResource, RRClientType);
 	xfree ((pointer) pCur);
     }
     xfree ((pointer) pHead);
@@ -286,1034 +350,172 @@ RRExtensionInit (void)
 
     if (RRNScreens == 0) return;
 
+    #ifndef NXAGENT_SERVER
+    if (!dixRequestPrivate(RRClientPrivateKey,
+				sizeof (RRClientRec) +
+				screenInfo.numScreens * sizeof (RRTimesRec)))
+	return;
+    #else
     RRClientPrivateIndex = AllocateClientPrivateIndex ();
     if (!AllocateClientPrivate (RRClientPrivateIndex,
 				sizeof (RRClientRec) +
 				screenInfo.numScreens * sizeof (RRTimesRec)))
 	return;
+    #endif
     if (!AddCallback (&amp;ClientStateCallback, RRClientCallback, 0))
 	return;
 
-    ClientType = CreateNewResourceType(RRFreeClient);
-    if (!ClientType)
+    RRClientType = CreateNewResourceType(RRFreeClient);
+    if (!RRClientType)
 	return;
-    EventType = CreateNewResourceType(RRFreeEvents);
-    if (!EventType)
+    RREventType = CreateNewResourceType(RRFreeEvents);
+    if (!RREventType)
 	return;
     extEntry = AddExtension (RANDR_NAME, RRNumberEvents, RRNumberErrors,
 			     ProcRRDispatch, SProcRRDispatch,
 			     RRResetProc, StandardMinorOpcode);
     if (!extEntry)
 	return;
-#if 0
-    RRReqCode = (CARD8) extEntry-&gt;base;
-    RRErrBase = extEntry-&gt;errorBase;
-#endif
+    RRErrorBase = extEntry-&gt;errorBase;
     RREventBase = extEntry-&gt;eventBase;
     EventSwapVector[RREventBase + RRScreenChangeNotify] = (EventSwapPtr) 
-      SRRScreenChangeNotifyEvent;
-
-    return;
+	SRRScreenChangeNotifyEvent;
+    EventSwapVector[RREventBase + RRNotify] = (EventSwapPtr)
+	SRRNotifyEvent;
+#ifdef PANORAMIX
+    RRXineramaExtensionInit();
+#endif
 }
-		
+
 static int
 TellChanged (WindowPtr pWin, pointer value)
 {
     RREventPtr			*pHead, pRREvent;
     ClientPtr			client;
-    xRRScreenChangeNotifyEvent	se;
     ScreenPtr			pScreen = pWin-&gt;drawable.pScreen;
     rrScrPriv(pScreen);
-    RRScreenSizePtr		pSize;
-    WindowPtr			pRoot = WindowTable[pScreen-&gt;myNum];
+    int				i;
 
-    pHead = (RREventPtr *) LookupIDByType (pWin-&gt;drawable.id, EventType);
+    pHead = (RREventPtr *) LookupIDByType (pWin-&gt;drawable.id, RREventType);
     if (!pHead)
 	return WT_WALKCHILDREN;
 
-    se.type = RRScreenChangeNotify + RREventBase;
-    se.rotation = (CARD8) pScrPriv-&gt;rotation;
-    se.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
-    se.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
-    se.root =  pRoot-&gt;drawable.id;
-    se.window = pWin-&gt;drawable.id;
-#ifdef RENDER
-    se.subpixelOrder = PictureGetSubpixelOrder (pScreen);
-#else
-    se.subpixelOrder = SubPixelUnknown;
-#endif
-    if (pScrPriv-&gt;size &gt;= 0)
-    {
-	pSize = &amp;pScrPriv-&gt;pSizes[pScrPriv-&gt;size];
-	se.sizeID = pSize-&gt;id;
-	se.widthInPixels = pSize-&gt;width;
-	se.heightInPixels = pSize-&gt;height;
-	se.widthInMillimeters = pSize-&gt;mmWidth;
-	se.heightInMillimeters = pSize-&gt;mmHeight;
-    }
-    else
-    {
-	/*
-	 * This &quot;shouldn't happen&quot;, but a broken DDX can
-	 * forget to set the current configuration on GetInfo
-	 */
-	se.sizeID = 0xffff;
-	se.widthInPixels = 0;
-	se.heightInPixels = 0;
-	se.widthInMillimeters = 0;
-	se.heightInMillimeters = 0;
-    }    
     for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent-&gt;next) 
     {
 	client = pRREvent-&gt;client;
 	if (client == serverClient || client-&gt;clientGone)
 	    continue;
-	se.sequenceNumber = client-&gt;sequence;
-	if(pRREvent-&gt;mask &amp; RRScreenChangeNotifyMask)
-	  WriteEventsToClient (client, 1, (xEvent *) &amp;se);
-    }
-    return WT_WALKCHILDREN;
-}
-
-static Bool
-RRGetInfo (ScreenPtr pScreen)
-{
-    rrScrPriv (pScreen);
-    int		    i, j, k, l;
-    Bool	    changed;
-    Rotation	    rotations;
-    RRScreenSizePtr pSize;
-    RRScreenRatePtr pRate;
-
-    for (i = 0; i &lt; pScrPriv-&gt;nSizes; i++)
-    {
-	pSize = &amp;pScrPriv-&gt;pSizes[i];
-	pSize-&gt;oldReferenced = pSize-&gt;referenced;
-	pSize-&gt;referenced = FALSE;
-	for (k = 0; k &lt; pSize-&gt;nRates; k++)
-	{
-	    pRate = &amp;pSize-&gt;pRates[k];
-	    pRate-&gt;oldReferenced = pRate-&gt;referenced;
-	    pRate-&gt;referenced = FALSE;
-	}
-    }
-    if (!(*pScrPriv-&gt;rrGetInfo) (pScreen, &amp;rotations))
-	return FALSE;
-
-    changed = FALSE;
-
-    /*
-     * Check whether anything changed and simultaneously generate
-     * the protocol id values for the objects
-     */
-    if (rotations != pScrPriv-&gt;rotations)
-    {
-	pScrPriv-&gt;rotations = rotations;
-	changed = TRUE;
-    }
-
-    j = 0;
-    for (i = 0; i &lt; pScrPriv-&gt;nSizes; i++)
-    {
-	pSize = &amp;pScrPriv-&gt;pSizes[i];
-	if (pSize-&gt;oldReferenced != pSize-&gt;referenced)
-	    changed = TRUE;
-	if (pSize-&gt;referenced)
-	    pSize-&gt;id = j++;
-	l = 0;
-	for (k = 0; k &lt; pSize-&gt;nRates; k++)
-	{
-	    pRate = &amp;pSize-&gt;pRates[k];
-	    if (pRate-&gt;oldReferenced != pRate-&gt;referenced)
-		changed = TRUE;
-	    if (pRate-&gt;referenced)
-		l++;
-	}
-	pSize-&gt;nRatesInUse = l;
-    }
-    pScrPriv-&gt;nSizesInUse = j;
-    if (changed)
-    {
-	UpdateCurrentTime ();
-	pScrPriv-&gt;lastConfigTime = currentTime;
-	WalkTree (pScreen, TellChanged, (pointer) pScreen);
-    }
-    return TRUE;
-}
 
-static void
-RRSendConfigNotify (ScreenPtr pScreen)
-{
-    WindowPtr	pWin = WindowTable[pScreen-&gt;myNum];
-    xEvent	event;
-
-    event.u.u.type = ConfigureNotify;
-    event.u.configureNotify.window = pWin-&gt;drawable.id;
-    event.u.configureNotify.aboveSibling = None;
-    event.u.configureNotify.x = 0;
-    event.u.configureNotify.y = 0;
-
-    /* XXX xinerama stuff ? */
-    
-    event.u.configureNotify.width = pWin-&gt;drawable.width;
-    event.u.configureNotify.height = pWin-&gt;drawable.height;
-    event.u.configureNotify.borderWidth = wBorderWidth (pWin);
-    event.u.configureNotify.override = pWin-&gt;overrideRedirect;
-    DeliverEvents(pWin, &amp;event, 1, NullWindow);
-}
-
-static int
-ProcRRQueryVersion (ClientPtr client)
-{
-    xRRQueryVersionReply rep;
-    register int n;
-    REQUEST(xRRQueryVersionReq);
-    rrClientPriv(client);
-
-    REQUEST_SIZE_MATCH(xRRQueryVersionReq);
-    pRRClient-&gt;major_version = stuff-&gt;majorVersion;
-    pRRClient-&gt;minor_version = stuff-&gt;minorVersion;
-    rep.type = X_Reply;
-    rep.length = 0;
-    rep.sequenceNumber = client-&gt;sequence;
-    rep.majorVersion = RANDR_MAJOR;
-    rep.minorVersion = RANDR_MINOR;
-    if (client-&gt;swapped) {
-    	swaps(&amp;rep.sequenceNumber, n);
-    	swapl(&amp;rep.length, n);
-	swapl(&amp;rep.majorVersion, n);
-	swapl(&amp;rep.minorVersion, n);
-    }
-    WriteToClient(client, sizeof(xRRQueryVersionReply), (char *)&amp;rep);
-    return (client-&gt;noClientException);
-}
-
-
-extern char	*ConnectionInfo;
-
-static int padlength[4] = {0, 3, 2, 1};
-
-static void
-RREditConnectionInfo (ScreenPtr pScreen)
-{
-    xConnSetup	    *connSetup;
-    char	    *vendor;
-    xPixmapFormat   *formats;
-    xWindowRoot	    *root;
-    xDepth	    *depth;
-    xVisualType	    *visual;
-    int		    screen = 0;
-    int		    d;
-
-    connSetup = (xConnSetup *) ConnectionInfo;
-    vendor = (char *) connSetup + sizeof (xConnSetup);
-    formats = (xPixmapFormat *) ((char *) vendor +
-				 connSetup-&gt;nbytesVendor +
-				 padlength[connSetup-&gt;nbytesVendor &amp; 3]);
-    root = (xWindowRoot *) ((char *) formats +
-			    sizeof (xPixmapFormat) * screenInfo.numPixmapFormats);
-    while (screen != pScreen-&gt;myNum)
-    {
-	depth = (xDepth *) ((char *) root + 
-			    sizeof (xWindowRoot));
-	for (d = 0; d &lt; root-&gt;nDepths; d++)
+	if (pRREvent-&gt;mask &amp; RRScreenChangeNotifyMask)
+	    RRDeliverScreenEvent (client, pWin, pScreen);
+	
+	if (pRREvent-&gt;mask &amp; RRCrtcChangeNotifyMask)
 	{
-	    visual = (xVisualType *) ((char *) depth +
-				      sizeof (xDepth));
-	    depth = (xDepth *) ((char *) visual +
-				depth-&gt;nVisuals * sizeof (xVisualType));
-	}
-	root = (xWindowRoot *) ((char *) depth);
-	screen++;
-    }
-    root-&gt;pixWidth = pScreen-&gt;width;
-    root-&gt;pixHeight = pScreen-&gt;height;
-    root-&gt;mmWidth = pScreen-&gt;mmWidth;
-    root-&gt;mmHeight = pScreen-&gt;mmHeight;
-}
-
-static int
-ProcRRGetScreenInfo (ClientPtr client)
-{
-    REQUEST(xRRGetScreenInfoReq);
-    xRRGetScreenInfoReply   rep;
-    WindowPtr	    	    pWin;
-    int			    n;
-    ScreenPtr		    pScreen;
-    rrScrPrivPtr	    pScrPriv;
-    CARD8		    *extra;
-    unsigned long	    extraLen;
-
-    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
-    pWin = (WindowPtr)SecurityLookupWindow(stuff-&gt;window, client,
-					   SecurityReadAccess);
-
-    if (!pWin)
-	return BadWindow;
-
-    pScreen = pWin-&gt;drawable.pScreen;
-    pScrPriv = rrGetScrPriv(pScreen);
-    rep.pad = 0;
-    if (!pScrPriv)
-    {
-	rep.type = X_Reply;
-	rep.setOfRotations = RR_Rotate_0;;
-	rep.sequenceNumber = client-&gt;sequence;
-	rep.length = 0;
-	rep.root = WindowTable[pWin-&gt;drawable.pScreen-&gt;myNum]-&gt;drawable.id;
-	rep.timestamp = currentTime.milliseconds;
-	rep.configTimestamp = currentTime.milliseconds;
-	rep.nSizes = 0;
-	rep.sizeID = 0;
-	rep.rotation = RR_Rotate_0;
-	rep.rate = 0;
-	rep.nrateEnts = 0;
-	extra = 0;
-	extraLen = 0;
-    }
-    else
-    {
-	int			i, j;
-	xScreenSizes		*size;
-	CARD16			*rates;
-	CARD8			*data8;
-	Bool			has_rate = RRClientKnowsRates (client);
-    
-	RRGetInfo (pScreen);
-
-	rep.type = X_Reply;
-	rep.setOfRotations = pScrPriv-&gt;rotations;
-	rep.sequenceNumber = client-&gt;sequence;
-	rep.length = 0;
-	rep.root = WindowTable[pWin-&gt;drawable.pScreen-&gt;myNum]-&gt;drawable.id;
-	rep.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
-	rep.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
-	rep.rotation = pScrPriv-&gt;rotation;
-	rep.nSizes = pScrPriv-&gt;nSizesInUse;
-	rep.rate = pScrPriv-&gt;rate;
-        rep.nrateEnts = 0;
-	if (has_rate)
-	{
-	    for (i = 0; i &lt; pScrPriv-&gt;nSizes; i++)
+	    for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
 	    {
-		RRScreenSizePtr pSize = &amp;pScrPriv-&gt;pSizes[i];
-		if (pSize-&gt;referenced)
-		{
-		    rep.nrateEnts += (1 + pSize-&gt;nRatesInUse);
-		}
+		RRCrtcPtr   crtc = pScrPriv-&gt;crtcs[i];
+		if (crtc-&gt;changed)
+		    RRDeliverCrtcEvent (client, pWin, crtc);
 	    }
 	}
-
-	if (pScrPriv-&gt;size &gt;= 0)
-	    rep.sizeID = pScrPriv-&gt;pSizes[pScrPriv-&gt;size].id;
-	else
-	    return BadImplementation;
-
-	extraLen = (rep.nSizes * sizeof (xScreenSizes) +
-		    rep.nrateEnts * sizeof (CARD16));
-
-	extra = (CARD8 *) xalloc (extraLen);
-	if (!extra)
-	    return BadAlloc;
-	/*
-	 * First comes the size information
-	 */
-	size = (xScreenSizes *) extra;
-	rates = (CARD16 *) (size + rep.nSizes);
-	for (i = 0; i &lt; pScrPriv-&gt;nSizes; i++)
+	
+	if (pRREvent-&gt;mask &amp; RROutputChangeNotifyMask)
 	{
-	    RRScreenSizePtr pSize = &amp;pScrPriv-&gt;pSizes[i];
-	    if (pSize-&gt;referenced)
+	    for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
 	    {
-		size-&gt;widthInPixels = pSize-&gt;width;
-		size-&gt;heightInPixels = pSize-&gt;height;
-		size-&gt;widthInMillimeters = pSize-&gt;mmWidth;
-		size-&gt;heightInMillimeters = pSize-&gt;mmHeight;
-		if (client-&gt;swapped)
-		{
-		    swaps (&amp;size-&gt;widthInPixels, n);
-		    swaps (&amp;size-&gt;heightInPixels, n);
-		    swaps (&amp;size-&gt;widthInMillimeters, n);
-		    swaps (&amp;size-&gt;heightInMillimeters, n);
-		}
-		size++;
-		if (has_rate)
-		{
-		    *rates = pSize-&gt;nRatesInUse;
-		    if (client-&gt;swapped)
-		    {
-			swaps (rates, n);
-		    }
-		    rates++;
-		    for (j = 0; j &lt; pSize-&gt;nRates; j++)
-		    {
-			RRScreenRatePtr	pRate = &amp;pSize-&gt;pRates[j];
-			if (pRate-&gt;referenced)
-			{
-			    *rates = pRate-&gt;rate;
-			    if (client-&gt;swapped)
-			    {
-				swaps (rates, n);
-			    }
-			    rates++;
-			}
-		    }
-		}
+		RROutputPtr   output = pScrPriv-&gt;outputs[i];
+		if (output-&gt;changed)
+		    RRDeliverOutputEvent (client, pWin, output);
 	    }
 	}
-	data8 = (CARD8 *) rates;
-
-	if (data8 - (CARD8 *) extra != extraLen)
-	    FatalError (&quot;RRGetScreenInfo bad extra len %ld != %ld\n&quot;,
-			(unsigned long)(data8 - (CARD8 *) extra), extraLen);
-	rep.length =  (extraLen + 3) &gt;&gt; 2;
-    }
-    if (client-&gt;swapped) {
-	swaps(&amp;rep.sequenceNumber, n);
-	swapl(&amp;rep.length, n);
-	swapl(&amp;rep.timestamp, n);
-	swaps(&amp;rep.rotation, n);
-	swaps(&amp;rep.nSizes, n);
-	swaps(&amp;rep.sizeID, n);
-	swaps(&amp;rep.rate, n);
-	swaps(&amp;rep.nrateEnts, n);
-    }
-    WriteToClient(client, sizeof(xRRGetScreenInfoReply), (char *)&amp;rep);
-    if (extraLen)
-    {
-	WriteToClient (client, extraLen, (char *) extra);
-	xfree (extra);
     }
-    return (client-&gt;noClientException);
+    return WT_WALKCHILDREN;
 }
 
-static int
-ProcRRSetScreenConfig (ClientPtr client)
+/*
+ * Something changed; send events and adjust pointer position
+ */
+void
+RRTellChanged (ScreenPtr pScreen)
 {
-    REQUEST(xRRSetScreenConfigReq);
-    xRRSetScreenConfigReply rep;
-    DrawablePtr		    pDraw;
-    int			    n;
-    ScreenPtr		    pScreen;
-    rrScrPrivPtr	    pScrPriv;
-    TimeStamp		    configTime;
-    TimeStamp		    time;
-    RRScreenSizePtr	    pSize;
-    int			    i;
-    Rotation		    rotation;
-    int			    rate;
-    short		    oldWidth, oldHeight;
-    Bool		    has_rate;
-
-    UpdateCurrentTime ();
-
-    if (RRClientKnowsRates (client))
-    {
-	REQUEST_SIZE_MATCH (xRRSetScreenConfigReq);
-	has_rate = TRUE;
-    }
-    else
-    {
-	REQUEST_SIZE_MATCH (xRR1_0SetScreenConfigReq);
-	has_rate = FALSE;
-    }
-    
-    SECURITY_VERIFY_DRAWABLE(pDraw, stuff-&gt;drawable, client,
-			     SecurityWriteAccess);
-
-    pScreen = pDraw-&gt;pScreen;
-
-    pScrPriv = rrGetScrPriv(pScreen);
-    
-    time = ClientTimeToServerTime(stuff-&gt;timestamp);
-    configTime = ClientTimeToServerTime(stuff-&gt;configTimestamp);
-    
-    oldWidth = pScreen-&gt;width;
-    oldHeight = pScreen-&gt;height;
-    
-    if (!pScrPriv)
-    {
-	time = currentTime;
-	rep.status = RRSetConfigFailed;
-	goto sendReply;
-    }
-    if (!RRGetInfo (pScreen))
-	return BadAlloc;
-    
-    /*
-     * if the client's config timestamp is not the same as the last config
-     * timestamp, then the config information isn't up-to-date and
-     * can't even be validated
-     */
-    if (CompareTimeStamps (configTime, pScrPriv-&gt;lastConfigTime) != 0)
-    {
-	rep.status = RRSetConfigInvalidConfigTime;
-	goto sendReply;
-    }
-    
-    /*
-     * Search for the requested size
-     */
-    pSize = 0;
-    for (i = 0; i &lt; pScrPriv-&gt;nSizes; i++)
-    {
-	pSize = &amp;pScrPriv-&gt;pSizes[i];
-	if (pSize-&gt;referenced &amp;&amp; pSize-&gt;id == stuff-&gt;sizeID)
-	{
-	    break;
-	}
-    }
-    if (i == pScrPriv-&gt;nSizes)
-    {
-	/*
-	 * Invalid size ID
-	 */
-	client-&gt;errorValue = stuff-&gt;sizeID;
-	return BadValue;
-    }
+    rrScrPriv (pScreen);
+    int i;
     
-    /*
-     * Validate requested rotation
-     */
-    rotation = (Rotation) stuff-&gt;rotation;
-
-    /* test the rotation bits only! */
-    switch (rotation &amp; 0xf) {
-    case RR_Rotate_0:
-    case RR_Rotate_90:
-    case RR_Rotate_180:
-    case RR_Rotate_270:
-	break;
-    default:
-	/*
-	 * Invalid rotation
-	 */
-	client-&gt;errorValue = stuff-&gt;rotation;
-	return BadValue;
-    }
-
-    if ((~pScrPriv-&gt;rotations) &amp; rotation)
-    {
-	/*
-	 * requested rotation or reflection not supported by screen
-	 */
-	client-&gt;errorValue = stuff-&gt;rotation;
-	return BadMatch;
-    }
-
-    /*
-     * Validate requested refresh
-     */
-    if (has_rate)
-	rate = (int) stuff-&gt;rate;
-    else
-	rate = 0;
-
-    if (rate)
+    if (pScrPriv-&gt;changed)
     {
-	for (i = 0; i &lt; pSize-&gt;nRates; i++)
+	UpdateCurrentTime ();
+	if (pScrPriv-&gt;configChanged)
 	{
-	    RRScreenRatePtr pRate = &amp;pSize-&gt;pRates[i];
-	    if (pRate-&gt;referenced &amp;&amp; pRate-&gt;rate == rate)
-		break;
+	    pScrPriv-&gt;lastConfigTime = currentTime;
+	    pScrPriv-&gt;configChanged = FALSE;
 	}
-	if (i == pSize-&gt;nRates)
+	pScrPriv-&gt;changed = FALSE;
+	WalkTree (pScreen, TellChanged, (pointer) pScreen);
+	for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	    pScrPriv-&gt;outputs[i]-&gt;changed = FALSE;
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	    pScrPriv-&gt;crtcs[i]-&gt;changed = FALSE;
+	if (pScrPriv-&gt;layoutChanged)
 	{
-	    /*
-	     * Invalid rate
-	     */
-	    client-&gt;errorValue = rate;
-	    return BadValue;
+	    pScrPriv-&gt;layoutChanged = FALSE;
+	    RRPointerScreenConfigured (pScreen);
+	    RRSendConfigNotify (pScreen);
 	}
     }
-    
-    /*
-     * Make sure the requested set-time is not older than
-     * the last set-time
-     */
-    if (CompareTimeStamps (time, pScrPriv-&gt;lastSetTime) &lt; 0)
-    {
-	rep.status = RRSetConfigInvalidTime;
-	goto sendReply;
-    }
-
-    /*
-     * call out to ddx routine to effect the change
-     */
-    if (!(*pScrPriv-&gt;rrSetConfig) (pScreen, rotation, rate,
-				   pSize))
-    {
-	/*
-	 * unknown DDX failure, report to client
-	 */
-	rep.status = RRSetConfigFailed;
-	goto sendReply;
-    }
-    
-    /*
-     * set current extension configuration pointers
-     */
-    RRSetCurrentConfig (pScreen, rotation, rate, pSize);
-    
-    /*
-     * Deliver ScreenChangeNotify events whenever
-     * the configuration is updated
-     */
-    WalkTree (pScreen, TellChanged, (pointer) pScreen);
-    
-    /*
-     * Deliver ConfigureNotify events when root changes
-     * pixel size
-     */
-    if (oldWidth != pScreen-&gt;width || oldHeight != pScreen-&gt;height)
-	RRSendConfigNotify (pScreen);
-    RREditConnectionInfo (pScreen);
-    
-    /*
-     * Fix pointer bounds and location
-     */
-    ScreenRestructured (pScreen);
-    pScrPriv-&gt;lastSetTime = time;
-    
-    /*
-     * Report Success
-     */
-    rep.status = RRSetConfigSuccess;
-    
-sendReply:
-    
-    rep.type = X_Reply;
-    /* rep.status has already been filled in */
-    rep.length = 0;
-    rep.sequenceNumber = client-&gt;sequence;
-
-    rep.newTimestamp = pScrPriv-&gt;lastSetTime.milliseconds;
-    rep.newConfigTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
-    rep.root = WindowTable[pDraw-&gt;pScreen-&gt;myNum]-&gt;drawable.id;
-
-    if (client-&gt;swapped) 
-    {
-    	swaps(&amp;rep.sequenceNumber, n);
-    	swapl(&amp;rep.length, n);
-	swapl(&amp;rep.newTimestamp, n);
-	swapl(&amp;rep.newConfigTimestamp, n);
-	swapl(&amp;rep.root, n);
-    }
-    WriteToClient(client, sizeof(xRRSetScreenConfigReply), (char *)&amp;rep);
-
-    return (client-&gt;noClientException);
 }
 
-int
-RRSetScreenConfig (ScreenPtr		pScreen,
-		   Rotation		rotation,
-		   int			rate,
-		   RRScreenSizePtr	pSize)
+/*
+ * Return the first output which is connected to an active CRTC
+ * Used in emulating 1.0 behaviour
+ */
+RROutputPtr
+RRFirstOutput (ScreenPtr pScreen)
 {
-    rrScrPrivPtr	    pScrPriv;
-    int			    i;
-    short		    oldWidth, oldHeight;
-
-    pScrPriv = rrGetScrPriv(pScreen);
-    
-    oldWidth = pScreen-&gt;width;
-    oldHeight = pScreen-&gt;height;
-    
-    if (!RRGetInfo (pScreen))
-	return BadAlloc;
+    rrScrPriv(pScreen);
+    RROutputPtr		    output;
+    int	i, j;
     
-    /*
-     * Validate requested rotation
-     */
-
-    /* test the rotation bits only! */
-    switch (rotation &amp; 0xf) {
-    case RR_Rotate_0:
-    case RR_Rotate_90:
-    case RR_Rotate_180:
-    case RR_Rotate_270:
-	break;
-    default:
-	/*
-	 * Invalid rotation
-	 */
-	return BadValue;
-    }
-
-    if ((~pScrPriv-&gt;rotations) &amp; rotation)
+    for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
     {
-	/*
-	 * requested rotation or reflection not supported by screen
-	 */
-	return BadMatch;
-    }
-
-    /*
-     * Validate requested refresh
-     */
-    if (rate)
-    {
-	for (i = 0; i &lt; pSize-&gt;nRates; i++)
+	RRCrtcPtr   crtc = pScrPriv-&gt;crtcs[i];
+	for (j = 0; j &lt; pScrPriv-&gt;numOutputs; j++)
 	{
-	    RRScreenRatePtr pRate = &amp;pSize-&gt;pRates[i];
-	    if (pRate-&gt;referenced &amp;&amp; pRate-&gt;rate == rate)
-		break;
+	    output = pScrPriv-&gt;outputs[j];
+	    if (output-&gt;crtc == crtc)
+		return output;
 	}
-	if (i == pSize-&gt;nRates)
-	{
-	    /*
-	     * Invalid rate
-	     */
-	    return BadValue;
-	}
-    }
-
-    /*
-     * call out to ddx routine to effect the change
-     */
-    if (!(*pScrPriv-&gt;rrSetConfig) (pScreen, rotation, rate,
-				   pSize))
-    {
-	/*
-	 * unknown DDX failure, report to client
-	 */
-        return BadImplementation;
     }
-    
-    /*
-     * set current extension configuration pointers
-     */
-    RRSetCurrentConfig (pScreen, rotation, rate, pSize);
-    
-    /*
-     * Deliver ScreenChangeNotify events whenever
-     * the configuration is updated
-     */
-    WalkTree (pScreen, TellChanged, (pointer) pScreen);
-    
-    /*
-     * Deliver ConfigureNotify events when root changes
-     * pixel size
-     */
-    if (oldWidth != pScreen-&gt;width || oldHeight != pScreen-&gt;height)
-	RRSendConfigNotify (pScreen);
-    RREditConnectionInfo (pScreen);
-    
-    /*
-     * Fix pointer bounds and location
-     */
-    ScreenRestructured (pScreen);
-    
-    return Success;
+    return NULL;
 }
 
-static int
-ProcRRSelectInput (ClientPtr client)
+CARD16
+RRVerticalRefresh (xRRModeInfo *mode)
 {
-    REQUEST(xRRSelectInputReq);
-    rrClientPriv(client);
-    RRTimesPtr	pTimes;
-    WindowPtr	pWin;
-    RREventPtr	pRREvent, pNewRREvent, *pHead;
-    XID		clientResource;
-
-    REQUEST_SIZE_MATCH(xRRSelectInputReq);
-    pWin = SecurityLookupWindow (stuff-&gt;window, client, SecurityWriteAccess);
-    if (!pWin)
-	return BadWindow;
-    pHead = (RREventPtr *)SecurityLookupIDByType(client,
-						 pWin-&gt;drawable.id, EventType,
-						 SecurityWriteAccess);
-
-    if (stuff-&gt;enable &amp; (RRScreenChangeNotifyMask)) 
-    {
-	ScreenPtr	pScreen = pWin-&gt;drawable.pScreen;
-	rrScrPriv	(pScreen);
-
-	if (pHead) 
-	{
-	    /* check for existing entry. */
-	    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent-&gt;next)
-		if (pRREvent-&gt;client == client)
-		    return Success;
-	}
-
-	/* build the entry */
-	pNewRREvent = (RREventPtr) xalloc (sizeof (RREventRec));
-	if (!pNewRREvent)
-	    return BadAlloc;
-	pNewRREvent-&gt;next = 0;
-	pNewRREvent-&gt;client = client;
-	pNewRREvent-&gt;window = pWin;
-	pNewRREvent-&gt;mask = stuff-&gt;enable;
-	/*
-	 * add a resource that will be deleted when
-	 * the client goes away
-	 */
-	clientResource = FakeClientID (client-&gt;index);
-	pNewRREvent-&gt;clientResource = clientResource;
-	if (!AddResource (clientResource, ClientType, (pointer)pNewRREvent))
-	    return BadAlloc;
-	/*
-	 * create a resource to contain a pointer to the list
-	 * of clients selecting input.  This must be indirect as
-	 * the list may be arbitrarily rearranged which cannot be
-	 * done through the resource database.
-	 */
-	if (!pHead)
-	{
-	    pHead = (RREventPtr *) xalloc (sizeof (RREventPtr));
-	    if (!pHead ||
-		!AddResource (pWin-&gt;drawable.id, EventType, (pointer)pHead))
-	    {
-		FreeResource (clientResource, RT_NONE);
-		return BadAlloc;
-	    }
-	    *pHead = 0;
-	}
-	pNewRREvent-&gt;next = *pHead;
-	*pHead = pNewRREvent;
-	/*
-	 * Now see if the client needs an event
-	 */
-	if (pScrPriv)
-	{
-	    pTimes = &amp;((RRTimesPtr) (pRRClient + 1))[pScreen-&gt;myNum];
-	    if (CompareTimeStamps (pTimes-&gt;setTime, 
-				   pScrPriv-&gt;lastSetTime) != 0 ||
-		CompareTimeStamps (pTimes-&gt;configTime, 
-				   pScrPriv-&gt;lastConfigTime) != 0)
-	    {
-		TellChanged (pWin, (pointer) pScreen);
-	    }
-	}
-    }
-    else if (stuff-&gt;enable == xFalse) 
-    {
-	/* delete the interest */
-	if (pHead) {
-	    pNewRREvent = 0;
-	    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent-&gt;next) {
-		if (pRREvent-&gt;client == client)
-		    break;
-		pNewRREvent = pRREvent;
-	    }
-	    if (pRREvent) {
-		FreeResource (pRREvent-&gt;clientResource, ClientType);
-		if (pNewRREvent)
-		    pNewRREvent-&gt;next = pRREvent-&gt;next;
-		else
-		    *pHead = pRREvent-&gt;next;
-		xfree (pRREvent);
-	    }
-	}
-    }
-    else 
-    {
-	client-&gt;errorValue = stuff-&gt;enable;
-	return BadValue;
-    }
-    return Success;
+    CARD32  refresh;
+    CARD32  dots = mode-&gt;hTotal * mode-&gt;vTotal;
+    if (!dots)
+	return 0;
+    refresh = (mode-&gt;dotClock + dots/2) / dots;
+    if (refresh &gt; 0xffff)
+	refresh = 0xffff;
+    return (CARD16) refresh;
 }
 
-
 static int
 ProcRRDispatch (ClientPtr client)
 {
     REQUEST(xReq);
-    switch (stuff-&gt;data)
-    {
-    case X_RRQueryVersion:
-	return ProcRRQueryVersion(client);
-    case X_RRSetScreenConfig:
-        return ProcRRSetScreenConfig(client);
-    case X_RRSelectInput:
-        return ProcRRSelectInput(client);
-    case X_RRGetScreenInfo:
-        return ProcRRGetScreenInfo(client);
-    default:
+    if (stuff-&gt;data &gt;= RRNumberRequests || !ProcRandrVector[stuff-&gt;data])
 	return BadRequest;
-    }
-}
-
-static int
-SProcRRQueryVersion (ClientPtr client)
-{
-    register int n;
-    REQUEST(xRRQueryVersionReq);
-
-    swaps(&amp;stuff-&gt;length, n);
-    swapl(&amp;stuff-&gt;majorVersion, n);
-    swapl(&amp;stuff-&gt;minorVersion, n);
-    return ProcRRQueryVersion(client);
-}
-
-static int
-SProcRRGetScreenInfo (ClientPtr client)
-{
-    register int n;
-    REQUEST(xRRGetScreenInfoReq);
-
-    swaps(&amp;stuff-&gt;length, n);
-    swapl(&amp;stuff-&gt;window, n);
-    return ProcRRGetScreenInfo(client);
-}
-
-static int
-SProcRRSetScreenConfig (ClientPtr client)
-{
-    register int n;
-    REQUEST(xRRSetScreenConfigReq);
-
-    if (RRClientKnowsRates (client))
-    {
-	REQUEST_SIZE_MATCH (xRRSetScreenConfigReq);
-	swaps (&amp;stuff-&gt;rate, n);
-    }
-    else
-    {
-	REQUEST_SIZE_MATCH (xRR1_0SetScreenConfigReq);
-    }
-    
-    swaps(&amp;stuff-&gt;length, n);
-    swapl(&amp;stuff-&gt;drawable, n);
-    swapl(&amp;stuff-&gt;timestamp, n);
-    swaps(&amp;stuff-&gt;sizeID, n);
-    swaps(&amp;stuff-&gt;rotation, n);
-    return ProcRRSetScreenConfig(client);
-}
-
-static int
-SProcRRSelectInput (ClientPtr client)
-{
-    register int n;
-    REQUEST(xRRSelectInputReq);
-
-    swaps(&amp;stuff-&gt;length, n);
-    swapl(&amp;stuff-&gt;window, n);
-    return ProcRRSelectInput(client);
+    return (*ProcRandrVector[stuff-&gt;data]) (client);
 }
 
-
 static int
 SProcRRDispatch (ClientPtr client)
 {
     REQUEST(xReq);
-    switch (stuff-&gt;data)
-    {
-    case X_RRQueryVersion:
-	return SProcRRQueryVersion(client);
-    case X_RRSetScreenConfig:
-        return SProcRRSetScreenConfig(client);
-    case X_RRSelectInput:
-        return SProcRRSelectInput(client);
-    case X_RRGetScreenInfo:
-        return SProcRRGetScreenInfo(client);
-    default:
+    if (stuff-&gt;data &gt;= RRNumberRequests || !ProcRandrVector[stuff-&gt;data])
 	return BadRequest;
-    }
+    return (*SProcRandrVector[stuff-&gt;data]) (client);
 }
 
-
-static Bool
-RRScreenSizeMatches (RRScreenSizePtr  a,
-		   RRScreenSizePtr  b)
-{
-    if (a-&gt;width != b-&gt;width)
-	return FALSE;
-    if (a-&gt;height != b-&gt;height)
-	return FALSE;
-    if (a-&gt;mmWidth != b-&gt;mmWidth)
-	return FALSE;
-    if (a-&gt;mmHeight != b-&gt;mmHeight)
-	return FALSE;
-    return TRUE;
-}
-
-RRScreenSizePtr
-RRRegisterSize (ScreenPtr	    pScreen,
-		short		    width, 
-		short		    height,
-		short		    mmWidth,
-		short		    mmHeight)
-{
-    rrScrPriv (pScreen);
-    int		    i;
-    RRScreenSize    tmp;
-    RRScreenSizePtr pNew;
-
-    if (!pScrPriv)
-	return 0;
-    
-    tmp.width = width;
-    tmp.height= height;
-    tmp.mmWidth = mmWidth;
-    tmp.mmHeight = mmHeight;
-    tmp.pRates = 0;
-    tmp.nRates = 0;
-    tmp.nRatesInUse = 0;
-    tmp.referenced = TRUE;
-    tmp.oldReferenced = FALSE;
-    for (i = 0; i &lt; pScrPriv-&gt;nSizes; i++)
-	if (RRScreenSizeMatches (&amp;tmp, &amp;pScrPriv-&gt;pSizes[i]))
-	{
-	    pScrPriv-&gt;pSizes[i].referenced = TRUE;
-	    return &amp;pScrPriv-&gt;pSizes[i];
-	}
-    pNew = xrealloc (pScrPriv-&gt;pSizes,
-		     (pScrPriv-&gt;nSizes + 1) * sizeof (RRScreenSize));
-    if (!pNew)
-	return 0;
-    pNew[pScrPriv-&gt;nSizes++] = tmp;
-    pScrPriv-&gt;pSizes = pNew;
-    return &amp;pNew[pScrPriv-&gt;nSizes-1];
-}
-
-Bool RRRegisterRate (ScreenPtr		pScreen,
-		     RRScreenSizePtr	pSize,
-		     int		rate)
-{
-    rrScrPriv(pScreen);
-    int		    i;
-    RRScreenRatePtr pNew, pRate;
-
-    if (!pScrPriv)
-	return FALSE;
-    
-    for (i = 0; i &lt; pSize-&gt;nRates; i++)
-    {
-	pRate = &amp;pSize-&gt;pRates[i];
-	if (pRate-&gt;rate == rate)
-	{
-	    pRate-&gt;referenced = TRUE;
-	    return TRUE;
-	}
-    }
-
-    pNew = xrealloc (pSize-&gt;pRates,
-		     (pSize-&gt;nRates + 1) * sizeof (RRScreenRate));
-    if (!pNew)
-	return FALSE;
-    pRate = &amp;pNew[pSize-&gt;nRates++];
-    pRate-&gt;rate = rate;
-    pRate-&gt;referenced = TRUE;
-    pRate-&gt;oldReferenced = FALSE;
-    pSize-&gt;pRates = pNew;
-    return TRUE;
-}
-
-void
-RRSetCurrentConfig (ScreenPtr		pScreen,
-		    Rotation		rotation,
-		    int			rate,
-		    RRScreenSizePtr	pSize)
-{
-    rrScrPriv (pScreen);
-
-    if (!pScrPriv)
-	return;
-
-    pScrPriv-&gt;rotation = rotation;
-    pScrPriv-&gt;size = pSize - pScrPriv-&gt;pSizes;
-    pScrPriv-&gt;rate = rate;
-}
diff --git a/nx-X11/programs/Xserver/randr/randr.c.NX.original b/nx-X11/programs/Xserver/randr/randr.c.NX.original
new file mode 100644
index 0000000..81df406
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/randr.c.NX.original
@@ -0,0 +1,521 @@
+/*
+ * Copyright &#169; 2000 Compaq Computer Corporation
+ * Copyright &#169; 2002 Hewlett-Packard Company
+ * Copyright &#169; 2006 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ *
+ * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
+ *	    Keith Packard, Intel Corporation
+ */
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#define NEED_REPLIES
+#define NEED_EVENTS
+#ifdef HAVE_DIX_CONFIG_H
+#include &lt;dix-config.h&gt;
+#endif
+
+#include &quot;randrstr.h&quot;
+
+/* From render.h */
+#ifndef SubPixelUnknown
+#define SubPixelUnknown 0
+#endif
+
+#define RR_VALIDATE
+static int	RRNScreens;
+
+#define wrap(priv,real,mem,func) {\
+    priv-&gt;mem = real-&gt;mem; \
+    real-&gt;mem = func; \
+}
+
+#define unwrap(priv,real,mem) {\
+    real-&gt;mem = priv-&gt;mem; \
+}
+
+static int ProcRRDispatch (ClientPtr pClient);
+static int SProcRRDispatch (ClientPtr pClient);
+
+int	RREventBase;
+int	RRErrorBase;
+RESTYPE RRClientType, RREventType; /* resource types for event masks */
+
+#ifndef NXAGENT_SERVER
+DevPrivateKey RRClientPrivateKey = &RRClientPrivateKey;
+DevPrivateKey rrPrivKey = &rrPrivKey;
+#else
+int	RRClientPrivateIndex;
+int	rrPrivIndex = -1;
+#endif
+
+static void
+RRClientCallback (CallbackListPtr	*list,
+		  pointer		closure,
+		  pointer		data)
+{
+    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
+    ClientPtr		pClient = clientinfo-&gt;client;
+    rrClientPriv(pClient);
+    RRTimesPtr		pTimes = (RRTimesPtr) (pRRClient + 1);
+    int			i;
+
+    pRRClient-&gt;major_version = 0;
+    pRRClient-&gt;minor_version = 0;
+    for (i = 0; i &lt; screenInfo.numScreens; i++)
+    {
+	ScreenPtr   pScreen = screenInfo.screens[i];
+	rrScrPriv(pScreen);
+
+	if (pScrPriv)
+	{
+	    pTimes[i].setTime = pScrPriv-&gt;lastSetTime;
+	    pTimes[i].configTime = pScrPriv-&gt;lastConfigTime;
+	}
+    }
+}
+
+static void
+RRResetProc (ExtensionEntry *extEntry)
+{
+}
+    
+static Bool
+RRCloseScreen (int i, ScreenPtr pScreen)
+{
+    rrScrPriv(pScreen);
+    int		    j;
+
+    unwrap (pScrPriv, pScreen, CloseScreen);
+    for (j = pScrPriv-&gt;numCrtcs - 1; j &gt;= 0; j--)
+	RRCrtcDestroy (pScrPriv-&gt;crtcs[j]);
+    for (j = pScrPriv-&gt;numOutputs - 1; j &gt;= 0; j--)
+	RROutputDestroy (pScrPriv-&gt;outputs[j]);
+    
+    xfree (pScrPriv);
+    RRNScreens -= 1;	/* ok, one fewer screen with RandR running */
+    return (*pScreen-&gt;CloseScreen) (i, pScreen);    
+}
+
+static void
+SRRScreenChangeNotifyEvent(xRRScreenChangeNotifyEvent *from,
+			   xRRScreenChangeNotifyEvent *to)
+{
+    to-&gt;type = from-&gt;type;
+    to-&gt;rotation = from-&gt;rotation;
+    cpswaps(from-&gt;sequenceNumber, to-&gt;sequenceNumber);
+    cpswapl(from-&gt;timestamp, to-&gt;timestamp);
+    cpswapl(from-&gt;configTimestamp, to-&gt;configTimestamp);
+    cpswapl(from-&gt;root, to-&gt;root);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswaps(from-&gt;sizeID, to-&gt;sizeID);
+    cpswaps(from-&gt;widthInPixels, to-&gt;widthInPixels);
+    cpswaps(from-&gt;heightInPixels, to-&gt;heightInPixels);
+    cpswaps(from-&gt;widthInMillimeters, to-&gt;widthInMillimeters);
+    cpswaps(from-&gt;heightInMillimeters, to-&gt;heightInMillimeters);
+    cpswaps(from-&gt;subpixelOrder, to-&gt;subpixelOrder);
+}
+
+static void
+SRRCrtcChangeNotifyEvent(xRRCrtcChangeNotifyEvent *from,
+			 xRRCrtcChangeNotifyEvent *to)
+{
+    to-&gt;type = from-&gt;type;
+    to-&gt;subCode = from-&gt;subCode;
+    cpswaps(from-&gt;sequenceNumber, to-&gt;sequenceNumber);
+    cpswapl(from-&gt;timestamp, to-&gt;timestamp);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswapl(from-&gt;crtc, to-&gt;crtc);
+    cpswapl(from-&gt;mode, to-&gt;mode);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswaps(from-&gt;rotation, to-&gt;rotation);
+    cpswaps(from-&gt;x, to-&gt;x);
+    cpswaps(from-&gt;y, to-&gt;y);
+    cpswaps(from-&gt;width, to-&gt;width);
+    cpswaps(from-&gt;height, to-&gt;height);
+}
+
+static void
+SRROutputChangeNotifyEvent(xRROutputChangeNotifyEvent *from,
+			   xRROutputChangeNotifyEvent *to)
+{
+    to-&gt;type = from-&gt;type;
+    to-&gt;subCode = from-&gt;subCode;
+    cpswaps(from-&gt;sequenceNumber, to-&gt;sequenceNumber);
+    cpswapl(from-&gt;timestamp, to-&gt;timestamp);
+    cpswapl(from-&gt;configTimestamp, to-&gt;configTimestamp);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswapl(from-&gt;output, to-&gt;output);
+    cpswapl(from-&gt;crtc, to-&gt;crtc);
+    cpswapl(from-&gt;mode, to-&gt;mode);
+    cpswaps(from-&gt;rotation, to-&gt;rotation);
+}
+
+static void
+SRROutputPropertyNotifyEvent(xRROutputPropertyNotifyEvent *from,
+			     xRROutputPropertyNotifyEvent *to)
+{
+    to-&gt;type = from-&gt;type;
+    to-&gt;subCode = from-&gt;subCode;
+    cpswaps(from-&gt;sequenceNumber, to-&gt;sequenceNumber);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswapl(from-&gt;output, to-&gt;output);
+    cpswapl(from-&gt;atom, to-&gt;atom);
+    cpswapl(from-&gt;timestamp, to-&gt;timestamp);
+}
+
+static void
+SRRNotifyEvent (xEvent *from,
+		xEvent *to)
+{
+    switch (from-&gt;u.u.detail) {
+    case RRNotify_CrtcChange:
+	SRRCrtcChangeNotifyEvent ((xRRCrtcChangeNotifyEvent *) from,
+				  (xRRCrtcChangeNotifyEvent *) to);
+	break;
+    case RRNotify_OutputChange:
+	SRROutputChangeNotifyEvent ((xRROutputChangeNotifyEvent *) from,
+				    (xRROutputChangeNotifyEvent *) to);
+	break;
+    case RRNotify_OutputProperty:
+	SRROutputPropertyNotifyEvent ((xRROutputPropertyNotifyEvent *) from,
+				      (xRROutputPropertyNotifyEvent *) to);
+	break;
+    default:
+	break;
+    }
+}
+
+static int RRGeneration;
+
+Bool RRInit (void)
+{
+    if (RRGeneration != serverGeneration)
+    {
+        #ifdef NXAGENT_SERVER
+	if ((rrPrivIndex = AllocateScreenPrivateIndex()) &lt; 0)
+	    return FALSE;
+        #endif
+	if (!RRModeInit ())
+	    return FALSE;
+	if (!RRCrtcInit ())
+	    return FALSE;
+	if (!RROutputInit ())
+	    return FALSE;
+	RRGeneration = serverGeneration;
+    }
+    return TRUE;
+}
+
+Bool RRScreenInit(ScreenPtr pScreen)
+{
+    rrScrPrivPtr   pScrPriv;
+
+    if (!RRInit ())
+	return FALSE;
+
+    pScrPriv = (rrScrPrivPtr) xcalloc (1, sizeof (rrScrPrivRec));
+    if (!pScrPriv)
+	return FALSE;
+
+    SetRRScreen(pScreen, pScrPriv);
+
+    /*
+     * Calling function best set these function vectors
+     */
+    pScrPriv-&gt;rrGetInfo = 0;
+    pScrPriv-&gt;maxWidth = pScrPriv-&gt;minWidth = pScreen-&gt;width;
+    pScrPriv-&gt;maxHeight = pScrPriv-&gt;minHeight = pScreen-&gt;height;
+    
+    pScrPriv-&gt;width = pScreen-&gt;width;
+    pScrPriv-&gt;height = pScreen-&gt;height;
+    pScrPriv-&gt;mmWidth = pScreen-&gt;mmWidth;
+    pScrPriv-&gt;mmHeight = pScreen-&gt;mmHeight;
+#if RANDR_12_INTERFACE
+    pScrPriv-&gt;rrScreenSetSize = NULL;
+    pScrPriv-&gt;rrCrtcSet = NULL;
+    pScrPriv-&gt;rrCrtcSetGamma = NULL;
+#endif
+#if RANDR_10_INTERFACE    
+    pScrPriv-&gt;rrSetConfig = 0;
+    pScrPriv-&gt;rotations = RR_Rotate_0;
+    pScrPriv-&gt;reqWidth = pScreen-&gt;width;
+    pScrPriv-&gt;reqHeight = pScreen-&gt;height;
+    pScrPriv-&gt;nSizes = 0;
+    pScrPriv-&gt;pSizes = NULL;
+    pScrPriv-&gt;rotation = RR_Rotate_0;
+    pScrPriv-&gt;rate = 0;
+    pScrPriv-&gt;size = 0;
+#endif
+    
+    /*
+     * This value doesn't really matter -- any client must call
+     * GetScreenInfo before reading it which will automatically update
+     * the time
+     */
+    pScrPriv-&gt;lastSetTime = currentTime;
+    pScrPriv-&gt;lastConfigTime = currentTime;
+    
+    wrap (pScrPriv, pScreen, CloseScreen, RRCloseScreen);
+
+    pScrPriv-&gt;numOutputs = 0;
+    pScrPriv-&gt;outputs = NULL;
+    pScrPriv-&gt;numCrtcs = 0;
+    pScrPriv-&gt;crtcs = NULL;
+    
+    RRNScreens += 1;	/* keep count of screens that implement randr */
+    return TRUE;
+}
+
+/*ARGSUSED*/
+static int
+RRFreeClient (pointer data, XID id)
+{
+    RREventPtr   pRREvent;
+    WindowPtr	    pWin;
+    RREventPtr   *pHead, pCur, pPrev;
+
+    pRREvent = (RREventPtr) data;
+    pWin = pRREvent-&gt;window;
+    pHead = (RREventPtr *) LookupIDByType(pWin-&gt;drawable.id, RREventType);
+    if (pHead) {
+	pPrev = 0;
+	for (pCur = *pHead; pCur &amp;&amp; pCur != pRREvent; pCur=pCur-&gt;next)
+	    pPrev = pCur;
+	if (pCur)
+	{
+	    if (pPrev)
+	    	pPrev-&gt;next = pRREvent-&gt;next;
+	    else
+	    	*pHead = pRREvent-&gt;next;
+	}
+    }
+    xfree ((pointer) pRREvent);
+    return 1;
+}
+
+/*ARGSUSED*/
+static int
+RRFreeEvents (pointer data, XID id)
+{
+    RREventPtr   *pHead, pCur, pNext;
+
+    pHead = (RREventPtr *) data;
+    for (pCur = *pHead; pCur; pCur = pNext) {
+	pNext = pCur-&gt;next;
+	FreeResource (pCur-&gt;clientResource, RRClientType);
+	xfree ((pointer) pCur);
+    }
+    xfree ((pointer) pHead);
+    return 1;
+}
+
+void
+RRExtensionInit (void)
+{
+    ExtensionEntry *extEntry;
+
+    if (RRNScreens == 0) return;
+
+    #ifndef NXAGENT_SERVER
+    if (!dixRequestPrivate(RRClientPrivateKey,
+				sizeof (RRClientRec) +
+				screenInfo.numScreens * sizeof (RRTimesRec)))
+	return;
+    #else
+    RRClientPrivateIndex = AllocateClientPrivateIndex ();
+    if (!AllocateClientPrivate (RRClientPrivateIndex,
+				sizeof (RRClientRec) +
+				screenInfo.numScreens * sizeof (RRTimesRec)))
+	return;
+    #endif
+    if (!AddCallback (&amp;ClientStateCallback, RRClientCallback, 0))
+	return;
+
+    RRClientType = CreateNewResourceType(RRFreeClient);
+    if (!RRClientType)
+	return;
+    RREventType = CreateNewResourceType(RRFreeEvents);
+    if (!RREventType)
+	return;
+    extEntry = AddExtension (RANDR_NAME, RRNumberEvents, RRNumberErrors,
+			     ProcRRDispatch, SProcRRDispatch,
+			     RRResetProc, StandardMinorOpcode);
+    if (!extEntry)
+	return;
+    RRErrorBase = extEntry-&gt;errorBase;
+    RREventBase = extEntry-&gt;eventBase;
+    EventSwapVector[RREventBase + RRScreenChangeNotify] = (EventSwapPtr) 
+	SRRScreenChangeNotifyEvent;
+    EventSwapVector[RREventBase + RRNotify] = (EventSwapPtr)
+	SRRNotifyEvent;
+#ifdef PANORAMIX
+    RRXineramaExtensionInit();
+#endif
+}
+
+static int
+TellChanged (WindowPtr pWin, pointer value)
+{
+    RREventPtr			*pHead, pRREvent;
+    ClientPtr			client;
+    ScreenPtr			pScreen = pWin-&gt;drawable.pScreen;
+    rrScrPriv(pScreen);
+    int				i;
+
+    pHead = (RREventPtr *) LookupIDByType (pWin-&gt;drawable.id, RREventType);
+    if (!pHead)
+	return WT_WALKCHILDREN;
+
+    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent-&gt;next) 
+    {
+	client = pRREvent-&gt;client;
+	if (client == serverClient || client-&gt;clientGone)
+	    continue;
+
+	if (pRREvent-&gt;mask &amp; RRScreenChangeNotifyMask)
+	    RRDeliverScreenEvent (client, pWin, pScreen);
+	
+	if (pRREvent-&gt;mask &amp; RRCrtcChangeNotifyMask)
+	{
+	    for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	    {
+		RRCrtcPtr   crtc = pScrPriv-&gt;crtcs[i];
+		if (crtc-&gt;changed)
+		    RRDeliverCrtcEvent (client, pWin, crtc);
+	    }
+	}
+	
+	if (pRREvent-&gt;mask &amp; RROutputChangeNotifyMask)
+	{
+	    for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	    {
+		RROutputPtr   output = pScrPriv-&gt;outputs[i];
+		if (output-&gt;changed)
+		    RRDeliverOutputEvent (client, pWin, output);
+	    }
+	}
+    }
+    return WT_WALKCHILDREN;
+}
+
+/*
+ * Something changed; send events and adjust pointer position
+ */
+void
+RRTellChanged (ScreenPtr pScreen)
+{
+    rrScrPriv (pScreen);
+    int i;
+    
+    if (pScrPriv-&gt;changed)
+    {
+	UpdateCurrentTime ();
+	if (pScrPriv-&gt;configChanged)
+	{
+	    pScrPriv-&gt;lastConfigTime = currentTime;
+	    pScrPriv-&gt;configChanged = FALSE;
+	}
+	pScrPriv-&gt;changed = FALSE;
+	WalkTree (pScreen, TellChanged, (pointer) pScreen);
+	for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	    pScrPriv-&gt;outputs[i]-&gt;changed = FALSE;
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	    pScrPriv-&gt;crtcs[i]-&gt;changed = FALSE;
+	if (pScrPriv-&gt;layoutChanged)
+	{
+	    pScrPriv-&gt;layoutChanged = FALSE;
+	    RRPointerScreenConfigured (pScreen);
+	    RRSendConfigNotify (pScreen);
+	}
+    }
+}
+
+/*
+ * Return the first output which is connected to an active CRTC
+ * Used in emulating 1.0 behaviour
+ */
+RROutputPtr
+RRFirstOutput (ScreenPtr pScreen)
+{
+    rrScrPriv(pScreen);
+    RROutputPtr		    output;
+    int	i, j;
+    
+    for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+    {
+	RRCrtcPtr   crtc = pScrPriv-&gt;crtcs[i];
+	for (j = 0; j &lt; pScrPriv-&gt;numOutputs; j++)
+	{
+	    output = pScrPriv-&gt;outputs[j];
+	    if (output-&gt;crtc == crtc)
+		return output;
+	}
+    }
+    return NULL;
+}
+
+CARD16
+RRVerticalRefresh (xRRModeInfo *mode)
+{
+    CARD32  refresh;
+    CARD32  dots = mode-&gt;hTotal * mode-&gt;vTotal;
+    if (!dots)
+	return 0;
+    refresh = (mode-&gt;dotClock + dots/2) / dots;
+    if (refresh &gt; 0xffff)
+	refresh = 0xffff;
+    return (CARD16) refresh;
+}
+
+static int
+ProcRRDispatch (ClientPtr client)
+{
+    REQUEST(xReq);
+    if (stuff-&gt;data &gt;= RRNumberRequests || !ProcRandrVector[stuff-&gt;data])
+	return BadRequest;
+    return (*ProcRandrVector[stuff-&gt;data]) (client);
+}
+
+static int
+SProcRRDispatch (ClientPtr client)
+{
+    REQUEST(xReq);
+    if (stuff-&gt;data &gt;= RRNumberRequests || !ProcRandrVector[stuff-&gt;data])
+	return BadRequest;
+    return (*SProcRandrVector[stuff-&gt;data]) (client);
+}
+
diff --git a/nx-X11/programs/Xserver/randr/randr.c.X.original b/nx-X11/programs/Xserver/randr/randr.c.X.original
new file mode 100644
index 0000000..bc2b995
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/randr.c.X.original
@@ -0,0 +1,487 @@
+/*
+ * Copyright &#169; 2000 Compaq Computer Corporation
+ * Copyright &#169; 2002 Hewlett-Packard Company
+ * Copyright &#169; 2006 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ *
+ * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
+ *	    Keith Packard, Intel Corporation
+ */
+
+#define NEED_REPLIES
+#define NEED_EVENTS
+#ifdef HAVE_DIX_CONFIG_H
+#include &lt;dix-config.h&gt;
+#endif
+
+#include &quot;randrstr.h&quot;
+
+/* From render.h */
+#ifndef SubPixelUnknown
+#define SubPixelUnknown 0
+#endif
+
+#define RR_VALIDATE
+static int	RRNScreens;
+
+#define wrap(priv,real,mem,func) {\
+    priv-&gt;mem = real-&gt;mem; \
+    real-&gt;mem = func; \
+}
+
+#define unwrap(priv,real,mem) {\
+    real-&gt;mem = priv-&gt;mem; \
+}
+
+static int ProcRRDispatch (ClientPtr pClient);
+static int SProcRRDispatch (ClientPtr pClient);
+
+int	RREventBase;
+int	RRErrorBase;
+RESTYPE RRClientType, RREventType; /* resource types for event masks */
+DevPrivateKey RRClientPrivateKey = &RRClientPrivateKey;
+
+DevPrivateKey rrPrivKey = &rrPrivKey;
+
+static void
+RRClientCallback (CallbackListPtr	*list,
+		  pointer		closure,
+		  pointer		data)
+{
+    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
+    ClientPtr		pClient = clientinfo-&gt;client;
+    rrClientPriv(pClient);
+    RRTimesPtr		pTimes = (RRTimesPtr) (pRRClient + 1);
+    int			i;
+
+    pRRClient-&gt;major_version = 0;
+    pRRClient-&gt;minor_version = 0;
+    for (i = 0; i &lt; screenInfo.numScreens; i++)
+    {
+	ScreenPtr   pScreen = screenInfo.screens[i];
+	rrScrPriv(pScreen);
+
+	if (pScrPriv)
+	{
+	    pTimes[i].setTime = pScrPriv-&gt;lastSetTime;
+	    pTimes[i].configTime = pScrPriv-&gt;lastConfigTime;
+	}
+    }
+}
+
+static void
+RRResetProc (ExtensionEntry *extEntry)
+{
+}
+    
+static Bool
+RRCloseScreen (int i, ScreenPtr pScreen)
+{
+    rrScrPriv(pScreen);
+    int		    j;
+
+    unwrap (pScrPriv, pScreen, CloseScreen);
+    for (j = pScrPriv-&gt;numCrtcs - 1; j &gt;= 0; j--)
+	RRCrtcDestroy (pScrPriv-&gt;crtcs[j]);
+    for (j = pScrPriv-&gt;numOutputs - 1; j &gt;= 0; j--)
+	RROutputDestroy (pScrPriv-&gt;outputs[j]);
+    
+    xfree (pScrPriv);
+    RRNScreens -= 1;	/* ok, one fewer screen with RandR running */
+    return (*pScreen-&gt;CloseScreen) (i, pScreen);    
+}
+
+static void
+SRRScreenChangeNotifyEvent(xRRScreenChangeNotifyEvent *from,
+			   xRRScreenChangeNotifyEvent *to)
+{
+    to-&gt;type = from-&gt;type;
+    to-&gt;rotation = from-&gt;rotation;
+    cpswaps(from-&gt;sequenceNumber, to-&gt;sequenceNumber);
+    cpswapl(from-&gt;timestamp, to-&gt;timestamp);
+    cpswapl(from-&gt;configTimestamp, to-&gt;configTimestamp);
+    cpswapl(from-&gt;root, to-&gt;root);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswaps(from-&gt;sizeID, to-&gt;sizeID);
+    cpswaps(from-&gt;widthInPixels, to-&gt;widthInPixels);
+    cpswaps(from-&gt;heightInPixels, to-&gt;heightInPixels);
+    cpswaps(from-&gt;widthInMillimeters, to-&gt;widthInMillimeters);
+    cpswaps(from-&gt;heightInMillimeters, to-&gt;heightInMillimeters);
+    cpswaps(from-&gt;subpixelOrder, to-&gt;subpixelOrder);
+}
+
+static void
+SRRCrtcChangeNotifyEvent(xRRCrtcChangeNotifyEvent *from,
+			 xRRCrtcChangeNotifyEvent *to)
+{
+    to-&gt;type = from-&gt;type;
+    to-&gt;subCode = from-&gt;subCode;
+    cpswaps(from-&gt;sequenceNumber, to-&gt;sequenceNumber);
+    cpswapl(from-&gt;timestamp, to-&gt;timestamp);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswapl(from-&gt;crtc, to-&gt;crtc);
+    cpswapl(from-&gt;mode, to-&gt;mode);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswaps(from-&gt;rotation, to-&gt;rotation);
+    cpswaps(from-&gt;x, to-&gt;x);
+    cpswaps(from-&gt;y, to-&gt;y);
+    cpswaps(from-&gt;width, to-&gt;width);
+    cpswaps(from-&gt;height, to-&gt;height);
+}
+
+static void
+SRROutputChangeNotifyEvent(xRROutputChangeNotifyEvent *from,
+			   xRROutputChangeNotifyEvent *to)
+{
+    to-&gt;type = from-&gt;type;
+    to-&gt;subCode = from-&gt;subCode;
+    cpswaps(from-&gt;sequenceNumber, to-&gt;sequenceNumber);
+    cpswapl(from-&gt;timestamp, to-&gt;timestamp);
+    cpswapl(from-&gt;configTimestamp, to-&gt;configTimestamp);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswapl(from-&gt;output, to-&gt;output);
+    cpswapl(from-&gt;crtc, to-&gt;crtc);
+    cpswapl(from-&gt;mode, to-&gt;mode);
+    cpswaps(from-&gt;rotation, to-&gt;rotation);
+}
+
+static void
+SRROutputPropertyNotifyEvent(xRROutputPropertyNotifyEvent *from,
+			     xRROutputPropertyNotifyEvent *to)
+{
+    to-&gt;type = from-&gt;type;
+    to-&gt;subCode = from-&gt;subCode;
+    cpswaps(from-&gt;sequenceNumber, to-&gt;sequenceNumber);
+    cpswapl(from-&gt;window, to-&gt;window);
+    cpswapl(from-&gt;output, to-&gt;output);
+    cpswapl(from-&gt;atom, to-&gt;atom);
+    cpswapl(from-&gt;timestamp, to-&gt;timestamp);
+}
+
+static void
+SRRNotifyEvent (xEvent *from,
+		xEvent *to)
+{
+    switch (from-&gt;u.u.detail) {
+    case RRNotify_CrtcChange:
+	SRRCrtcChangeNotifyEvent ((xRRCrtcChangeNotifyEvent *) from,
+				  (xRRCrtcChangeNotifyEvent *) to);
+	break;
+    case RRNotify_OutputChange:
+	SRROutputChangeNotifyEvent ((xRROutputChangeNotifyEvent *) from,
+				    (xRROutputChangeNotifyEvent *) to);
+	break;
+    case RRNotify_OutputProperty:
+	SRROutputPropertyNotifyEvent ((xRROutputPropertyNotifyEvent *) from,
+				      (xRROutputPropertyNotifyEvent *) to);
+	break;
+    default:
+	break;
+    }
+}
+
+static int RRGeneration;
+
+Bool RRInit (void)
+{
+    if (RRGeneration != serverGeneration)
+    {
+	if (!RRModeInit ())
+	    return FALSE;
+	if (!RRCrtcInit ())
+	    return FALSE;
+	if (!RROutputInit ())
+	    return FALSE;
+	RRGeneration = serverGeneration;
+    }
+    return TRUE;
+}
+
+Bool RRScreenInit(ScreenPtr pScreen)
+{
+    rrScrPrivPtr   pScrPriv;
+
+    if (!RRInit ())
+	return FALSE;
+
+    pScrPriv = (rrScrPrivPtr) xcalloc (1, sizeof (rrScrPrivRec));
+    if (!pScrPriv)
+	return FALSE;
+
+    SetRRScreen(pScreen, pScrPriv);
+
+    /*
+     * Calling function best set these function vectors
+     */
+    pScrPriv-&gt;rrGetInfo = 0;
+    pScrPriv-&gt;maxWidth = pScrPriv-&gt;minWidth = pScreen-&gt;width;
+    pScrPriv-&gt;maxHeight = pScrPriv-&gt;minHeight = pScreen-&gt;height;
+    
+    pScrPriv-&gt;width = pScreen-&gt;width;
+    pScrPriv-&gt;height = pScreen-&gt;height;
+    pScrPriv-&gt;mmWidth = pScreen-&gt;mmWidth;
+    pScrPriv-&gt;mmHeight = pScreen-&gt;mmHeight;
+#if RANDR_12_INTERFACE
+    pScrPriv-&gt;rrScreenSetSize = NULL;
+    pScrPriv-&gt;rrCrtcSet = NULL;
+    pScrPriv-&gt;rrCrtcSetGamma = NULL;
+#endif
+#if RANDR_10_INTERFACE    
+    pScrPriv-&gt;rrSetConfig = 0;
+    pScrPriv-&gt;rotations = RR_Rotate_0;
+    pScrPriv-&gt;reqWidth = pScreen-&gt;width;
+    pScrPriv-&gt;reqHeight = pScreen-&gt;height;
+    pScrPriv-&gt;nSizes = 0;
+    pScrPriv-&gt;pSizes = NULL;
+    pScrPriv-&gt;rotation = RR_Rotate_0;
+    pScrPriv-&gt;rate = 0;
+    pScrPriv-&gt;size = 0;
+#endif
+    
+    /*
+     * This value doesn't really matter -- any client must call
+     * GetScreenInfo before reading it which will automatically update
+     * the time
+     */
+    pScrPriv-&gt;lastSetTime = currentTime;
+    pScrPriv-&gt;lastConfigTime = currentTime;
+    
+    wrap (pScrPriv, pScreen, CloseScreen, RRCloseScreen);
+
+    pScrPriv-&gt;numOutputs = 0;
+    pScrPriv-&gt;outputs = NULL;
+    pScrPriv-&gt;numCrtcs = 0;
+    pScrPriv-&gt;crtcs = NULL;
+    
+    RRNScreens += 1;	/* keep count of screens that implement randr */
+    return TRUE;
+}
+
+/*ARGSUSED*/
+static int
+RRFreeClient (pointer data, XID id)
+{
+    RREventPtr   pRREvent;
+    WindowPtr	    pWin;
+    RREventPtr   *pHead, pCur, pPrev;
+
+    pRREvent = (RREventPtr) data;
+    pWin = pRREvent-&gt;window;
+    pHead = (RREventPtr *) LookupIDByType(pWin-&gt;drawable.id, RREventType);
+    if (pHead) {
+	pPrev = 0;
+	for (pCur = *pHead; pCur &amp;&amp; pCur != pRREvent; pCur=pCur-&gt;next)
+	    pPrev = pCur;
+	if (pCur)
+	{
+	    if (pPrev)
+	    	pPrev-&gt;next = pRREvent-&gt;next;
+	    else
+	    	*pHead = pRREvent-&gt;next;
+	}
+    }
+    xfree ((pointer) pRREvent);
+    return 1;
+}
+
+/*ARGSUSED*/
+static int
+RRFreeEvents (pointer data, XID id)
+{
+    RREventPtr   *pHead, pCur, pNext;
+
+    pHead = (RREventPtr *) data;
+    for (pCur = *pHead; pCur; pCur = pNext) {
+	pNext = pCur-&gt;next;
+	FreeResource (pCur-&gt;clientResource, RRClientType);
+	xfree ((pointer) pCur);
+    }
+    xfree ((pointer) pHead);
+    return 1;
+}
+
+void
+RRExtensionInit (void)
+{
+    ExtensionEntry *extEntry;
+
+    if (RRNScreens == 0) return;
+
+    if (!dixRequestPrivate(RRClientPrivateKey,
+				sizeof (RRClientRec) +
+				screenInfo.numScreens * sizeof (RRTimesRec)))
+	return;
+    if (!AddCallback (&amp;ClientStateCallback, RRClientCallback, 0))
+	return;
+
+    RRClientType = CreateNewResourceType(RRFreeClient);
+    if (!RRClientType)
+	return;
+    RREventType = CreateNewResourceType(RRFreeEvents);
+    if (!RREventType)
+	return;
+    extEntry = AddExtension (RANDR_NAME, RRNumberEvents, RRNumberErrors,
+			     ProcRRDispatch, SProcRRDispatch,
+			     RRResetProc, StandardMinorOpcode);
+    if (!extEntry)
+	return;
+    RRErrorBase = extEntry-&gt;errorBase;
+    RREventBase = extEntry-&gt;eventBase;
+    EventSwapVector[RREventBase + RRScreenChangeNotify] = (EventSwapPtr) 
+	SRRScreenChangeNotifyEvent;
+    EventSwapVector[RREventBase + RRNotify] = (EventSwapPtr)
+	SRRNotifyEvent;
+#ifdef PANORAMIX
+    RRXineramaExtensionInit();
+#endif
+}
+
+static int
+TellChanged (WindowPtr pWin, pointer value)
+{
+    RREventPtr			*pHead, pRREvent;
+    ClientPtr			client;
+    ScreenPtr			pScreen = pWin-&gt;drawable.pScreen;
+    rrScrPriv(pScreen);
+    int				i;
+
+    pHead = (RREventPtr *) LookupIDByType (pWin-&gt;drawable.id, RREventType);
+    if (!pHead)
+	return WT_WALKCHILDREN;
+
+    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent-&gt;next) 
+    {
+	client = pRREvent-&gt;client;
+	if (client == serverClient || client-&gt;clientGone)
+	    continue;
+
+	if (pRREvent-&gt;mask &amp; RRScreenChangeNotifyMask)
+	    RRDeliverScreenEvent (client, pWin, pScreen);
+	
+	if (pRREvent-&gt;mask &amp; RRCrtcChangeNotifyMask)
+	{
+	    for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	    {
+		RRCrtcPtr   crtc = pScrPriv-&gt;crtcs[i];
+		if (crtc-&gt;changed)
+		    RRDeliverCrtcEvent (client, pWin, crtc);
+	    }
+	}
+	
+	if (pRREvent-&gt;mask &amp; RROutputChangeNotifyMask)
+	{
+	    for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	    {
+		RROutputPtr   output = pScrPriv-&gt;outputs[i];
+		if (output-&gt;changed)
+		    RRDeliverOutputEvent (client, pWin, output);
+	    }
+	}
+    }
+    return WT_WALKCHILDREN;
+}
+
+/*
+ * Something changed; send events and adjust pointer position
+ */
+void
+RRTellChanged (ScreenPtr pScreen)
+{
+    rrScrPriv (pScreen);
+    int i;
+    
+    if (pScrPriv-&gt;changed)
+    {
+	UpdateCurrentTime ();
+	if (pScrPriv-&gt;configChanged)
+	{
+	    pScrPriv-&gt;lastConfigTime = currentTime;
+	    pScrPriv-&gt;configChanged = FALSE;
+	}
+	pScrPriv-&gt;changed = FALSE;
+	WalkTree (pScreen, TellChanged, (pointer) pScreen);
+	for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	    pScrPriv-&gt;outputs[i]-&gt;changed = FALSE;
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	    pScrPriv-&gt;crtcs[i]-&gt;changed = FALSE;
+	if (pScrPriv-&gt;layoutChanged)
+	{
+	    pScrPriv-&gt;layoutChanged = FALSE;
+	    RRPointerScreenConfigured (pScreen);
+	    RRSendConfigNotify (pScreen);
+	}
+    }
+}
+
+/*
+ * Return the first output which is connected to an active CRTC
+ * Used in emulating 1.0 behaviour
+ */
+RROutputPtr
+RRFirstOutput (ScreenPtr pScreen)
+{
+    rrScrPriv(pScreen);
+    RROutputPtr		    output;
+    int	i, j;
+    
+    for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+    {
+	RRCrtcPtr   crtc = pScrPriv-&gt;crtcs[i];
+	for (j = 0; j &lt; pScrPriv-&gt;numOutputs; j++)
+	{
+	    output = pScrPriv-&gt;outputs[j];
+	    if (output-&gt;crtc == crtc)
+		return output;
+	}
+    }
+    return NULL;
+}
+
+CARD16
+RRVerticalRefresh (xRRModeInfo *mode)
+{
+    CARD32  refresh;
+    CARD32  dots = mode-&gt;hTotal * mode-&gt;vTotal;
+    if (!dots)
+	return 0;
+    refresh = (mode-&gt;dotClock + dots/2) / dots;
+    if (refresh &gt; 0xffff)
+	refresh = 0xffff;
+    return (CARD16) refresh;
+}
+
+static int
+ProcRRDispatch (ClientPtr client)
+{
+    REQUEST(xReq);
+    if (stuff-&gt;data &gt;= RRNumberRequests || !ProcRandrVector[stuff-&gt;data])
+	return BadRequest;
+    return (*ProcRandrVector[stuff-&gt;data]) (client);
+}
+
+static int
+SProcRRDispatch (ClientPtr client)
+{
+    REQUEST(xReq);
+    if (stuff-&gt;data &gt;= RRNumberRequests || !ProcRandrVector[stuff-&gt;data])
+	return BadRequest;
+    return (*SProcRandrVector[stuff-&gt;data]) (client);
+}
+
diff --git a/nx-X11/programs/Xserver/randr/randr.h b/nx-X11/programs/Xserver/randr/randr.h
new file mode 100644
index 0000000..17e6ef9
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/randr.h
@@ -0,0 +1,141 @@
+/*
+ * Copyright &#169; 2000 Compaq Computer Corporation
+ * Copyright &#169; 2002 Hewlett Packard Company
+ * Copyright &#169; 2006 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ *
+ * Author:  Jim Gettys, HP Labs, Hewlett-Packard, Inc.
+ *	    Keith Packard, Intel Corporation
+ */
+
+#ifndef _RANDR_H_
+#define _RANDR_H_
+
+typedef unsigned short	Rotation;
+typedef unsigned short	SizeID;
+typedef unsigned short	SubpixelOrder;
+typedef unsigned short	Connection;
+typedef unsigned short	XRandrRotation;
+typedef unsigned short	XRandrSizeID;
+typedef unsigned short	XRandrSubpixelOrder;
+typedef unsigned long	XRandrModeFlags;
+
+#define RANDR_NAME		&quot;RANDR&quot;
+#define RANDR_MAJOR		1
+#define RANDR_MINOR		2
+
+#define RRNumberErrors		3
+#define RRNumberEvents		2
+#define RRNumberRequests	25
+
+#define X_RRQueryVersion	0
+/* we skip 1 to make old clients fail pretty immediately */
+#define X_RROldGetScreenInfo	1
+#define X_RR1_0SetScreenConfig	2
+/* V1.0 apps share the same set screen config request id */
+#define X_RRSetScreenConfig	2
+#define X_RROldScreenChangeSelectInput	3
+/* 3 used to be ScreenChangeSelectInput; deprecated */
+#define X_RRSelectInput		4
+#define X_RRGetScreenInfo	5
+
+/* V1.2 additions */
+#define X_RRGetScreenSizeRange	    6
+#define X_RRSetScreenSize	    7
+#define X_RRGetScreenResources	    8
+#define X_RRGetOutputInfo	    9
+#define X_RRListOutputProperties    10
+#define X_RRQueryOutputProperty	    11
+#define X_RRConfigureOutputProperty 12
+#define X_RRChangeOutputProperty    13
+#define X_RRDeleteOutputProperty    14
+#define X_RRGetOutputProperty	    15
+#define X_RRCreateMode		    16
+#define X_RRDestroyMode		    17
+#define X_RRAddOutputMode	    18
+#define X_RRDeleteOutputMode	    19
+#define X_RRGetCrtcInfo		    20
+#define X_RRSetCrtcConfig	    21
+#define X_RRGetCrtcGammaSize	    22
+#define X_RRGetCrtcGamma	    23
+#define X_RRSetCrtcGamma	    24
+
+/* Event selection bits */
+#define RRScreenChangeNotifyMask  (1L &lt;&lt; 0)
+/* V1.2 additions */
+#define RRCrtcChangeNotifyMask	    (1L &lt;&lt; 1)
+#define RROutputChangeNotifyMask    (1L &lt;&lt; 2)
+#define RROutputPropertyNotifyMask  (1L &lt;&lt; 3)
+
+/* Event codes */
+#define RRScreenChangeNotify	0
+/* V1.2 additions */
+#define RRNotify		    1
+/* RRNotify Subcodes */
+#define  RRNotify_CrtcChange	    0
+#define  RRNotify_OutputChange	    1
+#define  RRNotify_OutputProperty    2
+
+/* used in the rotation field; rotation and reflection in 0.1 proto. */
+#define RR_Rotate_0		1
+#define RR_Rotate_90		2
+#define RR_Rotate_180		4
+#define RR_Rotate_270		8
+
+/* new in 1.0 protocol, to allow reflection of screen */
+
+#define RR_Reflect_X		16
+#define RR_Reflect_Y		32
+
+#define RRSetConfigSuccess		0
+#define RRSetConfigInvalidConfigTime	1
+#define RRSetConfigInvalidTime		2
+#define RRSetConfigFailed		3
+
+/* new in 1.2 protocol */
+
+#define RR_HSyncPositive	0x00000001
+#define RR_HSyncNegative	0x00000002
+#define RR_VSyncPositive	0x00000004
+#define RR_VSyncNegative	0x00000008
+#define RR_Interlace		0x00000010
+#define RR_DoubleScan		0x00000020
+#define RR_CSync		0x00000040
+#define RR_CSyncPositive	0x00000080
+#define RR_CSyncNegative	0x00000100
+#define RR_HSkewPresent		0x00000200
+#define RR_BCast		0x00000400
+#define RR_PixelMultiplex	0x00000800
+#define RR_DoubleClock		0x00001000
+#define RR_ClockDivideBy2	0x00002000
+
+#define RR_Connected		0
+#define RR_Disconnected		1
+#define RR_UnknownConnection	2
+
+#define BadRROutput		0
+#define BadRRCrtc		1
+#define BadRRMode		2
+
+/* Conventional RandR output properties */
+
+#define RR_PROPERTY_RANDR_EDID		&quot;RANDR_EDID&quot;
+
+#endif	/* _RANDR_H_ */
diff --git a/nx-X11/programs/Xserver/randr/randr.h.NX.original b/nx-X11/programs/Xserver/randr/randr.h.NX.original
new file mode 100644
index 0000000..17e6ef9
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/randr.h.NX.original
@@ -0,0 +1,141 @@
+/*
+ * Copyright &#169; 2000 Compaq Computer Corporation
+ * Copyright &#169; 2002 Hewlett Packard Company
+ * Copyright &#169; 2006 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ *
+ * Author:  Jim Gettys, HP Labs, Hewlett-Packard, Inc.
+ *	    Keith Packard, Intel Corporation
+ */
+
+#ifndef _RANDR_H_
+#define _RANDR_H_
+
+typedef unsigned short	Rotation;
+typedef unsigned short	SizeID;
+typedef unsigned short	SubpixelOrder;
+typedef unsigned short	Connection;
+typedef unsigned short	XRandrRotation;
+typedef unsigned short	XRandrSizeID;
+typedef unsigned short	XRandrSubpixelOrder;
+typedef unsigned long	XRandrModeFlags;
+
+#define RANDR_NAME		&quot;RANDR&quot;
+#define RANDR_MAJOR		1
+#define RANDR_MINOR		2
+
+#define RRNumberErrors		3
+#define RRNumberEvents		2
+#define RRNumberRequests	25
+
+#define X_RRQueryVersion	0
+/* we skip 1 to make old clients fail pretty immediately */
+#define X_RROldGetScreenInfo	1
+#define X_RR1_0SetScreenConfig	2
+/* V1.0 apps share the same set screen config request id */
+#define X_RRSetScreenConfig	2
+#define X_RROldScreenChangeSelectInput	3
+/* 3 used to be ScreenChangeSelectInput; deprecated */
+#define X_RRSelectInput		4
+#define X_RRGetScreenInfo	5
+
+/* V1.2 additions */
+#define X_RRGetScreenSizeRange	    6
+#define X_RRSetScreenSize	    7
+#define X_RRGetScreenResources	    8
+#define X_RRGetOutputInfo	    9
+#define X_RRListOutputProperties    10
+#define X_RRQueryOutputProperty	    11
+#define X_RRConfigureOutputProperty 12
+#define X_RRChangeOutputProperty    13
+#define X_RRDeleteOutputProperty    14
+#define X_RRGetOutputProperty	    15
+#define X_RRCreateMode		    16
+#define X_RRDestroyMode		    17
+#define X_RRAddOutputMode	    18
+#define X_RRDeleteOutputMode	    19
+#define X_RRGetCrtcInfo		    20
+#define X_RRSetCrtcConfig	    21
+#define X_RRGetCrtcGammaSize	    22
+#define X_RRGetCrtcGamma	    23
+#define X_RRSetCrtcGamma	    24
+
+/* Event selection bits */
+#define RRScreenChangeNotifyMask  (1L &lt;&lt; 0)
+/* V1.2 additions */
+#define RRCrtcChangeNotifyMask	    (1L &lt;&lt; 1)
+#define RROutputChangeNotifyMask    (1L &lt;&lt; 2)
+#define RROutputPropertyNotifyMask  (1L &lt;&lt; 3)
+
+/* Event codes */
+#define RRScreenChangeNotify	0
+/* V1.2 additions */
+#define RRNotify		    1
+/* RRNotify Subcodes */
+#define  RRNotify_CrtcChange	    0
+#define  RRNotify_OutputChange	    1
+#define  RRNotify_OutputProperty    2
+
+/* used in the rotation field; rotation and reflection in 0.1 proto. */
+#define RR_Rotate_0		1
+#define RR_Rotate_90		2
+#define RR_Rotate_180		4
+#define RR_Rotate_270		8
+
+/* new in 1.0 protocol, to allow reflection of screen */
+
+#define RR_Reflect_X		16
+#define RR_Reflect_Y		32
+
+#define RRSetConfigSuccess		0
+#define RRSetConfigInvalidConfigTime	1
+#define RRSetConfigInvalidTime		2
+#define RRSetConfigFailed		3
+
+/* new in 1.2 protocol */
+
+#define RR_HSyncPositive	0x00000001
+#define RR_HSyncNegative	0x00000002
+#define RR_VSyncPositive	0x00000004
+#define RR_VSyncNegative	0x00000008
+#define RR_Interlace		0x00000010
+#define RR_DoubleScan		0x00000020
+#define RR_CSync		0x00000040
+#define RR_CSyncPositive	0x00000080
+#define RR_CSyncNegative	0x00000100
+#define RR_HSkewPresent		0x00000200
+#define RR_BCast		0x00000400
+#define RR_PixelMultiplex	0x00000800
+#define RR_DoubleClock		0x00001000
+#define RR_ClockDivideBy2	0x00002000
+
+#define RR_Connected		0
+#define RR_Disconnected		1
+#define RR_UnknownConnection	2
+
+#define BadRROutput		0
+#define BadRRCrtc		1
+#define BadRRMode		2
+
+/* Conventional RandR output properties */
+
+#define RR_PROPERTY_RANDR_EDID		&quot;RANDR_EDID&quot;
+
+#endif	/* _RANDR_H_ */
diff --git a/nx-X11/CHANGELOG.X.original b/nx-X11/programs/Xserver/randr/randr.h.X.original
similarity index 100%
copy from nx-X11/CHANGELOG.X.original
copy to nx-X11/programs/Xserver/randr/randr.h.X.original
diff --git a/nx-X11/programs/Xserver/randr/randrproto.h b/nx-X11/programs/Xserver/randr/randrproto.h
new file mode 100644
index 0000000..7d5c139
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/randrproto.h
@@ -0,0 +1,655 @@
+/*
+ * Copyright &#169; 2000 Compaq Computer Corporation
+ * Copyright &#169; 2002 Hewlett-Packard Company
+ * Copyright &#169; 2006 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ *
+ * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
+ *	    Keith Packard, Intel Corporation
+ */
+
+/* note that RANDR 1.0 is incompatible with version 0.0, or 0.1 */
+/* V1.0 removes depth switching from the protocol */
+#ifndef _XRANDRP_H_
+#define _XRANDRP_H_
+
+/*#include &lt;X11/extensions/randr.h&gt;*/
+#include &quot;randr.h&quot;
+
+#define Window CARD32
+#define Drawable CARD32
+#define Font CARD32
+#define Pixmap CARD32
+#define Cursor CARD32
+#define Colormap CARD32
+#define GContext CARD32
+#define Atom CARD32
+#define Time CARD32
+#define KeyCode CARD8
+#define KeySym CARD32
+#define RROutput CARD32
+#define RRMode CARD32
+#define RRCrtc CARD32
+#define RRModeFlags CARD32
+
+#define Rotation CARD16
+#define SizeID CARD16
+#define SubpixelOrder CARD16
+
+/*
+ * data structures
+ */
+
+typedef struct {
+    CARD16 widthInPixels B16;
+    CARD16 heightInPixels B16;
+    CARD16 widthInMillimeters B16;
+    CARD16 heightInMillimeters B16;
+} xScreenSizes;
+#define sz_xScreenSizes 8
+
+/* 
+ * requests and replies
+ */
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    CARD32  majorVersion B32;
+    CARD32  minorVersion B32;
+} xRRQueryVersionReq;
+#define sz_xRRQueryVersionReq   12
+
+typedef struct {
+    BYTE    type;   /* X_Reply */
+    BYTE    pad1;
+    CARD16  sequenceNumber B16;
+    CARD32  length B32;
+    CARD32  majorVersion B32;
+    CARD32  minorVersion B32;
+    CARD32  pad2 B32;
+    CARD32  pad3 B32;
+    CARD32  pad4 B32;
+    CARD32  pad5 B32;
+} xRRQueryVersionReply;
+#define sz_xRRQueryVersionReply	32
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    Window  window B32;
+} xRRGetScreenInfoReq;
+#define sz_xRRGetScreenInfoReq   8
+
+/* 
+ * the xRRScreenInfoReply structure is followed by:
+ *
+ * the size information
+ */
+
+
+typedef struct {
+    BYTE    type;   /* X_Reply */
+    BYTE    setOfRotations;
+    CARD16  sequenceNumber B16;
+    CARD32  length B32;
+    Window  root B32;
+    Time    timestamp B32;
+    Time    configTimestamp B32;
+    CARD16  nSizes B16;
+    SizeID  sizeID B16;
+    Rotation  rotation B16;
+    CARD16  rate B16;
+    CARD16  nrateEnts B16;
+    CARD16  pad B16;
+} xRRGetScreenInfoReply;
+#define sz_xRRGetScreenInfoReply	32
+
+typedef struct {
+    CARD8    reqType;
+    CARD8    randrReqType;
+    CARD16   length B16;
+    Drawable drawable B32;
+    Time     timestamp B32;
+    Time     configTimestamp B32;
+    SizeID   sizeID B16;
+    Rotation rotation B16;
+} xRR1_0SetScreenConfigReq;
+#define sz_xRR1_0SetScreenConfigReq   20
+
+typedef struct {
+    CARD8    reqType;
+    CARD8    randrReqType;
+    CARD16   length B16;
+    Drawable drawable B32;
+    Time     timestamp B32;
+    Time     configTimestamp B32;
+    SizeID   sizeID B16;
+    Rotation rotation B16;
+    CARD16   rate B16;
+    CARD16   pad B16;
+} xRRSetScreenConfigReq;
+#define sz_xRRSetScreenConfigReq   24
+
+typedef struct {
+    BYTE    type;   /* X_Reply */
+    CARD8   status;
+    CARD16  sequenceNumber B16;
+    CARD32  length B32;
+    Time    newTimestamp B32;  
+    Time    newConfigTimestamp B32;
+    Window  root;
+    CARD16  subpixelOrder B16;
+    CARD16  pad4 B16;
+    CARD32  pad5 B32;
+    CARD32  pad6 B32;
+} xRRSetScreenConfigReply;
+#define sz_xRRSetScreenConfigReply 32
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    Window  window B32;
+    CARD16  enable B16;
+    CARD16  pad2 B16;
+} xRRSelectInputReq;
+#define sz_xRRSelectInputReq   12
+
+/*
+ * Additions for version 1.2
+ */
+
+typedef struct _xRRModeInfo {
+    RRMode		id B32;
+    CARD16		width B16;
+    CARD16		height B16;
+    CARD32		dotClock B32;
+    CARD16		hSyncStart B16;
+    CARD16		hSyncEnd B16;
+    CARD16		hTotal B16;
+    CARD16		hSkew B16;
+    CARD16		vSyncStart B16;
+    CARD16		vSyncEnd B16;
+    CARD16		vTotal B16;
+    CARD16		nameLength B16;
+    RRModeFlags		modeFlags B32;
+} xRRModeInfo;
+#define sz_xRRModeInfo		    32
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    Window  window B32;
+} xRRGetScreenSizeRangeReq;
+#define sz_xRRGetScreenSizeRangeReq 8
+
+typedef struct {
+    BYTE    type;   /* X_Reply */
+    CARD8   pad;
+    CARD16  sequenceNumber B16;
+    CARD32  length B32;
+    CARD16  minWidth B16;
+    CARD16  minHeight B16;
+    CARD16  maxWidth B16;
+    CARD16  maxHeight B16;
+    CARD32  pad0 B32;
+    CARD32  pad1 B32;
+    CARD32  pad2 B32;
+    CARD32  pad3 B32;
+} xRRGetScreenSizeRangeReply;
+#define sz_xRRGetScreenSizeRangeReply 32
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    Window  window B32;
+    CARD16  width B16;
+    CARD16  height B16;
+    CARD32  widthInMillimeters B32;
+    CARD32  heightInMillimeters B32;
+} xRRSetScreenSizeReq;
+#define sz_xRRSetScreenSizeReq	    20
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    Window  window B32;
+} xRRGetScreenResourcesReq;
+#define sz_xRRGetScreenResourcesReq 8
+
+typedef struct {
+    BYTE	type;
+    CARD8	pad;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    Time	timestamp B32;
+    Time	configTimestamp B32;
+    CARD16	nCrtcs B16;
+    CARD16	nOutputs B16;
+    CARD16	nModes B16;
+    CARD16	nbytesNames B16;
+    CARD32	pad1 B32;
+    CARD32	pad2 B32;
+} xRRGetScreenResourcesReply;
+#define sz_xRRGetScreenResourcesReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Time	configTimestamp B32;
+} xRRGetOutputInfoReq;
+#define sz_xRRGetOutputInfoReq		12
+
+typedef struct {
+    BYTE	type;
+    CARD8	status;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    Time	timestamp B32;
+    RRCrtc	crtc B32;
+    CARD32	mmWidth B32;
+    CARD32	mmHeight B32;
+    CARD8	connection;
+    CARD8	subpixelOrder;
+    CARD16	nCrtcs B16;
+    CARD16	nModes B16;
+    CARD16	nPreferred B16;
+    CARD16	nClones B16;
+    CARD16	nameLength B16;
+} xRRGetOutputInfoReply;
+#define sz_xRRGetOutputInfoReply	36
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+} xRRListOutputPropertiesReq; 
+#define sz_xRRListOutputPropertiesReq	8
+
+typedef struct {
+    BYTE	type;
+    CARD8	pad0;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD16	nAtoms B16;
+    CARD16	pad1 B16;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xRRListOutputPropertiesReply;
+#define sz_xRRListOutputPropertiesReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Atom	property B32;
+} xRRQueryOutputPropertyReq; 
+#define sz_xRRQueryOutputPropertyReq	12
+
+typedef struct {
+    BYTE	type;
+    BYTE	pad0;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    BOOL	pending;
+    BOOL	range;
+    BOOL	immutable;
+    BYTE	pad1;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xRRQueryOutputPropertyReply;
+#define sz_xRRQueryOutputPropertyReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Atom	property B32;
+    BOOL	pending;
+    BOOL	range;
+    CARD16	pad B16;
+} xRRConfigureOutputPropertyReq; 
+#define sz_xRRConfigureOutputPropertyReq	16
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Atom	property B32;
+    Atom	type B32;
+    CARD8	format;
+    CARD8	mode;
+    CARD16	pad;
+    CARD32	nUnits B32;
+} xRRChangeOutputPropertyReq;
+#define sz_xRRChangeOutputPropertyReq	24
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Atom	property B32;
+} xRRDeleteOutputPropertyReq;
+#define sz_xRRDeleteOutputPropertyReq	12
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Atom	property B32;
+    Atom	type B32;
+    CARD32	longOffset B32;
+    CARD32	longLength B32;
+#ifdef __cplusplus
+    BOOL	_delete;
+#else
+    BOOL	delete;
+#endif
+    BOOL	pending;
+    CARD16	pad1 B16;
+} xRRGetOutputPropertyReq;
+#define sz_xRRGetOutputPropertyReq	28
+
+typedef struct {
+    BYTE	type;
+    CARD8	format;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    Atom	propertyType B32;
+    CARD32	bytesAfter B32;
+    CARD32	nItems B32;
+    CARD32	pad1 B32;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+} xRRGetOutputPropertyReply;
+#define sz_xRRGetOutputPropertyReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    Window	window B32;
+    xRRModeInfo	modeInfo;
+} xRRCreateModeReq; 
+#define sz_xRRCreateModeReq		40
+
+typedef struct {
+    BYTE	type;
+    CARD8	pad0;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    RRMode	mode B32;
+    CARD32	pad1 B32;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+} xRRCreateModeReply;
+#define sz_xRRCreateModeReply		32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRMode	mode B32;
+} xRRDestroyModeReq;
+#define sz_xRRDestroyModeReq		8
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    RRMode	mode B32;
+} xRRAddOutputModeReq;
+#define sz_xRRAddOutputModeReq		12
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    RRMode	mode B32;
+} xRRDeleteOutputModeReq;
+#define sz_xRRDeleteOutputModeReq	12
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRCrtc	crtc B32;
+    Time	configTimestamp B32;
+} xRRGetCrtcInfoReq; 
+#define sz_xRRGetCrtcInfoReq		12
+
+typedef struct {
+    BYTE	type;
+    CARD8	status;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    Time	timestamp B32;
+    INT16	x B16;
+    INT16	y B16;
+    CARD16	width B16;
+    CARD16	height B16;
+    RRMode	mode B32;
+    Rotation	rotation B16;
+    Rotation	rotations B16;
+    CARD16	nOutput B16;
+    CARD16	nPossibleOutput B16;
+} xRRGetCrtcInfoReply;
+#define sz_xRRGetCrtcInfoReply		32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRCrtc	crtc B32;
+    Time	timestamp B32;
+    Time    	configTimestamp B32;
+    INT16	x B16;
+    INT16	y B16;
+    RRMode	mode B32;
+    Rotation	rotation B16;
+    CARD16	pad B16;
+} xRRSetCrtcConfigReq; 
+#define sz_xRRSetCrtcConfigReq		28
+
+typedef struct {
+    BYTE	type;
+    CARD8	status;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    Time	newTimestamp B32;
+    CARD32	pad1 B32;
+    CARD32	pad2 B16;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+} xRRSetCrtcConfigReply;
+#define sz_xRRSetCrtcConfigReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRCrtc	crtc B32;
+} xRRGetCrtcGammaSizeReq; 
+#define sz_xRRGetCrtcGammaSizeReq	8
+
+typedef struct {
+    BYTE	type;
+    CARD8	status;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD16	size B16;
+    CARD16	pad1 B16;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xRRGetCrtcGammaSizeReply;
+#define sz_xRRGetCrtcGammaSizeReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRCrtc	crtc B32;
+} xRRGetCrtcGammaReq; 
+#define sz_xRRGetCrtcGammaReq		8
+
+typedef struct {
+    BYTE	type;
+    CARD8	status;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD16	size B16;
+    CARD16	pad1 B16;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xRRGetCrtcGammaReply;
+#define sz_xRRGetCrtcGammaReply		32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRCrtc	crtc B32;
+    CARD16	size B16;
+    CARD16	pad1 B16;
+} xRRSetCrtcGammaReq;
+#define sz_xRRSetCrtcGammaReq		12
+
+/*
+ * event
+ */
+typedef struct {
+    CARD8 type;				/* always evBase + ScreenChangeNotify */
+    CARD8 rotation;			/* new rotation */
+    CARD16 sequenceNumber B16;
+    Time timestamp B32;			/* time screen was changed */
+    Time configTimestamp B32;		/* time config data was changed */
+    Window root B32;			/* root window */
+    Window window B32;			/* window requesting notification */
+    SizeID sizeID B16;			/* new size ID */
+    CARD16 subpixelOrder B16;		/* subpixel order */
+    CARD16 widthInPixels B16;		/* new size */
+    CARD16 heightInPixels B16;
+    CARD16 widthInMillimeters B16;
+    CARD16 heightInMillimeters B16;
+} xRRScreenChangeNotifyEvent;
+#define sz_xRRScreenChangeNotifyEvent	32
+
+typedef struct {
+    CARD8 type;				/* always evBase + RRNotify */
+    CARD8 subCode;			/* RRNotify_CrtcChange */
+    CARD16 sequenceNumber B16;
+    Time timestamp B32;			/* time crtc was changed */
+    Window window B32;			/* window requesting notification */
+    RRCrtc crtc B32;			/* affected CRTC */
+    RRMode mode B32;			/* current mode */
+    CARD16 rotation B16;		/* rotation and reflection */
+    CARD16 pad1 B16;			/* unused */
+    INT16 x B16;			/* new location */
+    INT16 y B16;
+    CARD16 width B16;			/* new size */
+    CARD16 height B16;
+} xRRCrtcChangeNotifyEvent;
+#define sz_xRRCrtcChangeNotifyEvent	32
+
+typedef struct {
+    CARD8 type;				/* always evBase + RRNotify */
+    CARD8 subCode;			/* RRNotify_OutputChange */
+    CARD16 sequenceNumber B16;
+    Time timestamp B32;			/* time crtc was changed */
+    Time configTimestamp B32;		/* time crtc was changed */
+    Window window B32;			/* window requesting notification */
+    RROutput output B32;		/* affected output */
+    RRCrtc crtc B32;			/* current crtc */
+    RRMode mode B32;			/* current mode */
+    CARD16 rotation B16;		/* rotation and reflection */
+    CARD8 connection;			/* connection status */
+    CARD8 subpixelOrder;		/* subpixel order */
+} xRROutputChangeNotifyEvent;
+#define sz_xRROutputChangeNotifyEvent	32
+
+typedef struct {
+    CARD8 type;				/* always evBase + RRNotify */
+    CARD8 subCode;			/* RRNotify_OutputProperty */
+    CARD16 sequenceNumber B16;
+    Window window B32;			/* window requesting notification */
+    RROutput output B32;		/* affected output */
+    Atom atom B32;			/* property name */
+    Time timestamp B32;			/* time crtc was changed */
+    CARD8 state;			/* NewValue or Deleted */
+    CARD8 pad1;
+    CARD16 pad2 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+} xRROutputPropertyNotifyEvent;
+#define sz_xRROutputPropertyNotifyEvent	32
+
+#undef RRModeFlags
+#undef RRCrtc
+#undef RRMode
+#undef RROutput
+#undef RRMode
+#undef RRCrtc
+#undef Drawable
+#undef Window
+#undef Font
+#undef Pixmap
+#undef Cursor
+#undef Colormap
+#undef GContext
+#undef Atom
+#undef Time
+#undef KeyCode
+#undef KeySym
+#undef Rotation
+#undef SizeID
+#undef SubpixelOrder
+
+#endif /* _XRANDRP_H_ */
diff --git a/nx-X11/programs/Xserver/randr/randrproto.h.NX.original b/nx-X11/programs/Xserver/randr/randrproto.h.NX.original
new file mode 100644
index 0000000..7d5c139
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/randrproto.h.NX.original
@@ -0,0 +1,655 @@
+/*
+ * Copyright &#169; 2000 Compaq Computer Corporation
+ * Copyright &#169; 2002 Hewlett-Packard Company
+ * Copyright &#169; 2006 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ *
+ * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
+ *	    Keith Packard, Intel Corporation
+ */
+
+/* note that RANDR 1.0 is incompatible with version 0.0, or 0.1 */
+/* V1.0 removes depth switching from the protocol */
+#ifndef _XRANDRP_H_
+#define _XRANDRP_H_
+
+/*#include &lt;X11/extensions/randr.h&gt;*/
+#include &quot;randr.h&quot;
+
+#define Window CARD32
+#define Drawable CARD32
+#define Font CARD32
+#define Pixmap CARD32
+#define Cursor CARD32
+#define Colormap CARD32
+#define GContext CARD32
+#define Atom CARD32
+#define Time CARD32
+#define KeyCode CARD8
+#define KeySym CARD32
+#define RROutput CARD32
+#define RRMode CARD32
+#define RRCrtc CARD32
+#define RRModeFlags CARD32
+
+#define Rotation CARD16
+#define SizeID CARD16
+#define SubpixelOrder CARD16
+
+/*
+ * data structures
+ */
+
+typedef struct {
+    CARD16 widthInPixels B16;
+    CARD16 heightInPixels B16;
+    CARD16 widthInMillimeters B16;
+    CARD16 heightInMillimeters B16;
+} xScreenSizes;
+#define sz_xScreenSizes 8
+
+/* 
+ * requests and replies
+ */
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    CARD32  majorVersion B32;
+    CARD32  minorVersion B32;
+} xRRQueryVersionReq;
+#define sz_xRRQueryVersionReq   12
+
+typedef struct {
+    BYTE    type;   /* X_Reply */
+    BYTE    pad1;
+    CARD16  sequenceNumber B16;
+    CARD32  length B32;
+    CARD32  majorVersion B32;
+    CARD32  minorVersion B32;
+    CARD32  pad2 B32;
+    CARD32  pad3 B32;
+    CARD32  pad4 B32;
+    CARD32  pad5 B32;
+} xRRQueryVersionReply;
+#define sz_xRRQueryVersionReply	32
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    Window  window B32;
+} xRRGetScreenInfoReq;
+#define sz_xRRGetScreenInfoReq   8
+
+/* 
+ * the xRRScreenInfoReply structure is followed by:
+ *
+ * the size information
+ */
+
+
+typedef struct {
+    BYTE    type;   /* X_Reply */
+    BYTE    setOfRotations;
+    CARD16  sequenceNumber B16;
+    CARD32  length B32;
+    Window  root B32;
+    Time    timestamp B32;
+    Time    configTimestamp B32;
+    CARD16  nSizes B16;
+    SizeID  sizeID B16;
+    Rotation  rotation B16;
+    CARD16  rate B16;
+    CARD16  nrateEnts B16;
+    CARD16  pad B16;
+} xRRGetScreenInfoReply;
+#define sz_xRRGetScreenInfoReply	32
+
+typedef struct {
+    CARD8    reqType;
+    CARD8    randrReqType;
+    CARD16   length B16;
+    Drawable drawable B32;
+    Time     timestamp B32;
+    Time     configTimestamp B32;
+    SizeID   sizeID B16;
+    Rotation rotation B16;
+} xRR1_0SetScreenConfigReq;
+#define sz_xRR1_0SetScreenConfigReq   20
+
+typedef struct {
+    CARD8    reqType;
+    CARD8    randrReqType;
+    CARD16   length B16;
+    Drawable drawable B32;
+    Time     timestamp B32;
+    Time     configTimestamp B32;
+    SizeID   sizeID B16;
+    Rotation rotation B16;
+    CARD16   rate B16;
+    CARD16   pad B16;
+} xRRSetScreenConfigReq;
+#define sz_xRRSetScreenConfigReq   24
+
+typedef struct {
+    BYTE    type;   /* X_Reply */
+    CARD8   status;
+    CARD16  sequenceNumber B16;
+    CARD32  length B32;
+    Time    newTimestamp B32;  
+    Time    newConfigTimestamp B32;
+    Window  root;
+    CARD16  subpixelOrder B16;
+    CARD16  pad4 B16;
+    CARD32  pad5 B32;
+    CARD32  pad6 B32;
+} xRRSetScreenConfigReply;
+#define sz_xRRSetScreenConfigReply 32
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    Window  window B32;
+    CARD16  enable B16;
+    CARD16  pad2 B16;
+} xRRSelectInputReq;
+#define sz_xRRSelectInputReq   12
+
+/*
+ * Additions for version 1.2
+ */
+
+typedef struct _xRRModeInfo {
+    RRMode		id B32;
+    CARD16		width B16;
+    CARD16		height B16;
+    CARD32		dotClock B32;
+    CARD16		hSyncStart B16;
+    CARD16		hSyncEnd B16;
+    CARD16		hTotal B16;
+    CARD16		hSkew B16;
+    CARD16		vSyncStart B16;
+    CARD16		vSyncEnd B16;
+    CARD16		vTotal B16;
+    CARD16		nameLength B16;
+    RRModeFlags		modeFlags B32;
+} xRRModeInfo;
+#define sz_xRRModeInfo		    32
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    Window  window B32;
+} xRRGetScreenSizeRangeReq;
+#define sz_xRRGetScreenSizeRangeReq 8
+
+typedef struct {
+    BYTE    type;   /* X_Reply */
+    CARD8   pad;
+    CARD16  sequenceNumber B16;
+    CARD32  length B32;
+    CARD16  minWidth B16;
+    CARD16  minHeight B16;
+    CARD16  maxWidth B16;
+    CARD16  maxHeight B16;
+    CARD32  pad0 B32;
+    CARD32  pad1 B32;
+    CARD32  pad2 B32;
+    CARD32  pad3 B32;
+} xRRGetScreenSizeRangeReply;
+#define sz_xRRGetScreenSizeRangeReply 32
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    Window  window B32;
+    CARD16  width B16;
+    CARD16  height B16;
+    CARD32  widthInMillimeters B32;
+    CARD32  heightInMillimeters B32;
+} xRRSetScreenSizeReq;
+#define sz_xRRSetScreenSizeReq	    20
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   randrReqType;
+    CARD16  length B16;
+    Window  window B32;
+} xRRGetScreenResourcesReq;
+#define sz_xRRGetScreenResourcesReq 8
+
+typedef struct {
+    BYTE	type;
+    CARD8	pad;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    Time	timestamp B32;
+    Time	configTimestamp B32;
+    CARD16	nCrtcs B16;
+    CARD16	nOutputs B16;
+    CARD16	nModes B16;
+    CARD16	nbytesNames B16;
+    CARD32	pad1 B32;
+    CARD32	pad2 B32;
+} xRRGetScreenResourcesReply;
+#define sz_xRRGetScreenResourcesReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Time	configTimestamp B32;
+} xRRGetOutputInfoReq;
+#define sz_xRRGetOutputInfoReq		12
+
+typedef struct {
+    BYTE	type;
+    CARD8	status;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    Time	timestamp B32;
+    RRCrtc	crtc B32;
+    CARD32	mmWidth B32;
+    CARD32	mmHeight B32;
+    CARD8	connection;
+    CARD8	subpixelOrder;
+    CARD16	nCrtcs B16;
+    CARD16	nModes B16;
+    CARD16	nPreferred B16;
+    CARD16	nClones B16;
+    CARD16	nameLength B16;
+} xRRGetOutputInfoReply;
+#define sz_xRRGetOutputInfoReply	36
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+} xRRListOutputPropertiesReq; 
+#define sz_xRRListOutputPropertiesReq	8
+
+typedef struct {
+    BYTE	type;
+    CARD8	pad0;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD16	nAtoms B16;
+    CARD16	pad1 B16;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xRRListOutputPropertiesReply;
+#define sz_xRRListOutputPropertiesReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Atom	property B32;
+} xRRQueryOutputPropertyReq; 
+#define sz_xRRQueryOutputPropertyReq	12
+
+typedef struct {
+    BYTE	type;
+    BYTE	pad0;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    BOOL	pending;
+    BOOL	range;
+    BOOL	immutable;
+    BYTE	pad1;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xRRQueryOutputPropertyReply;
+#define sz_xRRQueryOutputPropertyReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Atom	property B32;
+    BOOL	pending;
+    BOOL	range;
+    CARD16	pad B16;
+} xRRConfigureOutputPropertyReq; 
+#define sz_xRRConfigureOutputPropertyReq	16
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Atom	property B32;
+    Atom	type B32;
+    CARD8	format;
+    CARD8	mode;
+    CARD16	pad;
+    CARD32	nUnits B32;
+} xRRChangeOutputPropertyReq;
+#define sz_xRRChangeOutputPropertyReq	24
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Atom	property B32;
+} xRRDeleteOutputPropertyReq;
+#define sz_xRRDeleteOutputPropertyReq	12
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    Atom	property B32;
+    Atom	type B32;
+    CARD32	longOffset B32;
+    CARD32	longLength B32;
+#ifdef __cplusplus
+    BOOL	_delete;
+#else
+    BOOL	delete;
+#endif
+    BOOL	pending;
+    CARD16	pad1 B16;
+} xRRGetOutputPropertyReq;
+#define sz_xRRGetOutputPropertyReq	28
+
+typedef struct {
+    BYTE	type;
+    CARD8	format;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    Atom	propertyType B32;
+    CARD32	bytesAfter B32;
+    CARD32	nItems B32;
+    CARD32	pad1 B32;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+} xRRGetOutputPropertyReply;
+#define sz_xRRGetOutputPropertyReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    Window	window B32;
+    xRRModeInfo	modeInfo;
+} xRRCreateModeReq; 
+#define sz_xRRCreateModeReq		40
+
+typedef struct {
+    BYTE	type;
+    CARD8	pad0;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    RRMode	mode B32;
+    CARD32	pad1 B32;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+} xRRCreateModeReply;
+#define sz_xRRCreateModeReply		32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRMode	mode B32;
+} xRRDestroyModeReq;
+#define sz_xRRDestroyModeReq		8
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    RRMode	mode B32;
+} xRRAddOutputModeReq;
+#define sz_xRRAddOutputModeReq		12
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RROutput	output B32;
+    RRMode	mode B32;
+} xRRDeleteOutputModeReq;
+#define sz_xRRDeleteOutputModeReq	12
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRCrtc	crtc B32;
+    Time	configTimestamp B32;
+} xRRGetCrtcInfoReq; 
+#define sz_xRRGetCrtcInfoReq		12
+
+typedef struct {
+    BYTE	type;
+    CARD8	status;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    Time	timestamp B32;
+    INT16	x B16;
+    INT16	y B16;
+    CARD16	width B16;
+    CARD16	height B16;
+    RRMode	mode B32;
+    Rotation	rotation B16;
+    Rotation	rotations B16;
+    CARD16	nOutput B16;
+    CARD16	nPossibleOutput B16;
+} xRRGetCrtcInfoReply;
+#define sz_xRRGetCrtcInfoReply		32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRCrtc	crtc B32;
+    Time	timestamp B32;
+    Time    	configTimestamp B32;
+    INT16	x B16;
+    INT16	y B16;
+    RRMode	mode B32;
+    Rotation	rotation B16;
+    CARD16	pad B16;
+} xRRSetCrtcConfigReq; 
+#define sz_xRRSetCrtcConfigReq		28
+
+typedef struct {
+    BYTE	type;
+    CARD8	status;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    Time	newTimestamp B32;
+    CARD32	pad1 B32;
+    CARD32	pad2 B16;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+} xRRSetCrtcConfigReply;
+#define sz_xRRSetCrtcConfigReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRCrtc	crtc B32;
+} xRRGetCrtcGammaSizeReq; 
+#define sz_xRRGetCrtcGammaSizeReq	8
+
+typedef struct {
+    BYTE	type;
+    CARD8	status;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD16	size B16;
+    CARD16	pad1 B16;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xRRGetCrtcGammaSizeReply;
+#define sz_xRRGetCrtcGammaSizeReply	32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRCrtc	crtc B32;
+} xRRGetCrtcGammaReq; 
+#define sz_xRRGetCrtcGammaReq		8
+
+typedef struct {
+    BYTE	type;
+    CARD8	status;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD16	size B16;
+    CARD16	pad1 B16;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xRRGetCrtcGammaReply;
+#define sz_xRRGetCrtcGammaReply		32
+
+typedef struct {
+    CARD8	reqType;
+    CARD8	randrReqType;
+    CARD16	length B16;
+    RRCrtc	crtc B32;
+    CARD16	size B16;
+    CARD16	pad1 B16;
+} xRRSetCrtcGammaReq;
+#define sz_xRRSetCrtcGammaReq		12
+
+/*
+ * event
+ */
+typedef struct {
+    CARD8 type;				/* always evBase + ScreenChangeNotify */
+    CARD8 rotation;			/* new rotation */
+    CARD16 sequenceNumber B16;
+    Time timestamp B32;			/* time screen was changed */
+    Time configTimestamp B32;		/* time config data was changed */
+    Window root B32;			/* root window */
+    Window window B32;			/* window requesting notification */
+    SizeID sizeID B16;			/* new size ID */
+    CARD16 subpixelOrder B16;		/* subpixel order */
+    CARD16 widthInPixels B16;		/* new size */
+    CARD16 heightInPixels B16;
+    CARD16 widthInMillimeters B16;
+    CARD16 heightInMillimeters B16;
+} xRRScreenChangeNotifyEvent;
+#define sz_xRRScreenChangeNotifyEvent	32
+
+typedef struct {
+    CARD8 type;				/* always evBase + RRNotify */
+    CARD8 subCode;			/* RRNotify_CrtcChange */
+    CARD16 sequenceNumber B16;
+    Time timestamp B32;			/* time crtc was changed */
+    Window window B32;			/* window requesting notification */
+    RRCrtc crtc B32;			/* affected CRTC */
+    RRMode mode B32;			/* current mode */
+    CARD16 rotation B16;		/* rotation and reflection */
+    CARD16 pad1 B16;			/* unused */
+    INT16 x B16;			/* new location */
+    INT16 y B16;
+    CARD16 width B16;			/* new size */
+    CARD16 height B16;
+} xRRCrtcChangeNotifyEvent;
+#define sz_xRRCrtcChangeNotifyEvent	32
+
+typedef struct {
+    CARD8 type;				/* always evBase + RRNotify */
+    CARD8 subCode;			/* RRNotify_OutputChange */
+    CARD16 sequenceNumber B16;
+    Time timestamp B32;			/* time crtc was changed */
+    Time configTimestamp B32;		/* time crtc was changed */
+    Window window B32;			/* window requesting notification */
+    RROutput output B32;		/* affected output */
+    RRCrtc crtc B32;			/* current crtc */
+    RRMode mode B32;			/* current mode */
+    CARD16 rotation B16;		/* rotation and reflection */
+    CARD8 connection;			/* connection status */
+    CARD8 subpixelOrder;		/* subpixel order */
+} xRROutputChangeNotifyEvent;
+#define sz_xRROutputChangeNotifyEvent	32
+
+typedef struct {
+    CARD8 type;				/* always evBase + RRNotify */
+    CARD8 subCode;			/* RRNotify_OutputProperty */
+    CARD16 sequenceNumber B16;
+    Window window B32;			/* window requesting notification */
+    RROutput output B32;		/* affected output */
+    Atom atom B32;			/* property name */
+    Time timestamp B32;			/* time crtc was changed */
+    CARD8 state;			/* NewValue or Deleted */
+    CARD8 pad1;
+    CARD16 pad2 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+} xRROutputPropertyNotifyEvent;
+#define sz_xRROutputPropertyNotifyEvent	32
+
+#undef RRModeFlags
+#undef RRCrtc
+#undef RRMode
+#undef RROutput
+#undef RRMode
+#undef RRCrtc
+#undef Drawable
+#undef Window
+#undef Font
+#undef Pixmap
+#undef Cursor
+#undef Colormap
+#undef GContext
+#undef Atom
+#undef Time
+#undef KeyCode
+#undef KeySym
+#undef Rotation
+#undef SizeID
+#undef SubpixelOrder
+
+#endif /* _XRANDRP_H_ */
diff --git a/nx-X11/CHANGELOG.X.original b/nx-X11/programs/Xserver/randr/randrproto.h.X.original
similarity index 100%
copy from nx-X11/CHANGELOG.X.original
copy to nx-X11/programs/Xserver/randr/randrproto.h.X.original
diff --git a/nx-X11/programs/Xserver/randr/randrstr.h b/nx-X11/programs/Xserver/randr/randrstr.h
index cd4ce38..52067b5 100644
--- a/nx-X11/programs/Xserver/randr/randrstr.h
+++ b/nx-X11/programs/Xserver/randr/randrstr.h
@@ -1,25 +1,28 @@
 /*
- * $XFree86: xc/programs/Xserver/randr/randrstr.h,v 1.5 2002/09/29 23:39:45 keithp Exp $
- *
  * Copyright &#169; 2000 Compaq Computer Corporation
+ * Copyright &#169; 2002 Hewlett-Packard Company
+ * Copyright &#169; 2006 Intel Corporation
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
- * the above copyright notice appear in all copies and that both that
- * copyright notice and this permission notice appear in supporting
- * documentation, and that the name of Compaq not be used in
- * advertising or publicity pertaining to distribution of the software without
- * specific, written prior permission.  Compaq makes no
- * representations about the suitability of this software for any purpose.  It
- * is provided &quot;as is&quot; without express or implied warranty.
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
  *
- * COMPAQ DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
- * EVENT SHALL COMPAQ BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
  * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
- * PERFORMANCE OF THIS SOFTWARE.
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ *
+ * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
+ *	    Keith Packard, Intel Corporation
  */
 
 #ifdef HAVE_DIX_CONFIG_H
@@ -29,68 +32,456 @@
 #ifndef _RANDRSTR_H_
 #define _RANDRSTR_H_
 
+#include &lt;X11/X.h&gt;
+#include &lt;X11/Xproto.h&gt;
+#include &quot;misc.h&quot;
+#include &quot;os.h&quot;
+#include &quot;dixstruct.h&quot;
+#include &quot;resource.h&quot;
+#include &quot;scrnintstr.h&quot;
+#include &quot;windowstr.h&quot;
+#include &quot;pixmapstr.h&quot;
+#include &quot;extnsionst.h&quot;
+#include &quot;servermd.h&quot;
+#ifndef NXAGENT_SERVER
 #include &lt;X11/extensions/randr.h&gt;
+#include &lt;X11/extensions/randrproto.h&gt;
+#else
+#include &quot;randr.h&quot;
+#include &quot;randrproto.h&quot;
+#endif
+#ifdef RENDER
+#include &lt;X11/extensions/render.h&gt; 	/* we share subpixel order information */
+#include &quot;picturestr.h&quot;
+#endif
+#include &lt;X11/Xfuncproto.h&gt;
+
+/* required for ABI compatibility for now */
+#define RANDR_10_INTERFACE 1
+#define RANDR_12_INTERFACE 1
+
+typedef XID	RRMode;
+typedef XID	RROutput;
+typedef XID	RRCrtc;
+
+extern int	RREventBase, RRErrorBase;
+
+extern int (*ProcRandrVector[RRNumberRequests])(ClientPtr);
+extern int (*SProcRandrVector[RRNumberRequests])(ClientPtr);
+    
+/*
+ * Modeline for a monitor. Name follows directly after this struct
+ */
+
+#define RRModeName(pMode) ((char *) (pMode + 1))
+typedef struct _rrMode		RRModeRec, *RRModePtr;
+typedef struct _rrPropertyValue	RRPropertyValueRec, *RRPropertyValuePtr;
+typedef struct _rrProperty	RRPropertyRec, *RRPropertyPtr;
+typedef struct _rrCrtc		RRCrtcRec, *RRCrtcPtr;
+typedef struct _rrOutput	RROutputRec, *RROutputPtr;
+
+struct _rrMode {
+    int		    refcnt;
+    xRRModeInfo	    mode;
+    char	    *name;
+    ScreenPtr	    userScreen;
+};
+
+struct _rrPropertyValue {
+    Atom	    type;       /* ignored by server */
+    short	    format;     /* format of data for swapping - 8,16,32 */
+    long	    size;	/* size of data in (format/8) bytes */
+    pointer         data;	/* private to client */
+};
+
+struct _rrProperty {
+    RRPropertyPtr   next;
+    ATOM 	    propertyName;
+    Bool	    is_pending;
+    Bool	    range;
+    Bool	    immutable;
+    int		    num_valid;
+    INT32	    *valid_values;
+    RRPropertyValueRec	current, pending;
+};
+
+struct _rrCrtc {
+    RRCrtc	    id;
+    ScreenPtr	    pScreen;
+    RRModePtr	    mode;
+    int		    x, y;
+    Rotation	    rotation;
+    Rotation	    rotations;
+    Bool	    changed;
+    int		    numOutputs;
+    RROutputPtr	    *outputs;
+    int		    gammaSize;
+    CARD16	    *gammaRed;
+    CARD16	    *gammaBlue;
+    CARD16	    *gammaGreen;
+    void	    *devPrivate;
+};
+
+struct _rrOutput {
+    RROutput	    id;
+    ScreenPtr	    pScreen;
+    char	    *name;
+    int		    nameLength;
+    CARD8	    connection;
+    CARD8	    subpixelOrder;
+    int		    mmWidth;
+    int		    mmHeight;
+    RRCrtcPtr	    crtc;
+    int		    numCrtcs;
+    RRCrtcPtr	    *crtcs;
+    int		    numClones;
+    RROutputPtr	    *clones;
+    int		    numModes;
+    int		    numPreferred;
+    RRModePtr	    *modes;
+    int		    numUserModes;
+    RRModePtr	    *userModes;
+    Bool	    changed;
+    RRPropertyPtr   properties;
+    Bool	    pendingProperties;
+    void	    *devPrivate;
+};
+
+#if RANDR_12_INTERFACE
+typedef Bool (*RRScreenSetSizeProcPtr) (ScreenPtr	pScreen,
+					CARD16		width,
+					CARD16		height,
+					CARD32		mmWidth,
+					CARD32		mmHeight);
+					
+typedef Bool (*RRCrtcSetProcPtr) (ScreenPtr		pScreen,
+				  RRCrtcPtr		crtc,
+				  RRModePtr		mode,
+				  int			x,
+				  int			y,
+				  Rotation		rotation,
+				  int			numOutputs,
+				  RROutputPtr		*outputs);
+
+typedef Bool (*RRCrtcSetGammaProcPtr) (ScreenPtr	pScreen,
+				       RRCrtcPtr	crtc);
 
-typedef struct _rrScreenRate {
-    int		    rate;
-    Bool	    referenced;
-    Bool	    oldReferenced;
+typedef Bool (*RROutputSetPropertyProcPtr) (ScreenPtr		pScreen,
+					    RROutputPtr		output,
+					    Atom		property,
+					    RRPropertyValuePtr	value);
+
+typedef Bool (*RROutputValidateModeProcPtr) (ScreenPtr		pScreen,
+					     RROutputPtr	output,
+					     RRModePtr		mode);
+
+typedef void (*RRModeDestroyProcPtr) (ScreenPtr	    pScreen,
+				      RRModePtr	    mode);
+
+#endif
+
+typedef Bool (*RRGetInfoProcPtr) (ScreenPtr pScreen, Rotation *rotations);
+typedef Bool (*RRCloseScreenProcPtr) ( int i, ScreenPtr pscreen);
+
+/* These are for 1.0 compatibility */
+ 
+typedef struct _rrRefresh {
+    CARD16	    rate;
+    RRModePtr	    mode;
 } RRScreenRate, *RRScreenRatePtr;
 
 typedef struct _rrScreenSize {
     int		    id;
     short	    width, height;
     short	    mmWidth, mmHeight;
-    RRScreenRatePtr pRates;
     int		    nRates;
-    int		    nRatesInUse;
-    Bool	    referenced;
-    Bool	    oldReferenced;
+    RRScreenRatePtr pRates;
 } RRScreenSize, *RRScreenSizePtr;
 
+#ifdef RANDR_10_INTERFACE
+
 typedef Bool (*RRSetConfigProcPtr) (ScreenPtr		pScreen,
 				    Rotation		rotation,
 				    int			rate,
 				    RRScreenSizePtr	pSize);
 
-typedef Bool (*RRGetInfoProcPtr) (ScreenPtr pScreen, Rotation *rotations);
-typedef Bool (*RRCloseScreenProcPtr) ( int i, ScreenPtr pscreen);
+#endif
 	
+
 typedef struct _rrScrPriv {
+    /*
+     * 'public' part of the structure; DDXen fill this in
+     * as they initialize
+     */
+#if RANDR_10_INTERFACE
     RRSetConfigProcPtr	    rrSetConfig;
+#endif
     RRGetInfoProcPtr	    rrGetInfo;
+#if RANDR_12_INTERFACE
+    RRScreenSetSizeProcPtr  rrScreenSetSize;
+    RRCrtcSetProcPtr	    rrCrtcSet;
+    RRCrtcSetGammaProcPtr   rrCrtcSetGamma;
+    RROutputSetPropertyProcPtr	rrOutputSetProperty;
+    RROutputValidateModeProcPtr	rrOutputValidateMode;
+    RRModeDestroyProcPtr	rrModeDestroy;
+#endif
     
+    /*
+     * Private part of the structure; not considered part of the ABI
+     */
     TimeStamp		    lastSetTime;	/* last changed by client */
     TimeStamp		    lastConfigTime;	/* possible configs changed */
     RRCloseScreenProcPtr    CloseScreen;
 
+    Bool		    changed;		/* some config changed */
+    Bool		    configChanged;	/* configuration changed */
+    Bool		    layoutChanged;	/* screen layout changed */
+
+    CARD16		    minWidth, minHeight;
+    CARD16		    maxWidth, maxHeight;
+    CARD16		    width, height;	/* last known screen size */
+    CARD16		    mmWidth, mmHeight;	/* last known screen size */
+
+    int			    numOutputs;
+    RROutputPtr		    *outputs;
+
+    int			    numCrtcs;
+    RRCrtcPtr		    *crtcs;
+
+    /* Last known pointer position */
+    RRCrtcPtr		    pointerCrtc;
+
+#ifdef RANDR_10_INTERFACE
     /*
      * Configuration information
      */
     Rotation		    rotations;
+    CARD16		    reqWidth, reqHeight;
     
     int			    nSizes;
-    int			    nSizesInUse;
     RRScreenSizePtr	    pSizes;
-
-    /*
-     * Current state
-     */
+    
     Rotation		    rotation;
-    int			    size;
     int			    rate;
+    int			    size;
+#endif
 } rrScrPrivRec, *rrScrPrivPtr;
 
+#ifndef NXAGENT_SERVER
+extern DevPrivateKey rrPrivKey;
+#else
 extern int rrPrivIndex;
+#endif
+
+#ifndef NXAGENT_SERVER
+
+#define rrGetScrPriv(pScr)  ((rrScrPrivPtr)dixLookupPrivate(&amp;(pScr)-&gt;devPrivates, rrPrivKey))
+#define rrScrPriv(pScr)	rrScrPrivPtr    pScrPriv = rrGetScrPriv(pScr)
+#define SetRRScreen(s,p) dixSetPrivate(&amp;(s)-&gt;devPrivates, rrPrivKey, p)
+
+#else
 
 #define rrGetScrPriv(pScr)  ((rrScrPrivPtr) (pScr)-&gt;devPrivates[rrPrivIndex].ptr)
 #define rrScrPriv(pScr)	rrScrPrivPtr    pScrPriv = rrGetScrPriv(pScr)
 #define SetRRScreen(s,p) ((s)-&gt;devPrivates[rrPrivIndex].ptr = (pointer) (p))
 
+#endif
+
+/*
+ * each window has a list of clients requesting
+ * RRNotify events.  Each client has a resource
+ * for each window it selects RRNotify input for,
+ * this resource is used to delete the RRNotifyRec
+ * entry from the per-window queue.
+ */
+
+typedef struct _RREvent *RREventPtr;
+
+typedef struct _RREvent {
+    RREventPtr  next;
+    ClientPtr	client;
+    WindowPtr	window;
+    XID		clientResource;
+    int		mask;
+} RREventRec;
+
+typedef struct _RRTimes {
+    TimeStamp	setTime;
+    TimeStamp	configTime;
+} RRTimesRec, *RRTimesPtr;
+
+typedef struct _RRClient {
+    int		major_version;
+    int		minor_version;
+/*  RRTimesRec	times[0]; */
+} RRClientRec, *RRClientPtr;
+
+extern RESTYPE	RRClientType, RREventType; /* resource types for event masks */
+#ifndef NXAGENT_SERVER
+extern DevPrivateKey RRClientPrivateKey;
+#else
+extern int	RRClientPrivateIndex;
+#endif
+extern RESTYPE	RRCrtcType, RRModeType, RROutputType;
+
+#define LookupOutput(client,id,a) ((RROutputPtr) \
+				   (SecurityLookupIDByType (client, id, \
+							    RROutputType, a)))
+#define LookupCrtc(client,id,a) ((RRCrtcPtr) \
+				 (SecurityLookupIDByType (client, id, \
+							  RRCrtcType, a)))
+#define LookupMode(client,id,a) ((RRModePtr) \
+				 (SecurityLookupIDByType (client, id, \
+							  RRModeType, a)))
+#ifndef NXAGENT_SERVER
+
+#define GetRRClient(pClient)    ((RRClientPtr)dixLookupPrivate(&amp;(pClient)-&gt;devPrivates, RRClientPrivateKey))
+#define rrClientPriv(pClient)	RRClientPtr pRRClient = GetRRClient(pClient)
+
+#else
+
+#define GetRRClient(pClient)    ((RRClientPtr) (pClient)-&gt;devPrivates[RRClientPrivateIndex].ptr)
+#define rrClientPriv(pClient)	RRClientPtr pRRClient = GetRRClient(pClient)
+
+#define DixUnknownAccess     SecurityUnknownAccess
+#define DixReadAccess        SecurityReadAccess   
+#define DixWriteAccess       SecurityWriteAccess  
+#define DixDestroyAccess     SecurityDestroyAccess
+
+#endif
+
 /* Initialize the extension */
 void
 RRExtensionInit (void);
 
+#ifdef RANDR_12_INTERFACE
+/*
+ * Set the range of sizes for the screen
+ */
+void
+RRScreenSetSizeRange (ScreenPtr	pScreen,
+		      CARD16	minWidth,
+		      CARD16	minHeight,
+		      CARD16	maxWidth,
+		      CARD16	maxHeight);
+#endif
+
+/* rrscreen.c */
+/*
+ * Notify the extension that the screen size has been changed.
+ * The driver is responsible for calling this whenever it has changed
+ * the size of the screen
+ */
+void
+RRScreenSizeNotify (ScreenPtr	pScreen);
+
+/*
+ * Request that the screen be resized
+ */
+Bool
+RRScreenSizeSet (ScreenPtr  pScreen,
+		 CARD16	    width,
+		 CARD16	    height,
+		 CARD32	    mmWidth,
+		 CARD32	    mmHeight);
+
+/*
+ * Send ConfigureNotify event to root window when 'something' happens
+ */
+void
+RRSendConfigNotify (ScreenPtr pScreen);
+    
+/*
+ * screen dispatch
+ */
+int 
+ProcRRGetScreenSizeRange (ClientPtr client);
+
+int
+ProcRRSetScreenSize (ClientPtr client);
+
+int
+ProcRRGetScreenResources (ClientPtr client);
+
+int
+ProcRRSetScreenConfig (ClientPtr client);
+
+int
+ProcRRGetScreenInfo (ClientPtr client);
+
+/*
+ * Deliver a ScreenNotify event
+ */
+void
+RRDeliverScreenEvent (ClientPtr client, WindowPtr pWin, ScreenPtr pScreen);
+    
+/* mirandr.c */
+Bool
+miRandRInit (ScreenPtr pScreen);
+
+Bool
+miRRGetInfo (ScreenPtr pScreen, Rotation *rotations);
+
+Bool
+miRRGetScreenInfo (ScreenPtr pScreen);
+
+Bool
+miRRCrtcSet (ScreenPtr	pScreen,
+	     RRCrtcPtr	crtc,
+	     RRModePtr	mode,
+	     int	x,
+	     int	y,
+	     Rotation	rotation,
+	     int	numOutput,
+	     RROutputPtr *outputs);
+
+Bool
+miRROutputSetProperty (ScreenPtr	    pScreen,
+		       RROutputPtr	    output,
+		       Atom		    property,
+		       RRPropertyValuePtr   value);
+
+Bool
+miRROutputValidateMode (ScreenPtr	    pScreen,
+			RROutputPtr	    output,
+			RRModePtr	    mode);
+
+void
+miRRModeDestroy (ScreenPtr  pScreen,
+		 RRModePtr  mode);
+
+/* randr.c */
+/*
+ * Send all pending events
+ */
+void
+RRTellChanged (ScreenPtr pScreen);
+
+/*
+ * Poll the driver for changed information
+ */
+Bool
+RRGetInfo (ScreenPtr pScreen);
+
+Bool RRInit (void);
+
+Bool RRScreenInit(ScreenPtr pScreen);
+
+RROutputPtr
+RRFirstOutput (ScreenPtr pScreen);
+
+Rotation
+RRGetRotation (ScreenPtr pScreen);
+
+CARD16
+RRVerticalRefresh (xRRModeInfo *mode);
+
+#ifdef RANDR_10_INTERFACE					
+/*
+ * This is the old interface, deprecated but left
+ * around for compatibility
+ */
+
 /*
  * Then, register the specific size with the screen
  */
@@ -116,7 +507,10 @@ RRSetCurrentConfig (ScreenPtr		pScreen,
 		    int			rate,
 		    RRScreenSizePtr	pSize);
 
-Bool RRScreenInit(ScreenPtr pScreen);
+Bool RRScreenInit (ScreenPtr pScreen);
+
+Rotation
+RRGetRotation (ScreenPtr pScreen);
 
 int
 RRSetScreenConfig (ScreenPtr		pScreen,
@@ -124,19 +518,371 @@ RRSetScreenConfig (ScreenPtr		pScreen,
 		   int			rate,
 		   RRScreenSizePtr	pSize);
 
+#endif					
+
+/* rrcrtc.c */
+
+/*
+ * Notify the CRTC of some change; layoutChanged indicates that
+ * some position or size element changed
+ */
+void
+RRCrtcChanged (RRCrtcPtr crtc, Bool layoutChanged);
+
+/*
+ * Create a CRTC
+ */
+RRCrtcPtr
+RRCrtcCreate (ScreenPtr pScreen, void	*devPrivate);
+
+/*
+ * Set the allowed rotations on a CRTC
+ */
+void
+RRCrtcSetRotations (RRCrtcPtr crtc, Rotation rotations);
+
+/*
+ * Notify the extension that the Crtc has been reconfigured,
+ * the driver calls this whenever it has updated the mode
+ */
 Bool
-miRandRInit (ScreenPtr pScreen);
+RRCrtcNotify (RRCrtcPtr	    crtc,
+	      RRModePtr	    mode,
+	      int	    x,
+	      int	    y,
+	      Rotation	    rotation,
+	      int	    numOutputs,
+	      RROutputPtr   *outputs);
 
+void
+RRDeliverCrtcEvent (ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc);
+    
+/*
+ * Request that the Crtc be reconfigured
+ */
 Bool
-miRRGetInfo (ScreenPtr pScreen, Rotation *rotations);
+RRCrtcSet (RRCrtcPtr    crtc,
+	   RRModePtr	mode,
+	   int		x,
+	   int		y,
+	   Rotation	rotation,
+	   int		numOutput,
+	   RROutputPtr  *outputs);
+
+/*
+ * Request that the Crtc gamma be changed
+ */
 
 Bool
-miRRSetConfig (ScreenPtr	pScreen,
-	       Rotation		rotation,
-	       int		rate,
-	       RRScreenSizePtr	size);
+RRCrtcGammaSet (RRCrtcPtr   crtc,
+		CARD16	    *red,
+		CARD16	    *green,
+		CARD16	    *blue);
+
+/*
+ * Notify the extension that the Crtc gamma has been changed
+ * The driver calls this whenever it has changed the gamma values
+ * in the RRCrtcRec
+ */
 
 Bool
-miRRGetScreenInfo (ScreenPtr pScreen);
+RRCrtcGammaNotify (RRCrtcPtr	crtc);
+
+/*
+ * Set the size of the gamma table at server startup time
+ */
+
+Bool
+RRCrtcGammaSetSize (RRCrtcPtr	crtc,
+		    int		size);
+
+/*
+ * Return the area of the frame buffer scanned out by the crtc,
+ * taking into account the current mode and rotation
+ */
+
+void
+RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height);
+
+/*
+ * Destroy a Crtc at shutdown
+ */
+void
+RRCrtcDestroy (RRCrtcPtr crtc);
+
+/*
+ * Initialize crtc type
+ */
+Bool
+RRCrtcInit (void);
+
+/*
+ * Crtc dispatch
+ */
+
+int
+ProcRRGetCrtcInfo (ClientPtr client);
+
+int
+ProcRRSetCrtcConfig (ClientPtr client);
+
+int
+ProcRRGetCrtcGammaSize (ClientPtr client);
+
+int
+ProcRRGetCrtcGamma (ClientPtr client);
+
+int
+ProcRRSetCrtcGamma (ClientPtr client);
+
+/* rrdispatch.c */
+Bool
+RRClientKnowsRates (ClientPtr	pClient);
+
+/* rrmode.c */
+/*
+ * Find, and if necessary, create a mode
+ */
+
+RRModePtr
+RRModeGet (xRRModeInfo	*modeInfo,
+	   const char	*name);
+
+void
+RRModePruneUnused (ScreenPtr pScreen);
+
+/*
+ * Destroy a mode.
+ */
+
+void
+RRModeDestroy (RRModePtr mode);
+
+/*
+ * Return a list of modes that are valid for some output in pScreen
+ */
+RRModePtr *
+RRModesForScreen (ScreenPtr pScreen, int *num_ret);
+    
+/*
+ * Initialize mode type
+ */
+Bool
+RRModeInit (void);
+    
+int
+ProcRRCreateMode (ClientPtr client);
+
+int
+ProcRRDestroyMode (ClientPtr client);
+
+int
+ProcRRAddOutputMode (ClientPtr client);
+
+int
+ProcRRDeleteOutputMode (ClientPtr client);
+
+/* rroutput.c */
+
+/*
+ * Notify the output of some change. configChanged indicates whether
+ * any external configuration (mode list, clones, connected status)
+ * has changed, or whether the change was strictly internal
+ * (which crtc is in use)
+ */
+void
+RROutputChanged (RROutputPtr output, Bool configChanged);
+
+/*
+ * Create an output
+ */
+
+RROutputPtr
+RROutputCreate (ScreenPtr   pScreen,
+		const char  *name,
+		int	    nameLength,
+		void	    *devPrivate);
+
+/*
+ * Notify extension that output parameters have been changed
+ */
+Bool
+RROutputSetClones (RROutputPtr  output,
+		   RROutputPtr  *clones,
+		   int		numClones);
+
+Bool
+RROutputSetModes (RROutputPtr	output,
+		  RRModePtr	*modes,
+		  int		numModes,
+		  int		numPreferred);
+
+int
+RROutputAddUserMode (RROutputPtr    output,
+		     RRModePtr	    mode);
+
+int
+RROutputDeleteUserMode (RROutputPtr output,
+			RRModePtr   mode);
+
+Bool
+RROutputSetCrtcs (RROutputPtr	output,
+		  RRCrtcPtr	*crtcs,
+		  int		numCrtcs);
+
+Bool
+RROutputSetConnection (RROutputPtr  output,
+		       CARD8	    connection);
+
+Bool
+RROutputSetSubpixelOrder (RROutputPtr output,
+			  int	      subpixelOrder);
+
+Bool
+RROutputSetPhysicalSize (RROutputPtr	output,
+			 int		mmWidth,
+			 int		mmHeight);
+
+void
+RRDeliverOutputEvent(ClientPtr client, WindowPtr pWin, RROutputPtr output);
+
+void
+RROutputDestroy (RROutputPtr	output);
+
+int
+ProcRRGetOutputInfo (ClientPtr client);
+
+/*
+ * Initialize output type
+ */
+Bool
+RROutputInit (void);
+    
+/* rrpointer.c */
+void
+RRPointerMoved (ScreenPtr pScreen, int x, int y);
+
+void
+RRPointerScreenConfigured (ScreenPtr pScreen);
+
+/* rrproperty.c */
+
+void
+RRDeleteAllOutputProperties (RROutputPtr output);
+
+RRPropertyValuePtr
+RRGetOutputProperty (RROutputPtr output, Atom property, Bool pending);
+
+RRPropertyPtr
+RRQueryOutputProperty (RROutputPtr output, Atom property);
+		       
+void
+RRDeleteOutputProperty (RROutputPtr output, Atom property);
+
+Bool
+RRPostPendingProperties (RROutputPtr output);
+    
+int
+RRChangeOutputProperty (RROutputPtr output, Atom property, Atom type,
+			int format, int mode, unsigned long len,
+			pointer value, Bool sendevent, Bool pending);
+
+int
+RRConfigureOutputProperty (RROutputPtr output, Atom property,
+			   Bool pending, Bool range, Bool immutable,
+			   int num_values, INT32 *values);
+int
+ProcRRChangeOutputProperty (ClientPtr client);
+
+int
+ProcRRGetOutputProperty (ClientPtr client);
+
+int
+ProcRRListOutputProperties (ClientPtr client);
+
+int
+ProcRRQueryOutputProperty (ClientPtr client);
+
+int
+ProcRRConfigureOutputProperty (ClientPtr client);
+
+int
+ProcRRDeleteOutputProperty (ClientPtr client);
+
+/* rrxinerama.c */
+void
+RRXineramaExtensionInit(void);
 
 #endif /* _RANDRSTR_H_ */
+
+/*
+ 
+randr extension implementation structure
+
+Query state:
+    ProcRRGetScreenInfo/ProcRRGetScreenResources
+	RRGetInfo
+ 
+	    &#8226; Request configuration from driver, either 1.0 or 1.2 style
+	    &#8226; These functions only record state changes, all
+	      other actions are pended until RRTellChanged is called
+ 
+	    -&gt;rrGetInfo
+	    1.0:
+		RRRegisterSize
+		RRRegisterRate
+		RRSetCurrentConfig
+	    1.2:
+		RRScreenSetSizeRange
+		RROutputSetCrtcs
+		RRModeGet
+		RROutputSetModes
+		RROutputSetConnection
+		RROutputSetSubpixelOrder
+		RROutputSetClones
+		RRCrtcNotify
+ 
+	&#8226; Must delay scanning configuration until after -&gt;rrGetInfo returns
+	  because some drivers will call SetCurrentConfig in the middle
+	  of the -&gt;rrGetInfo operation.
+ 
+	1.0:
+
+	    &#8226; Scan old configuration, mirror to new structures
+ 
+	    RRScanOldConfig
+		RRCrtcCreate
+		RROutputCreate
+		RROutputSetCrtcs
+		RROutputSetConnection
+		RROutputSetSubpixelOrder
+		RROldModeAdd	&#8226; This adds modes one-at-a-time
+		    RRModeGet
+		RRCrtcNotify
+ 
+	&#8226; send events, reset pointer if necessary
+ 
+	RRTellChanged
+	    WalkTree (sending events)
+ 
+	    &#8226; when layout has changed:
+		RRPointerScreenConfigured
+		RRSendConfigNotify
+ 
+Asynchronous state setting (1.2 only)
+    When setting state asynchronously, the driver invokes the
+    -&gt;rrGetInfo function and then calls RRTellChanged to flush
+    the changes to the clients and reset pointer if necessary
+
+Set state
+
+    ProcRRSetScreenConfig
+	RRCrtcSet
+	    1.2:
+		-&gt;rrCrtcSet
+		    RRCrtcNotify
+	    1.0:
+		-&gt;rrSetConfig
+		RRCrtcNotify
+	    RRTellChanged
+ */
diff --git a/nx-X11/programs/Xserver/randr/registry.h b/nx-X11/programs/Xserver/randr/registry.h
new file mode 100644
index 0000000..29e5fdf
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/registry.h
@@ -0,0 +1,64 @@
+/***********************************************************
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIX_REGISTRY_H
+#define DIX_REGISTRY_H
+
+/*
+ * Result returned from any unsuccessful lookup
+ */
+#define XREGISTRY_UNKNOWN &quot;&lt;unknown&gt;&quot;
+
+#ifdef XREGISTRY
+
+#include &quot;resource.h&quot;
+#include &quot;extnsionst.h&quot;
+
+/* Internal string registry - for auditing, debugging, security, etc. */
+
+/*
+ * Registration functions.  The name string is not copied, so it must
+ * not be a stack variable.
+ */
+void RegisterResourceName(RESTYPE type, char *name);
+void RegisterExtensionNames(ExtensionEntry *ext);
+
+/*
+ * Lookup functions.  The returned string must not be modified or freed.
+ */
+const char *LookupMajorName(int major);
+const char *LookupRequestName(int major, int minor);
+const char *LookupEventName(int event);
+const char *LookupErrorName(int error);
+const char *LookupResourceName(RESTYPE rtype);
+
+/*
+ * Setup and teardown
+ */
+void dixResetRegistry(void);
+
+#else /* XREGISTRY */
+
+/* Define calls away when the registry is not being built. */
+
+#define RegisterResourceName(a, b) { ; }
+#define RegisterExtensionNames(a) { ; }
+
+#define LookupMajorName(a) XREGISTRY_UNKNOWN
+#define LookupRequestName(a, b) XREGISTRY_UNKNOWN
+#define LookupEventName(a) XREGISTRY_UNKNOWN
+#define LookupErrorName(a) XREGISTRY_UNKNOWN
+#define LookupResourceName(a) XREGISTRY_UNKNOWN
+
+#define dixResetRegistry() { ; }
+
+#endif /* XREGISTRY */
+#endif /* DIX_REGISTRY_H */
diff --git a/nx-X11/programs/Xserver/randr/registry.h.NX.original b/nx-X11/programs/Xserver/randr/registry.h.NX.original
new file mode 100644
index 0000000..29e5fdf
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/registry.h.NX.original
@@ -0,0 +1,64 @@
+/***********************************************************
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIX_REGISTRY_H
+#define DIX_REGISTRY_H
+
+/*
+ * Result returned from any unsuccessful lookup
+ */
+#define XREGISTRY_UNKNOWN &quot;&lt;unknown&gt;&quot;
+
+#ifdef XREGISTRY
+
+#include &quot;resource.h&quot;
+#include &quot;extnsionst.h&quot;
+
+/* Internal string registry - for auditing, debugging, security, etc. */
+
+/*
+ * Registration functions.  The name string is not copied, so it must
+ * not be a stack variable.
+ */
+void RegisterResourceName(RESTYPE type, char *name);
+void RegisterExtensionNames(ExtensionEntry *ext);
+
+/*
+ * Lookup functions.  The returned string must not be modified or freed.
+ */
+const char *LookupMajorName(int major);
+const char *LookupRequestName(int major, int minor);
+const char *LookupEventName(int event);
+const char *LookupErrorName(int error);
+const char *LookupResourceName(RESTYPE rtype);
+
+/*
+ * Setup and teardown
+ */
+void dixResetRegistry(void);
+
+#else /* XREGISTRY */
+
+/* Define calls away when the registry is not being built. */
+
+#define RegisterResourceName(a, b) { ; }
+#define RegisterExtensionNames(a) { ; }
+
+#define LookupMajorName(a) XREGISTRY_UNKNOWN
+#define LookupRequestName(a, b) XREGISTRY_UNKNOWN
+#define LookupEventName(a) XREGISTRY_UNKNOWN
+#define LookupErrorName(a) XREGISTRY_UNKNOWN
+#define LookupResourceName(a) XREGISTRY_UNKNOWN
+
+#define dixResetRegistry() { ; }
+
+#endif /* XREGISTRY */
+#endif /* DIX_REGISTRY_H */
diff --git a/nx-X11/CHANGELOG.X.original b/nx-X11/programs/Xserver/randr/registry.h.X.original
similarity index 100%
copy from nx-X11/CHANGELOG.X.original
copy to nx-X11/programs/Xserver/randr/registry.h.X.original
diff --git a/nx-X11/programs/Xserver/randr/rrcrtc.c b/nx-X11/programs/Xserver/randr/rrcrtc.c
new file mode 100644
index 0000000..fb82a80
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrcrtc.c
@@ -0,0 +1,984 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &quot;randrstr.h&quot;
+#include &quot;swaprep.h&quot;
+#include &quot;registry.h&quot;
+
+RESTYPE	RRCrtcType;
+
+/*
+ * Notify the CRTC of some change
+ */
+void
+RRCrtcChanged (RRCrtcPtr crtc, Bool layoutChanged)
+{
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+
+    crtc-&gt;changed = TRUE;
+    if (pScreen)
+    {
+	rrScrPriv(pScreen);
+    
+	pScrPriv-&gt;changed = TRUE;
+	/*
+	 * Send ConfigureNotify on any layout change
+	 */
+	if (layoutChanged)
+	    pScrPriv-&gt;layoutChanged = TRUE;
+    }
+}
+
+/*
+ * Create a CRTC
+ */
+RRCrtcPtr
+RRCrtcCreate (ScreenPtr pScreen, void *devPrivate)
+{
+    RRCrtcPtr	    crtc;
+    RRCrtcPtr	    *crtcs;
+    rrScrPrivPtr    pScrPriv;
+
+    if (!RRInit())
+	return NULL;
+    
+    pScrPriv = rrGetScrPriv(pScreen);
+
+    /* make space for the crtc pointer */
+    if (pScrPriv-&gt;numCrtcs)
+	crtcs = xrealloc (pScrPriv-&gt;crtcs, 
+			  (pScrPriv-&gt;numCrtcs + 1) * sizeof (RRCrtcPtr));
+    else
+	crtcs = xalloc (sizeof (RRCrtcPtr));
+    if (!crtcs)
+	return FALSE;
+    pScrPriv-&gt;crtcs = crtcs;
+    
+    crtc = xcalloc (1, sizeof (RRCrtcRec));
+    if (!crtc)
+	return NULL;
+    crtc-&gt;id = FakeClientID (0);
+    crtc-&gt;pScreen = pScreen;
+    crtc-&gt;mode = NULL;
+    crtc-&gt;x = 0;
+    crtc-&gt;y = 0;
+    crtc-&gt;rotation = RR_Rotate_0;
+    crtc-&gt;rotations = RR_Rotate_0;
+    crtc-&gt;outputs = NULL;
+    crtc-&gt;numOutputs = 0;
+    crtc-&gt;gammaSize = 0;
+    crtc-&gt;gammaRed = crtc-&gt;gammaBlue = crtc-&gt;gammaGreen = NULL;
+    crtc-&gt;changed = FALSE;
+    crtc-&gt;devPrivate = devPrivate;
+
+    if (!AddResource (crtc-&gt;id, RRCrtcType, (pointer) crtc))
+	return NULL;
+
+    /* attach the screen and crtc together */
+    crtc-&gt;pScreen = pScreen;
+    pScrPriv-&gt;crtcs[pScrPriv-&gt;numCrtcs++] = crtc;
+    
+    return crtc;
+}
+
+/*
+ * Set the allowed rotations on a CRTC
+ */
+void
+RRCrtcSetRotations (RRCrtcPtr crtc, Rotation rotations)
+{
+    crtc-&gt;rotations = rotations;
+}
+
+/*
+ * Notify the extension that the Crtc has been reconfigured,
+ * the driver calls this whenever it has updated the mode
+ */
+Bool
+RRCrtcNotify (RRCrtcPtr	    crtc,
+	      RRModePtr	    mode,
+	      int	    x,
+	      int	    y,
+	      Rotation	    rotation,
+	      int	    numOutputs,
+	      RROutputPtr   *outputs)
+{
+    int	    i, j;
+    
+    /*
+     * Check to see if any of the new outputs were
+     * not in the old list and mark them as changed
+     */
+    for (i = 0; i &lt; numOutputs; i++)
+    {
+	for (j = 0; j &lt; crtc-&gt;numOutputs; j++)
+	    if (outputs[i] == crtc-&gt;outputs[j])
+		break;
+	if (j == crtc-&gt;numOutputs)
+	{
+	    outputs[i]-&gt;crtc = crtc;
+	    RROutputChanged (outputs[i], FALSE);
+	    RRCrtcChanged (crtc, FALSE);
+	}
+    }
+    /*
+     * Check to see if any of the old outputs are
+     * not in the new list and mark them as changed
+     */
+    for (j = 0; j &lt; crtc-&gt;numOutputs; j++)
+    {
+	for (i = 0; i &lt; numOutputs; i++)
+	    if (outputs[i] == crtc-&gt;outputs[j])
+		break;
+	if (i == numOutputs)
+	{
+	    if (crtc-&gt;outputs[j]-&gt;crtc == crtc)
+		crtc-&gt;outputs[j]-&gt;crtc = NULL;
+	    RROutputChanged (crtc-&gt;outputs[j], FALSE);
+	    RRCrtcChanged (crtc, FALSE);
+	}
+    }
+    /*
+     * Reallocate the crtc output array if necessary
+     */
+    if (numOutputs != crtc-&gt;numOutputs)
+    {
+	RROutputPtr *newoutputs;
+	
+	if (numOutputs)
+	{
+	    if (crtc-&gt;numOutputs)
+		newoutputs = xrealloc (crtc-&gt;outputs,
+				    numOutputs * sizeof (RROutputPtr));
+	    else
+		newoutputs = xalloc (numOutputs * sizeof (RROutputPtr));
+	    if (!newoutputs)
+		return FALSE;
+	}
+	else
+	{
+	    if (crtc-&gt;outputs)
+		xfree (crtc-&gt;outputs);
+	    newoutputs = NULL;
+	}
+	crtc-&gt;outputs = newoutputs;
+	crtc-&gt;numOutputs = numOutputs;
+    }
+    /*
+     * Copy the new list of outputs into the crtc
+     */
+    memcpy (crtc-&gt;outputs, outputs, numOutputs * sizeof (RROutputPtr));
+    /*
+     * Update remaining crtc fields
+     */
+    if (mode != crtc-&gt;mode)
+    {
+	if (crtc-&gt;mode)
+	    RRModeDestroy (crtc-&gt;mode);
+	crtc-&gt;mode = mode;
+	if (mode != NULL)
+	    mode-&gt;refcnt++;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    if (x != crtc-&gt;x)
+    {
+	crtc-&gt;x = x;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    if (y != crtc-&gt;y)
+    {
+	crtc-&gt;y = y;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    if (rotation != crtc-&gt;rotation)
+    {
+	crtc-&gt;rotation = rotation;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    return TRUE;
+}
+
+void
+RRDeliverCrtcEvent (ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc)
+{
+    ScreenPtr pScreen = pWin-&gt;drawable.pScreen;
+    rrScrPriv (pScreen);
+    xRRCrtcChangeNotifyEvent	ce;
+    RRModePtr	mode = crtc-&gt;mode;
+    
+    ce.type = RRNotify + RREventBase;
+    ce.subCode = RRNotify_CrtcChange;
+    ce.sequenceNumber = client-&gt;sequence;
+    ce.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    ce.window = pWin-&gt;drawable.id;
+    ce.crtc = crtc-&gt;id;
+    ce.rotation = crtc-&gt;rotation;
+    if (mode)
+    {
+	ce.mode = mode-&gt;mode.id;
+	ce.x = crtc-&gt;x;
+	ce.y = crtc-&gt;y;
+	ce.width = mode-&gt;mode.width;
+	ce.height = mode-&gt;mode.height;
+    }
+    else
+    {
+	ce.mode = None;
+	ce.x = 0;
+	ce.y = 0;
+	ce.width = 0;
+	ce.height = 0;
+    }
+    WriteEventsToClient (client, 1, (xEvent *) &amp;ce);
+}
+
+static Bool
+RRCrtcPendingProperties (RRCrtcPtr crtc)
+{
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+    rrScrPriv(pScreen);
+    int		o;
+
+    for (o = 0; o &lt; pScrPriv-&gt;numOutputs; o++)
+    {
+	RROutputPtr output = pScrPriv-&gt;outputs[o];
+	if (output-&gt;crtc == crtc &amp;&amp; output-&gt;pendingProperties)
+	    return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * Request that the Crtc be reconfigured
+ */
+Bool
+RRCrtcSet (RRCrtcPtr    crtc,
+	   RRModePtr	mode,
+	   int		x,
+	   int		y,
+	   Rotation	rotation,
+	   int		numOutputs,
+	   RROutputPtr  *outputs)
+{
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+    Bool	ret = FALSE;
+    rrScrPriv(pScreen);
+
+    /* See if nothing changed */
+    if (crtc-&gt;mode == mode &amp;&amp;
+	crtc-&gt;x == x &amp;&amp;
+	crtc-&gt;y == y &amp;&amp;
+	crtc-&gt;rotation == rotation &amp;&amp;
+	crtc-&gt;numOutputs == numOutputs &amp;&amp;
+	!memcmp (crtc-&gt;outputs, outputs, numOutputs * sizeof (RROutputPtr)) &amp;&amp;
+	!RRCrtcPendingProperties (crtc))
+    {
+	ret = TRUE;
+    }
+    else
+    {
+#if RANDR_12_INTERFACE
+	if (pScrPriv-&gt;rrCrtcSet)
+	{
+	    ret = (*pScrPriv-&gt;rrCrtcSet) (pScreen, crtc, mode, x, y, 
+					  rotation, numOutputs, outputs);
+	}
+	else
+#endif
+	{
+#if RANDR_10_INTERFACE
+	    if (pScrPriv-&gt;rrSetConfig)
+	    {
+		RRScreenSize	    size;
+		RRScreenRate	    rate;
+
+		if (!mode)
+		{
+		    RRCrtcNotify (crtc, NULL, x, y, rotation, 0, NULL);
+		    ret = TRUE;
+		}
+		else
+		{
+		    size.width = mode-&gt;mode.width;
+		    size.height = mode-&gt;mode.height;
+		    if (outputs[0]-&gt;mmWidth &amp;&amp; outputs[0]-&gt;mmHeight)
+		    {
+			size.mmWidth = outputs[0]-&gt;mmWidth;
+			size.mmHeight = outputs[0]-&gt;mmHeight;
+		    }
+		    else
+		    {
+			size.mmWidth = pScreen-&gt;mmWidth;
+			size.mmHeight = pScreen-&gt;mmHeight;
+		    }
+		    size.nRates = 1;
+		    rate.rate = RRVerticalRefresh (&amp;mode-&gt;mode);
+		    size.pRates = &rate;
+		    ret = (*pScrPriv-&gt;rrSetConfig) (pScreen, rotation, rate.rate, &amp;size);
+		    /*
+		     * Old 1.0 interface tied screen size to mode size
+		     */
+		    if (ret)
+		    {
+			RRCrtcNotify (crtc, mode, x, y, rotation, 1, outputs);
+			RRScreenSizeNotify (pScreen);
+		    }
+		}
+	    }
+#endif
+	}
+	if (ret)
+	{
+	    int	o;
+	    RRTellChanged (pScreen);
+
+	    for (o = 0; o &lt; numOutputs; o++)
+		RRPostPendingProperties (outputs[o]);
+	}
+    }
+    return ret;
+}
+
+/*
+ * Destroy a Crtc at shutdown
+ */
+void
+RRCrtcDestroy (RRCrtcPtr crtc)
+{
+    FreeResource (crtc-&gt;id, 0);
+}
+
+static int
+RRCrtcDestroyResource (pointer value, XID pid)
+{
+    RRCrtcPtr	crtc = (RRCrtcPtr) value;
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+
+    if (pScreen)
+    {
+	rrScrPriv(pScreen);
+	int		i;
+    
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	{
+	    if (pScrPriv-&gt;crtcs[i] == crtc)
+	    {
+		memmove (pScrPriv-&gt;crtcs + i, pScrPriv-&gt;crtcs + i + 1,
+			 (pScrPriv-&gt;numCrtcs - (i + 1)) * sizeof (RRCrtcPtr));
+		--pScrPriv-&gt;numCrtcs;
+		break;
+	    }
+	}
+    }
+    if (crtc-&gt;gammaRed)
+	xfree (crtc-&gt;gammaRed);
+    if (crtc-&gt;mode)
+	RRModeDestroy (crtc-&gt;mode);
+    xfree (crtc);
+    return 1;
+}
+
+/*
+ * Request that the Crtc gamma be changed
+ */
+
+Bool
+RRCrtcGammaSet (RRCrtcPtr   crtc,
+		CARD16	    *red,
+		CARD16	    *green,
+		CARD16	    *blue)
+{
+    Bool	ret = TRUE;
+#if RANDR_12_INTERFACE
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+#endif
+    
+    memcpy (crtc-&gt;gammaRed, red, crtc-&gt;gammaSize * sizeof (CARD16));
+    memcpy (crtc-&gt;gammaGreen, green, crtc-&gt;gammaSize * sizeof (CARD16));
+    memcpy (crtc-&gt;gammaBlue, blue, crtc-&gt;gammaSize * sizeof (CARD16));
+#if RANDR_12_INTERFACE
+    if (pScreen)
+    {
+	rrScrPriv(pScreen);
+	if (pScrPriv-&gt;rrCrtcSetGamma)
+	    ret = (*pScrPriv-&gt;rrCrtcSetGamma) (pScreen, crtc);
+    }
+#endif
+    return ret;
+}
+
+/*
+ * Notify the extension that the Crtc gamma has been changed
+ * The driver calls this whenever it has changed the gamma values
+ * in the RRCrtcRec
+ */
+
+Bool
+RRCrtcGammaNotify (RRCrtcPtr	crtc)
+{
+    return TRUE;    /* not much going on here */
+}
+
+/**
+ * Returns the width/height that the crtc scans out from the framebuffer
+ */
+void
+RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height)
+{
+    if (crtc-&gt;mode == NULL) {
+	*width = 0;
+	*height = 0;
+	return;
+    }
+
+    switch (crtc-&gt;rotation &amp; 0xf) {
+    case RR_Rotate_0:
+    case RR_Rotate_180:
+	*width = crtc-&gt;mode-&gt;mode.width;
+	*height = crtc-&gt;mode-&gt;mode.height;
+	break;
+    case RR_Rotate_90:
+    case RR_Rotate_270:
+	*width = crtc-&gt;mode-&gt;mode.height;
+	*height = crtc-&gt;mode-&gt;mode.width;
+	break;
+    }
+}
+
+/*
+ * Set the size of the gamma table at server startup time
+ */
+
+Bool
+RRCrtcGammaSetSize (RRCrtcPtr	crtc,
+		    int		size)
+{
+    CARD16  *gamma;
+
+    if (size == crtc-&gt;gammaSize)
+	return TRUE;
+    if (size)
+    {
+	gamma = xalloc (size * 3 * sizeof (CARD16));
+	if (!gamma)
+	    return FALSE;
+    }
+    else
+	gamma = NULL;
+    if (crtc-&gt;gammaRed)
+	xfree (crtc-&gt;gammaRed);
+    crtc-&gt;gammaRed = gamma;
+    crtc-&gt;gammaGreen = gamma + size;
+    crtc-&gt;gammaBlue = gamma + size*2;
+    crtc-&gt;gammaSize = size;
+    return TRUE;
+}
+
+/*
+ * Initialize crtc type
+ */
+Bool
+RRCrtcInit (void)
+{
+    RRCrtcType = CreateNewResourceType (RRCrtcDestroyResource);
+    if (!RRCrtcType)
+	return FALSE;
+    RegisterResourceName (RRCrtcType, &quot;CRTC&quot;);
+    return TRUE;
+}
+
+int
+ProcRRGetCrtcInfo (ClientPtr client)
+{
+    REQUEST(xRRGetCrtcInfoReq);
+    xRRGetCrtcInfoReply	rep;
+    RRCrtcPtr			crtc;
+    CARD8			*extra;
+    unsigned long		extraLen;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    RRModePtr			mode;
+    RROutput			*outputs;
+    RROutput			*possible;
+    int				i, j, k, n;
+    int				width, height;
+    
+    REQUEST_SIZE_MATCH(xRRGetCrtcInfoReq);
+    crtc = LookupCrtc(client, stuff-&gt;crtc, DixReadAccess);
+
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+
+    /* All crtcs must be associated with screens before client
+     * requests are processed
+     */
+    pScreen = crtc-&gt;pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+
+    mode = crtc-&gt;mode;
+    
+    rep.type = X_Reply;
+    rep.status = RRSetConfigSuccess;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.length = 0;
+    rep.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    rep.x = crtc-&gt;x;
+    rep.y = crtc-&gt;y;
+    RRCrtcGetScanoutSize (crtc, &amp;width, &amp;height);
+    rep.width = width;
+    rep.height = height;
+    rep.mode = mode ? mode-&gt;mode.id : 0;
+    rep.rotation = crtc-&gt;rotation;
+    rep.rotations = crtc-&gt;rotations;
+    rep.nOutput = crtc-&gt;numOutputs;
+    k = 0;
+    for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	for (j = 0; j &lt; pScrPriv-&gt;outputs[i]-&gt;numCrtcs; j++)
+	    if (pScrPriv-&gt;outputs[i]-&gt;crtcs[j] == crtc)
+		k++;
+    rep.nPossibleOutput = k;
+    
+    rep.length = rep.nOutput + rep.nPossibleOutput;
+
+    extraLen = rep.length &lt;&lt; 2;
+    if (extraLen)
+    {
+	extra = xalloc (extraLen);
+	if (!extra)
+	    return BadAlloc;
+    }
+    else
+	extra = NULL;
+
+    outputs = (RROutput *) extra;
+    possible = (RROutput *) (outputs + rep.nOutput);
+    
+    for (i = 0; i &lt; crtc-&gt;numOutputs; i++)
+    {
+	outputs[i] = crtc-&gt;outputs[i]-&gt;id;
+	if (client-&gt;swapped)
+	    swapl (&amp;outputs[i], n);
+    }
+    k = 0;
+    for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	for (j = 0; j &lt; pScrPriv-&gt;outputs[i]-&gt;numCrtcs; j++)
+	    if (pScrPriv-&gt;outputs[i]-&gt;crtcs[j] == crtc)
+	    {
+		possible[k] = pScrPriv-&gt;outputs[i]-&gt;id;
+		if (client-&gt;swapped)
+		    swapl (&amp;possible[k], n);
+		k++;
+	    }
+    
+    if (client-&gt;swapped) {
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.timestamp, n);
+	swaps(&amp;rep.x, n);
+	swaps(&amp;rep.y, n);
+	swaps(&amp;rep.width, n);
+	swaps(&amp;rep.height, n);
+	swapl(&amp;rep.mode, n);
+	swaps(&amp;rep.rotation, n);
+	swaps(&amp;rep.rotations, n);
+	swaps(&amp;rep.nOutput, n);
+	swaps(&amp;rep.nPossibleOutput, n);
+    }
+    WriteToClient(client, sizeof(xRRGetCrtcInfoReply), (char *)&amp;rep);
+    if (extraLen)
+    {
+	WriteToClient (client, extraLen, (char *) extra);
+	xfree (extra);
+    }
+    
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRSetCrtcConfig (ClientPtr client)
+{
+    REQUEST(xRRSetCrtcConfigReq);
+    xRRSetCrtcConfigReply   rep;
+    ScreenPtr		    pScreen;
+    rrScrPrivPtr	    pScrPriv;
+    RRCrtcPtr		    crtc;
+    RRModePtr		    mode;
+    int			    numOutputs;
+    RROutputPtr		    *outputs = NULL;
+    RROutput		    *outputIds;
+    TimeStamp		    configTime;
+    TimeStamp		    time;
+    Rotation		    rotation;
+    int			    i, j;
+    
+    REQUEST_AT_LEAST_SIZE(xRRSetCrtcConfigReq);
+    numOutputs = (stuff-&gt;length - (SIZEOF (xRRSetCrtcConfigReq) &gt;&gt; 2));
+    
+    crtc = LookupIDByType (stuff-&gt;crtc, RRCrtcType);
+    if (!crtc)
+    {
+	client-&gt;errorValue = stuff-&gt;crtc;
+	return RRErrorBase + BadRRCrtc;
+    }
+    if (stuff-&gt;mode == None)
+    {
+	mode = NULL;
+	if (numOutputs &gt; 0)
+	    return BadMatch;
+    }
+    else
+    {
+	mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+	if (!mode)
+	{
+	    client-&gt;errorValue = stuff-&gt;mode;
+	    return RRErrorBase + BadRRMode;
+	}
+	if (numOutputs == 0)
+	    return BadMatch;
+    }
+    if (numOutputs)
+    {
+	outputs = xalloc (numOutputs * sizeof (RROutputPtr));
+	if (!outputs)
+	    return BadAlloc;
+    }
+    else
+	outputs = NULL;
+    
+    outputIds = (RROutput *) (stuff + 1);
+    for (i = 0; i &lt; numOutputs; i++)
+    {
+	outputs[i] = (RROutputPtr) LookupIDByType (outputIds[i], RROutputType);
+	if (!outputs[i])
+	{
+	    client-&gt;errorValue = outputIds[i];
+	    if (outputs)
+		xfree (outputs);
+	    return RRErrorBase + BadRROutput;
+	}
+	/* validate crtc for this output */
+	for (j = 0; j &lt; outputs[i]-&gt;numCrtcs; j++)
+	    if (outputs[i]-&gt;crtcs[j] == crtc)
+		break;
+	if (j == outputs[i]-&gt;numCrtcs)
+	{
+	    if (outputs)
+		xfree (outputs);
+	    return BadMatch;
+	}
+	/* validate mode for this output */
+	for (j = 0; j &lt; outputs[i]-&gt;numModes + outputs[i]-&gt;numUserModes; j++)
+	{
+	    RRModePtr	m = (j &lt; outputs[i]-&gt;numModes ? 
+			     outputs[i]-&gt;modes[j] :
+			     outputs[i]-&gt;userModes[j - outputs[i]-&gt;numModes]);
+	    if (m == mode)
+		break;
+	}
+	if (j == outputs[i]-&gt;numModes + outputs[i]-&gt;numUserModes)
+	{
+	    if (outputs)
+		xfree (outputs);
+	    return BadMatch;
+	}
+    }
+    /* validate clones */
+    for (i = 0; i &lt; numOutputs; i++)
+    {
+	for (j = 0; j &lt; numOutputs; j++)
+	{
+	    int k;
+	    if (i == j)
+		continue;
+	    for (k = 0; k &lt; outputs[i]-&gt;numClones; k++)
+	    {
+		if (outputs[i]-&gt;clones[k] == outputs[j])
+		    break;
+	    }
+	    if (k == outputs[i]-&gt;numClones)
+	    {
+		if (outputs)
+		    xfree (outputs);
+		return BadMatch;
+	    }
+	}
+    }
+
+    pScreen = crtc-&gt;pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    time = ClientTimeToServerTime(stuff-&gt;timestamp);
+    configTime = ClientTimeToServerTime(stuff-&gt;configTimestamp);
+    
+    if (!pScrPriv)
+    {
+	time = currentTime;
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+    
+#if 0
+    /*
+     * if the client's config timestamp is not the same as the last config
+     * timestamp, then the config information isn't up-to-date and
+     * can't even be validated
+     */
+    if (CompareTimeStamps (configTime, pScrPriv-&gt;lastConfigTime) != 0)
+    {
+	rep.status = RRSetConfigInvalidConfigTime;
+	goto sendReply;
+    }
+#endif
+    
+    /*
+     * Validate requested rotation
+     */
+    rotation = (Rotation) stuff-&gt;rotation;
+
+    /* test the rotation bits only! */
+    switch (rotation &amp; 0xf) {
+    case RR_Rotate_0:
+    case RR_Rotate_90:
+    case RR_Rotate_180:
+    case RR_Rotate_270:
+	break;
+    default:
+	/*
+	 * Invalid rotation
+	 */
+	client-&gt;errorValue = stuff-&gt;rotation;
+	if (outputs)
+	    xfree (outputs);
+	return BadValue;
+    }
+
+    if (mode)
+    {
+	if ((~crtc-&gt;rotations) &amp; rotation)
+	{
+	    /*
+	     * requested rotation or reflection not supported by screen
+	     */
+	    client-&gt;errorValue = stuff-&gt;rotation;
+	    if (outputs)
+		xfree (outputs);
+	    return BadMatch;
+	}
+    
+#ifdef RANDR_12_INTERFACE
+	/*
+	 * Check screen size bounds if the DDX provides a 1.2 interface
+	 * for setting screen size. Else, assume the CrtcSet sets
+	 * the size along with the mode
+	 */
+	if (pScrPriv-&gt;rrScreenSetSize)
+	{
+	    int source_width = mode-&gt;mode.width;
+	    int	source_height = mode-&gt;mode.height;
+
+	    if ((rotation &amp; 0xf) == RR_Rotate_90 || (rotation &amp; 0xf) == RR_Rotate_270)
+	    {
+		source_width = mode-&gt;mode.height;
+		source_height = mode-&gt;mode.width;
+	    }
+	    if (stuff-&gt;x + source_width &gt; pScreen-&gt;width)
+	    {
+		client-&gt;errorValue = stuff-&gt;x;
+		if (outputs)
+		    xfree (outputs);
+		return BadValue;
+	    }
+	    
+	    if (stuff-&gt;y + source_height &gt; pScreen-&gt;height)
+	    {
+		client-&gt;errorValue = stuff-&gt;y;
+		if (outputs)
+		    xfree (outputs);
+		return BadValue;
+	    }
+	}
+#endif
+    }
+    
+    /*
+     * Make sure the requested set-time is not older than
+     * the last set-time
+     */
+    if (CompareTimeStamps (time, pScrPriv-&gt;lastSetTime) &lt; 0)
+    {
+	rep.status = RRSetConfigInvalidTime;
+	goto sendReply;
+    }
+
+    if (!RRCrtcSet (crtc, mode, stuff-&gt;x, stuff-&gt;y,
+		   rotation, numOutputs, outputs))
+    {
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+    #ifdef NXAGENT_SERVER /* Bug 21987 */
+    pScrPriv-&gt;lastSetTime = time;
+    #endif
+    rep.status = RRSetConfigSuccess;
+    
+sendReply:
+    if (outputs)
+	xfree (outputs);
+    
+    rep.type = X_Reply;
+    /* rep.status has already been filled in */
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    #ifndef NXAGENT_SERVER /* Bug 21987 */
+    rep.newTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+    #else
+    rep.newTimestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    #endif
+
+    if (client-&gt;swapped) 
+    {
+	int n;
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.newTimestamp, n);
+    }
+    WriteToClient(client, sizeof(xRRSetCrtcConfigReply), (char *)&amp;rep);
+    
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRGetCrtcGammaSize (ClientPtr client)
+{
+    REQUEST(xRRGetCrtcGammaSizeReq);
+    xRRGetCrtcGammaSizeReply	reply;
+    RRCrtcPtr			crtc;
+    int				n;
+
+    REQUEST_SIZE_MATCH(xRRGetCrtcGammaSizeReq);
+    crtc = LookupCrtc (client, stuff-&gt;crtc, DixReadAccess);
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+    
+    reply.type = X_Reply;
+    reply.sequenceNumber = client-&gt;sequence;
+    reply.length = 0;
+    reply.size = crtc-&gt;gammaSize;
+    if (client-&gt;swapped) {
+	swaps (&amp;reply.sequenceNumber, n);
+	swapl (&amp;reply.length, n);
+	swaps (&amp;reply.size, n);
+    }
+    WriteToClient (client, sizeof (xRRGetCrtcGammaSizeReply), (char *) &amp;reply);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRGetCrtcGamma (ClientPtr client)
+{
+    REQUEST(xRRGetCrtcGammaReq);
+    xRRGetCrtcGammaReply	reply;
+    RRCrtcPtr			crtc;
+    int				n;
+    unsigned long		len;
+    char			*extra;
+    
+    REQUEST_SIZE_MATCH(xRRGetCrtcGammaReq);
+    crtc = LookupCrtc (client, stuff-&gt;crtc, DixReadAccess);
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+    
+    len = crtc-&gt;gammaSize * 3 * 2;
+    
+    if (crtc-&gt;gammaSize) {
+	extra = xalloc(len);
+	if (!extra)
+	    return BadAlloc;
+    }
+
+    reply.type = X_Reply;
+    reply.sequenceNumber = client-&gt;sequence;
+    reply.length = (len + 3) &gt;&gt; 2;
+    reply.size = crtc-&gt;gammaSize;
+    if (client-&gt;swapped) {
+	swaps (&amp;reply.sequenceNumber, n);
+	swapl (&amp;reply.length, n);
+	swaps (&amp;reply.size, n);
+    }
+    WriteToClient (client, sizeof (xRRGetCrtcGammaReply), (char *) &amp;reply);
+    if (crtc-&gt;gammaSize)
+    {
+	memcpy(extra, crtc-&gt;gammaRed, len);
+	client-&gt;pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write;
+	WriteSwappedDataToClient (client, len, extra);
+	xfree(extra);
+    }
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRSetCrtcGamma (ClientPtr client)
+{
+    REQUEST(xRRSetCrtcGammaReq);
+    RRCrtcPtr			crtc;
+    unsigned long		len;
+    CARD16			*red, *green, *blue;
+    
+    REQUEST_AT_LEAST_SIZE(xRRSetCrtcGammaReq);
+    crtc = LookupCrtc (client, stuff-&gt;crtc, DixWriteAccess);
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+    
+    len = client-&gt;req_len - (sizeof (xRRSetCrtcGammaReq) &gt;&gt; 2);
+    if (len &lt; (stuff-&gt;size * 3 + 1) &gt;&gt; 1)
+	return BadLength;
+
+    if (stuff-&gt;size != crtc-&gt;gammaSize)
+	return BadMatch;
+    
+    red = (CARD16 *) (stuff + 1);
+    green = red + crtc-&gt;gammaSize;
+    blue = green + crtc-&gt;gammaSize;
+    
+    RRCrtcGammaSet (crtc, red, green, blue);
+
+    return Success;
+}
+
diff --git a/nx-X11/programs/Xserver/randr/rrcrtc.c.NX.original b/nx-X11/programs/Xserver/randr/rrcrtc.c.NX.original
new file mode 100644
index 0000000..fb82a80
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrcrtc.c.NX.original
@@ -0,0 +1,984 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &quot;randrstr.h&quot;
+#include &quot;swaprep.h&quot;
+#include &quot;registry.h&quot;
+
+RESTYPE	RRCrtcType;
+
+/*
+ * Notify the CRTC of some change
+ */
+void
+RRCrtcChanged (RRCrtcPtr crtc, Bool layoutChanged)
+{
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+
+    crtc-&gt;changed = TRUE;
+    if (pScreen)
+    {
+	rrScrPriv(pScreen);
+    
+	pScrPriv-&gt;changed = TRUE;
+	/*
+	 * Send ConfigureNotify on any layout change
+	 */
+	if (layoutChanged)
+	    pScrPriv-&gt;layoutChanged = TRUE;
+    }
+}
+
+/*
+ * Create a CRTC
+ */
+RRCrtcPtr
+RRCrtcCreate (ScreenPtr pScreen, void *devPrivate)
+{
+    RRCrtcPtr	    crtc;
+    RRCrtcPtr	    *crtcs;
+    rrScrPrivPtr    pScrPriv;
+
+    if (!RRInit())
+	return NULL;
+    
+    pScrPriv = rrGetScrPriv(pScreen);
+
+    /* make space for the crtc pointer */
+    if (pScrPriv-&gt;numCrtcs)
+	crtcs = xrealloc (pScrPriv-&gt;crtcs, 
+			  (pScrPriv-&gt;numCrtcs + 1) * sizeof (RRCrtcPtr));
+    else
+	crtcs = xalloc (sizeof (RRCrtcPtr));
+    if (!crtcs)
+	return FALSE;
+    pScrPriv-&gt;crtcs = crtcs;
+    
+    crtc = xcalloc (1, sizeof (RRCrtcRec));
+    if (!crtc)
+	return NULL;
+    crtc-&gt;id = FakeClientID (0);
+    crtc-&gt;pScreen = pScreen;
+    crtc-&gt;mode = NULL;
+    crtc-&gt;x = 0;
+    crtc-&gt;y = 0;
+    crtc-&gt;rotation = RR_Rotate_0;
+    crtc-&gt;rotations = RR_Rotate_0;
+    crtc-&gt;outputs = NULL;
+    crtc-&gt;numOutputs = 0;
+    crtc-&gt;gammaSize = 0;
+    crtc-&gt;gammaRed = crtc-&gt;gammaBlue = crtc-&gt;gammaGreen = NULL;
+    crtc-&gt;changed = FALSE;
+    crtc-&gt;devPrivate = devPrivate;
+
+    if (!AddResource (crtc-&gt;id, RRCrtcType, (pointer) crtc))
+	return NULL;
+
+    /* attach the screen and crtc together */
+    crtc-&gt;pScreen = pScreen;
+    pScrPriv-&gt;crtcs[pScrPriv-&gt;numCrtcs++] = crtc;
+    
+    return crtc;
+}
+
+/*
+ * Set the allowed rotations on a CRTC
+ */
+void
+RRCrtcSetRotations (RRCrtcPtr crtc, Rotation rotations)
+{
+    crtc-&gt;rotations = rotations;
+}
+
+/*
+ * Notify the extension that the Crtc has been reconfigured,
+ * the driver calls this whenever it has updated the mode
+ */
+Bool
+RRCrtcNotify (RRCrtcPtr	    crtc,
+	      RRModePtr	    mode,
+	      int	    x,
+	      int	    y,
+	      Rotation	    rotation,
+	      int	    numOutputs,
+	      RROutputPtr   *outputs)
+{
+    int	    i, j;
+    
+    /*
+     * Check to see if any of the new outputs were
+     * not in the old list and mark them as changed
+     */
+    for (i = 0; i &lt; numOutputs; i++)
+    {
+	for (j = 0; j &lt; crtc-&gt;numOutputs; j++)
+	    if (outputs[i] == crtc-&gt;outputs[j])
+		break;
+	if (j == crtc-&gt;numOutputs)
+	{
+	    outputs[i]-&gt;crtc = crtc;
+	    RROutputChanged (outputs[i], FALSE);
+	    RRCrtcChanged (crtc, FALSE);
+	}
+    }
+    /*
+     * Check to see if any of the old outputs are
+     * not in the new list and mark them as changed
+     */
+    for (j = 0; j &lt; crtc-&gt;numOutputs; j++)
+    {
+	for (i = 0; i &lt; numOutputs; i++)
+	    if (outputs[i] == crtc-&gt;outputs[j])
+		break;
+	if (i == numOutputs)
+	{
+	    if (crtc-&gt;outputs[j]-&gt;crtc == crtc)
+		crtc-&gt;outputs[j]-&gt;crtc = NULL;
+	    RROutputChanged (crtc-&gt;outputs[j], FALSE);
+	    RRCrtcChanged (crtc, FALSE);
+	}
+    }
+    /*
+     * Reallocate the crtc output array if necessary
+     */
+    if (numOutputs != crtc-&gt;numOutputs)
+    {
+	RROutputPtr *newoutputs;
+	
+	if (numOutputs)
+	{
+	    if (crtc-&gt;numOutputs)
+		newoutputs = xrealloc (crtc-&gt;outputs,
+				    numOutputs * sizeof (RROutputPtr));
+	    else
+		newoutputs = xalloc (numOutputs * sizeof (RROutputPtr));
+	    if (!newoutputs)
+		return FALSE;
+	}
+	else
+	{
+	    if (crtc-&gt;outputs)
+		xfree (crtc-&gt;outputs);
+	    newoutputs = NULL;
+	}
+	crtc-&gt;outputs = newoutputs;
+	crtc-&gt;numOutputs = numOutputs;
+    }
+    /*
+     * Copy the new list of outputs into the crtc
+     */
+    memcpy (crtc-&gt;outputs, outputs, numOutputs * sizeof (RROutputPtr));
+    /*
+     * Update remaining crtc fields
+     */
+    if (mode != crtc-&gt;mode)
+    {
+	if (crtc-&gt;mode)
+	    RRModeDestroy (crtc-&gt;mode);
+	crtc-&gt;mode = mode;
+	if (mode != NULL)
+	    mode-&gt;refcnt++;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    if (x != crtc-&gt;x)
+    {
+	crtc-&gt;x = x;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    if (y != crtc-&gt;y)
+    {
+	crtc-&gt;y = y;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    if (rotation != crtc-&gt;rotation)
+    {
+	crtc-&gt;rotation = rotation;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    return TRUE;
+}
+
+void
+RRDeliverCrtcEvent (ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc)
+{
+    ScreenPtr pScreen = pWin-&gt;drawable.pScreen;
+    rrScrPriv (pScreen);
+    xRRCrtcChangeNotifyEvent	ce;
+    RRModePtr	mode = crtc-&gt;mode;
+    
+    ce.type = RRNotify + RREventBase;
+    ce.subCode = RRNotify_CrtcChange;
+    ce.sequenceNumber = client-&gt;sequence;
+    ce.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    ce.window = pWin-&gt;drawable.id;
+    ce.crtc = crtc-&gt;id;
+    ce.rotation = crtc-&gt;rotation;
+    if (mode)
+    {
+	ce.mode = mode-&gt;mode.id;
+	ce.x = crtc-&gt;x;
+	ce.y = crtc-&gt;y;
+	ce.width = mode-&gt;mode.width;
+	ce.height = mode-&gt;mode.height;
+    }
+    else
+    {
+	ce.mode = None;
+	ce.x = 0;
+	ce.y = 0;
+	ce.width = 0;
+	ce.height = 0;
+    }
+    WriteEventsToClient (client, 1, (xEvent *) &amp;ce);
+}
+
+static Bool
+RRCrtcPendingProperties (RRCrtcPtr crtc)
+{
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+    rrScrPriv(pScreen);
+    int		o;
+
+    for (o = 0; o &lt; pScrPriv-&gt;numOutputs; o++)
+    {
+	RROutputPtr output = pScrPriv-&gt;outputs[o];
+	if (output-&gt;crtc == crtc &amp;&amp; output-&gt;pendingProperties)
+	    return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * Request that the Crtc be reconfigured
+ */
+Bool
+RRCrtcSet (RRCrtcPtr    crtc,
+	   RRModePtr	mode,
+	   int		x,
+	   int		y,
+	   Rotation	rotation,
+	   int		numOutputs,
+	   RROutputPtr  *outputs)
+{
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+    Bool	ret = FALSE;
+    rrScrPriv(pScreen);
+
+    /* See if nothing changed */
+    if (crtc-&gt;mode == mode &amp;&amp;
+	crtc-&gt;x == x &amp;&amp;
+	crtc-&gt;y == y &amp;&amp;
+	crtc-&gt;rotation == rotation &amp;&amp;
+	crtc-&gt;numOutputs == numOutputs &amp;&amp;
+	!memcmp (crtc-&gt;outputs, outputs, numOutputs * sizeof (RROutputPtr)) &amp;&amp;
+	!RRCrtcPendingProperties (crtc))
+    {
+	ret = TRUE;
+    }
+    else
+    {
+#if RANDR_12_INTERFACE
+	if (pScrPriv-&gt;rrCrtcSet)
+	{
+	    ret = (*pScrPriv-&gt;rrCrtcSet) (pScreen, crtc, mode, x, y, 
+					  rotation, numOutputs, outputs);
+	}
+	else
+#endif
+	{
+#if RANDR_10_INTERFACE
+	    if (pScrPriv-&gt;rrSetConfig)
+	    {
+		RRScreenSize	    size;
+		RRScreenRate	    rate;
+
+		if (!mode)
+		{
+		    RRCrtcNotify (crtc, NULL, x, y, rotation, 0, NULL);
+		    ret = TRUE;
+		}
+		else
+		{
+		    size.width = mode-&gt;mode.width;
+		    size.height = mode-&gt;mode.height;
+		    if (outputs[0]-&gt;mmWidth &amp;&amp; outputs[0]-&gt;mmHeight)
+		    {
+			size.mmWidth = outputs[0]-&gt;mmWidth;
+			size.mmHeight = outputs[0]-&gt;mmHeight;
+		    }
+		    else
+		    {
+			size.mmWidth = pScreen-&gt;mmWidth;
+			size.mmHeight = pScreen-&gt;mmHeight;
+		    }
+		    size.nRates = 1;
+		    rate.rate = RRVerticalRefresh (&amp;mode-&gt;mode);
+		    size.pRates = &rate;
+		    ret = (*pScrPriv-&gt;rrSetConfig) (pScreen, rotation, rate.rate, &amp;size);
+		    /*
+		     * Old 1.0 interface tied screen size to mode size
+		     */
+		    if (ret)
+		    {
+			RRCrtcNotify (crtc, mode, x, y, rotation, 1, outputs);
+			RRScreenSizeNotify (pScreen);
+		    }
+		}
+	    }
+#endif
+	}
+	if (ret)
+	{
+	    int	o;
+	    RRTellChanged (pScreen);
+
+	    for (o = 0; o &lt; numOutputs; o++)
+		RRPostPendingProperties (outputs[o]);
+	}
+    }
+    return ret;
+}
+
+/*
+ * Destroy a Crtc at shutdown
+ */
+void
+RRCrtcDestroy (RRCrtcPtr crtc)
+{
+    FreeResource (crtc-&gt;id, 0);
+}
+
+static int
+RRCrtcDestroyResource (pointer value, XID pid)
+{
+    RRCrtcPtr	crtc = (RRCrtcPtr) value;
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+
+    if (pScreen)
+    {
+	rrScrPriv(pScreen);
+	int		i;
+    
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	{
+	    if (pScrPriv-&gt;crtcs[i] == crtc)
+	    {
+		memmove (pScrPriv-&gt;crtcs + i, pScrPriv-&gt;crtcs + i + 1,
+			 (pScrPriv-&gt;numCrtcs - (i + 1)) * sizeof (RRCrtcPtr));
+		--pScrPriv-&gt;numCrtcs;
+		break;
+	    }
+	}
+    }
+    if (crtc-&gt;gammaRed)
+	xfree (crtc-&gt;gammaRed);
+    if (crtc-&gt;mode)
+	RRModeDestroy (crtc-&gt;mode);
+    xfree (crtc);
+    return 1;
+}
+
+/*
+ * Request that the Crtc gamma be changed
+ */
+
+Bool
+RRCrtcGammaSet (RRCrtcPtr   crtc,
+		CARD16	    *red,
+		CARD16	    *green,
+		CARD16	    *blue)
+{
+    Bool	ret = TRUE;
+#if RANDR_12_INTERFACE
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+#endif
+    
+    memcpy (crtc-&gt;gammaRed, red, crtc-&gt;gammaSize * sizeof (CARD16));
+    memcpy (crtc-&gt;gammaGreen, green, crtc-&gt;gammaSize * sizeof (CARD16));
+    memcpy (crtc-&gt;gammaBlue, blue, crtc-&gt;gammaSize * sizeof (CARD16));
+#if RANDR_12_INTERFACE
+    if (pScreen)
+    {
+	rrScrPriv(pScreen);
+	if (pScrPriv-&gt;rrCrtcSetGamma)
+	    ret = (*pScrPriv-&gt;rrCrtcSetGamma) (pScreen, crtc);
+    }
+#endif
+    return ret;
+}
+
+/*
+ * Notify the extension that the Crtc gamma has been changed
+ * The driver calls this whenever it has changed the gamma values
+ * in the RRCrtcRec
+ */
+
+Bool
+RRCrtcGammaNotify (RRCrtcPtr	crtc)
+{
+    return TRUE;    /* not much going on here */
+}
+
+/**
+ * Returns the width/height that the crtc scans out from the framebuffer
+ */
+void
+RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height)
+{
+    if (crtc-&gt;mode == NULL) {
+	*width = 0;
+	*height = 0;
+	return;
+    }
+
+    switch (crtc-&gt;rotation &amp; 0xf) {
+    case RR_Rotate_0:
+    case RR_Rotate_180:
+	*width = crtc-&gt;mode-&gt;mode.width;
+	*height = crtc-&gt;mode-&gt;mode.height;
+	break;
+    case RR_Rotate_90:
+    case RR_Rotate_270:
+	*width = crtc-&gt;mode-&gt;mode.height;
+	*height = crtc-&gt;mode-&gt;mode.width;
+	break;
+    }
+}
+
+/*
+ * Set the size of the gamma table at server startup time
+ */
+
+Bool
+RRCrtcGammaSetSize (RRCrtcPtr	crtc,
+		    int		size)
+{
+    CARD16  *gamma;
+
+    if (size == crtc-&gt;gammaSize)
+	return TRUE;
+    if (size)
+    {
+	gamma = xalloc (size * 3 * sizeof (CARD16));
+	if (!gamma)
+	    return FALSE;
+    }
+    else
+	gamma = NULL;
+    if (crtc-&gt;gammaRed)
+	xfree (crtc-&gt;gammaRed);
+    crtc-&gt;gammaRed = gamma;
+    crtc-&gt;gammaGreen = gamma + size;
+    crtc-&gt;gammaBlue = gamma + size*2;
+    crtc-&gt;gammaSize = size;
+    return TRUE;
+}
+
+/*
+ * Initialize crtc type
+ */
+Bool
+RRCrtcInit (void)
+{
+    RRCrtcType = CreateNewResourceType (RRCrtcDestroyResource);
+    if (!RRCrtcType)
+	return FALSE;
+    RegisterResourceName (RRCrtcType, &quot;CRTC&quot;);
+    return TRUE;
+}
+
+int
+ProcRRGetCrtcInfo (ClientPtr client)
+{
+    REQUEST(xRRGetCrtcInfoReq);
+    xRRGetCrtcInfoReply	rep;
+    RRCrtcPtr			crtc;
+    CARD8			*extra;
+    unsigned long		extraLen;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    RRModePtr			mode;
+    RROutput			*outputs;
+    RROutput			*possible;
+    int				i, j, k, n;
+    int				width, height;
+    
+    REQUEST_SIZE_MATCH(xRRGetCrtcInfoReq);
+    crtc = LookupCrtc(client, stuff-&gt;crtc, DixReadAccess);
+
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+
+    /* All crtcs must be associated with screens before client
+     * requests are processed
+     */
+    pScreen = crtc-&gt;pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+
+    mode = crtc-&gt;mode;
+    
+    rep.type = X_Reply;
+    rep.status = RRSetConfigSuccess;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.length = 0;
+    rep.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    rep.x = crtc-&gt;x;
+    rep.y = crtc-&gt;y;
+    RRCrtcGetScanoutSize (crtc, &amp;width, &amp;height);
+    rep.width = width;
+    rep.height = height;
+    rep.mode = mode ? mode-&gt;mode.id : 0;
+    rep.rotation = crtc-&gt;rotation;
+    rep.rotations = crtc-&gt;rotations;
+    rep.nOutput = crtc-&gt;numOutputs;
+    k = 0;
+    for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	for (j = 0; j &lt; pScrPriv-&gt;outputs[i]-&gt;numCrtcs; j++)
+	    if (pScrPriv-&gt;outputs[i]-&gt;crtcs[j] == crtc)
+		k++;
+    rep.nPossibleOutput = k;
+    
+    rep.length = rep.nOutput + rep.nPossibleOutput;
+
+    extraLen = rep.length &lt;&lt; 2;
+    if (extraLen)
+    {
+	extra = xalloc (extraLen);
+	if (!extra)
+	    return BadAlloc;
+    }
+    else
+	extra = NULL;
+
+    outputs = (RROutput *) extra;
+    possible = (RROutput *) (outputs + rep.nOutput);
+    
+    for (i = 0; i &lt; crtc-&gt;numOutputs; i++)
+    {
+	outputs[i] = crtc-&gt;outputs[i]-&gt;id;
+	if (client-&gt;swapped)
+	    swapl (&amp;outputs[i], n);
+    }
+    k = 0;
+    for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	for (j = 0; j &lt; pScrPriv-&gt;outputs[i]-&gt;numCrtcs; j++)
+	    if (pScrPriv-&gt;outputs[i]-&gt;crtcs[j] == crtc)
+	    {
+		possible[k] = pScrPriv-&gt;outputs[i]-&gt;id;
+		if (client-&gt;swapped)
+		    swapl (&amp;possible[k], n);
+		k++;
+	    }
+    
+    if (client-&gt;swapped) {
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.timestamp, n);
+	swaps(&amp;rep.x, n);
+	swaps(&amp;rep.y, n);
+	swaps(&amp;rep.width, n);
+	swaps(&amp;rep.height, n);
+	swapl(&amp;rep.mode, n);
+	swaps(&amp;rep.rotation, n);
+	swaps(&amp;rep.rotations, n);
+	swaps(&amp;rep.nOutput, n);
+	swaps(&amp;rep.nPossibleOutput, n);
+    }
+    WriteToClient(client, sizeof(xRRGetCrtcInfoReply), (char *)&amp;rep);
+    if (extraLen)
+    {
+	WriteToClient (client, extraLen, (char *) extra);
+	xfree (extra);
+    }
+    
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRSetCrtcConfig (ClientPtr client)
+{
+    REQUEST(xRRSetCrtcConfigReq);
+    xRRSetCrtcConfigReply   rep;
+    ScreenPtr		    pScreen;
+    rrScrPrivPtr	    pScrPriv;
+    RRCrtcPtr		    crtc;
+    RRModePtr		    mode;
+    int			    numOutputs;
+    RROutputPtr		    *outputs = NULL;
+    RROutput		    *outputIds;
+    TimeStamp		    configTime;
+    TimeStamp		    time;
+    Rotation		    rotation;
+    int			    i, j;
+    
+    REQUEST_AT_LEAST_SIZE(xRRSetCrtcConfigReq);
+    numOutputs = (stuff-&gt;length - (SIZEOF (xRRSetCrtcConfigReq) &gt;&gt; 2));
+    
+    crtc = LookupIDByType (stuff-&gt;crtc, RRCrtcType);
+    if (!crtc)
+    {
+	client-&gt;errorValue = stuff-&gt;crtc;
+	return RRErrorBase + BadRRCrtc;
+    }
+    if (stuff-&gt;mode == None)
+    {
+	mode = NULL;
+	if (numOutputs &gt; 0)
+	    return BadMatch;
+    }
+    else
+    {
+	mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+	if (!mode)
+	{
+	    client-&gt;errorValue = stuff-&gt;mode;
+	    return RRErrorBase + BadRRMode;
+	}
+	if (numOutputs == 0)
+	    return BadMatch;
+    }
+    if (numOutputs)
+    {
+	outputs = xalloc (numOutputs * sizeof (RROutputPtr));
+	if (!outputs)
+	    return BadAlloc;
+    }
+    else
+	outputs = NULL;
+    
+    outputIds = (RROutput *) (stuff + 1);
+    for (i = 0; i &lt; numOutputs; i++)
+    {
+	outputs[i] = (RROutputPtr) LookupIDByType (outputIds[i], RROutputType);
+	if (!outputs[i])
+	{
+	    client-&gt;errorValue = outputIds[i];
+	    if (outputs)
+		xfree (outputs);
+	    return RRErrorBase + BadRROutput;
+	}
+	/* validate crtc for this output */
+	for (j = 0; j &lt; outputs[i]-&gt;numCrtcs; j++)
+	    if (outputs[i]-&gt;crtcs[j] == crtc)
+		break;
+	if (j == outputs[i]-&gt;numCrtcs)
+	{
+	    if (outputs)
+		xfree (outputs);
+	    return BadMatch;
+	}
+	/* validate mode for this output */
+	for (j = 0; j &lt; outputs[i]-&gt;numModes + outputs[i]-&gt;numUserModes; j++)
+	{
+	    RRModePtr	m = (j &lt; outputs[i]-&gt;numModes ? 
+			     outputs[i]-&gt;modes[j] :
+			     outputs[i]-&gt;userModes[j - outputs[i]-&gt;numModes]);
+	    if (m == mode)
+		break;
+	}
+	if (j == outputs[i]-&gt;numModes + outputs[i]-&gt;numUserModes)
+	{
+	    if (outputs)
+		xfree (outputs);
+	    return BadMatch;
+	}
+    }
+    /* validate clones */
+    for (i = 0; i &lt; numOutputs; i++)
+    {
+	for (j = 0; j &lt; numOutputs; j++)
+	{
+	    int k;
+	    if (i == j)
+		continue;
+	    for (k = 0; k &lt; outputs[i]-&gt;numClones; k++)
+	    {
+		if (outputs[i]-&gt;clones[k] == outputs[j])
+		    break;
+	    }
+	    if (k == outputs[i]-&gt;numClones)
+	    {
+		if (outputs)
+		    xfree (outputs);
+		return BadMatch;
+	    }
+	}
+    }
+
+    pScreen = crtc-&gt;pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    time = ClientTimeToServerTime(stuff-&gt;timestamp);
+    configTime = ClientTimeToServerTime(stuff-&gt;configTimestamp);
+    
+    if (!pScrPriv)
+    {
+	time = currentTime;
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+    
+#if 0
+    /*
+     * if the client's config timestamp is not the same as the last config
+     * timestamp, then the config information isn't up-to-date and
+     * can't even be validated
+     */
+    if (CompareTimeStamps (configTime, pScrPriv-&gt;lastConfigTime) != 0)
+    {
+	rep.status = RRSetConfigInvalidConfigTime;
+	goto sendReply;
+    }
+#endif
+    
+    /*
+     * Validate requested rotation
+     */
+    rotation = (Rotation) stuff-&gt;rotation;
+
+    /* test the rotation bits only! */
+    switch (rotation &amp; 0xf) {
+    case RR_Rotate_0:
+    case RR_Rotate_90:
+    case RR_Rotate_180:
+    case RR_Rotate_270:
+	break;
+    default:
+	/*
+	 * Invalid rotation
+	 */
+	client-&gt;errorValue = stuff-&gt;rotation;
+	if (outputs)
+	    xfree (outputs);
+	return BadValue;
+    }
+
+    if (mode)
+    {
+	if ((~crtc-&gt;rotations) &amp; rotation)
+	{
+	    /*
+	     * requested rotation or reflection not supported by screen
+	     */
+	    client-&gt;errorValue = stuff-&gt;rotation;
+	    if (outputs)
+		xfree (outputs);
+	    return BadMatch;
+	}
+    
+#ifdef RANDR_12_INTERFACE
+	/*
+	 * Check screen size bounds if the DDX provides a 1.2 interface
+	 * for setting screen size. Else, assume the CrtcSet sets
+	 * the size along with the mode
+	 */
+	if (pScrPriv-&gt;rrScreenSetSize)
+	{
+	    int source_width = mode-&gt;mode.width;
+	    int	source_height = mode-&gt;mode.height;
+
+	    if ((rotation &amp; 0xf) == RR_Rotate_90 || (rotation &amp; 0xf) == RR_Rotate_270)
+	    {
+		source_width = mode-&gt;mode.height;
+		source_height = mode-&gt;mode.width;
+	    }
+	    if (stuff-&gt;x + source_width &gt; pScreen-&gt;width)
+	    {
+		client-&gt;errorValue = stuff-&gt;x;
+		if (outputs)
+		    xfree (outputs);
+		return BadValue;
+	    }
+	    
+	    if (stuff-&gt;y + source_height &gt; pScreen-&gt;height)
+	    {
+		client-&gt;errorValue = stuff-&gt;y;
+		if (outputs)
+		    xfree (outputs);
+		return BadValue;
+	    }
+	}
+#endif
+    }
+    
+    /*
+     * Make sure the requested set-time is not older than
+     * the last set-time
+     */
+    if (CompareTimeStamps (time, pScrPriv-&gt;lastSetTime) &lt; 0)
+    {
+	rep.status = RRSetConfigInvalidTime;
+	goto sendReply;
+    }
+
+    if (!RRCrtcSet (crtc, mode, stuff-&gt;x, stuff-&gt;y,
+		   rotation, numOutputs, outputs))
+    {
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+    #ifdef NXAGENT_SERVER /* Bug 21987 */
+    pScrPriv-&gt;lastSetTime = time;
+    #endif
+    rep.status = RRSetConfigSuccess;
+    
+sendReply:
+    if (outputs)
+	xfree (outputs);
+    
+    rep.type = X_Reply;
+    /* rep.status has already been filled in */
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    #ifndef NXAGENT_SERVER /* Bug 21987 */
+    rep.newTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+    #else
+    rep.newTimestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    #endif
+
+    if (client-&gt;swapped) 
+    {
+	int n;
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.newTimestamp, n);
+    }
+    WriteToClient(client, sizeof(xRRSetCrtcConfigReply), (char *)&amp;rep);
+    
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRGetCrtcGammaSize (ClientPtr client)
+{
+    REQUEST(xRRGetCrtcGammaSizeReq);
+    xRRGetCrtcGammaSizeReply	reply;
+    RRCrtcPtr			crtc;
+    int				n;
+
+    REQUEST_SIZE_MATCH(xRRGetCrtcGammaSizeReq);
+    crtc = LookupCrtc (client, stuff-&gt;crtc, DixReadAccess);
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+    
+    reply.type = X_Reply;
+    reply.sequenceNumber = client-&gt;sequence;
+    reply.length = 0;
+    reply.size = crtc-&gt;gammaSize;
+    if (client-&gt;swapped) {
+	swaps (&amp;reply.sequenceNumber, n);
+	swapl (&amp;reply.length, n);
+	swaps (&amp;reply.size, n);
+    }
+    WriteToClient (client, sizeof (xRRGetCrtcGammaSizeReply), (char *) &amp;reply);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRGetCrtcGamma (ClientPtr client)
+{
+    REQUEST(xRRGetCrtcGammaReq);
+    xRRGetCrtcGammaReply	reply;
+    RRCrtcPtr			crtc;
+    int				n;
+    unsigned long		len;
+    char			*extra;
+    
+    REQUEST_SIZE_MATCH(xRRGetCrtcGammaReq);
+    crtc = LookupCrtc (client, stuff-&gt;crtc, DixReadAccess);
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+    
+    len = crtc-&gt;gammaSize * 3 * 2;
+    
+    if (crtc-&gt;gammaSize) {
+	extra = xalloc(len);
+	if (!extra)
+	    return BadAlloc;
+    }
+
+    reply.type = X_Reply;
+    reply.sequenceNumber = client-&gt;sequence;
+    reply.length = (len + 3) &gt;&gt; 2;
+    reply.size = crtc-&gt;gammaSize;
+    if (client-&gt;swapped) {
+	swaps (&amp;reply.sequenceNumber, n);
+	swapl (&amp;reply.length, n);
+	swaps (&amp;reply.size, n);
+    }
+    WriteToClient (client, sizeof (xRRGetCrtcGammaReply), (char *) &amp;reply);
+    if (crtc-&gt;gammaSize)
+    {
+	memcpy(extra, crtc-&gt;gammaRed, len);
+	client-&gt;pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write;
+	WriteSwappedDataToClient (client, len, extra);
+	xfree(extra);
+    }
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRSetCrtcGamma (ClientPtr client)
+{
+    REQUEST(xRRSetCrtcGammaReq);
+    RRCrtcPtr			crtc;
+    unsigned long		len;
+    CARD16			*red, *green, *blue;
+    
+    REQUEST_AT_LEAST_SIZE(xRRSetCrtcGammaReq);
+    crtc = LookupCrtc (client, stuff-&gt;crtc, DixWriteAccess);
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+    
+    len = client-&gt;req_len - (sizeof (xRRSetCrtcGammaReq) &gt;&gt; 2);
+    if (len &lt; (stuff-&gt;size * 3 + 1) &gt;&gt; 1)
+	return BadLength;
+
+    if (stuff-&gt;size != crtc-&gt;gammaSize)
+	return BadMatch;
+    
+    red = (CARD16 *) (stuff + 1);
+    green = red + crtc-&gt;gammaSize;
+    blue = green + crtc-&gt;gammaSize;
+    
+    RRCrtcGammaSet (crtc, red, green, blue);
+
+    return Success;
+}
+
diff --git a/nx-X11/programs/Xserver/randr/rrcrtc.c.X.original b/nx-X11/programs/Xserver/randr/rrcrtc.c.X.original
new file mode 100644
index 0000000..ec65a04
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrcrtc.c.X.original
@@ -0,0 +1,960 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include &quot;randrstr.h&quot;
+#include &quot;swaprep.h&quot;
+#include &quot;registry.h&quot;
+
+RESTYPE	RRCrtcType;
+
+/*
+ * Notify the CRTC of some change
+ */
+void
+RRCrtcChanged (RRCrtcPtr crtc, Bool layoutChanged)
+{
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+
+    crtc-&gt;changed = TRUE;
+    if (pScreen)
+    {
+	rrScrPriv(pScreen);
+    
+	pScrPriv-&gt;changed = TRUE;
+	/*
+	 * Send ConfigureNotify on any layout change
+	 */
+	if (layoutChanged)
+	    pScrPriv-&gt;layoutChanged = TRUE;
+    }
+}
+
+/*
+ * Create a CRTC
+ */
+RRCrtcPtr
+RRCrtcCreate (ScreenPtr pScreen, void *devPrivate)
+{
+    RRCrtcPtr	    crtc;
+    RRCrtcPtr	    *crtcs;
+    rrScrPrivPtr    pScrPriv;
+
+    if (!RRInit())
+	return NULL;
+    
+    pScrPriv = rrGetScrPriv(pScreen);
+
+    /* make space for the crtc pointer */
+    if (pScrPriv-&gt;numCrtcs)
+	crtcs = xrealloc (pScrPriv-&gt;crtcs, 
+			  (pScrPriv-&gt;numCrtcs + 1) * sizeof (RRCrtcPtr));
+    else
+	crtcs = xalloc (sizeof (RRCrtcPtr));
+    if (!crtcs)
+	return FALSE;
+    pScrPriv-&gt;crtcs = crtcs;
+    
+    crtc = xcalloc (1, sizeof (RRCrtcRec));
+    if (!crtc)
+	return NULL;
+    crtc-&gt;id = FakeClientID (0);
+    crtc-&gt;pScreen = pScreen;
+    crtc-&gt;mode = NULL;
+    crtc-&gt;x = 0;
+    crtc-&gt;y = 0;
+    crtc-&gt;rotation = RR_Rotate_0;
+    crtc-&gt;rotations = RR_Rotate_0;
+    crtc-&gt;outputs = NULL;
+    crtc-&gt;numOutputs = 0;
+    crtc-&gt;gammaSize = 0;
+    crtc-&gt;gammaRed = crtc-&gt;gammaBlue = crtc-&gt;gammaGreen = NULL;
+    crtc-&gt;changed = FALSE;
+    crtc-&gt;devPrivate = devPrivate;
+
+    if (!AddResource (crtc-&gt;id, RRCrtcType, (pointer) crtc))
+	return NULL;
+
+    /* attach the screen and crtc together */
+    crtc-&gt;pScreen = pScreen;
+    pScrPriv-&gt;crtcs[pScrPriv-&gt;numCrtcs++] = crtc;
+    
+    return crtc;
+}
+
+/*
+ * Set the allowed rotations on a CRTC
+ */
+void
+RRCrtcSetRotations (RRCrtcPtr crtc, Rotation rotations)
+{
+    crtc-&gt;rotations = rotations;
+}
+
+/*
+ * Notify the extension that the Crtc has been reconfigured,
+ * the driver calls this whenever it has updated the mode
+ */
+Bool
+RRCrtcNotify (RRCrtcPtr	    crtc,
+	      RRModePtr	    mode,
+	      int	    x,
+	      int	    y,
+	      Rotation	    rotation,
+	      int	    numOutputs,
+	      RROutputPtr   *outputs)
+{
+    int	    i, j;
+    
+    /*
+     * Check to see if any of the new outputs were
+     * not in the old list and mark them as changed
+     */
+    for (i = 0; i &lt; numOutputs; i++)
+    {
+	for (j = 0; j &lt; crtc-&gt;numOutputs; j++)
+	    if (outputs[i] == crtc-&gt;outputs[j])
+		break;
+	if (j == crtc-&gt;numOutputs)
+	{
+	    outputs[i]-&gt;crtc = crtc;
+	    RROutputChanged (outputs[i], FALSE);
+	    RRCrtcChanged (crtc, FALSE);
+	}
+    }
+    /*
+     * Check to see if any of the old outputs are
+     * not in the new list and mark them as changed
+     */
+    for (j = 0; j &lt; crtc-&gt;numOutputs; j++)
+    {
+	for (i = 0; i &lt; numOutputs; i++)
+	    if (outputs[i] == crtc-&gt;outputs[j])
+		break;
+	if (i == numOutputs)
+	{
+	    if (crtc-&gt;outputs[j]-&gt;crtc == crtc)
+		crtc-&gt;outputs[j]-&gt;crtc = NULL;
+	    RROutputChanged (crtc-&gt;outputs[j], FALSE);
+	    RRCrtcChanged (crtc, FALSE);
+	}
+    }
+    /*
+     * Reallocate the crtc output array if necessary
+     */
+    if (numOutputs != crtc-&gt;numOutputs)
+    {
+	RROutputPtr *newoutputs;
+	
+	if (numOutputs)
+	{
+	    if (crtc-&gt;numOutputs)
+		newoutputs = xrealloc (crtc-&gt;outputs,
+				    numOutputs * sizeof (RROutputPtr));
+	    else
+		newoutputs = xalloc (numOutputs * sizeof (RROutputPtr));
+	    if (!newoutputs)
+		return FALSE;
+	}
+	else
+	{
+	    if (crtc-&gt;outputs)
+		xfree (crtc-&gt;outputs);
+	    newoutputs = NULL;
+	}
+	crtc-&gt;outputs = newoutputs;
+	crtc-&gt;numOutputs = numOutputs;
+    }
+    /*
+     * Copy the new list of outputs into the crtc
+     */
+    memcpy (crtc-&gt;outputs, outputs, numOutputs * sizeof (RROutputPtr));
+    /*
+     * Update remaining crtc fields
+     */
+    if (mode != crtc-&gt;mode)
+    {
+	if (crtc-&gt;mode)
+	    RRModeDestroy (crtc-&gt;mode);
+	crtc-&gt;mode = mode;
+	if (mode != NULL)
+	    mode-&gt;refcnt++;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    if (x != crtc-&gt;x)
+    {
+	crtc-&gt;x = x;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    if (y != crtc-&gt;y)
+    {
+	crtc-&gt;y = y;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    if (rotation != crtc-&gt;rotation)
+    {
+	crtc-&gt;rotation = rotation;
+	RRCrtcChanged (crtc, TRUE);
+    }
+    return TRUE;
+}
+
+void
+RRDeliverCrtcEvent (ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc)
+{
+    ScreenPtr pScreen = pWin-&gt;drawable.pScreen;
+    rrScrPriv (pScreen);
+    xRRCrtcChangeNotifyEvent	ce;
+    RRModePtr	mode = crtc-&gt;mode;
+    
+    ce.type = RRNotify + RREventBase;
+    ce.subCode = RRNotify_CrtcChange;
+    ce.sequenceNumber = client-&gt;sequence;
+    ce.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    ce.window = pWin-&gt;drawable.id;
+    ce.crtc = crtc-&gt;id;
+    ce.rotation = crtc-&gt;rotation;
+    if (mode)
+    {
+	ce.mode = mode-&gt;mode.id;
+	ce.x = crtc-&gt;x;
+	ce.y = crtc-&gt;y;
+	ce.width = mode-&gt;mode.width;
+	ce.height = mode-&gt;mode.height;
+    }
+    else
+    {
+	ce.mode = None;
+	ce.x = 0;
+	ce.y = 0;
+	ce.width = 0;
+	ce.height = 0;
+    }
+    WriteEventsToClient (client, 1, (xEvent *) &amp;ce);
+}
+
+static Bool
+RRCrtcPendingProperties (RRCrtcPtr crtc)
+{
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+    rrScrPriv(pScreen);
+    int		o;
+
+    for (o = 0; o &lt; pScrPriv-&gt;numOutputs; o++)
+    {
+	RROutputPtr output = pScrPriv-&gt;outputs[o];
+	if (output-&gt;crtc == crtc &amp;&amp; output-&gt;pendingProperties)
+	    return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * Request that the Crtc be reconfigured
+ */
+Bool
+RRCrtcSet (RRCrtcPtr    crtc,
+	   RRModePtr	mode,
+	   int		x,
+	   int		y,
+	   Rotation	rotation,
+	   int		numOutputs,
+	   RROutputPtr  *outputs)
+{
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+    Bool	ret = FALSE;
+    rrScrPriv(pScreen);
+
+    /* See if nothing changed */
+    if (crtc-&gt;mode == mode &amp;&amp;
+	crtc-&gt;x == x &amp;&amp;
+	crtc-&gt;y == y &amp;&amp;
+	crtc-&gt;rotation == rotation &amp;&amp;
+	crtc-&gt;numOutputs == numOutputs &amp;&amp;
+	!memcmp (crtc-&gt;outputs, outputs, numOutputs * sizeof (RROutputPtr)) &amp;&amp;
+	!RRCrtcPendingProperties (crtc))
+    {
+	ret = TRUE;
+    }
+    else
+    {
+#if RANDR_12_INTERFACE
+	if (pScrPriv-&gt;rrCrtcSet)
+	{
+	    ret = (*pScrPriv-&gt;rrCrtcSet) (pScreen, crtc, mode, x, y, 
+					  rotation, numOutputs, outputs);
+	}
+	else
+#endif
+	{
+#if RANDR_10_INTERFACE
+	    if (pScrPriv-&gt;rrSetConfig)
+	    {
+		RRScreenSize	    size;
+		RRScreenRate	    rate;
+
+		if (!mode)
+		{
+		    RRCrtcNotify (crtc, NULL, x, y, rotation, 0, NULL);
+		    ret = TRUE;
+		}
+		else
+		{
+		    size.width = mode-&gt;mode.width;
+		    size.height = mode-&gt;mode.height;
+		    if (outputs[0]-&gt;mmWidth &amp;&amp; outputs[0]-&gt;mmHeight)
+		    {
+			size.mmWidth = outputs[0]-&gt;mmWidth;
+			size.mmHeight = outputs[0]-&gt;mmHeight;
+		    }
+		    else
+		    {
+			size.mmWidth = pScreen-&gt;mmWidth;
+			size.mmHeight = pScreen-&gt;mmHeight;
+		    }
+		    size.nRates = 1;
+		    rate.rate = RRVerticalRefresh (&amp;mode-&gt;mode);
+		    size.pRates = &rate;
+		    ret = (*pScrPriv-&gt;rrSetConfig) (pScreen, rotation, rate.rate, &amp;size);
+		    /*
+		     * Old 1.0 interface tied screen size to mode size
+		     */
+		    if (ret)
+		    {
+			RRCrtcNotify (crtc, mode, x, y, rotation, 1, outputs);
+			RRScreenSizeNotify (pScreen);
+		    }
+		}
+	    }
+#endif
+	}
+	if (ret)
+	{
+	    int	o;
+	    RRTellChanged (pScreen);
+
+	    for (o = 0; o &lt; numOutputs; o++)
+		RRPostPendingProperties (outputs[o]);
+	}
+    }
+    return ret;
+}
+
+/*
+ * Destroy a Crtc at shutdown
+ */
+void
+RRCrtcDestroy (RRCrtcPtr crtc)
+{
+    FreeResource (crtc-&gt;id, 0);
+}
+
+static int
+RRCrtcDestroyResource (pointer value, XID pid)
+{
+    RRCrtcPtr	crtc = (RRCrtcPtr) value;
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+
+    if (pScreen)
+    {
+	rrScrPriv(pScreen);
+	int		i;
+    
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	{
+	    if (pScrPriv-&gt;crtcs[i] == crtc)
+	    {
+		memmove (pScrPriv-&gt;crtcs + i, pScrPriv-&gt;crtcs + i + 1,
+			 (pScrPriv-&gt;numCrtcs - (i + 1)) * sizeof (RRCrtcPtr));
+		--pScrPriv-&gt;numCrtcs;
+		break;
+	    }
+	}
+    }
+    if (crtc-&gt;gammaRed)
+	xfree (crtc-&gt;gammaRed);
+    if (crtc-&gt;mode)
+	RRModeDestroy (crtc-&gt;mode);
+    xfree (crtc);
+    return 1;
+}
+
+/*
+ * Request that the Crtc gamma be changed
+ */
+
+Bool
+RRCrtcGammaSet (RRCrtcPtr   crtc,
+		CARD16	    *red,
+		CARD16	    *green,
+		CARD16	    *blue)
+{
+    Bool	ret = TRUE;
+#if RANDR_12_INTERFACE
+    ScreenPtr	pScreen = crtc-&gt;pScreen;
+#endif
+    
+    memcpy (crtc-&gt;gammaRed, red, crtc-&gt;gammaSize * sizeof (CARD16));
+    memcpy (crtc-&gt;gammaGreen, green, crtc-&gt;gammaSize * sizeof (CARD16));
+    memcpy (crtc-&gt;gammaBlue, blue, crtc-&gt;gammaSize * sizeof (CARD16));
+#if RANDR_12_INTERFACE
+    if (pScreen)
+    {
+	rrScrPriv(pScreen);
+	if (pScrPriv-&gt;rrCrtcSetGamma)
+	    ret = (*pScrPriv-&gt;rrCrtcSetGamma) (pScreen, crtc);
+    }
+#endif
+    return ret;
+}
+
+/*
+ * Notify the extension that the Crtc gamma has been changed
+ * The driver calls this whenever it has changed the gamma values
+ * in the RRCrtcRec
+ */
+
+Bool
+RRCrtcGammaNotify (RRCrtcPtr	crtc)
+{
+    return TRUE;    /* not much going on here */
+}
+
+/**
+ * Returns the width/height that the crtc scans out from the framebuffer
+ */
+void
+RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height)
+{
+    if (crtc-&gt;mode == NULL) {
+	*width = 0;
+	*height = 0;
+	return;
+    }
+
+    switch (crtc-&gt;rotation &amp; 0xf) {
+    case RR_Rotate_0:
+    case RR_Rotate_180:
+	*width = crtc-&gt;mode-&gt;mode.width;
+	*height = crtc-&gt;mode-&gt;mode.height;
+	break;
+    case RR_Rotate_90:
+    case RR_Rotate_270:
+	*width = crtc-&gt;mode-&gt;mode.height;
+	*height = crtc-&gt;mode-&gt;mode.width;
+	break;
+    }
+}
+
+/*
+ * Set the size of the gamma table at server startup time
+ */
+
+Bool
+RRCrtcGammaSetSize (RRCrtcPtr	crtc,
+		    int		size)
+{
+    CARD16  *gamma;
+
+    if (size == crtc-&gt;gammaSize)
+	return TRUE;
+    if (size)
+    {
+	gamma = xalloc (size * 3 * sizeof (CARD16));
+	if (!gamma)
+	    return FALSE;
+    }
+    else
+	gamma = NULL;
+    if (crtc-&gt;gammaRed)
+	xfree (crtc-&gt;gammaRed);
+    crtc-&gt;gammaRed = gamma;
+    crtc-&gt;gammaGreen = gamma + size;
+    crtc-&gt;gammaBlue = gamma + size*2;
+    crtc-&gt;gammaSize = size;
+    return TRUE;
+}
+
+/*
+ * Initialize crtc type
+ */
+Bool
+RRCrtcInit (void)
+{
+    RRCrtcType = CreateNewResourceType (RRCrtcDestroyResource);
+    if (!RRCrtcType)
+	return FALSE;
+    RegisterResourceName (RRCrtcType, &quot;CRTC&quot;);
+    return TRUE;
+}
+
+int
+ProcRRGetCrtcInfo (ClientPtr client)
+{
+    REQUEST(xRRGetCrtcInfoReq);
+    xRRGetCrtcInfoReply	rep;
+    RRCrtcPtr			crtc;
+    CARD8			*extra;
+    unsigned long		extraLen;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    RRModePtr			mode;
+    RROutput			*outputs;
+    RROutput			*possible;
+    int				i, j, k, n;
+    int				width, height;
+    
+    REQUEST_SIZE_MATCH(xRRGetCrtcInfoReq);
+    crtc = LookupCrtc(client, stuff-&gt;crtc, DixReadAccess);
+
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+
+    /* All crtcs must be associated with screens before client
+     * requests are processed
+     */
+    pScreen = crtc-&gt;pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+
+    mode = crtc-&gt;mode;
+    
+    rep.type = X_Reply;
+    rep.status = RRSetConfigSuccess;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.length = 0;
+    rep.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    rep.x = crtc-&gt;x;
+    rep.y = crtc-&gt;y;
+    RRCrtcGetScanoutSize (crtc, &amp;width, &amp;height);
+    rep.width = width;
+    rep.height = height;
+    rep.mode = mode ? mode-&gt;mode.id : 0;
+    rep.rotation = crtc-&gt;rotation;
+    rep.rotations = crtc-&gt;rotations;
+    rep.nOutput = crtc-&gt;numOutputs;
+    k = 0;
+    for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	for (j = 0; j &lt; pScrPriv-&gt;outputs[i]-&gt;numCrtcs; j++)
+	    if (pScrPriv-&gt;outputs[i]-&gt;crtcs[j] == crtc)
+		k++;
+    rep.nPossibleOutput = k;
+    
+    rep.length = rep.nOutput + rep.nPossibleOutput;
+
+    extraLen = rep.length &lt;&lt; 2;
+    if (extraLen)
+    {
+	extra = xalloc (extraLen);
+	if (!extra)
+	    return BadAlloc;
+    }
+    else
+	extra = NULL;
+
+    outputs = (RROutput *) extra;
+    possible = (RROutput *) (outputs + rep.nOutput);
+    
+    for (i = 0; i &lt; crtc-&gt;numOutputs; i++)
+    {
+	outputs[i] = crtc-&gt;outputs[i]-&gt;id;
+	if (client-&gt;swapped)
+	    swapl (&amp;outputs[i], n);
+    }
+    k = 0;
+    for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	for (j = 0; j &lt; pScrPriv-&gt;outputs[i]-&gt;numCrtcs; j++)
+	    if (pScrPriv-&gt;outputs[i]-&gt;crtcs[j] == crtc)
+	    {
+		possible[k] = pScrPriv-&gt;outputs[i]-&gt;id;
+		if (client-&gt;swapped)
+		    swapl (&amp;possible[k], n);
+		k++;
+	    }
+    
+    if (client-&gt;swapped) {
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.timestamp, n);
+	swaps(&amp;rep.x, n);
+	swaps(&amp;rep.y, n);
+	swaps(&amp;rep.width, n);
+	swaps(&amp;rep.height, n);
+	swapl(&amp;rep.mode, n);
+	swaps(&amp;rep.rotation, n);
+	swaps(&amp;rep.rotations, n);
+	swaps(&amp;rep.nOutput, n);
+	swaps(&amp;rep.nPossibleOutput, n);
+    }
+    WriteToClient(client, sizeof(xRRGetCrtcInfoReply), (char *)&amp;rep);
+    if (extraLen)
+    {
+	WriteToClient (client, extraLen, (char *) extra);
+	xfree (extra);
+    }
+    
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRSetCrtcConfig (ClientPtr client)
+{
+    REQUEST(xRRSetCrtcConfigReq);
+    xRRSetCrtcConfigReply   rep;
+    ScreenPtr		    pScreen;
+    rrScrPrivPtr	    pScrPriv;
+    RRCrtcPtr		    crtc;
+    RRModePtr		    mode;
+    int			    numOutputs;
+    RROutputPtr		    *outputs = NULL;
+    RROutput		    *outputIds;
+    TimeStamp		    configTime;
+    TimeStamp		    time;
+    Rotation		    rotation;
+    int			    i, j;
+    
+    REQUEST_AT_LEAST_SIZE(xRRSetCrtcConfigReq);
+    numOutputs = (stuff-&gt;length - (SIZEOF (xRRSetCrtcConfigReq) &gt;&gt; 2));
+    
+    crtc = LookupIDByType (stuff-&gt;crtc, RRCrtcType);
+    if (!crtc)
+    {
+	client-&gt;errorValue = stuff-&gt;crtc;
+	return RRErrorBase + BadRRCrtc;
+    }
+    if (stuff-&gt;mode == None)
+    {
+	mode = NULL;
+	if (numOutputs &gt; 0)
+	    return BadMatch;
+    }
+    else
+    {
+	mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+	if (!mode)
+	{
+	    client-&gt;errorValue = stuff-&gt;mode;
+	    return RRErrorBase + BadRRMode;
+	}
+	if (numOutputs == 0)
+	    return BadMatch;
+    }
+    if (numOutputs)
+    {
+	outputs = xalloc (numOutputs * sizeof (RROutputPtr));
+	if (!outputs)
+	    return BadAlloc;
+    }
+    else
+	outputs = NULL;
+    
+    outputIds = (RROutput *) (stuff + 1);
+    for (i = 0; i &lt; numOutputs; i++)
+    {
+	outputs[i] = (RROutputPtr) LookupIDByType (outputIds[i], RROutputType);
+	if (!outputs[i])
+	{
+	    client-&gt;errorValue = outputIds[i];
+	    if (outputs)
+		xfree (outputs);
+	    return RRErrorBase + BadRROutput;
+	}
+	/* validate crtc for this output */
+	for (j = 0; j &lt; outputs[i]-&gt;numCrtcs; j++)
+	    if (outputs[i]-&gt;crtcs[j] == crtc)
+		break;
+	if (j == outputs[i]-&gt;numCrtcs)
+	{
+	    if (outputs)
+		xfree (outputs);
+	    return BadMatch;
+	}
+	/* validate mode for this output */
+	for (j = 0; j &lt; outputs[i]-&gt;numModes + outputs[i]-&gt;numUserModes; j++)
+	{
+	    RRModePtr	m = (j &lt; outputs[i]-&gt;numModes ? 
+			     outputs[i]-&gt;modes[j] :
+			     outputs[i]-&gt;userModes[j - outputs[i]-&gt;numModes]);
+	    if (m == mode)
+		break;
+	}
+	if (j == outputs[i]-&gt;numModes + outputs[i]-&gt;numUserModes)
+	{
+	    if (outputs)
+		xfree (outputs);
+	    return BadMatch;
+	}
+    }
+    /* validate clones */
+    for (i = 0; i &lt; numOutputs; i++)
+    {
+	for (j = 0; j &lt; numOutputs; j++)
+	{
+	    int k;
+	    if (i == j)
+		continue;
+	    for (k = 0; k &lt; outputs[i]-&gt;numClones; k++)
+	    {
+		if (outputs[i]-&gt;clones[k] == outputs[j])
+		    break;
+	    }
+	    if (k == outputs[i]-&gt;numClones)
+	    {
+		if (outputs)
+		    xfree (outputs);
+		return BadMatch;
+	    }
+	}
+    }
+
+    pScreen = crtc-&gt;pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    time = ClientTimeToServerTime(stuff-&gt;timestamp);
+    configTime = ClientTimeToServerTime(stuff-&gt;configTimestamp);
+    
+    if (!pScrPriv)
+    {
+	time = currentTime;
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+    
+#if 0
+    /*
+     * if the client's config timestamp is not the same as the last config
+     * timestamp, then the config information isn't up-to-date and
+     * can't even be validated
+     */
+    if (CompareTimeStamps (configTime, pScrPriv-&gt;lastConfigTime) != 0)
+    {
+	rep.status = RRSetConfigInvalidConfigTime;
+	goto sendReply;
+    }
+#endif
+    
+    /*
+     * Validate requested rotation
+     */
+    rotation = (Rotation) stuff-&gt;rotation;
+
+    /* test the rotation bits only! */
+    switch (rotation &amp; 0xf) {
+    case RR_Rotate_0:
+    case RR_Rotate_90:
+    case RR_Rotate_180:
+    case RR_Rotate_270:
+	break;
+    default:
+	/*
+	 * Invalid rotation
+	 */
+	client-&gt;errorValue = stuff-&gt;rotation;
+	if (outputs)
+	    xfree (outputs);
+	return BadValue;
+    }
+
+    if (mode)
+    {
+	if ((~crtc-&gt;rotations) &amp; rotation)
+	{
+	    /*
+	     * requested rotation or reflection not supported by screen
+	     */
+	    client-&gt;errorValue = stuff-&gt;rotation;
+	    if (outputs)
+		xfree (outputs);
+	    return BadMatch;
+	}
+    
+#ifdef RANDR_12_INTERFACE
+	/*
+	 * Check screen size bounds if the DDX provides a 1.2 interface
+	 * for setting screen size. Else, assume the CrtcSet sets
+	 * the size along with the mode
+	 */
+	if (pScrPriv-&gt;rrScreenSetSize)
+	{
+	    int source_width = mode-&gt;mode.width;
+	    int	source_height = mode-&gt;mode.height;
+
+	    if ((rotation &amp; 0xf) == RR_Rotate_90 || (rotation &amp; 0xf) == RR_Rotate_270)
+	    {
+		source_width = mode-&gt;mode.height;
+		source_height = mode-&gt;mode.width;
+	    }
+	    if (stuff-&gt;x + source_width &gt; pScreen-&gt;width)
+	    {
+		client-&gt;errorValue = stuff-&gt;x;
+		if (outputs)
+		    xfree (outputs);
+		return BadValue;
+	    }
+	    
+	    if (stuff-&gt;y + source_height &gt; pScreen-&gt;height)
+	    {
+		client-&gt;errorValue = stuff-&gt;y;
+		if (outputs)
+		    xfree (outputs);
+		return BadValue;
+	    }
+	}
+#endif
+    }
+    
+    /*
+     * Make sure the requested set-time is not older than
+     * the last set-time
+     */
+    if (CompareTimeStamps (time, pScrPriv-&gt;lastSetTime) &lt; 0)
+    {
+	rep.status = RRSetConfigInvalidTime;
+	goto sendReply;
+    }
+
+    if (!RRCrtcSet (crtc, mode, stuff-&gt;x, stuff-&gt;y,
+		   rotation, numOutputs, outputs))
+    {
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+    rep.status = RRSetConfigSuccess;
+    
+sendReply:
+    if (outputs)
+	xfree (outputs);
+    
+    rep.type = X_Reply;
+    /* rep.status has already been filled in */
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.newTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+
+    if (client-&gt;swapped) 
+    {
+	int n;
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.newTimestamp, n);
+    }
+    WriteToClient(client, sizeof(xRRSetCrtcConfigReply), (char *)&amp;rep);
+    
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRGetCrtcGammaSize (ClientPtr client)
+{
+    REQUEST(xRRGetCrtcGammaSizeReq);
+    xRRGetCrtcGammaSizeReply	reply;
+    RRCrtcPtr			crtc;
+    int				n;
+
+    REQUEST_SIZE_MATCH(xRRGetCrtcGammaSizeReq);
+    crtc = LookupCrtc (client, stuff-&gt;crtc, DixReadAccess);
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+    
+    reply.type = X_Reply;
+    reply.sequenceNumber = client-&gt;sequence;
+    reply.length = 0;
+    reply.size = crtc-&gt;gammaSize;
+    if (client-&gt;swapped) {
+	swaps (&amp;reply.sequenceNumber, n);
+	swapl (&amp;reply.length, n);
+	swaps (&amp;reply.size, n);
+    }
+    WriteToClient (client, sizeof (xRRGetCrtcGammaSizeReply), (char *) &amp;reply);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRGetCrtcGamma (ClientPtr client)
+{
+    REQUEST(xRRGetCrtcGammaReq);
+    xRRGetCrtcGammaReply	reply;
+    RRCrtcPtr			crtc;
+    int				n;
+    unsigned long		len;
+    char			*extra;
+    
+    REQUEST_SIZE_MATCH(xRRGetCrtcGammaReq);
+    crtc = LookupCrtc (client, stuff-&gt;crtc, DixReadAccess);
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+    
+    len = crtc-&gt;gammaSize * 3 * 2;
+    
+    if (crtc-&gt;gammaSize) {
+	extra = xalloc(len);
+	if (!extra)
+	    return BadAlloc;
+    }
+
+    reply.type = X_Reply;
+    reply.sequenceNumber = client-&gt;sequence;
+    reply.length = (len + 3) &gt;&gt; 2;
+    reply.size = crtc-&gt;gammaSize;
+    if (client-&gt;swapped) {
+	swaps (&amp;reply.sequenceNumber, n);
+	swapl (&amp;reply.length, n);
+	swaps (&amp;reply.size, n);
+    }
+    WriteToClient (client, sizeof (xRRGetCrtcGammaReply), (char *) &amp;reply);
+    if (crtc-&gt;gammaSize)
+    {
+	memcpy(extra, crtc-&gt;gammaRed, len);
+	client-&gt;pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write;
+	WriteSwappedDataToClient (client, len, extra);
+	xfree(extra);
+    }
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRSetCrtcGamma (ClientPtr client)
+{
+    REQUEST(xRRSetCrtcGammaReq);
+    RRCrtcPtr			crtc;
+    unsigned long		len;
+    CARD16			*red, *green, *blue;
+    
+    REQUEST_AT_LEAST_SIZE(xRRSetCrtcGammaReq);
+    crtc = LookupCrtc (client, stuff-&gt;crtc, DixWriteAccess);
+    if (!crtc)
+	return RRErrorBase + BadRRCrtc;
+    
+    len = client-&gt;req_len - (sizeof (xRRSetCrtcGammaReq) &gt;&gt; 2);
+    if (len &lt; (stuff-&gt;size * 3 + 1) &gt;&gt; 1)
+	return BadLength;
+
+    if (stuff-&gt;size != crtc-&gt;gammaSize)
+	return BadMatch;
+    
+    red = (CARD16 *) (stuff + 1);
+    green = red + crtc-&gt;gammaSize;
+    blue = green + crtc-&gt;gammaSize;
+    
+    RRCrtcGammaSet (crtc, red, green, blue);
+
+    return Success;
+}
+
diff --git a/nx-X11/programs/Xserver/randr/rrdispatch.c b/nx-X11/programs/Xserver/randr/rrdispatch.c
new file mode 100644
index 0000000..3d52b38
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrdispatch.c
@@ -0,0 +1,219 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include &quot;randrstr.h&quot;
+
+#define SERVER_RANDR_MAJOR	1
+#define SERVER_RANDR_MINOR	2
+
+Bool
+RRClientKnowsRates (ClientPtr	pClient)
+{
+    rrClientPriv(pClient);
+
+    return (pRRClient-&gt;major_version &gt; 1 ||
+	    (pRRClient-&gt;major_version == 1 &amp;&amp; pRRClient-&gt;minor_version &gt;= 1));
+}
+
+static int
+ProcRRQueryVersion (ClientPtr client)
+{
+    xRRQueryVersionReply rep;
+    register int n;
+    REQUEST(xRRQueryVersionReq);
+    rrClientPriv(client);
+
+    REQUEST_SIZE_MATCH(xRRQueryVersionReq);
+    pRRClient-&gt;major_version = stuff-&gt;majorVersion;
+    pRRClient-&gt;minor_version = stuff-&gt;minorVersion;
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    /*
+     * Report the current version; the current
+     * spec says they're all compatible after 1.0
+     */
+    rep.majorVersion = SERVER_RANDR_MAJOR;
+    rep.minorVersion = SERVER_RANDR_MINOR;
+    if (client-&gt;swapped) {
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.majorVersion, n);
+	swapl(&amp;rep.minorVersion, n);
+    }
+    WriteToClient(client, sizeof(xRRQueryVersionReply), (char *)&amp;rep);
+    return (client-&gt;noClientException);
+}
+
+static int
+ProcRRSelectInput (ClientPtr client)
+{
+    REQUEST(xRRSelectInputReq);
+    rrClientPriv(client);
+    RRTimesPtr	pTimes;
+    WindowPtr	pWin;
+    RREventPtr	pRREvent, *pHead;
+    XID		clientResource;
+    int		rc;
+
+    REQUEST_SIZE_MATCH(xRRSelectInputReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixWriteAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityWriteAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+    pHead = (RREventPtr *)SecurityLookupIDByType(client,
+						 pWin-&gt;drawable.id, RREventType,
+						 DixWriteAccess);
+
+    if (stuff-&gt;enable &amp; (RRScreenChangeNotifyMask|
+			 RRCrtcChangeNotifyMask|
+			 RROutputChangeNotifyMask)) 
+    {
+	ScreenPtr	pScreen = pWin-&gt;drawable.pScreen;
+	rrScrPriv	(pScreen);
+
+	pRREvent = NULL;
+	if (pHead) 
+	{
+	    /* check for existing entry. */
+	    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent-&gt;next)
+		if (pRREvent-&gt;client == client)
+		    break;
+	}
+
+	if (!pRREvent)
+	{
+	    /* build the entry */
+	    pRREvent = (RREventPtr) xalloc (sizeof (RREventRec));
+	    if (!pRREvent)
+		return BadAlloc;
+	    pRREvent-&gt;next = 0;
+	    pRREvent-&gt;client = client;
+	    pRREvent-&gt;window = pWin;
+	    pRREvent-&gt;mask = stuff-&gt;enable;
+	    /*
+	     * add a resource that will be deleted when
+	     * the client goes away
+	     */
+	    clientResource = FakeClientID (client-&gt;index);
+	    pRREvent-&gt;clientResource = clientResource;
+	    if (!AddResource (clientResource, RRClientType, (pointer)pRREvent))
+		return BadAlloc;
+	    /*
+	     * create a resource to contain a pointer to the list
+	     * of clients selecting input.  This must be indirect as
+	     * the list may be arbitrarily rearranged which cannot be
+	     * done through the resource database.
+	     */
+	    if (!pHead)
+	    {
+		pHead = (RREventPtr *) xalloc (sizeof (RREventPtr));
+		if (!pHead ||
+		    !AddResource (pWin-&gt;drawable.id, RREventType, (pointer)pHead))
+		{
+		    FreeResource (clientResource, RT_NONE);
+		    return BadAlloc;
+		}
+		*pHead = 0;
+	    }
+	    pRREvent-&gt;next = *pHead;
+	    *pHead = pRREvent;
+	}
+	/*
+	 * Now see if the client needs an event
+	 */
+	if (pScrPriv &amp;&amp; (pRREvent-&gt;mask &amp; RRScreenChangeNotifyMask))
+	{
+	    pTimes = &amp;((RRTimesPtr) (pRRClient + 1))[pScreen-&gt;myNum];
+	    if (CompareTimeStamps (pTimes-&gt;setTime, 
+				   pScrPriv-&gt;lastSetTime) != 0 ||
+		CompareTimeStamps (pTimes-&gt;configTime, 
+				   pScrPriv-&gt;lastConfigTime) != 0)
+	    {
+		RRDeliverScreenEvent (client, pWin, pScreen);
+	    }
+	}
+    }
+    else if (stuff-&gt;enable == 0) 
+    {
+	/* delete the interest */
+	if (pHead) {
+	    RREventPtr pNewRREvent = 0;
+	    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent-&gt;next) {
+		if (pRREvent-&gt;client == client)
+		    break;
+		pNewRREvent = pRREvent;
+	    }
+	    if (pRREvent) {
+		FreeResource (pRREvent-&gt;clientResource, RRClientType);
+		if (pNewRREvent)
+		    pNewRREvent-&gt;next = pRREvent-&gt;next;
+		else
+		    *pHead = pRREvent-&gt;next;
+		xfree (pRREvent);
+	    }
+	}
+    }
+    else 
+    {
+	client-&gt;errorValue = stuff-&gt;enable;
+	return BadValue;
+    }
+    return Success;
+}
+
+int (*ProcRandrVector[RRNumberRequests])(ClientPtr) = {
+    ProcRRQueryVersion,	/* 0 */
+/* we skip 1 to make old clients fail pretty immediately */
+    NULL,			/* 1 ProcRandrOldGetScreenInfo */
+/* V1.0 apps share the same set screen config request id */
+    ProcRRSetScreenConfig,	/* 2 */
+    NULL,			/* 3 ProcRandrOldScreenChangeSelectInput */
+/* 3 used to be ScreenChangeSelectInput; deprecated */
+    ProcRRSelectInput,		/* 4 */
+    ProcRRGetScreenInfo,    	/* 5 */
+/* V1.2 additions */
+    ProcRRGetScreenSizeRange,	/* 6 */
+    ProcRRSetScreenSize,	/* 7 */
+    ProcRRGetScreenResources,	/* 8 */
+    ProcRRGetOutputInfo,	/* 9 */
+    ProcRRListOutputProperties,	/* 10 */
+    ProcRRQueryOutputProperty,	/* 11 */
+    ProcRRConfigureOutputProperty,  /* 12 */
+    ProcRRChangeOutputProperty,	/* 13 */
+    ProcRRDeleteOutputProperty,	/* 14 */
+    ProcRRGetOutputProperty,	/* 15 */
+    ProcRRCreateMode,		/* 16 */
+    ProcRRDestroyMode,		/* 17 */
+    ProcRRAddOutputMode,	/* 18 */
+    ProcRRDeleteOutputMode,	/* 19 */
+    ProcRRGetCrtcInfo,		/* 20 */
+    ProcRRSetCrtcConfig,	/* 21 */
+    ProcRRGetCrtcGammaSize,	/* 22 */
+    ProcRRGetCrtcGamma,		/* 23 */
+    ProcRRSetCrtcGamma,		/* 24 */
+};
+
diff --git a/nx-X11/programs/Xserver/randr/rrdispatch.c.X.original b/nx-X11/programs/Xserver/randr/rrdispatch.c.X.original
new file mode 100644
index 0000000..5525427
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrdispatch.c.X.original
@@ -0,0 +1,214 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include &quot;randrstr.h&quot;
+
+#define SERVER_RANDR_MAJOR	1
+#define SERVER_RANDR_MINOR	2
+
+Bool
+RRClientKnowsRates (ClientPtr	pClient)
+{
+    rrClientPriv(pClient);
+
+    return (pRRClient-&gt;major_version &gt; 1 ||
+	    (pRRClient-&gt;major_version == 1 &amp;&amp; pRRClient-&gt;minor_version &gt;= 1));
+}
+
+static int
+ProcRRQueryVersion (ClientPtr client)
+{
+    xRRQueryVersionReply rep;
+    register int n;
+    REQUEST(xRRQueryVersionReq);
+    rrClientPriv(client);
+
+    REQUEST_SIZE_MATCH(xRRQueryVersionReq);
+    pRRClient-&gt;major_version = stuff-&gt;majorVersion;
+    pRRClient-&gt;minor_version = stuff-&gt;minorVersion;
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    /*
+     * Report the current version; the current
+     * spec says they're all compatible after 1.0
+     */
+    rep.majorVersion = SERVER_RANDR_MAJOR;
+    rep.minorVersion = SERVER_RANDR_MINOR;
+    if (client-&gt;swapped) {
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.majorVersion, n);
+	swapl(&amp;rep.minorVersion, n);
+    }
+    WriteToClient(client, sizeof(xRRQueryVersionReply), (char *)&amp;rep);
+    return (client-&gt;noClientException);
+}
+
+static int
+ProcRRSelectInput (ClientPtr client)
+{
+    REQUEST(xRRSelectInputReq);
+    rrClientPriv(client);
+    RRTimesPtr	pTimes;
+    WindowPtr	pWin;
+    RREventPtr	pRREvent, *pHead;
+    XID		clientResource;
+    int		rc;
+
+    REQUEST_SIZE_MATCH(xRRSelectInputReq);
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixWriteAccess);
+    if (rc != Success)
+	return rc;
+    pHead = (RREventPtr *)SecurityLookupIDByType(client,
+						 pWin-&gt;drawable.id, RREventType,
+						 DixWriteAccess);
+
+    if (stuff-&gt;enable &amp; (RRScreenChangeNotifyMask|
+			 RRCrtcChangeNotifyMask|
+			 RROutputChangeNotifyMask)) 
+    {
+	ScreenPtr	pScreen = pWin-&gt;drawable.pScreen;
+	rrScrPriv	(pScreen);
+
+	pRREvent = NULL;
+	if (pHead) 
+	{
+	    /* check for existing entry. */
+	    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent-&gt;next)
+		if (pRREvent-&gt;client == client)
+		    break;
+	}
+
+	if (!pRREvent)
+	{
+	    /* build the entry */
+	    pRREvent = (RREventPtr) xalloc (sizeof (RREventRec));
+	    if (!pRREvent)
+		return BadAlloc;
+	    pRREvent-&gt;next = 0;
+	    pRREvent-&gt;client = client;
+	    pRREvent-&gt;window = pWin;
+	    pRREvent-&gt;mask = stuff-&gt;enable;
+	    /*
+	     * add a resource that will be deleted when
+	     * the client goes away
+	     */
+	    clientResource = FakeClientID (client-&gt;index);
+	    pRREvent-&gt;clientResource = clientResource;
+	    if (!AddResource (clientResource, RRClientType, (pointer)pRREvent))
+		return BadAlloc;
+	    /*
+	     * create a resource to contain a pointer to the list
+	     * of clients selecting input.  This must be indirect as
+	     * the list may be arbitrarily rearranged which cannot be
+	     * done through the resource database.
+	     */
+	    if (!pHead)
+	    {
+		pHead = (RREventPtr *) xalloc (sizeof (RREventPtr));
+		if (!pHead ||
+		    !AddResource (pWin-&gt;drawable.id, RREventType, (pointer)pHead))
+		{
+		    FreeResource (clientResource, RT_NONE);
+		    return BadAlloc;
+		}
+		*pHead = 0;
+	    }
+	    pRREvent-&gt;next = *pHead;
+	    *pHead = pRREvent;
+	}
+	/*
+	 * Now see if the client needs an event
+	 */
+	if (pScrPriv &amp;&amp; (pRREvent-&gt;mask &amp; RRScreenChangeNotifyMask))
+	{
+	    pTimes = &amp;((RRTimesPtr) (pRRClient + 1))[pScreen-&gt;myNum];
+	    if (CompareTimeStamps (pTimes-&gt;setTime, 
+				   pScrPriv-&gt;lastSetTime) != 0 ||
+		CompareTimeStamps (pTimes-&gt;configTime, 
+				   pScrPriv-&gt;lastConfigTime) != 0)
+	    {
+		RRDeliverScreenEvent (client, pWin, pScreen);
+	    }
+	}
+    }
+    else if (stuff-&gt;enable == 0) 
+    {
+	/* delete the interest */
+	if (pHead) {
+	    RREventPtr pNewRREvent = 0;
+	    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent-&gt;next) {
+		if (pRREvent-&gt;client == client)
+		    break;
+		pNewRREvent = pRREvent;
+	    }
+	    if (pRREvent) {
+		FreeResource (pRREvent-&gt;clientResource, RRClientType);
+		if (pNewRREvent)
+		    pNewRREvent-&gt;next = pRREvent-&gt;next;
+		else
+		    *pHead = pRREvent-&gt;next;
+		xfree (pRREvent);
+	    }
+	}
+    }
+    else 
+    {
+	client-&gt;errorValue = stuff-&gt;enable;
+	return BadValue;
+    }
+    return Success;
+}
+
+int (*ProcRandrVector[RRNumberRequests])(ClientPtr) = {
+    ProcRRQueryVersion,	/* 0 */
+/* we skip 1 to make old clients fail pretty immediately */
+    NULL,			/* 1 ProcRandrOldGetScreenInfo */
+/* V1.0 apps share the same set screen config request id */
+    ProcRRSetScreenConfig,	/* 2 */
+    NULL,			/* 3 ProcRandrOldScreenChangeSelectInput */
+/* 3 used to be ScreenChangeSelectInput; deprecated */
+    ProcRRSelectInput,		/* 4 */
+    ProcRRGetScreenInfo,    	/* 5 */
+/* V1.2 additions */
+    ProcRRGetScreenSizeRange,	/* 6 */
+    ProcRRSetScreenSize,	/* 7 */
+    ProcRRGetScreenResources,	/* 8 */
+    ProcRRGetOutputInfo,	/* 9 */
+    ProcRRListOutputProperties,	/* 10 */
+    ProcRRQueryOutputProperty,	/* 11 */
+    ProcRRConfigureOutputProperty,  /* 12 */
+    ProcRRChangeOutputProperty,	/* 13 */
+    ProcRRDeleteOutputProperty,	/* 14 */
+    ProcRRGetOutputProperty,	/* 15 */
+    ProcRRCreateMode,		/* 16 */
+    ProcRRDestroyMode,		/* 17 */
+    ProcRRAddOutputMode,	/* 18 */
+    ProcRRDeleteOutputMode,	/* 19 */
+    ProcRRGetCrtcInfo,		/* 20 */
+    ProcRRSetCrtcConfig,	/* 21 */
+    ProcRRGetCrtcGammaSize,	/* 22 */
+    ProcRRGetCrtcGamma,		/* 23 */
+    ProcRRSetCrtcGamma,		/* 24 */
+};
+
diff --git a/nx-X11/programs/Xserver/randr/rrinfo.c b/nx-X11/programs/Xserver/randr/rrinfo.c
new file mode 100644
index 0000000..7e77d39
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrinfo.c
@@ -0,0 +1,335 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include &quot;randrstr.h&quot;
+
+#ifdef RANDR_10_INTERFACE
+static RRModePtr
+RROldModeAdd (RROutputPtr output, RRScreenSizePtr size, int refresh)
+{
+    ScreenPtr	pScreen = output-&gt;pScreen;
+    rrScrPriv(pScreen);
+    xRRModeInfo	modeInfo;
+    char	name[100];
+    RRModePtr	mode;
+    int		i;
+    RRModePtr   *modes;
+    
+    memset (&amp;modeInfo, '\0', sizeof (modeInfo));
+    sprintf (name, &quot;%dx%d&quot;, size-&gt;width, size-&gt;height);
+    
+    modeInfo.width = size-&gt;width;
+    modeInfo.height = size-&gt;height;
+    modeInfo.hTotal = size-&gt;width;
+    modeInfo.vTotal = size-&gt;height;
+    modeInfo.dotClock = ((CARD32) size-&gt;width * (CARD32) size-&gt;height *
+			 (CARD32) refresh);
+    modeInfo.nameLength = strlen (name);
+    mode = RRModeGet (&amp;modeInfo, name);
+    if (!mode)
+	return NULL;
+    for (i = 0; i &lt; output-&gt;numModes; i++)
+	if (output-&gt;modes[i] == mode)
+	{
+	    RRModeDestroy (mode);
+	    return mode;
+	}
+    
+    if (output-&gt;numModes)
+	modes = xrealloc (output-&gt;modes, 
+			  (output-&gt;numModes + 1) * sizeof (RRModePtr));
+    else
+	modes = xalloc (sizeof (RRModePtr));
+    if (!modes)
+    {
+	RRModeDestroy (mode);
+	FreeResource (mode-&gt;mode.id, 0);
+	return NULL;
+    }
+    modes[output-&gt;numModes++] = mode;
+    output-&gt;modes = modes;
+    output-&gt;changed = TRUE;
+    pScrPriv-&gt;changed = TRUE;
+    pScrPriv-&gt;configChanged = TRUE;
+    return mode;
+}
+
+static void
+RRScanOldConfig (ScreenPtr pScreen, Rotation rotations)
+{
+    rrScrPriv(pScreen);
+    RROutputPtr	output;
+    RRCrtcPtr	crtc;
+    RRModePtr	mode, newMode = NULL;
+    int		i;
+    CARD16	minWidth = MAXSHORT, minHeight = MAXSHORT;
+    CARD16	maxWidth = 0, maxHeight = 0;
+    
+    /*
+     * First time through, create a crtc and output and hook
+     * them together
+     */
+    if (pScrPriv-&gt;numOutputs == 0 &amp;&amp;
+	pScrPriv-&gt;numCrtcs == 0)
+    {
+	crtc = RRCrtcCreate (pScreen, NULL);
+	if (!crtc)
+	    return;
+	output = RROutputCreate (pScreen, &quot;default&quot;, 7, NULL);
+	if (!output)
+	    return;
+	RROutputSetCrtcs (output, &amp;crtc, 1);
+	RROutputSetConnection (output, RR_Connected);
+#ifdef RENDER
+	RROutputSetSubpixelOrder (output, PictureGetSubpixelOrder (pScreen));
+#endif
+    }
+
+    output = pScrPriv-&gt;outputs[0];
+    if (!output)
+	return;
+    crtc = pScrPriv-&gt;crtcs[0];
+    if (!crtc)
+	return;
+
+    /* check rotations */
+    if (rotations != crtc-&gt;rotations)
+    {
+        crtc-&gt;rotations = rotations;
+	crtc-&gt;changed = TRUE;
+	pScrPriv-&gt;changed = TRUE;
+    }
+	
+    /* regenerate mode list */
+    for (i = 0; i &lt; pScrPriv-&gt;nSizes; i++)
+    {
+	RRScreenSizePtr	size = &amp;pScrPriv-&gt;pSizes[i];
+	int		r;
+
+	if (size-&gt;nRates)
+	{
+	    for (r = 0; r &lt; size-&gt;nRates; r++)
+	    {
+		mode = RROldModeAdd (output, size, size-&gt;pRates[r].rate);
+		if (i == pScrPriv-&gt;size &amp;&amp; 
+		    size-&gt;pRates[r].rate == pScrPriv-&gt;rate)
+		{
+		    newMode = mode;
+		}
+	    }
+	    xfree (size-&gt;pRates);
+	}
+	else
+	{
+	    mode = RROldModeAdd (output, size, 0);
+	    if (i == pScrPriv-&gt;size)
+		newMode = mode;
+	}
+    }
+    if (pScrPriv-&gt;nSizes)
+	xfree (pScrPriv-&gt;pSizes);
+    pScrPriv-&gt;pSizes = NULL;
+    pScrPriv-&gt;nSizes = 0;
+	    
+    /* find size bounds */
+    for (i = 0; i &lt; output-&gt;numModes + output-&gt;numUserModes; i++) 
+    {
+	RRModePtr   mode = (i &lt; output-&gt;numModes ? 
+			    output-&gt;modes[i] : 
+			    output-&gt;userModes[i-output-&gt;numModes]);
+        CARD16	    width = mode-&gt;mode.width;
+        CARD16	    height = mode-&gt;mode.height;
+	
+	if (width &lt; minWidth) minWidth = width;
+	if (width &gt; maxWidth) maxWidth = width;
+	if (height &lt; minHeight) minHeight = height;
+	if (height &gt; maxHeight) maxHeight = height;
+    }
+
+    RRScreenSetSizeRange (pScreen, minWidth, minHeight, maxWidth, maxHeight);
+
+    /* notice current mode */
+    if (newMode)
+	RRCrtcNotify (crtc, newMode, 0, 0, pScrPriv-&gt;rotation,
+		      1, &amp;output);
+}
+#endif
+
+/*
+ * Poll the driver for changed information
+ */
+Bool
+RRGetInfo (ScreenPtr pScreen)
+{
+    rrScrPriv (pScreen);
+    Rotation	    rotations;
+    int		    i;
+
+    for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	pScrPriv-&gt;outputs[i]-&gt;changed = FALSE;
+    for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	pScrPriv-&gt;crtcs[i]-&gt;changed = FALSE;
+    
+    rotations = 0;
+    pScrPriv-&gt;changed = FALSE;
+    pScrPriv-&gt;configChanged = FALSE;
+    
+    if (!(*pScrPriv-&gt;rrGetInfo) (pScreen, &amp;rotations))
+	return FALSE;
+
+#if RANDR_10_INTERFACE
+    if (pScrPriv-&gt;nSizes)
+	RRScanOldConfig (pScreen, rotations);
+#endif
+    RRTellChanged (pScreen);
+    return TRUE;
+}
+
+/*
+ * Register the range of sizes for the screen
+ */
+void
+RRScreenSetSizeRange (ScreenPtr	pScreen,
+		      CARD16	minWidth,
+		      CARD16	minHeight,
+		      CARD16	maxWidth,
+		      CARD16	maxHeight)
+{
+    rrScrPriv (pScreen);
+
+    if (!pScrPriv)
+	return;
+    if (pScrPriv-&gt;minWidth == minWidth &amp;&amp; pScrPriv-&gt;minHeight == minHeight &amp;&amp;
+	pScrPriv-&gt;maxWidth == maxWidth &amp;&amp; pScrPriv-&gt;maxHeight == maxHeight)
+    {
+	return;
+    }
+	
+    pScrPriv-&gt;minWidth  = minWidth;
+    pScrPriv-&gt;minHeight = minHeight;
+    pScrPriv-&gt;maxWidth  = maxWidth;
+    pScrPriv-&gt;maxHeight = maxHeight;
+    pScrPriv-&gt;changed = TRUE;
+    pScrPriv-&gt;configChanged = TRUE;
+}
+
+#ifdef RANDR_10_INTERFACE
+static Bool
+RRScreenSizeMatches (RRScreenSizePtr  a,
+		   RRScreenSizePtr  b)
+{
+    if (a-&gt;width != b-&gt;width)
+	return FALSE;
+    if (a-&gt;height != b-&gt;height)
+	return FALSE;
+    if (a-&gt;mmWidth != b-&gt;mmWidth)
+	return FALSE;
+    if (a-&gt;mmHeight != b-&gt;mmHeight)
+	return FALSE;
+    return TRUE;
+}
+
+RRScreenSizePtr
+RRRegisterSize (ScreenPtr	    pScreen,
+		short		    width, 
+		short		    height,
+		short		    mmWidth,
+		short		    mmHeight)
+{
+    rrScrPriv (pScreen);
+    int		    i;
+    RRScreenSize    tmp;
+    RRScreenSizePtr pNew;
+
+    if (!pScrPriv)
+	return 0;
+    
+    tmp.id = 0;
+    tmp.width = width;
+    tmp.height= height;
+    tmp.mmWidth = mmWidth;
+    tmp.mmHeight = mmHeight;
+    tmp.pRates = 0;
+    tmp.nRates = 0;
+    for (i = 0; i &lt; pScrPriv-&gt;nSizes; i++)
+	if (RRScreenSizeMatches (&amp;tmp, &amp;pScrPriv-&gt;pSizes[i]))
+	    return &amp;pScrPriv-&gt;pSizes[i];
+    pNew = xrealloc (pScrPriv-&gt;pSizes,
+		     (pScrPriv-&gt;nSizes + 1) * sizeof (RRScreenSize));
+    if (!pNew)
+	return 0;
+    pNew[pScrPriv-&gt;nSizes++] = tmp;
+    pScrPriv-&gt;pSizes = pNew;
+    return &amp;pNew[pScrPriv-&gt;nSizes-1];
+}
+
+Bool RRRegisterRate (ScreenPtr		pScreen,
+		     RRScreenSizePtr	pSize,
+		     int		rate)
+{
+    rrScrPriv(pScreen);
+    int		    i;
+    RRScreenRatePtr pNew, pRate;
+
+    if (!pScrPriv)
+	return FALSE;
+    
+    for (i = 0; i &lt; pSize-&gt;nRates; i++)
+	if (pSize-&gt;pRates[i].rate == rate)
+	    return TRUE;
+
+    pNew = xrealloc (pSize-&gt;pRates,
+		     (pSize-&gt;nRates + 1) * sizeof (RRScreenRate));
+    if (!pNew)
+	return FALSE;
+    pRate = &amp;pNew[pSize-&gt;nRates++];
+    pRate-&gt;rate = rate;
+    pSize-&gt;pRates = pNew;
+    return TRUE;
+}
+
+Rotation
+RRGetRotation(ScreenPtr pScreen)
+{
+    RROutputPtr	output = RRFirstOutput (pScreen);
+
+    if (!output)
+	return RR_Rotate_0;
+
+    return output-&gt;crtc-&gt;rotation;
+}
+
+void
+RRSetCurrentConfig (ScreenPtr		pScreen,
+		    Rotation		rotation,
+		    int			rate,
+		    RRScreenSizePtr	pSize)
+{
+    rrScrPriv (pScreen);
+
+    if (!pScrPriv)
+	return;
+    pScrPriv-&gt;size = pSize - pScrPriv-&gt;pSizes;
+    pScrPriv-&gt;rotation = rotation;
+    pScrPriv-&gt;rate = rate;
+}
+#endif
diff --git a/nx-X11/programs/Xserver/randr/rrmode.c b/nx-X11/programs/Xserver/randr/rrmode.c
new file mode 100644
index 0000000..62c0148
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrmode.c
@@ -0,0 +1,420 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &quot;randrstr.h&quot;
+#include &quot;registry.h&quot;
+
+RESTYPE	RRModeType;
+
+static Bool
+RRModeEqual (xRRModeInfo *a, xRRModeInfo *b)
+{
+    if (a-&gt;width != b-&gt;width) return FALSE;
+    if (a-&gt;height != b-&gt;height) return FALSE;
+    if (a-&gt;dotClock != b-&gt;dotClock) return FALSE;
+    if (a-&gt;hSyncStart != b-&gt;hSyncStart) return FALSE;
+    if (a-&gt;hSyncEnd != b-&gt;hSyncEnd) return FALSE;
+    if (a-&gt;hTotal != b-&gt;hTotal) return FALSE;
+    if (a-&gt;hSkew != b-&gt;hSkew) return FALSE;
+    if (a-&gt;vSyncStart != b-&gt;vSyncStart) return FALSE;
+    if (a-&gt;vSyncEnd != b-&gt;vSyncEnd) return FALSE;
+    if (a-&gt;vTotal != b-&gt;vTotal) return FALSE;
+    if (a-&gt;nameLength != b-&gt;nameLength) return FALSE;
+    if (a-&gt;modeFlags != b-&gt;modeFlags) return FALSE;
+    return TRUE;
+}
+
+/*
+ * Keep a list so it's easy to find modes in the resource database.
+ */
+static int	    num_modes;
+static RRModePtr    *modes;
+
+static RRModePtr
+RRModeCreate (xRRModeInfo   *modeInfo,
+	      const char    *name,
+	      ScreenPtr	    userScreen)
+{
+    RRModePtr	mode, *newModes;
+    
+    if (!RRInit ())
+	return NULL;
+
+    mode = xalloc (sizeof (RRModeRec) + modeInfo-&gt;nameLength + 1);
+    if (!mode)
+	return NULL;
+    mode-&gt;refcnt = 1;
+    mode-&gt;mode = *modeInfo;
+    mode-&gt;name = (char *) (mode + 1);
+    memcpy (mode-&gt;name, name, modeInfo-&gt;nameLength);
+    mode-&gt;name[modeInfo-&gt;nameLength] = '\0';
+    mode-&gt;userScreen = userScreen;
+
+    if (num_modes)
+	newModes = xrealloc (modes, (num_modes + 1) * sizeof (RRModePtr));
+    else
+	newModes = xalloc (sizeof (RRModePtr));
+
+    if (!newModes)
+    {
+	xfree (mode);
+	return NULL;
+    }
+
+    mode-&gt;mode.id = FakeClientID(0);
+    if (!AddResource (mode-&gt;mode.id, RRModeType, (pointer) mode))
+	return NULL;
+    modes = newModes;
+    modes[num_modes++] = mode;
+    
+    /*
+     * give the caller a reference to this mode
+     */
+    ++mode-&gt;refcnt;
+    return mode;
+}
+
+static RRModePtr
+RRModeFindByName (const char	*name,
+		  CARD16    	nameLength)
+{
+    int		i;
+    RRModePtr	mode;
+
+    for (i = 0; i &lt; num_modes; i++)
+    {
+	mode = modes[i];
+	if (mode-&gt;mode.nameLength == nameLength &amp;&amp;
+	    !memcmp (name, mode-&gt;name, nameLength))
+	{
+	    return mode;
+	}
+    }
+    return NULL;
+}
+
+RRModePtr
+RRModeGet (xRRModeInfo	*modeInfo,
+	   const char	*name)
+{
+    int	i;
+
+    for (i = 0; i &lt; num_modes; i++)
+    {
+	RRModePtr   mode = modes[i];
+	if (RRModeEqual (&amp;mode-&gt;mode, modeInfo) &amp;&amp;
+	    !memcmp (name, mode-&gt;name, modeInfo-&gt;nameLength))
+	{
+	    ++mode-&gt;refcnt;
+	    return mode;
+	}
+    }
+
+    return RRModeCreate (modeInfo, name, NULL);
+}
+
+static RRModePtr
+RRModeCreateUser (ScreenPtr	pScreen,
+		  xRRModeInfo	*modeInfo,
+		  const char	*name,
+		  int		*error)
+{
+    RRModePtr	mode;
+
+    mode = RRModeFindByName (name, modeInfo-&gt;nameLength);
+    if (mode)
+    {
+	*error = BadName;
+	return NULL;
+    }
+    
+    mode = RRModeCreate (modeInfo, name, pScreen);
+    if (!mode)
+    {
+	*error = BadAlloc;
+	return NULL;
+    }
+    *error = Success;
+    return mode;
+}
+
+RRModePtr *
+RRModesForScreen (ScreenPtr pScreen, int *num_ret)
+{
+    rrScrPriv(pScreen);
+    int		o, c, m;
+    RRModePtr	*screen_modes;
+    int		num_screen_modes = 0;
+
+    screen_modes = xalloc ((num_modes ? num_modes : 1) * sizeof (RRModePtr));
+    if (!screen_modes)
+	return NULL;
+    
+    /*
+     * Add modes from all outputs
+     */
+    for (o = 0; o &lt; pScrPriv-&gt;numOutputs; o++)
+    {
+	RROutputPtr	output = pScrPriv-&gt;outputs[o];
+	int		m, n;
+
+	for (m = 0; m &lt; output-&gt;numModes + output-&gt;numUserModes; m++)
+	{
+	    RRModePtr   mode = (m &lt; output-&gt;numModes ? 
+				output-&gt;modes[m] : 
+				output-&gt;userModes[m-output-&gt;numModes]);
+	    for (n = 0; n &lt; num_screen_modes; n++)
+		if (screen_modes[n] == mode)
+		    break;
+	    if (n == num_screen_modes)
+		screen_modes[num_screen_modes++] = mode;
+	}
+    }
+    /*
+     * Add modes from all crtcs. The goal is to
+     * make sure all available and active modes
+     * are visible to the client
+     */
+    for (c = 0; c &lt; pScrPriv-&gt;numCrtcs; c++)
+    {
+	RRCrtcPtr	crtc = pScrPriv-&gt;crtcs[c];
+	RRModePtr	mode = crtc-&gt;mode;
+	int		n;
+
+	if (!mode) continue;
+	for (n = 0; n &lt; num_screen_modes; n++)
+	    if (screen_modes[n] == mode)
+		break;
+	if (n == num_screen_modes)
+	    screen_modes[num_screen_modes++] = mode;
+    }
+    /*
+     * Add all user modes for this screen
+     */
+    for (m = 0; m &lt; num_modes; m++)
+    {
+	RRModePtr	mode = modes[m];
+	int		n;
+
+	if (mode-&gt;userScreen != pScreen)
+	    continue;
+	for (n = 0; n &lt; num_screen_modes; n++)
+	    if (screen_modes[n] == mode)
+		break;
+	if (n == num_screen_modes)
+	    screen_modes[num_screen_modes++] = mode;
+    }
+    
+    *num_ret = num_screen_modes;
+    return screen_modes;
+}
+
+void
+RRModeDestroy (RRModePtr mode)
+{
+    int	m;
+    
+    if (--mode-&gt;refcnt &gt; 0)
+	return;
+    for (m = 0; m &lt; num_modes; m++)
+    {
+	if (modes[m] == mode)
+	{
+	    memmove (modes + m, modes + m + 1,
+		     (num_modes - m - 1) * sizeof (RRModePtr));
+	    num_modes--;
+	    if (!num_modes)
+	    {
+		xfree (modes);
+		modes = NULL;
+	    }
+	    break;
+	}
+    }
+    
+    xfree (mode);
+}
+
+static int
+RRModeDestroyResource (pointer value, XID pid)
+{
+    RRModeDestroy ((RRModePtr) value);
+    return 1;
+}
+
+Bool
+RRModeInit (void)
+{
+    assert (num_modes == 0);
+    assert (modes == NULL);
+    RRModeType = CreateNewResourceType (RRModeDestroyResource);
+    if (!RRModeType)
+	return FALSE;
+    RegisterResourceName (RRModeType, &quot;MODE&quot;);
+    return TRUE;
+}
+
+int
+ProcRRCreateMode (ClientPtr client)
+{
+    REQUEST(xRRCreateModeReq);
+    xRRCreateModeReply	rep;
+    WindowPtr		pWin;
+    ScreenPtr		pScreen;
+    rrScrPrivPtr	pScrPriv;
+    xRRModeInfo		*modeInfo;
+    long		units_after;
+    char		*name;
+    int			error, rc;
+    RRModePtr		mode;
+    
+    REQUEST_AT_LEAST_SIZE (xRRCreateModeReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    modeInfo = &amp;stuff-&gt;modeInfo;
+    name = (char *) (stuff + 1);
+    units_after = (stuff-&gt;length - (sizeof (xRRCreateModeReq) &gt;&gt; 2));
+
+    /* check to make sure requested name fits within the data provided */
+    if ((int) (modeInfo-&gt;nameLength + 3) &gt;&gt; 2 &gt; units_after)
+	return BadLength;
+
+    mode = RRModeCreateUser (pScreen, modeInfo, name, &amp;error);
+    if (!mode)
+	return error;
+
+    rep.type = X_Reply;
+    rep.pad0 = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.length = 0;
+    rep.mode = mode-&gt;mode.id;
+    if (client-&gt;swapped)
+    {
+	int n;
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.mode, n);
+    }
+    WriteToClient(client, sizeof(xRRCreateModeReply), (char *)&amp;rep);
+    
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRDestroyMode (ClientPtr client)
+{
+    REQUEST(xRRDestroyModeReq);
+    RRModePtr	mode;
+    
+    REQUEST_SIZE_MATCH(xRRDestroyModeReq);
+    mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+    if (!mode)
+    {
+	client-&gt;errorValue = stuff-&gt;mode;
+	return RRErrorBase + BadRRMode;
+    }
+    if (!mode-&gt;userScreen)
+	return BadMatch;
+    if (mode-&gt;refcnt &gt; 1)
+	return BadAccess;
+    FreeResource (stuff-&gt;mode, 0);
+    return Success;
+}
+
+int
+ProcRRAddOutputMode (ClientPtr client)
+{
+    REQUEST(xRRAddOutputModeReq);
+    RRModePtr	mode;
+    RROutputPtr	output;
+    
+    REQUEST_SIZE_MATCH(xRRAddOutputModeReq);
+    output = LookupOutput(client, stuff-&gt;output, DixReadAccess);
+
+    if (!output)
+    {
+	client-&gt;errorValue = stuff-&gt;output;
+	return RRErrorBase + BadRROutput;
+    }
+    
+    mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+    if (!mode)
+    {
+	client-&gt;errorValue = stuff-&gt;mode;
+	return RRErrorBase + BadRRMode;
+    }
+    
+    return RROutputAddUserMode (output, mode);
+}
+
+int
+ProcRRDeleteOutputMode (ClientPtr client)
+{
+    REQUEST(xRRDeleteOutputModeReq);
+    RRModePtr	mode;
+    RROutputPtr	output;
+    
+    REQUEST_SIZE_MATCH(xRRDeleteOutputModeReq);
+    output = LookupOutput(client, stuff-&gt;output, DixReadAccess);
+
+    if (!output)
+    {
+	client-&gt;errorValue = stuff-&gt;output;
+	return RRErrorBase + BadRROutput;
+    }
+    
+    mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+    if (!mode)
+    {
+	client-&gt;errorValue = stuff-&gt;mode;
+	return RRErrorBase + BadRRMode;
+    }
+    
+    return RROutputDeleteUserMode (output, mode);
+}
diff --git a/nx-X11/programs/Xserver/randr/rrmode.c.NX.original b/nx-X11/programs/Xserver/randr/rrmode.c.NX.original
new file mode 100644
index 0000000..62c0148
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrmode.c.NX.original
@@ -0,0 +1,420 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &quot;randrstr.h&quot;
+#include &quot;registry.h&quot;
+
+RESTYPE	RRModeType;
+
+static Bool
+RRModeEqual (xRRModeInfo *a, xRRModeInfo *b)
+{
+    if (a-&gt;width != b-&gt;width) return FALSE;
+    if (a-&gt;height != b-&gt;height) return FALSE;
+    if (a-&gt;dotClock != b-&gt;dotClock) return FALSE;
+    if (a-&gt;hSyncStart != b-&gt;hSyncStart) return FALSE;
+    if (a-&gt;hSyncEnd != b-&gt;hSyncEnd) return FALSE;
+    if (a-&gt;hTotal != b-&gt;hTotal) return FALSE;
+    if (a-&gt;hSkew != b-&gt;hSkew) return FALSE;
+    if (a-&gt;vSyncStart != b-&gt;vSyncStart) return FALSE;
+    if (a-&gt;vSyncEnd != b-&gt;vSyncEnd) return FALSE;
+    if (a-&gt;vTotal != b-&gt;vTotal) return FALSE;
+    if (a-&gt;nameLength != b-&gt;nameLength) return FALSE;
+    if (a-&gt;modeFlags != b-&gt;modeFlags) return FALSE;
+    return TRUE;
+}
+
+/*
+ * Keep a list so it's easy to find modes in the resource database.
+ */
+static int	    num_modes;
+static RRModePtr    *modes;
+
+static RRModePtr
+RRModeCreate (xRRModeInfo   *modeInfo,
+	      const char    *name,
+	      ScreenPtr	    userScreen)
+{
+    RRModePtr	mode, *newModes;
+    
+    if (!RRInit ())
+	return NULL;
+
+    mode = xalloc (sizeof (RRModeRec) + modeInfo-&gt;nameLength + 1);
+    if (!mode)
+	return NULL;
+    mode-&gt;refcnt = 1;
+    mode-&gt;mode = *modeInfo;
+    mode-&gt;name = (char *) (mode + 1);
+    memcpy (mode-&gt;name, name, modeInfo-&gt;nameLength);
+    mode-&gt;name[modeInfo-&gt;nameLength] = '\0';
+    mode-&gt;userScreen = userScreen;
+
+    if (num_modes)
+	newModes = xrealloc (modes, (num_modes + 1) * sizeof (RRModePtr));
+    else
+	newModes = xalloc (sizeof (RRModePtr));
+
+    if (!newModes)
+    {
+	xfree (mode);
+	return NULL;
+    }
+
+    mode-&gt;mode.id = FakeClientID(0);
+    if (!AddResource (mode-&gt;mode.id, RRModeType, (pointer) mode))
+	return NULL;
+    modes = newModes;
+    modes[num_modes++] = mode;
+    
+    /*
+     * give the caller a reference to this mode
+     */
+    ++mode-&gt;refcnt;
+    return mode;
+}
+
+static RRModePtr
+RRModeFindByName (const char	*name,
+		  CARD16    	nameLength)
+{
+    int		i;
+    RRModePtr	mode;
+
+    for (i = 0; i &lt; num_modes; i++)
+    {
+	mode = modes[i];
+	if (mode-&gt;mode.nameLength == nameLength &amp;&amp;
+	    !memcmp (name, mode-&gt;name, nameLength))
+	{
+	    return mode;
+	}
+    }
+    return NULL;
+}
+
+RRModePtr
+RRModeGet (xRRModeInfo	*modeInfo,
+	   const char	*name)
+{
+    int	i;
+
+    for (i = 0; i &lt; num_modes; i++)
+    {
+	RRModePtr   mode = modes[i];
+	if (RRModeEqual (&amp;mode-&gt;mode, modeInfo) &amp;&amp;
+	    !memcmp (name, mode-&gt;name, modeInfo-&gt;nameLength))
+	{
+	    ++mode-&gt;refcnt;
+	    return mode;
+	}
+    }
+
+    return RRModeCreate (modeInfo, name, NULL);
+}
+
+static RRModePtr
+RRModeCreateUser (ScreenPtr	pScreen,
+		  xRRModeInfo	*modeInfo,
+		  const char	*name,
+		  int		*error)
+{
+    RRModePtr	mode;
+
+    mode = RRModeFindByName (name, modeInfo-&gt;nameLength);
+    if (mode)
+    {
+	*error = BadName;
+	return NULL;
+    }
+    
+    mode = RRModeCreate (modeInfo, name, pScreen);
+    if (!mode)
+    {
+	*error = BadAlloc;
+	return NULL;
+    }
+    *error = Success;
+    return mode;
+}
+
+RRModePtr *
+RRModesForScreen (ScreenPtr pScreen, int *num_ret)
+{
+    rrScrPriv(pScreen);
+    int		o, c, m;
+    RRModePtr	*screen_modes;
+    int		num_screen_modes = 0;
+
+    screen_modes = xalloc ((num_modes ? num_modes : 1) * sizeof (RRModePtr));
+    if (!screen_modes)
+	return NULL;
+    
+    /*
+     * Add modes from all outputs
+     */
+    for (o = 0; o &lt; pScrPriv-&gt;numOutputs; o++)
+    {
+	RROutputPtr	output = pScrPriv-&gt;outputs[o];
+	int		m, n;
+
+	for (m = 0; m &lt; output-&gt;numModes + output-&gt;numUserModes; m++)
+	{
+	    RRModePtr   mode = (m &lt; output-&gt;numModes ? 
+				output-&gt;modes[m] : 
+				output-&gt;userModes[m-output-&gt;numModes]);
+	    for (n = 0; n &lt; num_screen_modes; n++)
+		if (screen_modes[n] == mode)
+		    break;
+	    if (n == num_screen_modes)
+		screen_modes[num_screen_modes++] = mode;
+	}
+    }
+    /*
+     * Add modes from all crtcs. The goal is to
+     * make sure all available and active modes
+     * are visible to the client
+     */
+    for (c = 0; c &lt; pScrPriv-&gt;numCrtcs; c++)
+    {
+	RRCrtcPtr	crtc = pScrPriv-&gt;crtcs[c];
+	RRModePtr	mode = crtc-&gt;mode;
+	int		n;
+
+	if (!mode) continue;
+	for (n = 0; n &lt; num_screen_modes; n++)
+	    if (screen_modes[n] == mode)
+		break;
+	if (n == num_screen_modes)
+	    screen_modes[num_screen_modes++] = mode;
+    }
+    /*
+     * Add all user modes for this screen
+     */
+    for (m = 0; m &lt; num_modes; m++)
+    {
+	RRModePtr	mode = modes[m];
+	int		n;
+
+	if (mode-&gt;userScreen != pScreen)
+	    continue;
+	for (n = 0; n &lt; num_screen_modes; n++)
+	    if (screen_modes[n] == mode)
+		break;
+	if (n == num_screen_modes)
+	    screen_modes[num_screen_modes++] = mode;
+    }
+    
+    *num_ret = num_screen_modes;
+    return screen_modes;
+}
+
+void
+RRModeDestroy (RRModePtr mode)
+{
+    int	m;
+    
+    if (--mode-&gt;refcnt &gt; 0)
+	return;
+    for (m = 0; m &lt; num_modes; m++)
+    {
+	if (modes[m] == mode)
+	{
+	    memmove (modes + m, modes + m + 1,
+		     (num_modes - m - 1) * sizeof (RRModePtr));
+	    num_modes--;
+	    if (!num_modes)
+	    {
+		xfree (modes);
+		modes = NULL;
+	    }
+	    break;
+	}
+    }
+    
+    xfree (mode);
+}
+
+static int
+RRModeDestroyResource (pointer value, XID pid)
+{
+    RRModeDestroy ((RRModePtr) value);
+    return 1;
+}
+
+Bool
+RRModeInit (void)
+{
+    assert (num_modes == 0);
+    assert (modes == NULL);
+    RRModeType = CreateNewResourceType (RRModeDestroyResource);
+    if (!RRModeType)
+	return FALSE;
+    RegisterResourceName (RRModeType, &quot;MODE&quot;);
+    return TRUE;
+}
+
+int
+ProcRRCreateMode (ClientPtr client)
+{
+    REQUEST(xRRCreateModeReq);
+    xRRCreateModeReply	rep;
+    WindowPtr		pWin;
+    ScreenPtr		pScreen;
+    rrScrPrivPtr	pScrPriv;
+    xRRModeInfo		*modeInfo;
+    long		units_after;
+    char		*name;
+    int			error, rc;
+    RRModePtr		mode;
+    
+    REQUEST_AT_LEAST_SIZE (xRRCreateModeReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    modeInfo = &amp;stuff-&gt;modeInfo;
+    name = (char *) (stuff + 1);
+    units_after = (stuff-&gt;length - (sizeof (xRRCreateModeReq) &gt;&gt; 2));
+
+    /* check to make sure requested name fits within the data provided */
+    if ((int) (modeInfo-&gt;nameLength + 3) &gt;&gt; 2 &gt; units_after)
+	return BadLength;
+
+    mode = RRModeCreateUser (pScreen, modeInfo, name, &amp;error);
+    if (!mode)
+	return error;
+
+    rep.type = X_Reply;
+    rep.pad0 = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.length = 0;
+    rep.mode = mode-&gt;mode.id;
+    if (client-&gt;swapped)
+    {
+	int n;
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.mode, n);
+    }
+    WriteToClient(client, sizeof(xRRCreateModeReply), (char *)&amp;rep);
+    
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRDestroyMode (ClientPtr client)
+{
+    REQUEST(xRRDestroyModeReq);
+    RRModePtr	mode;
+    
+    REQUEST_SIZE_MATCH(xRRDestroyModeReq);
+    mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+    if (!mode)
+    {
+	client-&gt;errorValue = stuff-&gt;mode;
+	return RRErrorBase + BadRRMode;
+    }
+    if (!mode-&gt;userScreen)
+	return BadMatch;
+    if (mode-&gt;refcnt &gt; 1)
+	return BadAccess;
+    FreeResource (stuff-&gt;mode, 0);
+    return Success;
+}
+
+int
+ProcRRAddOutputMode (ClientPtr client)
+{
+    REQUEST(xRRAddOutputModeReq);
+    RRModePtr	mode;
+    RROutputPtr	output;
+    
+    REQUEST_SIZE_MATCH(xRRAddOutputModeReq);
+    output = LookupOutput(client, stuff-&gt;output, DixReadAccess);
+
+    if (!output)
+    {
+	client-&gt;errorValue = stuff-&gt;output;
+	return RRErrorBase + BadRROutput;
+    }
+    
+    mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+    if (!mode)
+    {
+	client-&gt;errorValue = stuff-&gt;mode;
+	return RRErrorBase + BadRRMode;
+    }
+    
+    return RROutputAddUserMode (output, mode);
+}
+
+int
+ProcRRDeleteOutputMode (ClientPtr client)
+{
+    REQUEST(xRRDeleteOutputModeReq);
+    RRModePtr	mode;
+    RROutputPtr	output;
+    
+    REQUEST_SIZE_MATCH(xRRDeleteOutputModeReq);
+    output = LookupOutput(client, stuff-&gt;output, DixReadAccess);
+
+    if (!output)
+    {
+	client-&gt;errorValue = stuff-&gt;output;
+	return RRErrorBase + BadRROutput;
+    }
+    
+    mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+    if (!mode)
+    {
+	client-&gt;errorValue = stuff-&gt;mode;
+	return RRErrorBase + BadRRMode;
+    }
+    
+    return RROutputDeleteUserMode (output, mode);
+}
diff --git a/nx-X11/programs/Xserver/randr/rrmode.c.X.original b/nx-X11/programs/Xserver/randr/rrmode.c.X.original
new file mode 100644
index 0000000..d507208
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrmode.c.X.original
@@ -0,0 +1,398 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include &quot;randrstr.h&quot;
+#include &quot;registry.h&quot;
+
+RESTYPE	RRModeType;
+
+static Bool
+RRModeEqual (xRRModeInfo *a, xRRModeInfo *b)
+{
+    if (a-&gt;width != b-&gt;width) return FALSE;
+    if (a-&gt;height != b-&gt;height) return FALSE;
+    if (a-&gt;dotClock != b-&gt;dotClock) return FALSE;
+    if (a-&gt;hSyncStart != b-&gt;hSyncStart) return FALSE;
+    if (a-&gt;hSyncEnd != b-&gt;hSyncEnd) return FALSE;
+    if (a-&gt;hTotal != b-&gt;hTotal) return FALSE;
+    if (a-&gt;hSkew != b-&gt;hSkew) return FALSE;
+    if (a-&gt;vSyncStart != b-&gt;vSyncStart) return FALSE;
+    if (a-&gt;vSyncEnd != b-&gt;vSyncEnd) return FALSE;
+    if (a-&gt;vTotal != b-&gt;vTotal) return FALSE;
+    if (a-&gt;nameLength != b-&gt;nameLength) return FALSE;
+    if (a-&gt;modeFlags != b-&gt;modeFlags) return FALSE;
+    return TRUE;
+}
+
+/*
+ * Keep a list so it's easy to find modes in the resource database.
+ */
+static int	    num_modes;
+static RRModePtr    *modes;
+
+static RRModePtr
+RRModeCreate (xRRModeInfo   *modeInfo,
+	      const char    *name,
+	      ScreenPtr	    userScreen)
+{
+    RRModePtr	mode, *newModes;
+    
+    if (!RRInit ())
+	return NULL;
+
+    mode = xalloc (sizeof (RRModeRec) + modeInfo-&gt;nameLength + 1);
+    if (!mode)
+	return NULL;
+    mode-&gt;refcnt = 1;
+    mode-&gt;mode = *modeInfo;
+    mode-&gt;name = (char *) (mode + 1);
+    memcpy (mode-&gt;name, name, modeInfo-&gt;nameLength);
+    mode-&gt;name[modeInfo-&gt;nameLength] = '\0';
+    mode-&gt;userScreen = userScreen;
+
+    if (num_modes)
+	newModes = xrealloc (modes, (num_modes + 1) * sizeof (RRModePtr));
+    else
+	newModes = xalloc (sizeof (RRModePtr));
+
+    if (!newModes)
+    {
+	xfree (mode);
+	return NULL;
+    }
+
+    mode-&gt;mode.id = FakeClientID(0);
+    if (!AddResource (mode-&gt;mode.id, RRModeType, (pointer) mode))
+	return NULL;
+    modes = newModes;
+    modes[num_modes++] = mode;
+    
+    /*
+     * give the caller a reference to this mode
+     */
+    ++mode-&gt;refcnt;
+    return mode;
+}
+
+static RRModePtr
+RRModeFindByName (const char	*name,
+		  CARD16    	nameLength)
+{
+    int		i;
+    RRModePtr	mode;
+
+    for (i = 0; i &lt; num_modes; i++)
+    {
+	mode = modes[i];
+	if (mode-&gt;mode.nameLength == nameLength &amp;&amp;
+	    !memcmp (name, mode-&gt;name, nameLength))
+	{
+	    return mode;
+	}
+    }
+    return NULL;
+}
+
+RRModePtr
+RRModeGet (xRRModeInfo	*modeInfo,
+	   const char	*name)
+{
+    int	i;
+
+    for (i = 0; i &lt; num_modes; i++)
+    {
+	RRModePtr   mode = modes[i];
+	if (RRModeEqual (&amp;mode-&gt;mode, modeInfo) &amp;&amp;
+	    !memcmp (name, mode-&gt;name, modeInfo-&gt;nameLength))
+	{
+	    ++mode-&gt;refcnt;
+	    return mode;
+	}
+    }
+
+    return RRModeCreate (modeInfo, name, NULL);
+}
+
+static RRModePtr
+RRModeCreateUser (ScreenPtr	pScreen,
+		  xRRModeInfo	*modeInfo,
+		  const char	*name,
+		  int		*error)
+{
+    RRModePtr	mode;
+
+    mode = RRModeFindByName (name, modeInfo-&gt;nameLength);
+    if (mode)
+    {
+	*error = BadName;
+	return NULL;
+    }
+    
+    mode = RRModeCreate (modeInfo, name, pScreen);
+    if (!mode)
+    {
+	*error = BadAlloc;
+	return NULL;
+    }
+    *error = Success;
+    return mode;
+}
+
+RRModePtr *
+RRModesForScreen (ScreenPtr pScreen, int *num_ret)
+{
+    rrScrPriv(pScreen);
+    int		o, c, m;
+    RRModePtr	*screen_modes;
+    int		num_screen_modes = 0;
+
+    screen_modes = xalloc ((num_modes ? num_modes : 1) * sizeof (RRModePtr));
+    if (!screen_modes)
+	return NULL;
+    
+    /*
+     * Add modes from all outputs
+     */
+    for (o = 0; o &lt; pScrPriv-&gt;numOutputs; o++)
+    {
+	RROutputPtr	output = pScrPriv-&gt;outputs[o];
+	int		m, n;
+
+	for (m = 0; m &lt; output-&gt;numModes + output-&gt;numUserModes; m++)
+	{
+	    RRModePtr   mode = (m &lt; output-&gt;numModes ? 
+				output-&gt;modes[m] : 
+				output-&gt;userModes[m-output-&gt;numModes]);
+	    for (n = 0; n &lt; num_screen_modes; n++)
+		if (screen_modes[n] == mode)
+		    break;
+	    if (n == num_screen_modes)
+		screen_modes[num_screen_modes++] = mode;
+	}
+    }
+    /*
+     * Add modes from all crtcs. The goal is to
+     * make sure all available and active modes
+     * are visible to the client
+     */
+    for (c = 0; c &lt; pScrPriv-&gt;numCrtcs; c++)
+    {
+	RRCrtcPtr	crtc = pScrPriv-&gt;crtcs[c];
+	RRModePtr	mode = crtc-&gt;mode;
+	int		n;
+
+	if (!mode) continue;
+	for (n = 0; n &lt; num_screen_modes; n++)
+	    if (screen_modes[n] == mode)
+		break;
+	if (n == num_screen_modes)
+	    screen_modes[num_screen_modes++] = mode;
+    }
+    /*
+     * Add all user modes for this screen
+     */
+    for (m = 0; m &lt; num_modes; m++)
+    {
+	RRModePtr	mode = modes[m];
+	int		n;
+
+	if (mode-&gt;userScreen != pScreen)
+	    continue;
+	for (n = 0; n &lt; num_screen_modes; n++)
+	    if (screen_modes[n] == mode)
+		break;
+	if (n == num_screen_modes)
+	    screen_modes[num_screen_modes++] = mode;
+    }
+    
+    *num_ret = num_screen_modes;
+    return screen_modes;
+}
+
+void
+RRModeDestroy (RRModePtr mode)
+{
+    int	m;
+    
+    if (--mode-&gt;refcnt &gt; 0)
+	return;
+    for (m = 0; m &lt; num_modes; m++)
+    {
+	if (modes[m] == mode)
+	{
+	    memmove (modes + m, modes + m + 1,
+		     (num_modes - m - 1) * sizeof (RRModePtr));
+	    num_modes--;
+	    if (!num_modes)
+	    {
+		xfree (modes);
+		modes = NULL;
+	    }
+	    break;
+	}
+    }
+    
+    xfree (mode);
+}
+
+static int
+RRModeDestroyResource (pointer value, XID pid)
+{
+    RRModeDestroy ((RRModePtr) value);
+    return 1;
+}
+
+Bool
+RRModeInit (void)
+{
+    assert (num_modes == 0);
+    assert (modes == NULL);
+    RRModeType = CreateNewResourceType (RRModeDestroyResource);
+    if (!RRModeType)
+	return FALSE;
+    RegisterResourceName (RRModeType, &quot;MODE&quot;);
+    return TRUE;
+}
+
+int
+ProcRRCreateMode (ClientPtr client)
+{
+    REQUEST(xRRCreateModeReq);
+    xRRCreateModeReply	rep;
+    WindowPtr		pWin;
+    ScreenPtr		pScreen;
+    rrScrPrivPtr	pScrPriv;
+    xRRModeInfo		*modeInfo;
+    long		units_after;
+    char		*name;
+    int			error, rc;
+    RRModePtr		mode;
+    
+    REQUEST_AT_LEAST_SIZE (xRRCreateModeReq);
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    modeInfo = &amp;stuff-&gt;modeInfo;
+    name = (char *) (stuff + 1);
+    units_after = (stuff-&gt;length - (sizeof (xRRCreateModeReq) &gt;&gt; 2));
+
+    /* check to make sure requested name fits within the data provided */
+    if ((int) (modeInfo-&gt;nameLength + 3) &gt;&gt; 2 &gt; units_after)
+	return BadLength;
+
+    mode = RRModeCreateUser (pScreen, modeInfo, name, &amp;error);
+    if (!mode)
+	return error;
+
+    rep.type = X_Reply;
+    rep.pad0 = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.length = 0;
+    rep.mode = mode-&gt;mode.id;
+    if (client-&gt;swapped)
+    {
+	int n;
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.mode, n);
+    }
+    WriteToClient(client, sizeof(xRRCreateModeReply), (char *)&amp;rep);
+    
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRDestroyMode (ClientPtr client)
+{
+    REQUEST(xRRDestroyModeReq);
+    RRModePtr	mode;
+    
+    REQUEST_SIZE_MATCH(xRRDestroyModeReq);
+    mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+    if (!mode)
+    {
+	client-&gt;errorValue = stuff-&gt;mode;
+	return RRErrorBase + BadRRMode;
+    }
+    if (!mode-&gt;userScreen)
+	return BadMatch;
+    if (mode-&gt;refcnt &gt; 1)
+	return BadAccess;
+    FreeResource (stuff-&gt;mode, 0);
+    return Success;
+}
+
+int
+ProcRRAddOutputMode (ClientPtr client)
+{
+    REQUEST(xRRAddOutputModeReq);
+    RRModePtr	mode;
+    RROutputPtr	output;
+    
+    REQUEST_SIZE_MATCH(xRRAddOutputModeReq);
+    output = LookupOutput(client, stuff-&gt;output, DixReadAccess);
+
+    if (!output)
+    {
+	client-&gt;errorValue = stuff-&gt;output;
+	return RRErrorBase + BadRROutput;
+    }
+    
+    mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+    if (!mode)
+    {
+	client-&gt;errorValue = stuff-&gt;mode;
+	return RRErrorBase + BadRRMode;
+    }
+    
+    return RROutputAddUserMode (output, mode);
+}
+
+int
+ProcRRDeleteOutputMode (ClientPtr client)
+{
+    REQUEST(xRRDeleteOutputModeReq);
+    RRModePtr	mode;
+    RROutputPtr	output;
+    
+    REQUEST_SIZE_MATCH(xRRDeleteOutputModeReq);
+    output = LookupOutput(client, stuff-&gt;output, DixReadAccess);
+
+    if (!output)
+    {
+	client-&gt;errorValue = stuff-&gt;output;
+	return RRErrorBase + BadRROutput;
+    }
+    
+    mode = LookupIDByType (stuff-&gt;mode, RRModeType);
+    if (!mode)
+    {
+	client-&gt;errorValue = stuff-&gt;mode;
+	return RRErrorBase + BadRRMode;
+    }
+    
+    return RROutputDeleteUserMode (output, mode);
+}
diff --git a/nx-X11/programs/Xserver/randr/rroutput.c b/nx-X11/programs/Xserver/randr/rroutput.c
new file mode 100644
index 0000000..1ecde31
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rroutput.c
@@ -0,0 +1,535 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include &quot;randrstr.h&quot;
+#include &quot;registry.h&quot;
+
+RESTYPE	RROutputType;
+
+/*
+ * Notify the output of some change
+ */
+void
+RROutputChanged (RROutputPtr output, Bool configChanged)
+{
+    ScreenPtr	pScreen = output-&gt;pScreen;
+    
+    output-&gt;changed = TRUE;
+    if (pScreen)
+    {
+	rrScrPriv (pScreen);
+	pScrPriv-&gt;changed = TRUE;
+	if (configChanged)
+	    pScrPriv-&gt;configChanged = TRUE;
+    }
+}
+
+/*
+ * Create an output
+ */
+
+RROutputPtr
+RROutputCreate (ScreenPtr   pScreen,
+		const char  *name,
+		int	    nameLength,
+		void	    *devPrivate)
+{
+    RROutputPtr	    output;
+    RROutputPtr	    *outputs;
+    rrScrPrivPtr    pScrPriv;
+
+    if (!RRInit())
+	return NULL;
+    
+    pScrPriv = rrGetScrPriv(pScreen);
+
+    if (pScrPriv-&gt;numOutputs)
+	outputs = xrealloc (pScrPriv-&gt;outputs, 
+			    (pScrPriv-&gt;numOutputs + 1) * sizeof (RROutputPtr));
+    else
+	outputs = xalloc (sizeof (RROutputPtr));
+    if (!outputs)
+	return FALSE;
+
+    pScrPriv-&gt;outputs = outputs;
+    
+    output = xalloc (sizeof (RROutputRec) + nameLength + 1);
+    if (!output)
+	return NULL;
+    output-&gt;id = FakeClientID (0);
+    output-&gt;pScreen = pScreen;
+    output-&gt;name = (char *) (output + 1);
+    output-&gt;nameLength = nameLength;
+    memcpy (output-&gt;name, name, nameLength);
+    output-&gt;name[nameLength] = '\0';
+    output-&gt;connection = RR_UnknownConnection;
+    output-&gt;subpixelOrder = SubPixelUnknown;
+    output-&gt;mmWidth = 0;
+    output-&gt;mmHeight = 0;
+    output-&gt;crtc = NULL;
+    output-&gt;numCrtcs = 0;
+    output-&gt;crtcs = NULL;
+    output-&gt;numClones = 0;
+    output-&gt;clones = NULL;
+    output-&gt;numModes = 0;
+    output-&gt;numPreferred = 0;
+    output-&gt;modes = NULL;
+    output-&gt;numUserModes = 0;
+    output-&gt;userModes = NULL;
+    output-&gt;properties = NULL;
+    output-&gt;pendingProperties = FALSE;
+    output-&gt;changed = FALSE;
+    output-&gt;devPrivate = devPrivate;
+    
+    if (!AddResource (output-&gt;id, RROutputType, (pointer) output))
+	return NULL;
+
+    pScrPriv-&gt;outputs[pScrPriv-&gt;numOutputs++] = output;
+    return output;
+}
+
+/*
+ * Notify extension that output parameters have been changed
+ */
+Bool
+RROutputSetClones (RROutputPtr  output,
+		   RROutputPtr  *clones,
+		   int		numClones)
+{
+    RROutputPtr	*newClones;
+    int		i;
+
+    if (numClones == output-&gt;numClones)
+    {
+	for (i = 0; i &lt; numClones; i++)
+	    if (output-&gt;clones[i] != clones[i])
+		break;
+	if (i == numClones)
+	    return TRUE;
+    }
+    if (numClones)
+    {
+	newClones = xalloc (numClones * sizeof (RROutputPtr));
+	if (!newClones)
+	    return FALSE;
+    }
+    else
+	newClones = NULL;
+    if (output-&gt;clones)
+	xfree (output-&gt;clones);
+    memcpy (newClones, clones, numClones * sizeof (RROutputPtr));
+    output-&gt;clones = newClones;
+    output-&gt;numClones = numClones;
+    RROutputChanged (output, TRUE);
+    return TRUE;
+}
+
+Bool
+RROutputSetModes (RROutputPtr	output,
+		  RRModePtr	*modes,
+		  int		numModes,
+		  int		numPreferred)
+{
+    RRModePtr	*newModes;
+    int		i;
+
+    if (numModes == output-&gt;numModes &amp;&amp; numPreferred == output-&gt;numPreferred)
+    {
+	for (i = 0; i &lt; numModes; i++)
+	    if (output-&gt;modes[i] != modes[i])
+		break;
+	if (i == numModes)
+	{
+	    for (i = 0; i &lt; numModes; i++)
+		RRModeDestroy (modes[i]);
+	    return TRUE;
+	}
+    }
+
+    if (numModes)
+    {
+	newModes = xalloc (numModes * sizeof (RRModePtr));
+	if (!newModes)
+	    return FALSE;
+    }
+    else
+	newModes = NULL;
+    if (output-&gt;modes)
+    {
+	for (i = 0; i &lt; output-&gt;numModes; i++)
+	    RRModeDestroy (output-&gt;modes[i]);
+	xfree (output-&gt;modes);
+    }
+    memcpy (newModes, modes, numModes * sizeof (RRModePtr));
+    output-&gt;modes = newModes;
+    output-&gt;numModes = numModes;
+    output-&gt;numPreferred = numPreferred;
+    RROutputChanged (output, TRUE);
+    return TRUE;
+}
+
+int
+RROutputAddUserMode (RROutputPtr    output,
+		     RRModePtr	    mode)
+{
+    int		m;
+    ScreenPtr	pScreen = output-&gt;pScreen;
+    rrScrPriv(pScreen);
+    RRModePtr	*newModes;
+
+    /* Check to see if this mode is already listed for this output */
+    for (m = 0; m &lt; output-&gt;numModes + output-&gt;numUserModes; m++)
+    {
+	RRModePtr   e = (m &lt; output-&gt;numModes ?
+			 output-&gt;modes[m] :
+			 output-&gt;userModes[m - output-&gt;numModes]);
+	if (mode == e)
+	    return Success;
+    }
+
+    /* Check with the DDX to see if this mode is OK */
+    if (pScrPriv-&gt;rrOutputValidateMode)
+	if (!pScrPriv-&gt;rrOutputValidateMode (pScreen, output, mode))
+	    return BadMatch;
+
+    if (output-&gt;userModes)
+	newModes = xrealloc (output-&gt;userModes,
+			     (output-&gt;numUserModes + 1) * sizeof (RRModePtr));
+    else
+	newModes = xalloc (sizeof (RRModePtr));
+    if (!newModes)
+	return BadAlloc;
+
+    output-&gt;userModes = newModes;
+    output-&gt;userModes[output-&gt;numUserModes++] = mode;
+    ++mode-&gt;refcnt;
+    RROutputChanged (output, TRUE);
+    RRTellChanged (pScreen);
+    return Success;
+}
+
+int
+RROutputDeleteUserMode (RROutputPtr output,
+			RRModePtr   mode)
+{
+    int		m;
+    
+    /* Find this mode in the user mode list */
+    for (m = 0; m &lt; output-&gt;numUserModes; m++)
+    {
+	RRModePtr   e = output-&gt;userModes[m];
+
+	if (mode == e)
+	    break;
+    }
+    /* Not there, access error */
+    if (m == output-&gt;numUserModes)
+	return BadAccess;
+
+    /* make sure the mode isn't active for this output */
+    if (output-&gt;crtc &amp;&amp; output-&gt;crtc-&gt;mode == mode)
+	return BadMatch;
+
+    memmove (output-&gt;userModes + m, output-&gt;userModes + m + 1,
+	     (output-&gt;numUserModes - m - 1) * sizeof (RRModePtr));
+    output-&gt;numUserModes--;
+    RRModeDestroy (mode);
+    return Success;
+}
+
+Bool
+RROutputSetCrtcs (RROutputPtr	output,
+		  RRCrtcPtr	*crtcs,
+		  int		numCrtcs)
+{
+    RRCrtcPtr	*newCrtcs;
+    int		i;
+
+    if (numCrtcs == output-&gt;numCrtcs)
+    {
+	for (i = 0; i &lt; numCrtcs; i++)
+	    if (output-&gt;crtcs[i] != crtcs[i])
+		break;
+	if (i == numCrtcs)
+	    return TRUE;
+    }
+    if (numCrtcs)
+    {
+	newCrtcs = xalloc (numCrtcs * sizeof (RRCrtcPtr));
+	if (!newCrtcs)
+	    return FALSE;
+    }
+    else
+	newCrtcs = NULL;
+    if (output-&gt;crtcs)
+	xfree (output-&gt;crtcs);
+    memcpy (newCrtcs, crtcs, numCrtcs * sizeof (RRCrtcPtr));
+    output-&gt;crtcs = newCrtcs;
+    output-&gt;numCrtcs = numCrtcs;
+    RROutputChanged (output, TRUE);
+    return TRUE;
+}
+
+Bool
+RROutputSetConnection (RROutputPtr  output,
+		       CARD8	    connection)
+{
+    if (output-&gt;connection == connection)
+	return TRUE;
+    output-&gt;connection = connection;
+    RROutputChanged (output, TRUE);
+    return TRUE;
+}
+
+Bool
+RROutputSetSubpixelOrder (RROutputPtr output,
+			  int	      subpixelOrder)
+{
+    if (output-&gt;subpixelOrder == subpixelOrder)
+	return TRUE;
+
+    output-&gt;subpixelOrder = subpixelOrder;
+    RROutputChanged (output, FALSE);
+    return TRUE;
+}
+
+Bool
+RROutputSetPhysicalSize (RROutputPtr	output,
+			 int		mmWidth,
+			 int		mmHeight)
+{
+    if (output-&gt;mmWidth == mmWidth &amp;&amp; output-&gt;mmHeight == mmHeight)
+	return TRUE;
+    output-&gt;mmWidth = mmWidth;
+    output-&gt;mmHeight = mmHeight;
+    RROutputChanged (output, FALSE);
+    return TRUE;
+}
+
+
+void
+RRDeliverOutputEvent(ClientPtr client, WindowPtr pWin, RROutputPtr output)
+{
+    ScreenPtr pScreen = pWin-&gt;drawable.pScreen;
+    rrScrPriv (pScreen);
+    xRROutputChangeNotifyEvent	oe;
+    RRCrtcPtr	crtc = output-&gt;crtc;
+    RRModePtr	mode = crtc ? crtc-&gt;mode : 0;
+    
+    oe.type = RRNotify + RREventBase;
+    oe.subCode = RRNotify_OutputChange;
+    oe.sequenceNumber = client-&gt;sequence;
+    oe.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    oe.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+    oe.window = pWin-&gt;drawable.id;
+    oe.output = output-&gt;id;
+    if (crtc)
+    {
+	oe.crtc = crtc-&gt;id;
+	oe.mode = mode ? mode-&gt;mode.id : None;
+	oe.rotation = crtc-&gt;rotation;
+    }
+    else
+    {
+	oe.crtc = None;
+	oe.mode = None;
+	oe.rotation = RR_Rotate_0;
+    }
+    oe.connection = output-&gt;connection;
+    oe.subpixelOrder = output-&gt;subpixelOrder;
+    WriteEventsToClient (client, 1, (xEvent *) &amp;oe);
+}
+
+/*
+ * Destroy a Output at shutdown
+ */
+void
+RROutputDestroy (RROutputPtr output)
+{
+    FreeResource (output-&gt;id, 0);
+}
+
+static int
+RROutputDestroyResource (pointer value, XID pid)
+{
+    RROutputPtr	output = (RROutputPtr) value;
+    ScreenPtr	pScreen = output-&gt;pScreen;
+    int		m;
+
+    if (pScreen)
+    {
+	rrScrPriv(pScreen);
+	int		i;
+    
+	for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	{
+	    if (pScrPriv-&gt;outputs[i] == output)
+	    {
+		memmove (pScrPriv-&gt;outputs + i, pScrPriv-&gt;outputs + i + 1,
+			 (pScrPriv-&gt;numOutputs - (i + 1)) * sizeof (RROutputPtr));
+		--pScrPriv-&gt;numOutputs;
+		break;
+	    }
+	}
+    }
+    if (output-&gt;modes)
+    {
+	for (m = 0; m &lt; output-&gt;numModes; m++)
+	    RRModeDestroy (output-&gt;modes[m]);
+	xfree (output-&gt;modes);
+    }
+    
+    for (m = 0; m &lt; output-&gt;numUserModes; m++)
+	RRModeDestroy (output-&gt;userModes[m]);
+    if (output-&gt;userModes)
+	xfree (output-&gt;userModes);
+
+    if (output-&gt;crtcs)
+	xfree (output-&gt;crtcs);
+    if (output-&gt;clones)
+	xfree (output-&gt;clones);
+    RRDeleteAllOutputProperties (output);
+    xfree (output);
+    return 1;
+}
+
+/*
+ * Initialize output type
+ */
+Bool
+RROutputInit (void)
+{
+    RROutputType = CreateNewResourceType (RROutputDestroyResource);
+    if (!RROutputType)
+	return FALSE;
+    RegisterResourceName (RROutputType, &quot;OUTPUT&quot;);
+    return TRUE;
+}
+
+#define OutputInfoExtra	(SIZEOF(xRRGetOutputInfoReply) - 32)
+				
+int
+ProcRRGetOutputInfo (ClientPtr client)
+{
+    REQUEST(xRRGetOutputInfoReq);
+    xRRGetOutputInfoReply	rep;
+    RROutputPtr			output;
+    CARD8			*extra;
+    unsigned long		extraLen;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    RRCrtc			*crtcs;
+    RRMode			*modes;
+    RROutput			*clones;
+    char			*name;
+    int				i, n;
+    
+    REQUEST_SIZE_MATCH(xRRGetOutputInfoReq);
+    output = LookupOutput(client, stuff-&gt;output, DixReadAccess);
+
+    if (!output)
+    {
+	client-&gt;errorValue = stuff-&gt;output;
+	return RRErrorBase + BadRROutput;
+    }
+
+    pScreen = output-&gt;pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+
+    rep.type = X_Reply;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.length = OutputInfoExtra &gt;&gt; 2;
+    rep.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    rep.crtc = output-&gt;crtc ? output-&gt;crtc-&gt;id : None;
+    rep.mmWidth = output-&gt;mmWidth;
+    rep.mmHeight = output-&gt;mmHeight;
+    rep.connection = output-&gt;connection;
+    rep.subpixelOrder = output-&gt;subpixelOrder;
+    rep.nCrtcs = output-&gt;numCrtcs;
+    rep.nModes = output-&gt;numModes + output-&gt;numUserModes;
+    rep.nPreferred = output-&gt;numPreferred;
+    rep.nClones = output-&gt;numClones;
+    rep.nameLength = output-&gt;nameLength;
+    
+    extraLen = ((output-&gt;numCrtcs + 
+		 output-&gt;numModes + output-&gt;numUserModes +
+		 output-&gt;numClones +
+		 ((rep.nameLength + 3) &gt;&gt; 2)) &lt;&lt; 2);
+
+    if (extraLen)
+    {
+	rep.length += extraLen &gt;&gt; 2;
+	extra = xalloc (extraLen);
+	if (!extra)
+	    return BadAlloc;
+    }
+    else
+	extra = NULL;
+
+    crtcs = (RRCrtc *) extra;
+    modes = (RRMode *) (crtcs + output-&gt;numCrtcs);
+    clones = (RROutput *) (modes + output-&gt;numModes + output-&gt;numUserModes);
+    name = (char *) (clones + output-&gt;numClones);
+    
+    for (i = 0; i &lt; output-&gt;numCrtcs; i++)
+    {
+	crtcs[i] = output-&gt;crtcs[i]-&gt;id;
+	if (client-&gt;swapped)
+	    swapl (&amp;crtcs[i], n);
+    }
+    for (i = 0; i &lt; output-&gt;numModes + output-&gt;numUserModes; i++)
+    {
+	if (i &lt; output-&gt;numModes)
+	    modes[i] = output-&gt;modes[i]-&gt;mode.id;
+	else
+	    modes[i] = output-&gt;userModes[i - output-&gt;numModes]-&gt;mode.id;
+	if (client-&gt;swapped)
+	    swapl (&amp;modes[i], n);
+    }
+    for (i = 0; i &lt; output-&gt;numClones; i++)
+    {
+	clones[i] = output-&gt;clones[i]-&gt;id;
+	if (client-&gt;swapped)
+	    swapl (&amp;clones[i], n);
+    }
+    memcpy (name, output-&gt;name, output-&gt;nameLength);
+    if (client-&gt;swapped) {
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.timestamp, n);
+	swapl(&amp;rep.crtc, n);
+	swapl(&amp;rep.mmWidth, n);
+	swapl(&amp;rep.mmHeight, n);
+	swaps(&amp;rep.nCrtcs, n);
+	swaps(&amp;rep.nModes, n);
+	swaps(&amp;rep.nClones, n);
+	swaps(&amp;rep.nameLength, n);
+    }
+    WriteToClient(client, sizeof(xRRGetOutputInfoReply), (char *)&amp;rep);
+    if (extraLen)
+    {
+	WriteToClient (client, extraLen, (char *) extra);
+	xfree (extra);
+    }
+    
+    return client-&gt;noClientException;
+}
diff --git a/nx-X11/programs/Xserver/randr/rrpointer.c b/nx-X11/programs/Xserver/randr/rrpointer.c
new file mode 100644
index 0000000..c88a0f8
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrpointer.c
@@ -0,0 +1,145 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include &quot;randrstr.h&quot;
+
+/*
+ * When the pointer moves, check to see if the specified position is outside
+ * any of theavailable CRTCs and move it to a 'sensible' place if so, where
+ * sensible is the closest monitor to the departing edge.
+ *
+ * Returns whether the position was adjusted
+ */
+
+static Bool
+RRCrtcContainsPosition (RRCrtcPtr crtc, int x, int y)
+{
+    RRModePtr   mode = crtc-&gt;mode;
+    int		scan_width, scan_height;
+
+    if (!mode)
+	return FALSE;
+
+    RRCrtcGetScanoutSize (crtc, &amp;scan_width, &amp;scan_height);
+
+    if (crtc-&gt;x &lt;= x &amp;&amp; x &lt; crtc-&gt;x + scan_width &amp;&amp;
+	crtc-&gt;y &lt;= y &amp;&amp; y &lt; crtc-&gt;y + scan_height)
+	return TRUE;
+    return FALSE;
+}
+
+/*
+ * Find the CRTC nearest the specified position, ignoring 'skip'
+ */
+static void
+RRPointerToNearestCrtc (ScreenPtr pScreen, int x, int y, RRCrtcPtr skip)
+{
+    rrScrPriv (pScreen);
+    int		c;
+    RRCrtcPtr	nearest = NULL;
+    int		best = 0;
+    int		best_dx = 0, best_dy = 0;
+
+    for (c = 0; c &lt; pScrPriv-&gt;numCrtcs; c++)
+    {
+	RRCrtcPtr   crtc = pScrPriv-&gt;crtcs[c];
+	RRModePtr   mode = crtc-&gt;mode;
+	int	    dx, dy;
+	int	    dist;
+	int	    scan_width, scan_height;
+
+	if (!mode)
+	    continue;
+	if (crtc == skip)
+	    continue;
+
+	RRCrtcGetScanoutSize (crtc, &amp;scan_width, &amp;scan_height);
+
+	if (x &lt; crtc-&gt;x)
+	    dx = crtc-&gt;x - x;
+	else if (x &gt; crtc-&gt;x + scan_width)
+	    dx = x - (crtc-&gt;x + scan_width);
+	else
+	    dx = 0;
+	if (y &lt; crtc-&gt;y)
+	    dy = crtc-&gt;y - x;
+	else if (y &gt; crtc-&gt;y + scan_height)
+	    dy = y - (crtc-&gt;y + scan_height);
+	else
+	    dy = 0;
+	dist = dx + dy;
+	if (!nearest || dist &lt; best)
+	{
+	    nearest = crtc;
+	    best_dx = dx;
+	    best_dy = dy;
+	}
+    }
+    if (best_dx || best_dy)
+	(*pScreen-&gt;SetCursorPosition) (pScreen, x + best_dx, y + best_dy, TRUE);
+    pScrPriv-&gt;pointerCrtc = nearest;
+}
+
+void
+RRPointerMoved (ScreenPtr pScreen, int x, int y)
+{
+    rrScrPriv (pScreen);
+    RRCrtcPtr	pointerCrtc = pScrPriv-&gt;pointerCrtc;
+    int	c;
+
+    /* Check last known CRTC */
+    if (pointerCrtc &amp;&amp; RRCrtcContainsPosition (pointerCrtc, x, y))
+	return;
+    
+    /* Check all CRTCs */
+    for (c = 0; c &lt; pScrPriv-&gt;numCrtcs; c++)
+    {
+	RRCrtcPtr   crtc = pScrPriv-&gt;crtcs[c];
+	
+	if (RRCrtcContainsPosition (crtc, x, y))
+	{
+	    /* Remember containing CRTC */
+	    pScrPriv-&gt;pointerCrtc = crtc;
+	    return;
+	}
+    }
+
+    /* None contain pointer, find nearest */
+    RRPointerToNearestCrtc (pScreen, x, y, pointerCrtc);
+}
+
+/*
+ * When the screen is reconfigured, move the pointer to the nearest
+ * CRTC
+ */
+void
+RRPointerScreenConfigured (ScreenPtr pScreen)
+{
+    WindowPtr	pRoot = GetCurrentRootWindow ();
+    ScreenPtr	pCurrentScreen = pRoot ? pRoot-&gt;drawable.pScreen : NULL;
+    int		x, y;
+
+    if (pScreen != pCurrentScreen)
+	return;
+    GetSpritePosition (&amp;x, &amp;y);
+    RRPointerToNearestCrtc (pScreen, x, y, NULL);
+}
diff --git a/nx-X11/programs/Xserver/randr/rrproperty.c b/nx-X11/programs/Xserver/randr/rrproperty.c
new file mode 100644
index 0000000..429246c
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrproperty.c
@@ -0,0 +1,736 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include &quot;randrstr.h&quot;
+#include &quot;propertyst.h&quot;
+#include &quot;swaprep.h&quot;
+
+static void
+RRDeliverEvent (ScreenPtr pScreen, xEvent *event, CARD32 mask)
+{
+
+}
+
+void
+RRDeleteAllOutputProperties (RROutputPtr output)
+{
+    RRPropertyPtr prop, next;
+    xRROutputPropertyNotifyEvent    event;
+
+    for (prop = output-&gt;properties; prop; prop = next)
+    {
+	next = prop-&gt;next;
+	event.type = RREventBase + RRNotify;
+	event.subCode = RRNotify_OutputProperty;
+	event.output = output-&gt;id;
+	event.state = PropertyDelete;
+	event.atom = prop-&gt;propertyName;
+	event.timestamp = currentTime.milliseconds;
+	RRDeliverEvent (output-&gt;pScreen, (xEvent *) &amp;event, RROutputPropertyNotifyMask);
+	if (prop-&gt;current.data)
+	    xfree(prop-&gt;current.data);
+	if (prop-&gt;pending.data)
+	    xfree(prop-&gt;pending.data);
+	xfree(prop);
+    }
+}
+
+static void
+RRInitOutputPropertyValue (RRPropertyValuePtr property_value)
+{
+    property_value-&gt;type = None;
+    property_value-&gt;format = 0;
+    property_value-&gt;size = 0;
+    property_value-&gt;data = NULL;
+}
+
+static RRPropertyPtr
+RRCreateOutputProperty (Atom property)
+{
+    RRPropertyPtr   prop;
+
+    prop = (RRPropertyPtr)xalloc(sizeof(RRPropertyRec));
+    if (!prop)
+	return NULL;
+    prop-&gt;next = NULL;
+    prop-&gt;propertyName = property;
+    prop-&gt;is_pending = FALSE;
+    prop-&gt;range = FALSE;
+    prop-&gt;immutable = FALSE;
+    prop-&gt;num_valid = 0;
+    prop-&gt;valid_values = NULL;
+    RRInitOutputPropertyValue (&amp;prop-&gt;current);
+    RRInitOutputPropertyValue (&amp;prop-&gt;pending);
+    return prop;
+}
+
+static void
+RRDestroyOutputProperty (RRPropertyPtr prop)
+{
+    if (prop-&gt;valid_values)
+	xfree (prop-&gt;valid_values);
+    if (prop-&gt;current.data)
+	xfree(prop-&gt;current.data);
+    if (prop-&gt;pending.data)
+	xfree(prop-&gt;pending.data);
+    xfree(prop);
+}
+
+void
+RRDeleteOutputProperty (RROutputPtr output, Atom property)
+{
+    RRPropertyPtr	prop, *prev;
+    xRROutputPropertyNotifyEvent    event;
+
+    for (prev = &amp;output-&gt;properties; (prop = *prev); prev = &amp;(prop-&gt;next))
+	if (prop-&gt;propertyName == property)
+	    break;
+    if (prop)
+    {
+	*prev = prop-&gt;next;
+	event.type = RREventBase + RRNotify;
+	event.subCode = RRNotify_OutputProperty;
+	event.output = output-&gt;id;
+	event.state = PropertyDelete;
+	event.atom = prop-&gt;propertyName;
+	event.timestamp = currentTime.milliseconds;
+	RRDeliverEvent (output-&gt;pScreen, (xEvent *) &amp;event, RROutputPropertyNotifyMask);
+	RRDestroyOutputProperty (prop);
+    }
+}
+
+int
+RRChangeOutputProperty (RROutputPtr output, Atom property, Atom type,
+			int format, int mode, unsigned long len,
+			pointer value, Bool sendevent, Bool pending)
+{
+    RRPropertyPtr		    prop;
+    xRROutputPropertyNotifyEvent    event;
+    rrScrPrivPtr		    pScrPriv = rrGetScrPriv(output-&gt;pScreen);
+    int				    size_in_bytes;
+    int				    total_size;
+    unsigned long		    total_len;
+    RRPropertyValuePtr		    prop_value;
+    RRPropertyValueRec		    new_value;
+    Bool			    add = FALSE;
+
+    size_in_bytes = format &gt;&gt; 3;
+
+    /* first see if property already exists */
+    prop = RRQueryOutputProperty (output, property);
+    if (!prop)   /* just add to list */
+    {
+	prop = RRCreateOutputProperty (property);
+	if (!prop)
+	    return(BadAlloc);
+	add = TRUE;
+	mode = PropModeReplace;
+    }
+    if (pending &amp;&amp; prop-&gt;is_pending)
+	prop_value = &amp;prop-&gt;pending;
+    else
+	prop_value = &amp;prop-&gt;current;
+
+    /* To append or prepend to a property the request format and type
+     must match those of the already defined property.  The
+     existing format and type are irrelevant when using the mode
+     &quot;PropModeReplace&quot; since they will be written over. */
+
+    if ((format != prop_value-&gt;format) &amp;&amp; (mode != PropModeReplace))
+	return(BadMatch);
+    if ((prop_value-&gt;type != type) &amp;&amp; (mode != PropModeReplace))
+	return(BadMatch);
+    new_value = *prop_value;
+    if (mode == PropModeReplace)
+	total_len = len;
+    else
+	total_len = prop_value-&gt;size + len;
+
+    if (mode == PropModeReplace || len &gt; 0)
+    {
+	pointer	    new_data = NULL, old_data = NULL;
+
+	total_size = total_len * size_in_bytes;
+	new_value.data = (pointer)xalloc (total_size);
+	if (!new_value.data &amp;&amp; total_size)
+	{
+	    if (add)
+		RRDestroyOutputProperty (prop);
+	    return BadAlloc;
+	}
+	new_value.size = len;
+	new_value.type = type;
+	new_value.format = format;
+
+	switch (mode) {
+	case PropModeReplace:
+	    new_data = new_value.data;
+	    old_data = NULL;
+	    break;
+	case PropModeAppend:
+	    new_data = (pointer) (((char *) new_value.data) + 
+				  (prop_value-&gt;size * size_in_bytes));
+	    old_data = new_value.data;
+	    break;
+	case PropModePrepend:
+	    new_data = new_value.data;
+	    old_data = (pointer) (((char *) new_value.data) + 
+				  (prop_value-&gt;size * size_in_bytes));
+	    break;
+	}
+	if (new_data)
+	    memcpy ((char *) new_data, (char *) value, len * size_in_bytes);
+	if (old_data)
+	    memcpy ((char *) old_data, (char *) prop_value-&gt;data, 
+		    prop_value-&gt;size * size_in_bytes);
+
+	if (pending &amp;&amp; pScrPriv-&gt;rrOutputSetProperty &amp;&amp;
+	    !pScrPriv-&gt;rrOutputSetProperty(output-&gt;pScreen, output,
+					   prop-&gt;propertyName, &amp;new_value))
+	{
+	    if (new_value.data)
+		xfree (new_value.data);
+	    return (BadValue);
+	}
+	if (prop_value-&gt;data)
+	    xfree (prop_value-&gt;data);
+	*prop_value = new_value;
+    }
+
+    else if (len == 0)
+    {
+	/* do nothing */
+    }
+
+    if (add)
+    {
+	prop-&gt;next = output-&gt;properties;
+	output-&gt;properties = prop;
+    }
+
+    if (pending &amp;&amp; prop-&gt;is_pending)
+	output-&gt;pendingProperties = TRUE;
+
+    if (sendevent)
+    {
+	event.type = RREventBase + RRNotify;
+	event.subCode = RRNotify_OutputProperty;
+	event.output = output-&gt;id;
+	event.state = PropertyNewValue;
+	event.atom = prop-&gt;propertyName;
+	event.timestamp = currentTime.milliseconds;
+	RRDeliverEvent (output-&gt;pScreen, (xEvent *) &amp;event, RROutputPropertyNotifyMask);
+    }
+    return(Success);
+}
+
+Bool
+RRPostPendingProperties (RROutputPtr output)
+{
+    RRPropertyValuePtr	pending_value;
+    RRPropertyValuePtr	current_value;
+    RRPropertyPtr	property;
+    Bool		ret = TRUE;
+
+    if (!output-&gt;pendingProperties)
+	return TRUE;
+    
+    output-&gt;pendingProperties = FALSE;
+    for (property = output-&gt;properties; property; property = property-&gt;next)
+    {
+	/* Skip non-pending properties */
+	if (!property-&gt;is_pending)
+	    continue;
+	
+	pending_value = &amp;property-&gt;pending;
+	current_value = &amp;property-&gt;current;
+
+	/*
+	 * If the pending and current values are equal, don't mark it
+	 * as changed (which would deliver an event)
+	 */
+	if (pending_value-&gt;type == current_value-&gt;type &amp;&amp;
+	    pending_value-&gt;format == current_value-&gt;format &amp;&amp;
+	    pending_value-&gt;size == current_value-&gt;size &amp;&amp;
+	    !memcmp (pending_value-&gt;data, current_value-&gt;data,
+		     pending_value-&gt;size))
+	    continue;
+
+	if (RRChangeOutputProperty (output, property-&gt;propertyName,
+				    pending_value-&gt;type, pending_value-&gt;format,
+				    PropModeReplace, pending_value-&gt;size,
+				    pending_value-&gt;data, TRUE,
+				    FALSE) != Success)
+	    ret = FALSE;
+    }
+    return ret;
+}
+
+RRPropertyPtr
+RRQueryOutputProperty (RROutputPtr output, Atom property)
+{
+    RRPropertyPtr   prop;
+    
+    for (prop = output-&gt;properties; prop; prop = prop-&gt;next)
+	if (prop-&gt;propertyName == property)
+	    return prop;
+    return NULL;
+}
+		       
+RRPropertyValuePtr
+RRGetOutputProperty (RROutputPtr output, Atom property, Bool pending)
+{
+    RRPropertyPtr   prop = RRQueryOutputProperty (output, property);
+
+    if (!prop)
+	return NULL;
+    if (pending &amp;&amp; prop-&gt;is_pending)
+	return &amp;prop-&gt;pending;
+    else
+	return &amp;prop-&gt;current;
+}
+
+int
+RRConfigureOutputProperty (RROutputPtr output, Atom property,
+			   Bool pending, Bool range, Bool immutable,
+			   int num_values, INT32 *values)
+{
+    RRPropertyPtr   prop = RRQueryOutputProperty (output, property);
+    Bool	    add = FALSE;
+    INT32	    *new_values;
+
+    if (!prop)
+    {
+        prop = RRCreateOutputProperty (property);
+	if (!prop)
+	    return(BadAlloc);
+	add = TRUE;
+    } else if (prop-&gt;immutable &amp;&amp; !immutable)
+	return(BadAccess);
+    
+    /*
+     * ranges must have even number of values
+     */
+    if (range &amp;&amp; (num_values &amp; 1))
+	return BadMatch;
+
+    new_values = xalloc (num_values * sizeof (INT32));
+    if (!new_values &amp;&amp; num_values)
+	return BadAlloc;
+    if (num_values)
+	memcpy (new_values, values, num_values * sizeof (INT32));
+    
+    /*
+     * Property moving from pending to non-pending
+     * loses any pending values
+     */
+    if (prop-&gt;is_pending &amp;&amp; !pending)
+    {
+	if (prop-&gt;pending.data)
+	    xfree (prop-&gt;pending.data);
+	RRInitOutputPropertyValue (&amp;prop-&gt;pending);
+    }
+
+    prop-&gt;is_pending = pending;
+    prop-&gt;range = range;
+    prop-&gt;immutable = immutable;
+    prop-&gt;num_valid = num_values;
+    if (prop-&gt;valid_values)
+	xfree (prop-&gt;valid_values);
+    prop-&gt;valid_values = new_values;
+
+    if (add) {
+	prop-&gt;next = output-&gt;properties;
+	output-&gt;properties = prop;
+    }
+
+    return Success;
+}
+
+int
+ProcRRListOutputProperties (ClientPtr client)
+{
+    REQUEST(xRRListOutputPropertiesReq);
+    Atom			    *pAtoms = NULL, *temppAtoms;
+    xRRListOutputPropertiesReply    rep;
+    int				    numProps = 0;
+    RROutputPtr			    output;
+    RRPropertyPtr			    prop;
+    
+    REQUEST_SIZE_MATCH(xRRListOutputPropertiesReq);
+
+    output = LookupOutput (client, stuff-&gt;output, DixReadAccess);
+    
+    if (!output)
+        return RRErrorBase + BadRROutput;
+
+    for (prop = output-&gt;properties; prop; prop = prop-&gt;next)
+	numProps++;
+    if (numProps)
+        if(!(pAtoms = (Atom *)xalloc(numProps * sizeof(Atom))))
+            return(BadAlloc);
+
+    rep.type = X_Reply;
+    rep.length = (numProps * sizeof(Atom)) &gt;&gt; 2;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.nAtoms = numProps;
+    if (client-&gt;swapped) 
+    {
+	int n;
+	swaps (&amp;rep.sequenceNumber, n);
+	swapl (&amp;rep.length, n);
+	swaps (&amp;rep.nAtoms, n);
+    }
+    temppAtoms = pAtoms;
+    for (prop = output-&gt;properties; prop; prop = prop-&gt;next)
+	*temppAtoms++ = prop-&gt;propertyName;
+
+    WriteToClient(client, sizeof(xRRListOutputPropertiesReply), (char*)&amp;rep);
+    if (numProps)
+    {
+        client-&gt;pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
+        WriteSwappedDataToClient(client, numProps * sizeof(Atom), pAtoms);
+        xfree(pAtoms);
+    }
+    return(client-&gt;noClientException);
+}
+
+int
+ProcRRQueryOutputProperty (ClientPtr client)
+{
+    REQUEST(xRRQueryOutputPropertyReq);
+    xRRQueryOutputPropertyReply	    rep;
+    RROutputPtr			    output;
+    RRPropertyPtr		    prop;
+    char *extra;
+    
+    REQUEST_SIZE_MATCH(xRRQueryOutputPropertyReq);
+
+    output = LookupOutput (client, stuff-&gt;output, DixReadAccess);
+    
+    if (!output)
+        return RRErrorBase + BadRROutput;
+    
+    prop = RRQueryOutputProperty (output, stuff-&gt;property);
+    if (!prop)
+	return BadName;
+    
+    if (prop-&gt;num_valid) {
+	extra = xalloc(prop-&gt;num_valid * sizeof(INT32));
+	if (!extra)
+	    return BadAlloc;
+    }
+    rep.type = X_Reply;
+    rep.length = prop-&gt;num_valid;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.pending = prop-&gt;is_pending;
+    rep.range = prop-&gt;range;
+    rep.immutable = prop-&gt;immutable;
+    if (client-&gt;swapped) 
+    {
+	int n;
+	swaps (&amp;rep.sequenceNumber, n);
+	swapl (&amp;rep.length, n);
+    }
+    WriteToClient (client, sizeof (xRRQueryOutputPropertyReply), (char*)&amp;rep);
+    if (prop-&gt;num_valid)
+    {
+        memcpy(extra, prop-&gt;valid_values, prop-&gt;num_valid * sizeof(INT32));
+        client-&gt;pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
+        WriteSwappedDataToClient(client, prop-&gt;num_valid * sizeof(INT32),
+				 extra);
+        xfree(extra);
+    }
+    return(client-&gt;noClientException);
+}
+
+int
+ProcRRConfigureOutputProperty (ClientPtr client)
+{
+    REQUEST(xRRConfigureOutputPropertyReq);
+    RROutputPtr				output;
+    int					num_valid;
+    
+    REQUEST_AT_LEAST_SIZE(xRRConfigureOutputPropertyReq);
+
+    output = LookupOutput (client, stuff-&gt;output, DixReadAccess);
+    
+    if (!output)
+        return RRErrorBase + BadRROutput;
+    
+    num_valid = stuff-&gt;length - (sizeof (xRRConfigureOutputPropertyReq) &gt;&gt; 2);
+    return RRConfigureOutputProperty (output, stuff-&gt;property,
+				      stuff-&gt;pending, stuff-&gt;range,
+				      FALSE, num_valid, 
+				      (INT32 *) (stuff + 1));
+}
+
+int
+ProcRRChangeOutputProperty (ClientPtr client)
+{
+    REQUEST(xRRChangeOutputPropertyReq);
+    RROutputPtr	    output;
+    char	    format, mode;
+    unsigned long   len;
+    int		    sizeInBytes;
+    int		    totalSize;
+    int		    err;
+
+    REQUEST_AT_LEAST_SIZE(xRRChangeOutputPropertyReq);
+    UpdateCurrentTime();
+    format = stuff-&gt;format;
+    mode = stuff-&gt;mode;
+    if ((mode != PropModeReplace) &amp;&amp; (mode != PropModeAppend) &amp;&amp;
+	(mode != PropModePrepend))
+    {
+	client-&gt;errorValue = mode;
+	return BadValue;
+    }
+    if ((format != 8) &amp;&amp; (format != 16) &amp;&amp; (format != 32))
+    {
+	client-&gt;errorValue = format;
+        return BadValue;
+    }
+    len = stuff-&gt;nUnits;
+    if (len &gt; ((0xffffffff - sizeof(xChangePropertyReq)) &gt;&gt; 2))
+	return BadLength;
+    sizeInBytes = format&gt;&gt;3;
+    totalSize = len * sizeInBytes;
+    REQUEST_FIXED_SIZE(xRRChangeOutputPropertyReq, totalSize);
+
+    output = LookupOutput (client, stuff-&gt;output, DixWriteAccess);
+    if (!output)
+	return RRErrorBase + BadRROutput;
+    
+    if (!ValidAtom(stuff-&gt;property))
+    {
+	client-&gt;errorValue = stuff-&gt;property;
+	return(BadAtom);
+    }
+    if (!ValidAtom(stuff-&gt;type))
+    {
+	client-&gt;errorValue = stuff-&gt;type;
+	return(BadAtom);
+    }
+
+    err = RRChangeOutputProperty(output, stuff-&gt;property,
+				 stuff-&gt;type, (int)format,
+				 (int)mode, len, (pointer)&amp;stuff[1], TRUE, TRUE);
+    if (err != Success)
+	return err;
+    else
+	return client-&gt;noClientException;
+}
+
+int
+ProcRRDeleteOutputProperty (ClientPtr client)
+{
+    REQUEST(xRRDeleteOutputPropertyReq);
+    RROutputPtr	output;
+              
+    REQUEST_SIZE_MATCH(xRRDeleteOutputPropertyReq);
+    UpdateCurrentTime();
+    output = LookupOutput (client, stuff-&gt;output, DixWriteAccess);
+    if (!output)
+        return RRErrorBase + BadRROutput;
+    
+    if (!ValidAtom(stuff-&gt;property))
+    {
+	client-&gt;errorValue = stuff-&gt;property;
+	return (BadAtom);
+    }
+
+
+    RRDeleteOutputProperty(output, stuff-&gt;property);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRGetOutputProperty (ClientPtr client)
+{
+    REQUEST(xRRGetOutputPropertyReq);
+    RRPropertyPtr		prop, *prev;
+    RRPropertyValuePtr		prop_value;
+    unsigned long		n, len, ind;
+    RROutputPtr			output;
+    xRRGetOutputPropertyReply	reply;
+    char			*extra;
+
+    REQUEST_SIZE_MATCH(xRRGetOutputPropertyReq);
+    if (stuff-&gt;delete)
+	UpdateCurrentTime();
+    output = LookupOutput (client, stuff-&gt;output, 
+			   stuff-&gt;delete ? DixWriteAccess :
+			   DixReadAccess);
+    if (!output)
+	return RRErrorBase + BadRROutput;
+
+    if (!ValidAtom(stuff-&gt;property))
+    {
+	client-&gt;errorValue = stuff-&gt;property;
+	return(BadAtom);
+    }
+    if ((stuff-&gt;delete != xTrue) &amp;&amp; (stuff-&gt;delete != xFalse))
+    {
+	client-&gt;errorValue = stuff-&gt;delete;
+	return(BadValue);
+    }
+    if ((stuff-&gt;type != AnyPropertyType) &amp;&amp; !ValidAtom(stuff-&gt;type))
+    {
+	client-&gt;errorValue = stuff-&gt;type;
+	return(BadAtom);
+    }
+
+    for (prev = &amp;output-&gt;properties; (prop = *prev); prev = &amp;prop-&gt;next)
+	if (prop-&gt;propertyName == stuff-&gt;property) 
+	    break;
+
+    reply.type = X_Reply;
+    reply.sequenceNumber = client-&gt;sequence;
+    if (!prop) 
+    {
+	reply.nItems = 0;
+	reply.length = 0;
+	reply.bytesAfter = 0;
+	reply.propertyType = None;
+	reply.format = 0;
+	if (client-&gt;swapped) {
+	    int n;
+
+	    swaps(&amp;reply.sequenceNumber, n);
+	    swapl(&amp;reply.length, n);
+	    swapl(&amp;reply.propertyType, n);
+	    swapl(&amp;reply.bytesAfter, n);
+	    swapl(&amp;reply.nItems, n);
+	}
+	WriteToClient(client, sizeof(xRRGetOutputPropertyReply), &amp;reply);
+	return(client-&gt;noClientException);
+    }
+
+    if (prop-&gt;immutable &amp;&amp; stuff-&gt;delete)
+	return BadAccess;
+
+    if (stuff-&gt;pending &amp;&amp; prop-&gt;is_pending)
+	prop_value = &amp;prop-&gt;pending;
+    else
+	prop_value = &amp;prop-&gt;current;
+    
+    /* If the request type and actual type don't match. Return the
+    property information, but not the data. */
+
+    if (((stuff-&gt;type != prop_value-&gt;type) &amp;&amp;
+	 (stuff-&gt;type != AnyPropertyType))
+       )
+    {
+	reply.bytesAfter = prop_value-&gt;size;
+	reply.format = prop_value-&gt;format;
+	reply.length = 0;
+	reply.nItems = 0;
+	reply.propertyType = prop_value-&gt;type;
+	if (client-&gt;swapped) {
+	    int n;
+
+	    swaps(&amp;reply.sequenceNumber, n);
+	    swapl(&amp;reply.length, n);
+	    swapl(&amp;reply.propertyType, n);
+	    swapl(&amp;reply.bytesAfter, n);
+	    swapl(&amp;reply.nItems, n);
+	}
+	WriteToClient(client, sizeof(xRRGetOutputPropertyReply), &amp;reply);
+	return(client-&gt;noClientException);
+    }
+
+/*
+ *  Return type, format, value to client
+ */
+    n = (prop_value-&gt;format/8) * prop_value-&gt;size; /* size (bytes) of prop */
+    ind = stuff-&gt;longOffset &lt;&lt; 2;        
+
+   /* If longOffset is invalid such that it causes &quot;len&quot; to
+	    be negative, it's a value error. */
+
+    if (n &lt; ind)
+    {
+	client-&gt;errorValue = stuff-&gt;longOffset;
+	return BadValue;
+    }
+
+    len = min(n - ind, 4 * stuff-&gt;longLength);
+
+    if (len) {
+	extra = xalloc(len);
+	if (!extra)
+	    return BadAlloc;
+    }
+    reply.bytesAfter = n - (ind + len);
+    reply.format = prop_value-&gt;format;
+    reply.length = (len + 3) &gt;&gt; 2;
+    if (prop_value-&gt;format)
+	reply.nItems = len / (prop_value-&gt;format / 8);
+    else
+	reply.nItems = 0;
+    reply.propertyType = prop_value-&gt;type;
+
+    if (stuff-&gt;delete &amp;&amp; (reply.bytesAfter == 0))
+    {
+	xRROutputPropertyNotifyEvent    event;
+
+	event.type = RREventBase + RRNotify;
+	event.subCode = RRNotify_OutputProperty;
+	event.output = output-&gt;id;
+	event.state = PropertyDelete;
+	event.atom = prop-&gt;propertyName;
+	event.timestamp = currentTime.milliseconds;
+	RRDeliverEvent (output-&gt;pScreen, (xEvent *) &amp;event, RROutputPropertyNotifyMask);
+    }
+
+    if (client-&gt;swapped) {
+	int n;
+
+	swaps(&amp;reply.sequenceNumber, n);
+	swapl(&amp;reply.length, n);
+	swapl(&amp;reply.propertyType, n);
+	swapl(&amp;reply.bytesAfter, n);
+	swapl(&amp;reply.nItems, n);
+    }
+    WriteToClient(client, sizeof(xGenericReply), &amp;reply);
+    if (len)
+    {
+	memcpy(extra, (char *)prop_value-&gt;data + ind, len);
+	switch (reply.format) {
+	case 32: client-&gt;pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
+	case 16: client-&gt;pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
+	default: client-&gt;pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
+	}
+	WriteSwappedDataToClient(client, len,
+				 extra);
+	xfree(extra);
+    }
+
+    if (stuff-&gt;delete &amp;&amp; (reply.bytesAfter == 0))
+    { /* delete the Property */
+	*prev = prop-&gt;next;
+	RRDestroyOutputProperty (prop);
+    }
+    return(client-&gt;noClientException);
+}
+
diff --git a/nx-X11/programs/Xserver/randr/rrscreen.c b/nx-X11/programs/Xserver/randr/rrscreen.c
new file mode 100644
index 0000000..9b3935e
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrscreen.c
@@ -0,0 +1,1030 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &quot;randrstr.h&quot;
+
+extern char	*ConnectionInfo;
+
+static int padlength[4] = {0, 3, 2, 1};
+
+static CARD16
+RR10CurrentSizeID (ScreenPtr pScreen);
+
+/*
+ * Edit connection information block so that new clients
+ * see the current screen size on connect
+ */
+static void
+RREditConnectionInfo (ScreenPtr pScreen)
+{
+    xConnSetup	    *connSetup;
+    char	    *vendor;
+    xPixmapFormat   *formats;
+    xWindowRoot	    *root;
+    xDepth	    *depth;
+    xVisualType	    *visual;
+    int		    screen = 0;
+    int		    d;
+
+    connSetup = (xConnSetup *) ConnectionInfo;
+    vendor = (char *) connSetup + sizeof (xConnSetup);
+    formats = (xPixmapFormat *) ((char *) vendor +
+				 connSetup-&gt;nbytesVendor +
+				 padlength[connSetup-&gt;nbytesVendor &amp; 3]);
+    root = (xWindowRoot *) ((char *) formats +
+			    sizeof (xPixmapFormat) * screenInfo.numPixmapFormats);
+    while (screen != pScreen-&gt;myNum)
+    {
+	depth = (xDepth *) ((char *) root + 
+			    sizeof (xWindowRoot));
+	for (d = 0; d &lt; root-&gt;nDepths; d++)
+	{
+	    visual = (xVisualType *) ((char *) depth +
+				      sizeof (xDepth));
+	    depth = (xDepth *) ((char *) visual +
+				depth-&gt;nVisuals * sizeof (xVisualType));
+	}
+	root = (xWindowRoot *) ((char *) depth);
+	screen++;
+    }
+    root-&gt;pixWidth = pScreen-&gt;width;
+    root-&gt;pixHeight = pScreen-&gt;height;
+    root-&gt;mmWidth = pScreen-&gt;mmWidth;
+    root-&gt;mmHeight = pScreen-&gt;mmHeight;
+}
+
+void
+RRSendConfigNotify (ScreenPtr pScreen)
+{
+    WindowPtr	pWin = WindowTable[pScreen-&gt;myNum];
+    xEvent	event;
+
+    event.u.u.type = ConfigureNotify;
+    event.u.configureNotify.window = pWin-&gt;drawable.id;
+    event.u.configureNotify.aboveSibling = None;
+    event.u.configureNotify.x = 0;
+    event.u.configureNotify.y = 0;
+
+    /* XXX xinerama stuff ? */
+    
+    event.u.configureNotify.width = pWin-&gt;drawable.width;
+    event.u.configureNotify.height = pWin-&gt;drawable.height;
+    event.u.configureNotify.borderWidth = wBorderWidth (pWin);
+    event.u.configureNotify.override = pWin-&gt;overrideRedirect;
+    DeliverEvents(pWin, &amp;event, 1, NullWindow);
+}
+
+void
+RRDeliverScreenEvent (ClientPtr client, WindowPtr pWin, ScreenPtr pScreen)
+{
+    rrScrPriv (pScreen);
+    xRRScreenChangeNotifyEvent	se;
+    RRCrtcPtr	crtc = pScrPriv-&gt;numCrtcs ? pScrPriv-&gt;crtcs[0] : NULL;
+    WindowPtr	pRoot = WindowTable[pScreen-&gt;myNum];
+    
+    se.type = RRScreenChangeNotify + RREventBase;
+    se.rotation = (CARD8) (crtc ? crtc-&gt;rotation : RR_Rotate_0);
+    se.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    se.sequenceNumber = client-&gt;sequence;
+    se.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+    se.root =  pRoot-&gt;drawable.id;
+    se.window = pWin-&gt;drawable.id;
+#ifdef RENDER
+    se.subpixelOrder = PictureGetSubpixelOrder (pScreen);
+#else
+    se.subpixelOrder = SubPixelUnknown;
+#endif
+
+    se.sequenceNumber = client-&gt;sequence;
+    se.sizeID = RR10CurrentSizeID (pScreen);
+
+    if (se.rotation &amp; (RR_Rotate_90 | RR_Rotate_270)) {
+	se.widthInPixels = pScreen-&gt;height;
+	se.heightInPixels = pScreen-&gt;width;
+	se.widthInMillimeters = pScreen-&gt;mmHeight;
+	se.heightInMillimeters = pScreen-&gt;mmWidth;
+    } else {
+	se.widthInPixels = pScreen-&gt;width;
+	se.heightInPixels = pScreen-&gt;height;
+	se.widthInMillimeters = pScreen-&gt;mmWidth;
+	se.heightInMillimeters = pScreen-&gt;mmHeight;
+    }
+
+    WriteEventsToClient (client, 1, (xEvent *) &amp;se);
+}
+
+/*
+ * Notify the extension that the screen size has been changed.
+ * The driver is responsible for calling this whenever it has changed
+ * the size of the screen
+ */
+void
+RRScreenSizeNotify (ScreenPtr	pScreen)
+{
+    rrScrPriv(pScreen);
+    /*
+     * Deliver ConfigureNotify events when root changes
+     * pixel size
+     */
+    if (pScrPriv-&gt;width == pScreen-&gt;width &amp;&amp;
+	pScrPriv-&gt;height == pScreen-&gt;height &amp;&amp;
+	pScrPriv-&gt;mmWidth == pScreen-&gt;mmWidth &amp;&amp;
+	pScrPriv-&gt;mmHeight == pScreen-&gt;mmHeight)
+	return;
+    
+    pScrPriv-&gt;width = pScreen-&gt;width;
+    pScrPriv-&gt;height = pScreen-&gt;height;
+    pScrPriv-&gt;mmWidth = pScreen-&gt;mmWidth;
+    pScrPriv-&gt;mmHeight = pScreen-&gt;mmHeight;
+    pScrPriv-&gt;changed = TRUE;
+/*    pScrPriv-&gt;sizeChanged = TRUE; */
+
+    RRTellChanged (pScreen);
+    RRSendConfigNotify (pScreen);
+    RREditConnectionInfo (pScreen);
+    
+    RRPointerScreenConfigured (pScreen);
+    /*
+     * Fix pointer bounds and location
+     */
+    ScreenRestructured (pScreen);
+}
+
+/*
+ * Request that the screen be resized
+ */
+Bool
+RRScreenSizeSet (ScreenPtr  pScreen,
+		 CARD16	    width,
+		 CARD16	    height,
+		 CARD32	    mmWidth,
+		 CARD32	    mmHeight)
+{
+    rrScrPriv(pScreen);
+
+#if RANDR_12_INTERFACE
+    if (pScrPriv-&gt;rrScreenSetSize)
+    {
+	return (*pScrPriv-&gt;rrScreenSetSize) (pScreen,
+					     width, height,
+					     mmWidth, mmHeight);
+    }
+#endif
+#if RANDR_10_INTERFACE
+    if (pScrPriv-&gt;rrSetConfig)
+    {
+	return TRUE;	/* can't set size separately */
+    }
+#endif
+    return FALSE;
+}
+
+/*
+ * Retrieve valid screen size range
+ */
+int 
+ProcRRGetScreenSizeRange (ClientPtr client)
+{
+    REQUEST(xRRGetScreenSizeRangeReq);
+    xRRGetScreenSizeRangeReply	rep;
+    WindowPtr			pWin;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    int				rc;
+    
+    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    rep.type = X_Reply;
+    rep.pad = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.length = 0;
+    
+    if (pScrPriv) 
+    {
+	if (!RRGetInfo (pScreen))
+	    return BadAlloc;
+	rep.minWidth  = pScrPriv-&gt;minWidth;
+	rep.minHeight = pScrPriv-&gt;minHeight;
+	rep.maxWidth  = pScrPriv-&gt;maxWidth;
+	rep.maxHeight = pScrPriv-&gt;maxHeight;
+    }
+    else
+    {
+	rep.maxWidth  = rep.minWidth  = pScreen-&gt;width;
+	rep.maxHeight = rep.minHeight = pScreen-&gt;height;
+    }
+    if (client-&gt;swapped) 
+    {
+	int n;
+	
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swaps(&amp;rep.minWidth, n);
+	swaps(&amp;rep.minHeight, n);
+	swaps(&amp;rep.maxWidth, n);
+	swaps(&amp;rep.maxHeight, n);
+    }
+    WriteToClient(client, sizeof(xRRGetScreenSizeRangeReply), (char *)&amp;rep);
+    return (client-&gt;noClientException);
+}
+
+int
+ProcRRSetScreenSize (ClientPtr client)
+{
+    REQUEST(xRRSetScreenSizeReq);
+    WindowPtr		pWin;
+    ScreenPtr		pScreen;
+    rrScrPrivPtr	pScrPriv;
+    int			i, rc;
+    
+    REQUEST_SIZE_MATCH(xRRSetScreenSizeReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    if (stuff-&gt;width &lt; pScrPriv-&gt;minWidth || pScrPriv-&gt;maxWidth &lt; stuff-&gt;width)
+    {
+	client-&gt;errorValue = stuff-&gt;width;
+	return BadValue;
+    }
+    if (stuff-&gt;height &lt; pScrPriv-&gt;minHeight || 
+	pScrPriv-&gt;maxHeight &lt; stuff-&gt;height)
+    {
+	client-&gt;errorValue = stuff-&gt;height;
+	return BadValue;
+    }
+    for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++) 
+    {
+	RRCrtcPtr   crtc = pScrPriv-&gt;crtcs[i];
+	RRModePtr   mode = crtc-&gt;mode;
+	if (mode)
+	{
+	    int		source_width = mode-&gt;mode.width;
+	    int		source_height = mode-&gt;mode.height;
+	    Rotation	rotation = crtc-&gt;rotation;
+
+	    if (rotation == RR_Rotate_90 || rotation == RR_Rotate_270)
+	    {
+		source_width = mode-&gt;mode.height;
+		source_height = mode-&gt;mode.width;
+	    }
+	    
+	    if (crtc-&gt;x + source_width &gt; stuff-&gt;width ||
+		crtc-&gt;y + source_height &gt; stuff-&gt;height)
+	    return BadMatch;
+	}
+    }
+    if (stuff-&gt;widthInMillimeters == 0 || stuff-&gt;heightInMillimeters == 0)
+    {
+	client-&gt;errorValue = 0;
+	return BadValue;
+    }
+    if (!RRScreenSizeSet (pScreen, 
+			  stuff-&gt;width, stuff-&gt;height,
+			  stuff-&gt;widthInMillimeters,
+			  stuff-&gt;heightInMillimeters))
+    {
+	return BadMatch;
+    }
+    return Success;
+}
+
+int
+ProcRRGetScreenResources (ClientPtr client)
+{
+    REQUEST(xRRGetScreenResourcesReq);
+    xRRGetScreenResourcesReply  rep;
+    WindowPtr			pWin;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    CARD8			*extra;
+    unsigned long		extraLen;
+    int				i, n, rc;
+    RRCrtc			*crtcs;
+    RROutput			*outputs;
+    xRRModeInfo			*modeinfos;
+    CARD8			*names;
+    
+    REQUEST_SIZE_MATCH(xRRGetScreenResourcesReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+    
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    rep.pad = 0;
+    
+    if (pScrPriv)
+	if (!RRGetInfo (pScreen))
+	    return BadAlloc;
+
+    if (!pScrPriv)
+    {
+	rep.type = X_Reply;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.timestamp = currentTime.milliseconds;
+	rep.configTimestamp = currentTime.milliseconds;
+	rep.nCrtcs = 0;
+	rep.nOutputs = 0;
+	rep.nModes = 0;
+	rep.nbytesNames = 0;
+	extra = NULL;
+	extraLen = 0;
+    }
+    else
+    {
+	RRModePtr   *modes;
+	int	    num_modes;
+
+	modes = RRModesForScreen (pScreen, &amp;num_modes);
+	if (!modes)
+	    return BadAlloc;
+	
+	rep.type = X_Reply;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+	rep.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+	rep.nCrtcs = pScrPriv-&gt;numCrtcs;
+	rep.nOutputs = pScrPriv-&gt;numOutputs;
+	rep.nModes = num_modes;
+	rep.nbytesNames = 0;
+
+	for (i = 0; i &lt; num_modes; i++)
+	    rep.nbytesNames += modes[i]-&gt;mode.nameLength;
+
+	rep.length = (pScrPriv-&gt;numCrtcs + 
+		      pScrPriv-&gt;numOutputs + 
+		      num_modes * (SIZEOF(xRRModeInfo) &gt;&gt; 2) +
+		      ((rep.nbytesNames + 3) &gt;&gt; 2));
+	
+	extraLen = rep.length &lt;&lt; 2;
+	if (extraLen)
+	{
+	    extra = xalloc (extraLen);
+	    if (!extra)
+	    {
+		xfree (modes);
+		return BadAlloc;
+	    }
+	}
+	else
+	    extra = NULL;
+
+	crtcs = (RRCrtc *) extra;
+	outputs = (RROutput *) (crtcs + pScrPriv-&gt;numCrtcs);
+	modeinfos = (xRRModeInfo *) (outputs + pScrPriv-&gt;numOutputs);
+	names = (CARD8 *) (modeinfos + num_modes);
+	
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	{
+	    crtcs[i] = pScrPriv-&gt;crtcs[i]-&gt;id;
+	    if (client-&gt;swapped)
+		swapl (&amp;crtcs[i], n);
+	}
+	
+	for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	{
+	    outputs[i] = pScrPriv-&gt;outputs[i]-&gt;id;
+	    if (client-&gt;swapped)
+		swapl (&amp;outputs[i], n);
+	}
+	
+	for (i = 0; i &lt; num_modes; i++)
+	{
+	    RRModePtr	mode = modes[i];
+	    modeinfos[i] = mode-&gt;mode;
+	    if (client-&gt;swapped)
+	    {
+		swapl (&amp;modeinfos[i].id, n);
+		swaps (&amp;modeinfos[i].width, n);
+		swaps (&amp;modeinfos[i].height, n);
+		swapl (&amp;modeinfos[i].dotClock, n);
+		swaps (&amp;modeinfos[i].hSyncStart, n);
+		swaps (&amp;modeinfos[i].hSyncEnd, n);
+		swaps (&amp;modeinfos[i].hTotal, n);
+		swaps (&amp;modeinfos[i].hSkew, n);
+		swaps (&amp;modeinfos[i].vSyncStart, n);
+		swaps (&amp;modeinfos[i].vSyncEnd, n);
+		swaps (&amp;modeinfos[i].vTotal, n);
+		swaps (&amp;modeinfos[i].nameLength, n);
+		swapl (&amp;modeinfos[i].modeFlags, n);
+	    }
+	    memcpy (names, mode-&gt;name, 
+		    mode-&gt;mode.nameLength);
+	    names += mode-&gt;mode.nameLength;
+	}
+    	xfree (modes);
+	assert (((((char *) names - (char *) extra) + 3) &gt;&gt; 2) == rep.length);
+    }
+    
+    if (client-&gt;swapped) {
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.timestamp, n);
+	swapl(&amp;rep.configTimestamp, n);
+	swaps(&amp;rep.nCrtcs, n);
+	swaps(&amp;rep.nOutputs, n);
+	swaps(&amp;rep.nModes, n);
+	swaps(&amp;rep.nbytesNames, n);
+    }
+    WriteToClient(client, sizeof(xRRGetScreenResourcesReply), (char *)&amp;rep);
+    if (extraLen)
+    {
+	WriteToClient (client, extraLen, (char *) extra);
+	xfree (extra);
+    }
+    return client-&gt;noClientException;
+}
+
+typedef struct _RR10Data {
+    RRScreenSizePtr sizes;
+    int		    nsize;
+    int		    nrefresh;
+    int		    size;
+    CARD16	    refresh;
+} RR10DataRec, *RR10DataPtr;
+
+/*
+ * Convert 1.2 monitor data into 1.0 screen data
+ */
+static RR10DataPtr
+RR10GetData (ScreenPtr pScreen, RROutputPtr output)
+{
+    RR10DataPtr	    data;
+    RRScreenSizePtr size;
+    int		    nmode = output-&gt;numModes + output-&gt;numUserModes;
+    int		    o, os, l, r;
+    RRScreenRatePtr refresh;
+    CARD16	    vRefresh;
+    RRModePtr	    mode;
+    Bool	    *used;
+
+    /* Make sure there is plenty of space for any combination */
+    data = malloc (sizeof (RR10DataRec) + 
+		   sizeof (RRScreenSize) * nmode + 
+		   sizeof (RRScreenRate) * nmode +
+		   sizeof (Bool) * nmode);
+    if (!data)
+	return NULL;
+    size = (RRScreenSizePtr) (data + 1);
+    refresh = (RRScreenRatePtr) (size + nmode);
+    used = (Bool *) (refresh + nmode);
+    memset (used, '\0', sizeof (Bool) * nmode);
+    data-&gt;sizes = size;
+    data-&gt;nsize = 0;
+    data-&gt;nrefresh = 0;
+    data-&gt;size = 0;
+    data-&gt;refresh = 0;
+    
+    /*
+     * find modes not yet listed
+     */
+    for (o = 0; o &lt; output-&gt;numModes + output-&gt;numUserModes; o++)
+    {
+	if (used[o]) continue;
+	
+	if (o &lt; output-&gt;numModes)
+	    mode = output-&gt;modes[o];
+	else
+	    mode = output-&gt;userModes[o - output-&gt;numModes];
+	
+	l = data-&gt;nsize;
+	size[l].id = data-&gt;nsize;
+	size[l].width = mode-&gt;mode.width;
+	size[l].height = mode-&gt;mode.height;
+	if (output-&gt;mmWidth &amp;&amp; output-&gt;mmHeight) {
+	    size[l].mmWidth = output-&gt;mmWidth;
+	    size[l].mmHeight = output-&gt;mmHeight;
+	} else {
+	    size[l].mmWidth = pScreen-&gt;mmWidth;
+	    size[l].mmHeight = pScreen-&gt;mmHeight;
+	}
+	size[l].nRates = 0;
+	size[l].pRates = &amp;refresh[data-&gt;nrefresh];
+	data-&gt;nsize++;
+	
+	/*
+	 * Find all modes with matching size
+	 */
+	for (os = o; os &lt; output-&gt;numModes + output-&gt;numUserModes; os++)
+	{
+	    if (os &lt; output-&gt;numModes)
+		mode = output-&gt;modes[os];
+	    else
+		mode = output-&gt;userModes[os - output-&gt;numModes];
+	    if (mode-&gt;mode.width == size[l].width &amp;&amp;
+		mode-&gt;mode.height == size[l].height)
+	    {
+		vRefresh = RRVerticalRefresh (&amp;mode-&gt;mode);
+		used[os] = TRUE;
+		
+		for (r = 0; r &lt; size[l].nRates; r++)
+		    if (vRefresh == size[l].pRates[r].rate)
+			break;
+		if (r == size[l].nRates)
+		{
+		    size[l].pRates[r].rate = vRefresh;
+		    size[l].pRates[r].mode = mode;
+		    size[l].nRates++;
+		    data-&gt;nrefresh++;
+		}
+		if (mode == output-&gt;crtc-&gt;mode)
+		{
+		    data-&gt;size = l;
+		    data-&gt;refresh = vRefresh;
+		}
+	    }
+	}
+    }
+    return data;
+}
+
+int
+ProcRRGetScreenInfo (ClientPtr client)
+{
+    REQUEST(xRRGetScreenInfoReq);
+    xRRGetScreenInfoReply   rep;
+    WindowPtr	    	    pWin;
+    int			    n, rc;
+    ScreenPtr		    pScreen;
+    rrScrPrivPtr	    pScrPriv;
+    CARD8		    *extra;
+    unsigned long	    extraLen;
+    RROutputPtr		    output;
+
+    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    rep.pad = 0;
+    
+    if (pScrPriv)
+	if (!RRGetInfo (pScreen))
+	    return BadAlloc;
+
+    output = RRFirstOutput (pScreen);
+    
+    if (!pScrPriv || !output)
+    {
+	rep.type = X_Reply;
+	rep.setOfRotations = RR_Rotate_0;;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.root = WindowTable[pWin-&gt;drawable.pScreen-&gt;myNum]-&gt;drawable.id;
+	rep.timestamp = currentTime.milliseconds;
+	rep.configTimestamp = currentTime.milliseconds;
+	rep.nSizes = 0;
+	rep.sizeID = 0;
+	rep.rotation = RR_Rotate_0;
+	rep.rate = 0;
+	rep.nrateEnts = 0;
+	extra = 0;
+	extraLen = 0;
+    }
+    else
+    {
+	int			i, j;
+	xScreenSizes		*size;
+	CARD16			*rates;
+	CARD8			*data8;
+	Bool			has_rate = RRClientKnowsRates (client);
+	RR10DataPtr		pData;
+	RRScreenSizePtr		pSize;
+    
+	pData = RR10GetData (pScreen, output);
+	if (!pData)
+	    return BadAlloc;
+	
+	rep.type = X_Reply;
+	rep.setOfRotations = output-&gt;crtc-&gt;rotations;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.root = WindowTable[pWin-&gt;drawable.pScreen-&gt;myNum]-&gt;drawable.id;
+	rep.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+	rep.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+	rep.rotation = output-&gt;crtc-&gt;rotation;
+	rep.nSizes = pData-&gt;nsize;
+        rep.nrateEnts = pData-&gt;nrefresh + pData-&gt;nsize;
+	rep.sizeID = pData-&gt;size;
+	rep.rate = pData-&gt;refresh;
+
+	extraLen = (rep.nSizes * sizeof (xScreenSizes) +
+		    rep.nrateEnts * sizeof (CARD16));
+
+	if (extraLen)
+	{
+	    extra = (CARD8 *) xalloc (extraLen);
+	    if (!extra)
+	    {
+		xfree (pData);
+		return BadAlloc;
+	    }
+	}
+	else
+	    extra = NULL;
+
+	/*
+	 * First comes the size information
+	 */
+	size = (xScreenSizes *) extra;
+	rates = (CARD16 *) (size + rep.nSizes);
+	for (i = 0; i &lt; pData-&gt;nsize; i++)
+	{
+	    pSize = &amp;pData-&gt;sizes[i];
+	    size-&gt;widthInPixels = pSize-&gt;width;
+	    size-&gt;heightInPixels = pSize-&gt;height;
+	    size-&gt;widthInMillimeters = pSize-&gt;mmWidth;
+	    size-&gt;heightInMillimeters = pSize-&gt;mmHeight;
+	    if (client-&gt;swapped)
+	    {
+	        swaps (&amp;size-&gt;widthInPixels, n);
+	        swaps (&amp;size-&gt;heightInPixels, n);
+	        swaps (&amp;size-&gt;widthInMillimeters, n);
+	        swaps (&amp;size-&gt;heightInMillimeters, n);
+	    }
+	    size++;
+	    if (has_rate)
+	    {
+		*rates = pSize-&gt;nRates;
+		if (client-&gt;swapped)
+		{
+		    swaps (rates, n);
+		}
+		rates++;
+		for (j = 0; j &lt; pSize-&gt;nRates; j++)
+		{
+		    *rates = pSize-&gt;pRates[j].rate;
+		    if (client-&gt;swapped)
+		    {
+			swaps (rates, n);
+		    }
+		    rates++;
+		}
+	    }
+	}
+        xfree (pData);
+	
+	data8 = (CARD8 *) rates;
+
+	if (data8 - (CARD8 *) extra != extraLen)
+	    FatalError (&quot;RRGetScreenInfo bad extra len %ld != %ld\n&quot;,
+			(unsigned long)(data8 - (CARD8 *) extra), extraLen);
+	rep.length =  (extraLen + 3) &gt;&gt; 2;
+    }
+    if (client-&gt;swapped) {
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.timestamp, n);
+	swaps(&amp;rep.rotation, n);
+	swaps(&amp;rep.nSizes, n);
+	swaps(&amp;rep.sizeID, n);
+	swaps(&amp;rep.rate, n);
+	swaps(&amp;rep.nrateEnts, n);
+    }
+    WriteToClient(client, sizeof(xRRGetScreenInfoReply), (char *)&amp;rep);
+    if (extraLen)
+    {
+	WriteToClient (client, extraLen, (char *) extra);
+	xfree (extra);
+    }
+    return (client-&gt;noClientException);
+}
+
+int
+ProcRRSetScreenConfig (ClientPtr client)
+{
+    REQUEST(xRRSetScreenConfigReq);
+    xRRSetScreenConfigReply rep;
+    DrawablePtr		    pDraw;
+    int			    n, rc;
+    ScreenPtr		    pScreen;
+    rrScrPrivPtr	    pScrPriv;
+    TimeStamp		    time;
+    int			    i;
+    Rotation		    rotation;
+    int			    rate;
+    Bool		    has_rate;
+    RROutputPtr		    output;
+    RRCrtcPtr		    crtc;
+    RRModePtr		    mode;
+    RR10DataPtr		    pData = NULL;
+    RRScreenSizePtr    	    pSize;
+    int			    width, height;
+    
+    UpdateCurrentTime ();
+
+    if (RRClientKnowsRates (client))
+    {
+	REQUEST_SIZE_MATCH (xRRSetScreenConfigReq);
+	has_rate = TRUE;
+    }
+    else
+    {
+	REQUEST_SIZE_MATCH (xRR1_0SetScreenConfigReq);
+	has_rate = FALSE;
+    }
+    
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupDrawable(&amp;pDraw, stuff-&gt;drawable, client, 0, DixWriteAccess);
+    #else
+    pDraw = SecurityLookupDrawable(stuff-&gt;drawable, client, SecurityWriteAccess);
+    rc = pDraw ? Success : BadDrawable;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pDraw-&gt;pScreen;
+
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    time = ClientTimeToServerTime(stuff-&gt;timestamp);
+    
+    if (!pScrPriv)
+    {
+	time = currentTime;
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+    if (!RRGetInfo (pScreen))
+	return BadAlloc;
+    
+    output = RRFirstOutput (pScreen);
+    if (!output)
+    {
+	time = currentTime;
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+
+    crtc = output-&gt;crtc;
+
+    /*
+     * If the client's config timestamp is not the same as the last config
+     * timestamp, then the config information isn't up-to-date and
+     * can't even be validated.
+     *
+     * Note that the client only knows about the milliseconds part of the
+     * timestamp, so using CompareTimeStamps here would cause randr to suddenly
+     * stop working after several hours have passed (freedesktop bug #6502).
+     */
+    if (stuff-&gt;configTimestamp != pScrPriv-&gt;lastConfigTime.milliseconds)
+    {
+	rep.status = RRSetConfigInvalidConfigTime;
+	goto sendReply;
+    }
+    
+    pData = RR10GetData (pScreen, output);
+    if (!pData)
+	return BadAlloc;
+    
+    if (stuff-&gt;sizeID &gt;= pData-&gt;nsize)
+    {
+	/*
+	 * Invalid size ID
+	 */
+	client-&gt;errorValue = stuff-&gt;sizeID;
+	xfree (pData);
+	return BadValue;
+    }
+    pSize = &amp;pData-&gt;sizes[stuff-&gt;sizeID];
+    
+    /*
+     * Validate requested rotation
+     */
+    rotation = (Rotation) stuff-&gt;rotation;
+
+    /* test the rotation bits only! */
+    switch (rotation &amp; 0xf) {
+    case RR_Rotate_0:
+    case RR_Rotate_90:
+    case RR_Rotate_180:
+    case RR_Rotate_270:
+	break;
+    default:
+	/*
+	 * Invalid rotation
+	 */
+	client-&gt;errorValue = stuff-&gt;rotation;
+	xfree (pData);
+	return BadValue;
+    }
+
+    if ((~crtc-&gt;rotations) &amp; rotation)
+    {
+	/*
+	 * requested rotation or reflection not supported by screen
+	 */
+	client-&gt;errorValue = stuff-&gt;rotation;
+	xfree (pData);
+	return BadMatch;
+    }
+
+    /*
+     * Validate requested refresh
+     */
+    if (has_rate)
+	rate = (int) stuff-&gt;rate;
+    else
+	rate = 0;
+
+    if (rate)
+    {
+	for (i = 0; i &lt; pSize-&gt;nRates; i++)
+	{
+	    if (pSize-&gt;pRates[i].rate == rate)
+		break;
+	}
+	if (i == pSize-&gt;nRates)
+	{
+	    /*
+	     * Invalid rate
+	     */
+	    client-&gt;errorValue = rate;
+	    xfree (pData);
+	    return BadValue;
+	}
+	mode = pSize-&gt;pRates[i].mode;
+    }
+    else
+	mode = pSize-&gt;pRates[0].mode;
+    
+    /*
+     * Make sure the requested set-time is not older than
+     * the last set-time
+     */
+    if (CompareTimeStamps (time, pScrPriv-&gt;lastSetTime) &lt; 0)
+    {
+	rep.status = RRSetConfigInvalidTime;
+	goto sendReply;
+    }
+
+    /*
+     * If the screen size is changing, adjust all of the other outputs
+     * to fit the new size, mirroring as much as possible
+     */
+    width = mode-&gt;mode.width;
+    height = mode-&gt;mode.height;
+    if (rotation &amp; (RR_Rotate_90|RR_Rotate_270))
+    {
+	width = mode-&gt;mode.height;
+	height = mode-&gt;mode.width;
+    }
+    if (width != pScreen-&gt;width || height != pScreen-&gt;height)
+    {
+	int	c;
+
+	for (c = 0; c &lt; pScrPriv-&gt;numCrtcs; c++)
+	{
+	    if (!RRCrtcSet (pScrPriv-&gt;crtcs[c], NULL, 0, 0, RR_Rotate_0,
+			    0, NULL))
+	    {
+		rep.status = RRSetConfigFailed;
+		/* XXX recover from failure */
+		goto sendReply;
+	    }
+	}
+	if (!RRScreenSizeSet (pScreen, width, height,
+			      pScreen-&gt;mmWidth, pScreen-&gt;mmHeight))
+	{
+	    rep.status = RRSetConfigFailed;
+	    /* XXX recover from failure */
+	    goto sendReply;
+	}
+    }
+
+    if (!RRCrtcSet (crtc, mode, 0, 0, stuff-&gt;rotation, 1, &amp;output))
+	rep.status = RRSetConfigFailed;
+    #ifndef NXAGENT_SERVER /* Bug 21987 */
+    else
+	rep.status = RRSetConfigSuccess;
+    #else
+    else {
+	rep.status = RRSetConfigSuccess;
+	pScrPriv-&gt;lastSetTime = time;
+    }
+    #endif
+
+    /*
+     * XXX Configure other crtcs to mirror as much as possible
+     */
+    
+sendReply:
+    
+    if (pData)
+	xfree (pData);
+
+    rep.type = X_Reply;
+    /* rep.status has already been filled in */
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+
+    rep.newTimestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    rep.newConfigTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+    rep.root = WindowTable[pDraw-&gt;pScreen-&gt;myNum]-&gt;drawable.id;
+
+    if (client-&gt;swapped) 
+    {
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.newTimestamp, n);
+	swapl(&amp;rep.newConfigTimestamp, n);
+	swapl(&amp;rep.root, n);
+    }
+    WriteToClient(client, sizeof(xRRSetScreenConfigReply), (char *)&amp;rep);
+
+    return (client-&gt;noClientException);
+}
+
+static CARD16
+RR10CurrentSizeID (ScreenPtr pScreen)
+{
+    CARD16	sizeID = 0xffff;
+    RROutputPtr output = RRFirstOutput (pScreen);
+    
+    if (output)
+    {
+	RR10DataPtr data = RR10GetData (pScreen, output);
+	if (data)
+	{
+	    int i;
+	    for (i = 0; i &lt; data-&gt;nsize; i++)
+		if (data-&gt;sizes[i].width == pScreen-&gt;width &amp;&amp;
+		    data-&gt;sizes[i].height == pScreen-&gt;height)
+		{
+		    sizeID = (CARD16) i;
+		    break;
+		}
+	    xfree (data);
+	}
+    }
+    return sizeID;
+}
diff --git a/nx-X11/programs/Xserver/randr/rrscreen.c.NX.original b/nx-X11/programs/Xserver/randr/rrscreen.c.NX.original
new file mode 100644
index 0000000..9b3935e
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrscreen.c.NX.original
@@ -0,0 +1,1030 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &quot;randrstr.h&quot;
+
+extern char	*ConnectionInfo;
+
+static int padlength[4] = {0, 3, 2, 1};
+
+static CARD16
+RR10CurrentSizeID (ScreenPtr pScreen);
+
+/*
+ * Edit connection information block so that new clients
+ * see the current screen size on connect
+ */
+static void
+RREditConnectionInfo (ScreenPtr pScreen)
+{
+    xConnSetup	    *connSetup;
+    char	    *vendor;
+    xPixmapFormat   *formats;
+    xWindowRoot	    *root;
+    xDepth	    *depth;
+    xVisualType	    *visual;
+    int		    screen = 0;
+    int		    d;
+
+    connSetup = (xConnSetup *) ConnectionInfo;
+    vendor = (char *) connSetup + sizeof (xConnSetup);
+    formats = (xPixmapFormat *) ((char *) vendor +
+				 connSetup-&gt;nbytesVendor +
+				 padlength[connSetup-&gt;nbytesVendor &amp; 3]);
+    root = (xWindowRoot *) ((char *) formats +
+			    sizeof (xPixmapFormat) * screenInfo.numPixmapFormats);
+    while (screen != pScreen-&gt;myNum)
+    {
+	depth = (xDepth *) ((char *) root + 
+			    sizeof (xWindowRoot));
+	for (d = 0; d &lt; root-&gt;nDepths; d++)
+	{
+	    visual = (xVisualType *) ((char *) depth +
+				      sizeof (xDepth));
+	    depth = (xDepth *) ((char *) visual +
+				depth-&gt;nVisuals * sizeof (xVisualType));
+	}
+	root = (xWindowRoot *) ((char *) depth);
+	screen++;
+    }
+    root-&gt;pixWidth = pScreen-&gt;width;
+    root-&gt;pixHeight = pScreen-&gt;height;
+    root-&gt;mmWidth = pScreen-&gt;mmWidth;
+    root-&gt;mmHeight = pScreen-&gt;mmHeight;
+}
+
+void
+RRSendConfigNotify (ScreenPtr pScreen)
+{
+    WindowPtr	pWin = WindowTable[pScreen-&gt;myNum];
+    xEvent	event;
+
+    event.u.u.type = ConfigureNotify;
+    event.u.configureNotify.window = pWin-&gt;drawable.id;
+    event.u.configureNotify.aboveSibling = None;
+    event.u.configureNotify.x = 0;
+    event.u.configureNotify.y = 0;
+
+    /* XXX xinerama stuff ? */
+    
+    event.u.configureNotify.width = pWin-&gt;drawable.width;
+    event.u.configureNotify.height = pWin-&gt;drawable.height;
+    event.u.configureNotify.borderWidth = wBorderWidth (pWin);
+    event.u.configureNotify.override = pWin-&gt;overrideRedirect;
+    DeliverEvents(pWin, &amp;event, 1, NullWindow);
+}
+
+void
+RRDeliverScreenEvent (ClientPtr client, WindowPtr pWin, ScreenPtr pScreen)
+{
+    rrScrPriv (pScreen);
+    xRRScreenChangeNotifyEvent	se;
+    RRCrtcPtr	crtc = pScrPriv-&gt;numCrtcs ? pScrPriv-&gt;crtcs[0] : NULL;
+    WindowPtr	pRoot = WindowTable[pScreen-&gt;myNum];
+    
+    se.type = RRScreenChangeNotify + RREventBase;
+    se.rotation = (CARD8) (crtc ? crtc-&gt;rotation : RR_Rotate_0);
+    se.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    se.sequenceNumber = client-&gt;sequence;
+    se.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+    se.root =  pRoot-&gt;drawable.id;
+    se.window = pWin-&gt;drawable.id;
+#ifdef RENDER
+    se.subpixelOrder = PictureGetSubpixelOrder (pScreen);
+#else
+    se.subpixelOrder = SubPixelUnknown;
+#endif
+
+    se.sequenceNumber = client-&gt;sequence;
+    se.sizeID = RR10CurrentSizeID (pScreen);
+
+    if (se.rotation &amp; (RR_Rotate_90 | RR_Rotate_270)) {
+	se.widthInPixels = pScreen-&gt;height;
+	se.heightInPixels = pScreen-&gt;width;
+	se.widthInMillimeters = pScreen-&gt;mmHeight;
+	se.heightInMillimeters = pScreen-&gt;mmWidth;
+    } else {
+	se.widthInPixels = pScreen-&gt;width;
+	se.heightInPixels = pScreen-&gt;height;
+	se.widthInMillimeters = pScreen-&gt;mmWidth;
+	se.heightInMillimeters = pScreen-&gt;mmHeight;
+    }
+
+    WriteEventsToClient (client, 1, (xEvent *) &amp;se);
+}
+
+/*
+ * Notify the extension that the screen size has been changed.
+ * The driver is responsible for calling this whenever it has changed
+ * the size of the screen
+ */
+void
+RRScreenSizeNotify (ScreenPtr	pScreen)
+{
+    rrScrPriv(pScreen);
+    /*
+     * Deliver ConfigureNotify events when root changes
+     * pixel size
+     */
+    if (pScrPriv-&gt;width == pScreen-&gt;width &amp;&amp;
+	pScrPriv-&gt;height == pScreen-&gt;height &amp;&amp;
+	pScrPriv-&gt;mmWidth == pScreen-&gt;mmWidth &amp;&amp;
+	pScrPriv-&gt;mmHeight == pScreen-&gt;mmHeight)
+	return;
+    
+    pScrPriv-&gt;width = pScreen-&gt;width;
+    pScrPriv-&gt;height = pScreen-&gt;height;
+    pScrPriv-&gt;mmWidth = pScreen-&gt;mmWidth;
+    pScrPriv-&gt;mmHeight = pScreen-&gt;mmHeight;
+    pScrPriv-&gt;changed = TRUE;
+/*    pScrPriv-&gt;sizeChanged = TRUE; */
+
+    RRTellChanged (pScreen);
+    RRSendConfigNotify (pScreen);
+    RREditConnectionInfo (pScreen);
+    
+    RRPointerScreenConfigured (pScreen);
+    /*
+     * Fix pointer bounds and location
+     */
+    ScreenRestructured (pScreen);
+}
+
+/*
+ * Request that the screen be resized
+ */
+Bool
+RRScreenSizeSet (ScreenPtr  pScreen,
+		 CARD16	    width,
+		 CARD16	    height,
+		 CARD32	    mmWidth,
+		 CARD32	    mmHeight)
+{
+    rrScrPriv(pScreen);
+
+#if RANDR_12_INTERFACE
+    if (pScrPriv-&gt;rrScreenSetSize)
+    {
+	return (*pScrPriv-&gt;rrScreenSetSize) (pScreen,
+					     width, height,
+					     mmWidth, mmHeight);
+    }
+#endif
+#if RANDR_10_INTERFACE
+    if (pScrPriv-&gt;rrSetConfig)
+    {
+	return TRUE;	/* can't set size separately */
+    }
+#endif
+    return FALSE;
+}
+
+/*
+ * Retrieve valid screen size range
+ */
+int 
+ProcRRGetScreenSizeRange (ClientPtr client)
+{
+    REQUEST(xRRGetScreenSizeRangeReq);
+    xRRGetScreenSizeRangeReply	rep;
+    WindowPtr			pWin;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    int				rc;
+    
+    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    rep.type = X_Reply;
+    rep.pad = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.length = 0;
+    
+    if (pScrPriv) 
+    {
+	if (!RRGetInfo (pScreen))
+	    return BadAlloc;
+	rep.minWidth  = pScrPriv-&gt;minWidth;
+	rep.minHeight = pScrPriv-&gt;minHeight;
+	rep.maxWidth  = pScrPriv-&gt;maxWidth;
+	rep.maxHeight = pScrPriv-&gt;maxHeight;
+    }
+    else
+    {
+	rep.maxWidth  = rep.minWidth  = pScreen-&gt;width;
+	rep.maxHeight = rep.minHeight = pScreen-&gt;height;
+    }
+    if (client-&gt;swapped) 
+    {
+	int n;
+	
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swaps(&amp;rep.minWidth, n);
+	swaps(&amp;rep.minHeight, n);
+	swaps(&amp;rep.maxWidth, n);
+	swaps(&amp;rep.maxHeight, n);
+    }
+    WriteToClient(client, sizeof(xRRGetScreenSizeRangeReply), (char *)&amp;rep);
+    return (client-&gt;noClientException);
+}
+
+int
+ProcRRSetScreenSize (ClientPtr client)
+{
+    REQUEST(xRRSetScreenSizeReq);
+    WindowPtr		pWin;
+    ScreenPtr		pScreen;
+    rrScrPrivPtr	pScrPriv;
+    int			i, rc;
+    
+    REQUEST_SIZE_MATCH(xRRSetScreenSizeReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    if (stuff-&gt;width &lt; pScrPriv-&gt;minWidth || pScrPriv-&gt;maxWidth &lt; stuff-&gt;width)
+    {
+	client-&gt;errorValue = stuff-&gt;width;
+	return BadValue;
+    }
+    if (stuff-&gt;height &lt; pScrPriv-&gt;minHeight || 
+	pScrPriv-&gt;maxHeight &lt; stuff-&gt;height)
+    {
+	client-&gt;errorValue = stuff-&gt;height;
+	return BadValue;
+    }
+    for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++) 
+    {
+	RRCrtcPtr   crtc = pScrPriv-&gt;crtcs[i];
+	RRModePtr   mode = crtc-&gt;mode;
+	if (mode)
+	{
+	    int		source_width = mode-&gt;mode.width;
+	    int		source_height = mode-&gt;mode.height;
+	    Rotation	rotation = crtc-&gt;rotation;
+
+	    if (rotation == RR_Rotate_90 || rotation == RR_Rotate_270)
+	    {
+		source_width = mode-&gt;mode.height;
+		source_height = mode-&gt;mode.width;
+	    }
+	    
+	    if (crtc-&gt;x + source_width &gt; stuff-&gt;width ||
+		crtc-&gt;y + source_height &gt; stuff-&gt;height)
+	    return BadMatch;
+	}
+    }
+    if (stuff-&gt;widthInMillimeters == 0 || stuff-&gt;heightInMillimeters == 0)
+    {
+	client-&gt;errorValue = 0;
+	return BadValue;
+    }
+    if (!RRScreenSizeSet (pScreen, 
+			  stuff-&gt;width, stuff-&gt;height,
+			  stuff-&gt;widthInMillimeters,
+			  stuff-&gt;heightInMillimeters))
+    {
+	return BadMatch;
+    }
+    return Success;
+}
+
+int
+ProcRRGetScreenResources (ClientPtr client)
+{
+    REQUEST(xRRGetScreenResourcesReq);
+    xRRGetScreenResourcesReply  rep;
+    WindowPtr			pWin;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    CARD8			*extra;
+    unsigned long		extraLen;
+    int				i, n, rc;
+    RRCrtc			*crtcs;
+    RROutput			*outputs;
+    xRRModeInfo			*modeinfos;
+    CARD8			*names;
+    
+    REQUEST_SIZE_MATCH(xRRGetScreenResourcesReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+    
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    rep.pad = 0;
+    
+    if (pScrPriv)
+	if (!RRGetInfo (pScreen))
+	    return BadAlloc;
+
+    if (!pScrPriv)
+    {
+	rep.type = X_Reply;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.timestamp = currentTime.milliseconds;
+	rep.configTimestamp = currentTime.milliseconds;
+	rep.nCrtcs = 0;
+	rep.nOutputs = 0;
+	rep.nModes = 0;
+	rep.nbytesNames = 0;
+	extra = NULL;
+	extraLen = 0;
+    }
+    else
+    {
+	RRModePtr   *modes;
+	int	    num_modes;
+
+	modes = RRModesForScreen (pScreen, &amp;num_modes);
+	if (!modes)
+	    return BadAlloc;
+	
+	rep.type = X_Reply;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+	rep.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+	rep.nCrtcs = pScrPriv-&gt;numCrtcs;
+	rep.nOutputs = pScrPriv-&gt;numOutputs;
+	rep.nModes = num_modes;
+	rep.nbytesNames = 0;
+
+	for (i = 0; i &lt; num_modes; i++)
+	    rep.nbytesNames += modes[i]-&gt;mode.nameLength;
+
+	rep.length = (pScrPriv-&gt;numCrtcs + 
+		      pScrPriv-&gt;numOutputs + 
+		      num_modes * (SIZEOF(xRRModeInfo) &gt;&gt; 2) +
+		      ((rep.nbytesNames + 3) &gt;&gt; 2));
+	
+	extraLen = rep.length &lt;&lt; 2;
+	if (extraLen)
+	{
+	    extra = xalloc (extraLen);
+	    if (!extra)
+	    {
+		xfree (modes);
+		return BadAlloc;
+	    }
+	}
+	else
+	    extra = NULL;
+
+	crtcs = (RRCrtc *) extra;
+	outputs = (RROutput *) (crtcs + pScrPriv-&gt;numCrtcs);
+	modeinfos = (xRRModeInfo *) (outputs + pScrPriv-&gt;numOutputs);
+	names = (CARD8 *) (modeinfos + num_modes);
+	
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	{
+	    crtcs[i] = pScrPriv-&gt;crtcs[i]-&gt;id;
+	    if (client-&gt;swapped)
+		swapl (&amp;crtcs[i], n);
+	}
+	
+	for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	{
+	    outputs[i] = pScrPriv-&gt;outputs[i]-&gt;id;
+	    if (client-&gt;swapped)
+		swapl (&amp;outputs[i], n);
+	}
+	
+	for (i = 0; i &lt; num_modes; i++)
+	{
+	    RRModePtr	mode = modes[i];
+	    modeinfos[i] = mode-&gt;mode;
+	    if (client-&gt;swapped)
+	    {
+		swapl (&amp;modeinfos[i].id, n);
+		swaps (&amp;modeinfos[i].width, n);
+		swaps (&amp;modeinfos[i].height, n);
+		swapl (&amp;modeinfos[i].dotClock, n);
+		swaps (&amp;modeinfos[i].hSyncStart, n);
+		swaps (&amp;modeinfos[i].hSyncEnd, n);
+		swaps (&amp;modeinfos[i].hTotal, n);
+		swaps (&amp;modeinfos[i].hSkew, n);
+		swaps (&amp;modeinfos[i].vSyncStart, n);
+		swaps (&amp;modeinfos[i].vSyncEnd, n);
+		swaps (&amp;modeinfos[i].vTotal, n);
+		swaps (&amp;modeinfos[i].nameLength, n);
+		swapl (&amp;modeinfos[i].modeFlags, n);
+	    }
+	    memcpy (names, mode-&gt;name, 
+		    mode-&gt;mode.nameLength);
+	    names += mode-&gt;mode.nameLength;
+	}
+    	xfree (modes);
+	assert (((((char *) names - (char *) extra) + 3) &gt;&gt; 2) == rep.length);
+    }
+    
+    if (client-&gt;swapped) {
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.timestamp, n);
+	swapl(&amp;rep.configTimestamp, n);
+	swaps(&amp;rep.nCrtcs, n);
+	swaps(&amp;rep.nOutputs, n);
+	swaps(&amp;rep.nModes, n);
+	swaps(&amp;rep.nbytesNames, n);
+    }
+    WriteToClient(client, sizeof(xRRGetScreenResourcesReply), (char *)&amp;rep);
+    if (extraLen)
+    {
+	WriteToClient (client, extraLen, (char *) extra);
+	xfree (extra);
+    }
+    return client-&gt;noClientException;
+}
+
+typedef struct _RR10Data {
+    RRScreenSizePtr sizes;
+    int		    nsize;
+    int		    nrefresh;
+    int		    size;
+    CARD16	    refresh;
+} RR10DataRec, *RR10DataPtr;
+
+/*
+ * Convert 1.2 monitor data into 1.0 screen data
+ */
+static RR10DataPtr
+RR10GetData (ScreenPtr pScreen, RROutputPtr output)
+{
+    RR10DataPtr	    data;
+    RRScreenSizePtr size;
+    int		    nmode = output-&gt;numModes + output-&gt;numUserModes;
+    int		    o, os, l, r;
+    RRScreenRatePtr refresh;
+    CARD16	    vRefresh;
+    RRModePtr	    mode;
+    Bool	    *used;
+
+    /* Make sure there is plenty of space for any combination */
+    data = malloc (sizeof (RR10DataRec) + 
+		   sizeof (RRScreenSize) * nmode + 
+		   sizeof (RRScreenRate) * nmode +
+		   sizeof (Bool) * nmode);
+    if (!data)
+	return NULL;
+    size = (RRScreenSizePtr) (data + 1);
+    refresh = (RRScreenRatePtr) (size + nmode);
+    used = (Bool *) (refresh + nmode);
+    memset (used, '\0', sizeof (Bool) * nmode);
+    data-&gt;sizes = size;
+    data-&gt;nsize = 0;
+    data-&gt;nrefresh = 0;
+    data-&gt;size = 0;
+    data-&gt;refresh = 0;
+    
+    /*
+     * find modes not yet listed
+     */
+    for (o = 0; o &lt; output-&gt;numModes + output-&gt;numUserModes; o++)
+    {
+	if (used[o]) continue;
+	
+	if (o &lt; output-&gt;numModes)
+	    mode = output-&gt;modes[o];
+	else
+	    mode = output-&gt;userModes[o - output-&gt;numModes];
+	
+	l = data-&gt;nsize;
+	size[l].id = data-&gt;nsize;
+	size[l].width = mode-&gt;mode.width;
+	size[l].height = mode-&gt;mode.height;
+	if (output-&gt;mmWidth &amp;&amp; output-&gt;mmHeight) {
+	    size[l].mmWidth = output-&gt;mmWidth;
+	    size[l].mmHeight = output-&gt;mmHeight;
+	} else {
+	    size[l].mmWidth = pScreen-&gt;mmWidth;
+	    size[l].mmHeight = pScreen-&gt;mmHeight;
+	}
+	size[l].nRates = 0;
+	size[l].pRates = &amp;refresh[data-&gt;nrefresh];
+	data-&gt;nsize++;
+	
+	/*
+	 * Find all modes with matching size
+	 */
+	for (os = o; os &lt; output-&gt;numModes + output-&gt;numUserModes; os++)
+	{
+	    if (os &lt; output-&gt;numModes)
+		mode = output-&gt;modes[os];
+	    else
+		mode = output-&gt;userModes[os - output-&gt;numModes];
+	    if (mode-&gt;mode.width == size[l].width &amp;&amp;
+		mode-&gt;mode.height == size[l].height)
+	    {
+		vRefresh = RRVerticalRefresh (&amp;mode-&gt;mode);
+		used[os] = TRUE;
+		
+		for (r = 0; r &lt; size[l].nRates; r++)
+		    if (vRefresh == size[l].pRates[r].rate)
+			break;
+		if (r == size[l].nRates)
+		{
+		    size[l].pRates[r].rate = vRefresh;
+		    size[l].pRates[r].mode = mode;
+		    size[l].nRates++;
+		    data-&gt;nrefresh++;
+		}
+		if (mode == output-&gt;crtc-&gt;mode)
+		{
+		    data-&gt;size = l;
+		    data-&gt;refresh = vRefresh;
+		}
+	    }
+	}
+    }
+    return data;
+}
+
+int
+ProcRRGetScreenInfo (ClientPtr client)
+{
+    REQUEST(xRRGetScreenInfoReq);
+    xRRGetScreenInfoReply   rep;
+    WindowPtr	    	    pWin;
+    int			    n, rc;
+    ScreenPtr		    pScreen;
+    rrScrPrivPtr	    pScrPriv;
+    CARD8		    *extra;
+    unsigned long	    extraLen;
+    RROutputPtr		    output;
+
+    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    rep.pad = 0;
+    
+    if (pScrPriv)
+	if (!RRGetInfo (pScreen))
+	    return BadAlloc;
+
+    output = RRFirstOutput (pScreen);
+    
+    if (!pScrPriv || !output)
+    {
+	rep.type = X_Reply;
+	rep.setOfRotations = RR_Rotate_0;;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.root = WindowTable[pWin-&gt;drawable.pScreen-&gt;myNum]-&gt;drawable.id;
+	rep.timestamp = currentTime.milliseconds;
+	rep.configTimestamp = currentTime.milliseconds;
+	rep.nSizes = 0;
+	rep.sizeID = 0;
+	rep.rotation = RR_Rotate_0;
+	rep.rate = 0;
+	rep.nrateEnts = 0;
+	extra = 0;
+	extraLen = 0;
+    }
+    else
+    {
+	int			i, j;
+	xScreenSizes		*size;
+	CARD16			*rates;
+	CARD8			*data8;
+	Bool			has_rate = RRClientKnowsRates (client);
+	RR10DataPtr		pData;
+	RRScreenSizePtr		pSize;
+    
+	pData = RR10GetData (pScreen, output);
+	if (!pData)
+	    return BadAlloc;
+	
+	rep.type = X_Reply;
+	rep.setOfRotations = output-&gt;crtc-&gt;rotations;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.root = WindowTable[pWin-&gt;drawable.pScreen-&gt;myNum]-&gt;drawable.id;
+	rep.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+	rep.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+	rep.rotation = output-&gt;crtc-&gt;rotation;
+	rep.nSizes = pData-&gt;nsize;
+        rep.nrateEnts = pData-&gt;nrefresh + pData-&gt;nsize;
+	rep.sizeID = pData-&gt;size;
+	rep.rate = pData-&gt;refresh;
+
+	extraLen = (rep.nSizes * sizeof (xScreenSizes) +
+		    rep.nrateEnts * sizeof (CARD16));
+
+	if (extraLen)
+	{
+	    extra = (CARD8 *) xalloc (extraLen);
+	    if (!extra)
+	    {
+		xfree (pData);
+		return BadAlloc;
+	    }
+	}
+	else
+	    extra = NULL;
+
+	/*
+	 * First comes the size information
+	 */
+	size = (xScreenSizes *) extra;
+	rates = (CARD16 *) (size + rep.nSizes);
+	for (i = 0; i &lt; pData-&gt;nsize; i++)
+	{
+	    pSize = &amp;pData-&gt;sizes[i];
+	    size-&gt;widthInPixels = pSize-&gt;width;
+	    size-&gt;heightInPixels = pSize-&gt;height;
+	    size-&gt;widthInMillimeters = pSize-&gt;mmWidth;
+	    size-&gt;heightInMillimeters = pSize-&gt;mmHeight;
+	    if (client-&gt;swapped)
+	    {
+	        swaps (&amp;size-&gt;widthInPixels, n);
+	        swaps (&amp;size-&gt;heightInPixels, n);
+	        swaps (&amp;size-&gt;widthInMillimeters, n);
+	        swaps (&amp;size-&gt;heightInMillimeters, n);
+	    }
+	    size++;
+	    if (has_rate)
+	    {
+		*rates = pSize-&gt;nRates;
+		if (client-&gt;swapped)
+		{
+		    swaps (rates, n);
+		}
+		rates++;
+		for (j = 0; j &lt; pSize-&gt;nRates; j++)
+		{
+		    *rates = pSize-&gt;pRates[j].rate;
+		    if (client-&gt;swapped)
+		    {
+			swaps (rates, n);
+		    }
+		    rates++;
+		}
+	    }
+	}
+        xfree (pData);
+	
+	data8 = (CARD8 *) rates;
+
+	if (data8 - (CARD8 *) extra != extraLen)
+	    FatalError (&quot;RRGetScreenInfo bad extra len %ld != %ld\n&quot;,
+			(unsigned long)(data8 - (CARD8 *) extra), extraLen);
+	rep.length =  (extraLen + 3) &gt;&gt; 2;
+    }
+    if (client-&gt;swapped) {
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.timestamp, n);
+	swaps(&amp;rep.rotation, n);
+	swaps(&amp;rep.nSizes, n);
+	swaps(&amp;rep.sizeID, n);
+	swaps(&amp;rep.rate, n);
+	swaps(&amp;rep.nrateEnts, n);
+    }
+    WriteToClient(client, sizeof(xRRGetScreenInfoReply), (char *)&amp;rep);
+    if (extraLen)
+    {
+	WriteToClient (client, extraLen, (char *) extra);
+	xfree (extra);
+    }
+    return (client-&gt;noClientException);
+}
+
+int
+ProcRRSetScreenConfig (ClientPtr client)
+{
+    REQUEST(xRRSetScreenConfigReq);
+    xRRSetScreenConfigReply rep;
+    DrawablePtr		    pDraw;
+    int			    n, rc;
+    ScreenPtr		    pScreen;
+    rrScrPrivPtr	    pScrPriv;
+    TimeStamp		    time;
+    int			    i;
+    Rotation		    rotation;
+    int			    rate;
+    Bool		    has_rate;
+    RROutputPtr		    output;
+    RRCrtcPtr		    crtc;
+    RRModePtr		    mode;
+    RR10DataPtr		    pData = NULL;
+    RRScreenSizePtr    	    pSize;
+    int			    width, height;
+    
+    UpdateCurrentTime ();
+
+    if (RRClientKnowsRates (client))
+    {
+	REQUEST_SIZE_MATCH (xRRSetScreenConfigReq);
+	has_rate = TRUE;
+    }
+    else
+    {
+	REQUEST_SIZE_MATCH (xRR1_0SetScreenConfigReq);
+	has_rate = FALSE;
+    }
+    
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupDrawable(&amp;pDraw, stuff-&gt;drawable, client, 0, DixWriteAccess);
+    #else
+    pDraw = SecurityLookupDrawable(stuff-&gt;drawable, client, SecurityWriteAccess);
+    rc = pDraw ? Success : BadDrawable;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pDraw-&gt;pScreen;
+
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    time = ClientTimeToServerTime(stuff-&gt;timestamp);
+    
+    if (!pScrPriv)
+    {
+	time = currentTime;
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+    if (!RRGetInfo (pScreen))
+	return BadAlloc;
+    
+    output = RRFirstOutput (pScreen);
+    if (!output)
+    {
+	time = currentTime;
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+
+    crtc = output-&gt;crtc;
+
+    /*
+     * If the client's config timestamp is not the same as the last config
+     * timestamp, then the config information isn't up-to-date and
+     * can't even be validated.
+     *
+     * Note that the client only knows about the milliseconds part of the
+     * timestamp, so using CompareTimeStamps here would cause randr to suddenly
+     * stop working after several hours have passed (freedesktop bug #6502).
+     */
+    if (stuff-&gt;configTimestamp != pScrPriv-&gt;lastConfigTime.milliseconds)
+    {
+	rep.status = RRSetConfigInvalidConfigTime;
+	goto sendReply;
+    }
+    
+    pData = RR10GetData (pScreen, output);
+    if (!pData)
+	return BadAlloc;
+    
+    if (stuff-&gt;sizeID &gt;= pData-&gt;nsize)
+    {
+	/*
+	 * Invalid size ID
+	 */
+	client-&gt;errorValue = stuff-&gt;sizeID;
+	xfree (pData);
+	return BadValue;
+    }
+    pSize = &amp;pData-&gt;sizes[stuff-&gt;sizeID];
+    
+    /*
+     * Validate requested rotation
+     */
+    rotation = (Rotation) stuff-&gt;rotation;
+
+    /* test the rotation bits only! */
+    switch (rotation &amp; 0xf) {
+    case RR_Rotate_0:
+    case RR_Rotate_90:
+    case RR_Rotate_180:
+    case RR_Rotate_270:
+	break;
+    default:
+	/*
+	 * Invalid rotation
+	 */
+	client-&gt;errorValue = stuff-&gt;rotation;
+	xfree (pData);
+	return BadValue;
+    }
+
+    if ((~crtc-&gt;rotations) &amp; rotation)
+    {
+	/*
+	 * requested rotation or reflection not supported by screen
+	 */
+	client-&gt;errorValue = stuff-&gt;rotation;
+	xfree (pData);
+	return BadMatch;
+    }
+
+    /*
+     * Validate requested refresh
+     */
+    if (has_rate)
+	rate = (int) stuff-&gt;rate;
+    else
+	rate = 0;
+
+    if (rate)
+    {
+	for (i = 0; i &lt; pSize-&gt;nRates; i++)
+	{
+	    if (pSize-&gt;pRates[i].rate == rate)
+		break;
+	}
+	if (i == pSize-&gt;nRates)
+	{
+	    /*
+	     * Invalid rate
+	     */
+	    client-&gt;errorValue = rate;
+	    xfree (pData);
+	    return BadValue;
+	}
+	mode = pSize-&gt;pRates[i].mode;
+    }
+    else
+	mode = pSize-&gt;pRates[0].mode;
+    
+    /*
+     * Make sure the requested set-time is not older than
+     * the last set-time
+     */
+    if (CompareTimeStamps (time, pScrPriv-&gt;lastSetTime) &lt; 0)
+    {
+	rep.status = RRSetConfigInvalidTime;
+	goto sendReply;
+    }
+
+    /*
+     * If the screen size is changing, adjust all of the other outputs
+     * to fit the new size, mirroring as much as possible
+     */
+    width = mode-&gt;mode.width;
+    height = mode-&gt;mode.height;
+    if (rotation &amp; (RR_Rotate_90|RR_Rotate_270))
+    {
+	width = mode-&gt;mode.height;
+	height = mode-&gt;mode.width;
+    }
+    if (width != pScreen-&gt;width || height != pScreen-&gt;height)
+    {
+	int	c;
+
+	for (c = 0; c &lt; pScrPriv-&gt;numCrtcs; c++)
+	{
+	    if (!RRCrtcSet (pScrPriv-&gt;crtcs[c], NULL, 0, 0, RR_Rotate_0,
+			    0, NULL))
+	    {
+		rep.status = RRSetConfigFailed;
+		/* XXX recover from failure */
+		goto sendReply;
+	    }
+	}
+	if (!RRScreenSizeSet (pScreen, width, height,
+			      pScreen-&gt;mmWidth, pScreen-&gt;mmHeight))
+	{
+	    rep.status = RRSetConfigFailed;
+	    /* XXX recover from failure */
+	    goto sendReply;
+	}
+    }
+
+    if (!RRCrtcSet (crtc, mode, 0, 0, stuff-&gt;rotation, 1, &amp;output))
+	rep.status = RRSetConfigFailed;
+    #ifndef NXAGENT_SERVER /* Bug 21987 */
+    else
+	rep.status = RRSetConfigSuccess;
+    #else
+    else {
+	rep.status = RRSetConfigSuccess;
+	pScrPriv-&gt;lastSetTime = time;
+    }
+    #endif
+
+    /*
+     * XXX Configure other crtcs to mirror as much as possible
+     */
+    
+sendReply:
+    
+    if (pData)
+	xfree (pData);
+
+    rep.type = X_Reply;
+    /* rep.status has already been filled in */
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+
+    rep.newTimestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    rep.newConfigTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+    rep.root = WindowTable[pDraw-&gt;pScreen-&gt;myNum]-&gt;drawable.id;
+
+    if (client-&gt;swapped) 
+    {
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.newTimestamp, n);
+	swapl(&amp;rep.newConfigTimestamp, n);
+	swapl(&amp;rep.root, n);
+    }
+    WriteToClient(client, sizeof(xRRSetScreenConfigReply), (char *)&amp;rep);
+
+    return (client-&gt;noClientException);
+}
+
+static CARD16
+RR10CurrentSizeID (ScreenPtr pScreen)
+{
+    CARD16	sizeID = 0xffff;
+    RROutputPtr output = RRFirstOutput (pScreen);
+    
+    if (output)
+    {
+	RR10DataPtr data = RR10GetData (pScreen, output);
+	if (data)
+	{
+	    int i;
+	    for (i = 0; i &lt; data-&gt;nsize; i++)
+		if (data-&gt;sizes[i].width == pScreen-&gt;width &amp;&amp;
+		    data-&gt;sizes[i].height == pScreen-&gt;height)
+		{
+		    sizeID = (CARD16) i;
+		    break;
+		}
+	    xfree (data);
+	}
+    }
+    return sizeID;
+}
diff --git a/nx-X11/programs/Xserver/randr/rrscreen.c.X.original b/nx-X11/programs/Xserver/randr/rrscreen.c.X.original
new file mode 100644
index 0000000..f391973
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrscreen.c.X.original
@@ -0,0 +1,981 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include &quot;randrstr.h&quot;
+
+extern char	*ConnectionInfo;
+
+static int padlength[4] = {0, 3, 2, 1};
+
+static CARD16
+RR10CurrentSizeID (ScreenPtr pScreen);
+
+/*
+ * Edit connection information block so that new clients
+ * see the current screen size on connect
+ */
+static void
+RREditConnectionInfo (ScreenPtr pScreen)
+{
+    xConnSetup	    *connSetup;
+    char	    *vendor;
+    xPixmapFormat   *formats;
+    xWindowRoot	    *root;
+    xDepth	    *depth;
+    xVisualType	    *visual;
+    int		    screen = 0;
+    int		    d;
+
+    connSetup = (xConnSetup *) ConnectionInfo;
+    vendor = (char *) connSetup + sizeof (xConnSetup);
+    formats = (xPixmapFormat *) ((char *) vendor +
+				 connSetup-&gt;nbytesVendor +
+				 padlength[connSetup-&gt;nbytesVendor &amp; 3]);
+    root = (xWindowRoot *) ((char *) formats +
+			    sizeof (xPixmapFormat) * screenInfo.numPixmapFormats);
+    while (screen != pScreen-&gt;myNum)
+    {
+	depth = (xDepth *) ((char *) root + 
+			    sizeof (xWindowRoot));
+	for (d = 0; d &lt; root-&gt;nDepths; d++)
+	{
+	    visual = (xVisualType *) ((char *) depth +
+				      sizeof (xDepth));
+	    depth = (xDepth *) ((char *) visual +
+				depth-&gt;nVisuals * sizeof (xVisualType));
+	}
+	root = (xWindowRoot *) ((char *) depth);
+	screen++;
+    }
+    root-&gt;pixWidth = pScreen-&gt;width;
+    root-&gt;pixHeight = pScreen-&gt;height;
+    root-&gt;mmWidth = pScreen-&gt;mmWidth;
+    root-&gt;mmHeight = pScreen-&gt;mmHeight;
+}
+
+void
+RRSendConfigNotify (ScreenPtr pScreen)
+{
+    WindowPtr	pWin = WindowTable[pScreen-&gt;myNum];
+    xEvent	event;
+
+    event.u.u.type = ConfigureNotify;
+    event.u.configureNotify.window = pWin-&gt;drawable.id;
+    event.u.configureNotify.aboveSibling = None;
+    event.u.configureNotify.x = 0;
+    event.u.configureNotify.y = 0;
+
+    /* XXX xinerama stuff ? */
+    
+    event.u.configureNotify.width = pWin-&gt;drawable.width;
+    event.u.configureNotify.height = pWin-&gt;drawable.height;
+    event.u.configureNotify.borderWidth = wBorderWidth (pWin);
+    event.u.configureNotify.override = pWin-&gt;overrideRedirect;
+    DeliverEvents(pWin, &amp;event, 1, NullWindow);
+}
+
+void
+RRDeliverScreenEvent (ClientPtr client, WindowPtr pWin, ScreenPtr pScreen)
+{
+    rrScrPriv (pScreen);
+    xRRScreenChangeNotifyEvent	se;
+    RRCrtcPtr	crtc = pScrPriv-&gt;numCrtcs ? pScrPriv-&gt;crtcs[0] : NULL;
+    WindowPtr	pRoot = WindowTable[pScreen-&gt;myNum];
+    
+    se.type = RRScreenChangeNotify + RREventBase;
+    se.rotation = (CARD8) (crtc ? crtc-&gt;rotation : RR_Rotate_0);
+    se.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    se.sequenceNumber = client-&gt;sequence;
+    se.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+    se.root =  pRoot-&gt;drawable.id;
+    se.window = pWin-&gt;drawable.id;
+#ifdef RENDER
+    se.subpixelOrder = PictureGetSubpixelOrder (pScreen);
+#else
+    se.subpixelOrder = SubPixelUnknown;
+#endif
+
+    se.sequenceNumber = client-&gt;sequence;
+    se.sizeID = RR10CurrentSizeID (pScreen);
+
+    if (se.rotation &amp; (RR_Rotate_90 | RR_Rotate_270)) {
+	se.widthInPixels = pScreen-&gt;height;
+	se.heightInPixels = pScreen-&gt;width;
+	se.widthInMillimeters = pScreen-&gt;mmHeight;
+	se.heightInMillimeters = pScreen-&gt;mmWidth;
+    } else {
+	se.widthInPixels = pScreen-&gt;width;
+	se.heightInPixels = pScreen-&gt;height;
+	se.widthInMillimeters = pScreen-&gt;mmWidth;
+	se.heightInMillimeters = pScreen-&gt;mmHeight;
+    }
+
+    WriteEventsToClient (client, 1, (xEvent *) &amp;se);
+}
+
+/*
+ * Notify the extension that the screen size has been changed.
+ * The driver is responsible for calling this whenever it has changed
+ * the size of the screen
+ */
+void
+RRScreenSizeNotify (ScreenPtr	pScreen)
+{
+    rrScrPriv(pScreen);
+    /*
+     * Deliver ConfigureNotify events when root changes
+     * pixel size
+     */
+    if (pScrPriv-&gt;width == pScreen-&gt;width &amp;&amp;
+	pScrPriv-&gt;height == pScreen-&gt;height &amp;&amp;
+	pScrPriv-&gt;mmWidth == pScreen-&gt;mmWidth &amp;&amp;
+	pScrPriv-&gt;mmHeight == pScreen-&gt;mmHeight)
+	return;
+    
+    pScrPriv-&gt;width = pScreen-&gt;width;
+    pScrPriv-&gt;height = pScreen-&gt;height;
+    pScrPriv-&gt;mmWidth = pScreen-&gt;mmWidth;
+    pScrPriv-&gt;mmHeight = pScreen-&gt;mmHeight;
+    pScrPriv-&gt;changed = TRUE;
+/*    pScrPriv-&gt;sizeChanged = TRUE; */
+
+    RRTellChanged (pScreen);
+    RRSendConfigNotify (pScreen);
+    RREditConnectionInfo (pScreen);
+    
+    RRPointerScreenConfigured (pScreen);
+    /*
+     * Fix pointer bounds and location
+     */
+    ScreenRestructured (pScreen);
+}
+
+/*
+ * Request that the screen be resized
+ */
+Bool
+RRScreenSizeSet (ScreenPtr  pScreen,
+		 CARD16	    width,
+		 CARD16	    height,
+		 CARD32	    mmWidth,
+		 CARD32	    mmHeight)
+{
+    rrScrPriv(pScreen);
+
+#if RANDR_12_INTERFACE
+    if (pScrPriv-&gt;rrScreenSetSize)
+    {
+	return (*pScrPriv-&gt;rrScreenSetSize) (pScreen,
+					     width, height,
+					     mmWidth, mmHeight);
+    }
+#endif
+#if RANDR_10_INTERFACE
+    if (pScrPriv-&gt;rrSetConfig)
+    {
+	return TRUE;	/* can't set size separately */
+    }
+#endif
+    return FALSE;
+}
+
+/*
+ * Retrieve valid screen size range
+ */
+int 
+ProcRRGetScreenSizeRange (ClientPtr client)
+{
+    REQUEST(xRRGetScreenSizeRangeReq);
+    xRRGetScreenSizeRangeReply	rep;
+    WindowPtr			pWin;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    int				rc;
+    
+    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    rep.type = X_Reply;
+    rep.pad = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.length = 0;
+    
+    if (pScrPriv) 
+    {
+	if (!RRGetInfo (pScreen))
+	    return BadAlloc;
+	rep.minWidth  = pScrPriv-&gt;minWidth;
+	rep.minHeight = pScrPriv-&gt;minHeight;
+	rep.maxWidth  = pScrPriv-&gt;maxWidth;
+	rep.maxHeight = pScrPriv-&gt;maxHeight;
+    }
+    else
+    {
+	rep.maxWidth  = rep.minWidth  = pScreen-&gt;width;
+	rep.maxHeight = rep.minHeight = pScreen-&gt;height;
+    }
+    if (client-&gt;swapped) 
+    {
+	int n;
+	
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swaps(&amp;rep.minWidth, n);
+	swaps(&amp;rep.minHeight, n);
+	swaps(&amp;rep.maxWidth, n);
+	swaps(&amp;rep.maxHeight, n);
+    }
+    WriteToClient(client, sizeof(xRRGetScreenSizeRangeReply), (char *)&amp;rep);
+    return (client-&gt;noClientException);
+}
+
+int
+ProcRRSetScreenSize (ClientPtr client)
+{
+    REQUEST(xRRSetScreenSizeReq);
+    WindowPtr		pWin;
+    ScreenPtr		pScreen;
+    rrScrPrivPtr	pScrPriv;
+    int			i, rc;
+    
+    REQUEST_SIZE_MATCH(xRRSetScreenSizeReq);
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    if (stuff-&gt;width &lt; pScrPriv-&gt;minWidth || pScrPriv-&gt;maxWidth &lt; stuff-&gt;width)
+    {
+	client-&gt;errorValue = stuff-&gt;width;
+	return BadValue;
+    }
+    if (stuff-&gt;height &lt; pScrPriv-&gt;minHeight || 
+	pScrPriv-&gt;maxHeight &lt; stuff-&gt;height)
+    {
+	client-&gt;errorValue = stuff-&gt;height;
+	return BadValue;
+    }
+    for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++) 
+    {
+	RRCrtcPtr   crtc = pScrPriv-&gt;crtcs[i];
+	RRModePtr   mode = crtc-&gt;mode;
+	if (mode)
+	{
+	    int		source_width = mode-&gt;mode.width;
+	    int		source_height = mode-&gt;mode.height;
+	    Rotation	rotation = crtc-&gt;rotation;
+
+	    if (rotation == RR_Rotate_90 || rotation == RR_Rotate_270)
+	    {
+		source_width = mode-&gt;mode.height;
+		source_height = mode-&gt;mode.width;
+	    }
+	    
+	    if (crtc-&gt;x + source_width &gt; stuff-&gt;width ||
+		crtc-&gt;y + source_height &gt; stuff-&gt;height)
+	    return BadMatch;
+	}
+    }
+    if (stuff-&gt;widthInMillimeters == 0 || stuff-&gt;heightInMillimeters == 0)
+    {
+	client-&gt;errorValue = 0;
+	return BadValue;
+    }
+    if (!RRScreenSizeSet (pScreen, 
+			  stuff-&gt;width, stuff-&gt;height,
+			  stuff-&gt;widthInMillimeters,
+			  stuff-&gt;heightInMillimeters))
+    {
+	return BadMatch;
+    }
+    return Success;
+}
+
+int
+ProcRRGetScreenResources (ClientPtr client)
+{
+    REQUEST(xRRGetScreenResourcesReq);
+    xRRGetScreenResourcesReply  rep;
+    WindowPtr			pWin;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    CARD8			*extra;
+    unsigned long		extraLen;
+    int				i, n, rc;
+    RRCrtc			*crtcs;
+    RROutput			*outputs;
+    xRRModeInfo			*modeinfos;
+    CARD8			*names;
+    
+    REQUEST_SIZE_MATCH(xRRGetScreenResourcesReq);
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    if (rc != Success)
+	return rc;
+    
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    rep.pad = 0;
+    
+    if (pScrPriv)
+	if (!RRGetInfo (pScreen))
+	    return BadAlloc;
+
+    if (!pScrPriv)
+    {
+	rep.type = X_Reply;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.timestamp = currentTime.milliseconds;
+	rep.configTimestamp = currentTime.milliseconds;
+	rep.nCrtcs = 0;
+	rep.nOutputs = 0;
+	rep.nModes = 0;
+	rep.nbytesNames = 0;
+	extra = NULL;
+	extraLen = 0;
+    }
+    else
+    {
+	RRModePtr   *modes;
+	int	    num_modes;
+
+	modes = RRModesForScreen (pScreen, &amp;num_modes);
+	if (!modes)
+	    return BadAlloc;
+	
+	rep.type = X_Reply;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+	rep.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+	rep.nCrtcs = pScrPriv-&gt;numCrtcs;
+	rep.nOutputs = pScrPriv-&gt;numOutputs;
+	rep.nModes = num_modes;
+	rep.nbytesNames = 0;
+
+	for (i = 0; i &lt; num_modes; i++)
+	    rep.nbytesNames += modes[i]-&gt;mode.nameLength;
+
+	rep.length = (pScrPriv-&gt;numCrtcs + 
+		      pScrPriv-&gt;numOutputs + 
+		      num_modes * (SIZEOF(xRRModeInfo) &gt;&gt; 2) +
+		      ((rep.nbytesNames + 3) &gt;&gt; 2));
+	
+	extraLen = rep.length &lt;&lt; 2;
+	if (extraLen)
+	{
+	    extra = xalloc (extraLen);
+	    if (!extra)
+	    {
+		xfree (modes);
+		return BadAlloc;
+	    }
+	}
+	else
+	    extra = NULL;
+
+	crtcs = (RRCrtc *) extra;
+	outputs = (RROutput *) (crtcs + pScrPriv-&gt;numCrtcs);
+	modeinfos = (xRRModeInfo *) (outputs + pScrPriv-&gt;numOutputs);
+	names = (CARD8 *) (modeinfos + num_modes);
+	
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	{
+	    crtcs[i] = pScrPriv-&gt;crtcs[i]-&gt;id;
+	    if (client-&gt;swapped)
+		swapl (&amp;crtcs[i], n);
+	}
+	
+	for (i = 0; i &lt; pScrPriv-&gt;numOutputs; i++)
+	{
+	    outputs[i] = pScrPriv-&gt;outputs[i]-&gt;id;
+	    if (client-&gt;swapped)
+		swapl (&amp;outputs[i], n);
+	}
+	
+	for (i = 0; i &lt; num_modes; i++)
+	{
+	    RRModePtr	mode = modes[i];
+	    modeinfos[i] = mode-&gt;mode;
+	    if (client-&gt;swapped)
+	    {
+		swapl (&amp;modeinfos[i].id, n);
+		swaps (&amp;modeinfos[i].width, n);
+		swaps (&amp;modeinfos[i].height, n);
+		swapl (&amp;modeinfos[i].dotClock, n);
+		swaps (&amp;modeinfos[i].hSyncStart, n);
+		swaps (&amp;modeinfos[i].hSyncEnd, n);
+		swaps (&amp;modeinfos[i].hTotal, n);
+		swaps (&amp;modeinfos[i].hSkew, n);
+		swaps (&amp;modeinfos[i].vSyncStart, n);
+		swaps (&amp;modeinfos[i].vSyncEnd, n);
+		swaps (&amp;modeinfos[i].vTotal, n);
+		swaps (&amp;modeinfos[i].nameLength, n);
+		swapl (&amp;modeinfos[i].modeFlags, n);
+	    }
+	    memcpy (names, mode-&gt;name, 
+		    mode-&gt;mode.nameLength);
+	    names += mode-&gt;mode.nameLength;
+	}
+    	xfree (modes);
+	assert (((((char *) names - (char *) extra) + 3) &gt;&gt; 2) == rep.length);
+    }
+    
+    if (client-&gt;swapped) {
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.timestamp, n);
+	swapl(&amp;rep.configTimestamp, n);
+	swaps(&amp;rep.nCrtcs, n);
+	swaps(&amp;rep.nOutputs, n);
+	swaps(&amp;rep.nModes, n);
+	swaps(&amp;rep.nbytesNames, n);
+    }
+    WriteToClient(client, sizeof(xRRGetScreenResourcesReply), (char *)&amp;rep);
+    if (extraLen)
+    {
+	WriteToClient (client, extraLen, (char *) extra);
+	xfree (extra);
+    }
+    return client-&gt;noClientException;
+}
+
+typedef struct _RR10Data {
+    RRScreenSizePtr sizes;
+    int		    nsize;
+    int		    nrefresh;
+    int		    size;
+    CARD16	    refresh;
+} RR10DataRec, *RR10DataPtr;
+
+/*
+ * Convert 1.2 monitor data into 1.0 screen data
+ */
+static RR10DataPtr
+RR10GetData (ScreenPtr pScreen, RROutputPtr output)
+{
+    RR10DataPtr	    data;
+    RRScreenSizePtr size;
+    int		    nmode = output-&gt;numModes + output-&gt;numUserModes;
+    int		    o, os, l, r;
+    RRScreenRatePtr refresh;
+    CARD16	    vRefresh;
+    RRModePtr	    mode;
+    Bool	    *used;
+
+    /* Make sure there is plenty of space for any combination */
+    data = malloc (sizeof (RR10DataRec) + 
+		   sizeof (RRScreenSize) * nmode + 
+		   sizeof (RRScreenRate) * nmode +
+		   sizeof (Bool) * nmode);
+    if (!data)
+	return NULL;
+    size = (RRScreenSizePtr) (data + 1);
+    refresh = (RRScreenRatePtr) (size + nmode);
+    used = (Bool *) (refresh + nmode);
+    memset (used, '\0', sizeof (Bool) * nmode);
+    data-&gt;sizes = size;
+    data-&gt;nsize = 0;
+    data-&gt;nrefresh = 0;
+    data-&gt;size = 0;
+    data-&gt;refresh = 0;
+    
+    /*
+     * find modes not yet listed
+     */
+    for (o = 0; o &lt; output-&gt;numModes + output-&gt;numUserModes; o++)
+    {
+	if (used[o]) continue;
+	
+	if (o &lt; output-&gt;numModes)
+	    mode = output-&gt;modes[o];
+	else
+	    mode = output-&gt;userModes[o - output-&gt;numModes];
+	
+	l = data-&gt;nsize;
+	size[l].id = data-&gt;nsize;
+	size[l].width = mode-&gt;mode.width;
+	size[l].height = mode-&gt;mode.height;
+	if (output-&gt;mmWidth &amp;&amp; output-&gt;mmHeight) {
+	    size[l].mmWidth = output-&gt;mmWidth;
+	    size[l].mmHeight = output-&gt;mmHeight;
+	} else {
+	    size[l].mmWidth = pScreen-&gt;mmWidth;
+	    size[l].mmHeight = pScreen-&gt;mmHeight;
+	}
+	size[l].nRates = 0;
+	size[l].pRates = &amp;refresh[data-&gt;nrefresh];
+	data-&gt;nsize++;
+	
+	/*
+	 * Find all modes with matching size
+	 */
+	for (os = o; os &lt; output-&gt;numModes + output-&gt;numUserModes; os++)
+	{
+	    if (os &lt; output-&gt;numModes)
+		mode = output-&gt;modes[os];
+	    else
+		mode = output-&gt;userModes[os - output-&gt;numModes];
+	    if (mode-&gt;mode.width == size[l].width &amp;&amp;
+		mode-&gt;mode.height == size[l].height)
+	    {
+		vRefresh = RRVerticalRefresh (&amp;mode-&gt;mode);
+		used[os] = TRUE;
+		
+		for (r = 0; r &lt; size[l].nRates; r++)
+		    if (vRefresh == size[l].pRates[r].rate)
+			break;
+		if (r == size[l].nRates)
+		{
+		    size[l].pRates[r].rate = vRefresh;
+		    size[l].pRates[r].mode = mode;
+		    size[l].nRates++;
+		    data-&gt;nrefresh++;
+		}
+		if (mode == output-&gt;crtc-&gt;mode)
+		{
+		    data-&gt;size = l;
+		    data-&gt;refresh = vRefresh;
+		}
+	    }
+	}
+    }
+    return data;
+}
+
+int
+ProcRRGetScreenInfo (ClientPtr client)
+{
+    REQUEST(xRRGetScreenInfoReq);
+    xRRGetScreenInfoReply   rep;
+    WindowPtr	    	    pWin;
+    int			    n, rc;
+    ScreenPtr		    pScreen;
+    rrScrPrivPtr	    pScrPriv;
+    CARD8		    *extra;
+    unsigned long	    extraLen;
+    RROutputPtr		    output;
+
+    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixReadAccess);
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    rep.pad = 0;
+    
+    if (pScrPriv)
+	if (!RRGetInfo (pScreen))
+	    return BadAlloc;
+
+    output = RRFirstOutput (pScreen);
+    
+    if (!pScrPriv || !output)
+    {
+	rep.type = X_Reply;
+	rep.setOfRotations = RR_Rotate_0;;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.root = WindowTable[pWin-&gt;drawable.pScreen-&gt;myNum]-&gt;drawable.id;
+	rep.timestamp = currentTime.milliseconds;
+	rep.configTimestamp = currentTime.milliseconds;
+	rep.nSizes = 0;
+	rep.sizeID = 0;
+	rep.rotation = RR_Rotate_0;
+	rep.rate = 0;
+	rep.nrateEnts = 0;
+	extra = 0;
+	extraLen = 0;
+    }
+    else
+    {
+	int			i, j;
+	xScreenSizes		*size;
+	CARD16			*rates;
+	CARD8			*data8;
+	Bool			has_rate = RRClientKnowsRates (client);
+	RR10DataPtr		pData;
+	RRScreenSizePtr		pSize;
+    
+	pData = RR10GetData (pScreen, output);
+	if (!pData)
+	    return BadAlloc;
+	
+	rep.type = X_Reply;
+	rep.setOfRotations = output-&gt;crtc-&gt;rotations;
+	rep.sequenceNumber = client-&gt;sequence;
+	rep.length = 0;
+	rep.root = WindowTable[pWin-&gt;drawable.pScreen-&gt;myNum]-&gt;drawable.id;
+	rep.timestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+	rep.configTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+	rep.rotation = output-&gt;crtc-&gt;rotation;
+	rep.nSizes = pData-&gt;nsize;
+        rep.nrateEnts = pData-&gt;nrefresh + pData-&gt;nsize;
+	rep.sizeID = pData-&gt;size;
+	rep.rate = pData-&gt;refresh;
+
+	extraLen = (rep.nSizes * sizeof (xScreenSizes) +
+		    rep.nrateEnts * sizeof (CARD16));
+
+	if (extraLen)
+	{
+	    extra = (CARD8 *) xalloc (extraLen);
+	    if (!extra)
+	    {
+		xfree (pData);
+		return BadAlloc;
+	    }
+	}
+	else
+	    extra = NULL;
+
+	/*
+	 * First comes the size information
+	 */
+	size = (xScreenSizes *) extra;
+	rates = (CARD16 *) (size + rep.nSizes);
+	for (i = 0; i &lt; pData-&gt;nsize; i++)
+	{
+	    pSize = &amp;pData-&gt;sizes[i];
+	    size-&gt;widthInPixels = pSize-&gt;width;
+	    size-&gt;heightInPixels = pSize-&gt;height;
+	    size-&gt;widthInMillimeters = pSize-&gt;mmWidth;
+	    size-&gt;heightInMillimeters = pSize-&gt;mmHeight;
+	    if (client-&gt;swapped)
+	    {
+	        swaps (&amp;size-&gt;widthInPixels, n);
+	        swaps (&amp;size-&gt;heightInPixels, n);
+	        swaps (&amp;size-&gt;widthInMillimeters, n);
+	        swaps (&amp;size-&gt;heightInMillimeters, n);
+	    }
+	    size++;
+	    if (has_rate)
+	    {
+		*rates = pSize-&gt;nRates;
+		if (client-&gt;swapped)
+		{
+		    swaps (rates, n);
+		}
+		rates++;
+		for (j = 0; j &lt; pSize-&gt;nRates; j++)
+		{
+		    *rates = pSize-&gt;pRates[j].rate;
+		    if (client-&gt;swapped)
+		    {
+			swaps (rates, n);
+		    }
+		    rates++;
+		}
+	    }
+	}
+        xfree (pData);
+	
+	data8 = (CARD8 *) rates;
+
+	if (data8 - (CARD8 *) extra != extraLen)
+	    FatalError (&quot;RRGetScreenInfo bad extra len %ld != %ld\n&quot;,
+			(unsigned long)(data8 - (CARD8 *) extra), extraLen);
+	rep.length =  (extraLen + 3) &gt;&gt; 2;
+    }
+    if (client-&gt;swapped) {
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.timestamp, n);
+	swaps(&amp;rep.rotation, n);
+	swaps(&amp;rep.nSizes, n);
+	swaps(&amp;rep.sizeID, n);
+	swaps(&amp;rep.rate, n);
+	swaps(&amp;rep.nrateEnts, n);
+    }
+    WriteToClient(client, sizeof(xRRGetScreenInfoReply), (char *)&amp;rep);
+    if (extraLen)
+    {
+	WriteToClient (client, extraLen, (char *) extra);
+	xfree (extra);
+    }
+    return (client-&gt;noClientException);
+}
+
+int
+ProcRRSetScreenConfig (ClientPtr client)
+{
+    REQUEST(xRRSetScreenConfigReq);
+    xRRSetScreenConfigReply rep;
+    DrawablePtr		    pDraw;
+    int			    n, rc;
+    ScreenPtr		    pScreen;
+    rrScrPrivPtr	    pScrPriv;
+    TimeStamp		    time;
+    int			    i;
+    Rotation		    rotation;
+    int			    rate;
+    Bool		    has_rate;
+    RROutputPtr		    output;
+    RRCrtcPtr		    crtc;
+    RRModePtr		    mode;
+    RR10DataPtr		    pData = NULL;
+    RRScreenSizePtr    	    pSize;
+    int			    width, height;
+    
+    UpdateCurrentTime ();
+
+    if (RRClientKnowsRates (client))
+    {
+	REQUEST_SIZE_MATCH (xRRSetScreenConfigReq);
+	has_rate = TRUE;
+    }
+    else
+    {
+	REQUEST_SIZE_MATCH (xRR1_0SetScreenConfigReq);
+	has_rate = FALSE;
+    }
+    
+    rc = dixLookupDrawable(&amp;pDraw, stuff-&gt;drawable, client, 0, DixWriteAccess);
+    if (rc != Success)
+	return rc;
+
+    pScreen = pDraw-&gt;pScreen;
+
+    pScrPriv = rrGetScrPriv(pScreen);
+    
+    time = ClientTimeToServerTime(stuff-&gt;timestamp);
+    
+    if (!pScrPriv)
+    {
+	time = currentTime;
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+    if (!RRGetInfo (pScreen))
+	return BadAlloc;
+    
+    output = RRFirstOutput (pScreen);
+    if (!output)
+    {
+	time = currentTime;
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+
+    crtc = output-&gt;crtc;
+
+    /*
+     * If the client's config timestamp is not the same as the last config
+     * timestamp, then the config information isn't up-to-date and
+     * can't even be validated.
+     *
+     * Note that the client only knows about the milliseconds part of the
+     * timestamp, so using CompareTimeStamps here would cause randr to suddenly
+     * stop working after several hours have passed (freedesktop bug #6502).
+     */
+    if (stuff-&gt;configTimestamp != pScrPriv-&gt;lastConfigTime.milliseconds)
+    {
+	rep.status = RRSetConfigInvalidConfigTime;
+	goto sendReply;
+    }
+    
+    pData = RR10GetData (pScreen, output);
+    if (!pData)
+	return BadAlloc;
+    
+    if (stuff-&gt;sizeID &gt;= pData-&gt;nsize)
+    {
+	/*
+	 * Invalid size ID
+	 */
+	client-&gt;errorValue = stuff-&gt;sizeID;
+	xfree (pData);
+	return BadValue;
+    }
+    pSize = &amp;pData-&gt;sizes[stuff-&gt;sizeID];
+    
+    /*
+     * Validate requested rotation
+     */
+    rotation = (Rotation) stuff-&gt;rotation;
+
+    /* test the rotation bits only! */
+    switch (rotation &amp; 0xf) {
+    case RR_Rotate_0:
+    case RR_Rotate_90:
+    case RR_Rotate_180:
+    case RR_Rotate_270:
+	break;
+    default:
+	/*
+	 * Invalid rotation
+	 */
+	client-&gt;errorValue = stuff-&gt;rotation;
+	xfree (pData);
+	return BadValue;
+    }
+
+    if ((~crtc-&gt;rotations) &amp; rotation)
+    {
+	/*
+	 * requested rotation or reflection not supported by screen
+	 */
+	client-&gt;errorValue = stuff-&gt;rotation;
+	xfree (pData);
+	return BadMatch;
+    }
+
+    /*
+     * Validate requested refresh
+     */
+    if (has_rate)
+	rate = (int) stuff-&gt;rate;
+    else
+	rate = 0;
+
+    if (rate)
+    {
+	for (i = 0; i &lt; pSize-&gt;nRates; i++)
+	{
+	    if (pSize-&gt;pRates[i].rate == rate)
+		break;
+	}
+	if (i == pSize-&gt;nRates)
+	{
+	    /*
+	     * Invalid rate
+	     */
+	    client-&gt;errorValue = rate;
+	    xfree (pData);
+	    return BadValue;
+	}
+	mode = pSize-&gt;pRates[i].mode;
+    }
+    else
+	mode = pSize-&gt;pRates[0].mode;
+    
+    /*
+     * Make sure the requested set-time is not older than
+     * the last set-time
+     */
+    if (CompareTimeStamps (time, pScrPriv-&gt;lastSetTime) &lt; 0)
+    {
+	rep.status = RRSetConfigInvalidTime;
+	goto sendReply;
+    }
+
+    /*
+     * If the screen size is changing, adjust all of the other outputs
+     * to fit the new size, mirroring as much as possible
+     */
+    width = mode-&gt;mode.width;
+    height = mode-&gt;mode.height;
+    if (rotation &amp; (RR_Rotate_90|RR_Rotate_270))
+    {
+	width = mode-&gt;mode.height;
+	height = mode-&gt;mode.width;
+    }
+    if (width != pScreen-&gt;width || height != pScreen-&gt;height)
+    {
+	int	c;
+
+	for (c = 0; c &lt; pScrPriv-&gt;numCrtcs; c++)
+	{
+	    if (!RRCrtcSet (pScrPriv-&gt;crtcs[c], NULL, 0, 0, RR_Rotate_0,
+			    0, NULL))
+	    {
+		rep.status = RRSetConfigFailed;
+		/* XXX recover from failure */
+		goto sendReply;
+	    }
+	}
+	if (!RRScreenSizeSet (pScreen, width, height,
+			      pScreen-&gt;mmWidth, pScreen-&gt;mmHeight))
+	{
+	    rep.status = RRSetConfigFailed;
+	    /* XXX recover from failure */
+	    goto sendReply;
+	}
+    }
+
+    if (!RRCrtcSet (crtc, mode, 0, 0, stuff-&gt;rotation, 1, &amp;output))
+	rep.status = RRSetConfigFailed;
+    else
+	rep.status = RRSetConfigSuccess;
+
+    /*
+     * XXX Configure other crtcs to mirror as much as possible
+     */
+    
+sendReply:
+    
+    if (pData)
+	xfree (pData);
+
+    rep.type = X_Reply;
+    /* rep.status has already been filled in */
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+
+    rep.newTimestamp = pScrPriv-&gt;lastSetTime.milliseconds;
+    rep.newConfigTimestamp = pScrPriv-&gt;lastConfigTime.milliseconds;
+    rep.root = WindowTable[pDraw-&gt;pScreen-&gt;myNum]-&gt;drawable.id;
+
+    if (client-&gt;swapped) 
+    {
+    	swaps(&amp;rep.sequenceNumber, n);
+    	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.newTimestamp, n);
+	swapl(&amp;rep.newConfigTimestamp, n);
+	swapl(&amp;rep.root, n);
+    }
+    WriteToClient(client, sizeof(xRRSetScreenConfigReply), (char *)&amp;rep);
+
+    return (client-&gt;noClientException);
+}
+
+static CARD16
+RR10CurrentSizeID (ScreenPtr pScreen)
+{
+    CARD16	sizeID = 0xffff;
+    RROutputPtr output = RRFirstOutput (pScreen);
+    
+    if (output)
+    {
+	RR10DataPtr data = RR10GetData (pScreen, output);
+	if (data)
+	{
+	    int i;
+	    for (i = 0; i &lt; data-&gt;nsize; i++)
+		if (data-&gt;sizes[i].width == pScreen-&gt;width &amp;&amp;
+		    data-&gt;sizes[i].height == pScreen-&gt;height)
+		{
+		    sizeID = (CARD16) i;
+		    break;
+		}
+	    xfree (data);
+	}
+    }
+    return sizeID;
+}
diff --git a/nx-X11/programs/Xserver/randr/rrsdispatch.c b/nx-X11/programs/Xserver/randr/rrsdispatch.c
new file mode 100644
index 0000000..80d16b7
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrsdispatch.c
@@ -0,0 +1,398 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include &quot;randrstr.h&quot;
+
+static int
+SProcRRQueryVersion (ClientPtr client)
+{
+    register int n;
+    REQUEST(xRRQueryVersionReq);
+
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;majorVersion, n);
+    swapl(&amp;stuff-&gt;minorVersion, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRGetScreenInfo (ClientPtr client)
+{
+    register int n;
+    REQUEST(xRRGetScreenInfoReq);
+
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;window, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRSetScreenConfig (ClientPtr client)
+{
+    register int n;
+    REQUEST(xRRSetScreenConfigReq);
+
+    if (RRClientKnowsRates (client))
+    {
+	REQUEST_SIZE_MATCH (xRRSetScreenConfigReq);
+	swaps (&amp;stuff-&gt;rate, n);
+    }
+    else
+    {
+	REQUEST_SIZE_MATCH (xRR1_0SetScreenConfigReq);
+    }
+    
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;drawable, n);
+    swapl(&amp;stuff-&gt;timestamp, n);
+    swaps(&amp;stuff-&gt;sizeID, n);
+    swaps(&amp;stuff-&gt;rotation, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRSelectInput (ClientPtr client)
+{
+    register int n;
+    REQUEST(xRRSelectInputReq);
+
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;window, n);
+    swaps(&amp;stuff-&gt;enable, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRGetScreenSizeRange (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRGetScreenSizeRangeReq);
+
+    REQUEST_SIZE_MATCH(xRRGetScreenSizeRangeReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;window, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRSetScreenSize (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRSetScreenSizeReq);
+
+    REQUEST_SIZE_MATCH(xRRSetScreenSizeReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;window, n);
+    swaps(&amp;stuff-&gt;width, n);
+    swaps(&amp;stuff-&gt;height, n);
+    swapl(&amp;stuff-&gt;widthInMillimeters, n);
+    swapl(&amp;stuff-&gt;heightInMillimeters, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRGetScreenResources (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRGetScreenResourcesReq);
+
+    REQUEST_SIZE_MATCH(xRRGetScreenResourcesReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;window, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRGetOutputInfo (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRGetOutputInfoReq);;
+
+    REQUEST_SIZE_MATCH(xRRGetOutputInfoReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;output, n);
+    swapl(&amp;stuff-&gt;configTimestamp, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRListOutputProperties (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRListOutputPropertiesReq);
+
+    REQUEST_SIZE_MATCH(xRRListOutputPropertiesReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;output, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRQueryOutputProperty (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRQueryOutputPropertyReq);
+
+    REQUEST_SIZE_MATCH(xRRQueryOutputPropertyReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;output, n);
+    swapl(&amp;stuff-&gt;property, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRConfigureOutputProperty (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRConfigureOutputPropertyReq);
+
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;output, n);
+    swapl(&amp;stuff-&gt;property, n);
+    SwapRestL(stuff);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRChangeOutputProperty (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRChangeOutputPropertyReq);
+
+    REQUEST_AT_LEAST_SIZE (xRRChangeOutputPropertyReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;output, n);
+    swapl(&amp;stuff-&gt;property, n);
+    swapl(&amp;stuff-&gt;type, n);
+    swapl(&amp;stuff-&gt;nUnits, n);
+    switch(stuff-&gt;format) {
+	case 8:
+	    break;
+	case 16:
+	    SwapRestS(stuff);
+	    break;
+	case 32:
+	    SwapRestL(stuff);
+	    break;
+	default:
+	    client-&gt;errorValue = stuff-&gt;format;
+	    return BadValue;
+    }
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRDeleteOutputProperty (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRDeleteOutputPropertyReq);
+    
+    REQUEST_SIZE_MATCH(xRRDeleteOutputPropertyReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;output, n);
+    swapl(&amp;stuff-&gt;property, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRGetOutputProperty (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRGetOutputPropertyReq);
+
+    REQUEST_SIZE_MATCH(xRRGetOutputPropertyReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;output, n);
+    swapl(&amp;stuff-&gt;property, n);
+    swapl(&amp;stuff-&gt;type, n);
+    swapl(&amp;stuff-&gt;longOffset, n);
+    swapl(&amp;stuff-&gt;longLength, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRCreateMode (ClientPtr client)
+{
+    int n;
+    xRRModeInfo *modeinfo;
+    REQUEST(xRRCreateModeReq);
+
+    REQUEST_AT_LEAST_SIZE(xRRCreateModeReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;window, n);
+
+    modeinfo = &amp;stuff-&gt;modeInfo;
+    swapl(&amp;modeinfo-&gt;id, n);
+    swaps(&amp;modeinfo-&gt;width, n);
+    swaps(&amp;modeinfo-&gt;height, n);
+    swapl(&amp;modeinfo-&gt;dotClock, n);
+    swaps(&amp;modeinfo-&gt;hSyncStart, n);
+    swaps(&amp;modeinfo-&gt;hSyncEnd, n);
+    swaps(&amp;modeinfo-&gt;hTotal, n);
+    swaps(&amp;modeinfo-&gt;vSyncStart, n);
+    swaps(&amp;modeinfo-&gt;vSyncEnd, n);
+    swaps(&amp;modeinfo-&gt;vTotal, n);
+    swaps(&amp;modeinfo-&gt;nameLength, n);
+    swapl(&amp;modeinfo-&gt;modeFlags, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRDestroyMode (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRDestroyModeReq);
+
+    REQUEST_SIZE_MATCH(xRRDestroyModeReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;mode, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRAddOutputMode (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRAddOutputModeReq);
+
+    REQUEST_SIZE_MATCH(xRRAddOutputModeReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;output, n);
+    swapl(&amp;stuff-&gt;mode, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRDeleteOutputMode (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRDeleteOutputModeReq);
+
+    REQUEST_SIZE_MATCH(xRRDeleteOutputModeReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;output, n);
+    swapl(&amp;stuff-&gt;mode, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRGetCrtcInfo (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRGetCrtcInfoReq);
+
+    REQUEST_SIZE_MATCH(xRRGetCrtcInfoReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;crtc, n);
+    swapl(&amp;stuff-&gt;configTimestamp, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRSetCrtcConfig (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRSetCrtcConfigReq);
+
+    REQUEST_AT_LEAST_SIZE(xRRSetCrtcConfigReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;crtc, n);
+    swapl(&amp;stuff-&gt;timestamp, n);
+    swapl(&amp;stuff-&gt;configTimestamp, n);
+    swaps(&amp;stuff-&gt;x, n);
+    swaps(&amp;stuff-&gt;y, n);
+    swapl(&amp;stuff-&gt;mode, n);
+    swaps(&amp;stuff-&gt;rotation, n);
+    SwapRestL(stuff);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRGetCrtcGammaSize (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRGetCrtcGammaSizeReq);
+
+    REQUEST_SIZE_MATCH(xRRGetCrtcGammaSizeReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;crtc, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRGetCrtcGamma (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRGetCrtcGammaReq);
+
+    REQUEST_SIZE_MATCH(xRRGetCrtcGammaReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;crtc, n);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+static int
+SProcRRSetCrtcGamma (ClientPtr client)
+{
+    int n;
+    REQUEST(xRRSetCrtcGammaReq);
+
+    REQUEST_AT_LEAST_SIZE(xRRSetCrtcGammaReq);
+    swaps(&amp;stuff-&gt;length, n);
+    swapl(&amp;stuff-&gt;crtc, n);
+    swaps(&amp;stuff-&gt;size, n);
+    SwapRestS(stuff);
+    return (*ProcRandrVector[stuff-&gt;randrReqType]) (client);
+}
+
+int (*SProcRandrVector[RRNumberRequests])(ClientPtr) = {
+    SProcRRQueryVersion,	/* 0 */
+/* we skip 1 to make old clients fail pretty immediately */
+    NULL,			/* 1 SProcRandrOldGetScreenInfo */
+/* V1.0 apps share the same set screen config request id */
+    SProcRRSetScreenConfig,	/* 2 */
+    NULL,			/* 3 SProcRandrOldScreenChangeSelectInput */
+/* 3 used to be ScreenChangeSelectInput; deprecated */
+    SProcRRSelectInput,		/* 4 */
+    SProcRRGetScreenInfo,    	/* 5 */
+/* V1.2 additions */
+    SProcRRGetScreenSizeRange,	/* 6 */
+    SProcRRSetScreenSize,	/* 7 */
+    SProcRRGetScreenResources,	/* 8 */
+    SProcRRGetOutputInfo,	/* 9 */
+    SProcRRListOutputProperties,/* 10 */
+    SProcRRQueryOutputProperty,	/* 11 */
+    SProcRRConfigureOutputProperty,  /* 12 */
+    SProcRRChangeOutputProperty,/* 13 */
+    SProcRRDeleteOutputProperty,/* 14 */
+    SProcRRGetOutputProperty,	/* 15 */
+    SProcRRCreateMode,		/* 16 */
+    SProcRRDestroyMode,		/* 17 */
+    SProcRRAddOutputMode,	/* 18 */
+    SProcRRDeleteOutputMode,	/* 19 */
+    SProcRRGetCrtcInfo,		/* 20 */
+    SProcRRSetCrtcConfig,	/* 21 */
+    SProcRRGetCrtcGammaSize,	/* 22 */
+    SProcRRGetCrtcGamma,	/* 23 */
+    SProcRRSetCrtcGamma,	/* 24 */
+};
+
diff --git a/nx-X11/programs/Xserver/randr/rrxinerama.c b/nx-X11/programs/Xserver/randr/rrxinerama.c
new file mode 100644
index 0000000..9f11279
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrxinerama.c
@@ -0,0 +1,490 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+/*
+ * This Xinerama implementation comes from the SiS driver which has
+ * the following notice:
+ */
+/* 
+ * SiS driver main code
+ *
+ * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1) Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2) Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3) The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author: Thomas Winischhofer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">thomas at winischhofer.net</A>&gt;
+ *	- driver entirely rewritten since 2001, only basic structure taken from
+ *	  old code (except sis_dri.c, sis_shadow.c, sis_accel.c and parts of
+ *	  sis_dga.c; these were mostly taken over; sis_dri.c was changed for
+ *	  new versions of the DRI layer)
+ *
+ * This notice covers the entire driver code unless indicated otherwise.
+ *
+ * Formerly based on code which was
+ * 	     Copyright (C) 1998, 1999 by Alan Hourihane, Wigan, England.
+ * 	     Written by:
+ *           Alan Hourihane &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">alanh at fairlite.demon.co.uk</A>&gt;,
+ *           Mike Chapman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike at paranoia.com</A>&gt;,
+ *           Juanjo Santamarta &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">santamarta at ctv.es</A>&gt;,
+ *           Mitani Hiroshi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">hmitani at drl.mei.co.jp</A>&gt;,
+ *           David Thomas &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">davtom at dream.org.uk</A>&gt;.
+ */
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &quot;randrstr.h&quot;
+#include &quot;swaprep.h&quot;
+#ifndef NXAGENT_SERVER
+#include &lt;X11/extensions/panoramiXproto.h&gt;
+#else
+#include &quot;panoramiXproto.h&quot;
+#endif
+
+#define RR_XINERAMA_MAJOR_VERSION   1
+#define RR_XINERAMA_MINOR_VERSION   1
+
+/* Xinerama is not multi-screen capable; just report about screen 0 */
+#define RR_XINERAMA_SCREEN  0
+
+static int ProcRRXineramaQueryVersion(ClientPtr client);
+static int ProcRRXineramaGetState(ClientPtr client);
+static int ProcRRXineramaGetScreenCount(ClientPtr client);
+static int ProcRRXineramaGetScreenSize(ClientPtr client);
+static int ProcRRXineramaIsActive(ClientPtr client);
+static int ProcRRXineramaQueryScreens(ClientPtr client);
+static int SProcRRXineramaDispatch(ClientPtr client);
+
+/* Proc */
+
+int
+ProcRRXineramaQueryVersion(ClientPtr client)
+{
+    xPanoramiXQueryVersionReply	  rep;
+    register int		  n;
+
+    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.majorVersion = RR_XINERAMA_MAJOR_VERSION;
+    rep.minorVersion = RR_XINERAMA_MINOR_VERSION;
+    if(client-&gt;swapped) {
+        swaps(&amp;rep.sequenceNumber, n);
+        swapl(&amp;rep.length, n);
+        swaps(&amp;rep.majorVersion, n);
+        swaps(&amp;rep.minorVersion, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *)&amp;rep);
+    return (client-&gt;noClientException);
+}
+
+int
+ProcRRXineramaGetState(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetStateReq);
+    WindowPtr			pWin;
+    xPanoramiXGetStateReply	rep;
+    register int		n, rc;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    Bool			active = FALSE;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixGetAttrAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if(rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    if (pScrPriv)
+    {
+	/* XXX do we need more than this? */
+	active = TRUE;
+    }
+
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.state = active;
+    rep.window = stuff-&gt;window;
+    if(client-&gt;swapped) {
+       swaps (&amp;rep.sequenceNumber, n);
+       swapl (&amp;rep.length, n);
+       swapl (&amp;rep.window, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&amp;rep);
+    return client-&gt;noClientException;
+}
+
+static Bool
+RRXineramaCrtcActive (RRCrtcPtr crtc)
+{
+    return crtc-&gt;mode != NULL &amp;&amp; crtc-&gt;numOutputs &gt; 0;
+}
+
+static int
+RRXineramaScreenCount (ScreenPtr pScreen)
+{
+    int	i, n;
+    
+    n = 0;
+    if (rrGetScrPriv (pScreen))
+    {
+	rrScrPriv(pScreen);
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	    if (RRXineramaCrtcActive (pScrPriv-&gt;crtcs[i]))
+		n++;
+    }
+    return n;
+}
+
+static Bool
+RRXineramaScreenActive (ScreenPtr pScreen)
+{
+    return RRXineramaScreenCount (pScreen) &gt; 0;
+}
+
+int
+ProcRRXineramaGetScreenCount(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenCountReq);
+    WindowPtr				pWin;
+    xPanoramiXGetScreenCountReply	rep;
+    register int			n, rc;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixGetAttrAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+    
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.ScreenCount = RRXineramaScreenCount (pWin-&gt;drawable.pScreen);
+    rep.window = stuff-&gt;window;
+    if(client-&gt;swapped) {
+       swaps(&amp;rep.sequenceNumber, n);
+       swapl(&amp;rep.length, n);
+       swapl(&amp;rep.window, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&amp;rep);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRXineramaGetScreenSize(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenSizeReq);
+    WindowPtr				pWin, pRoot;
+    ScreenPtr				pScreen;
+    xPanoramiXGetScreenSizeReply	rep;
+    register int			n, rc;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixGetAttrAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pRoot = WindowTable[pScreen-&gt;myNum];
+    
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.width  = pRoot-&gt;drawable.width;
+    rep.height = pRoot-&gt;drawable.height;
+    rep.window = stuff-&gt;window;
+    rep.screen = stuff-&gt;screen;
+    if(client-&gt;swapped) {
+       swaps(&amp;rep.sequenceNumber, n);
+       swapl(&amp;rep.length, n);
+       swapl(&amp;rep.width, n);
+       swapl(&amp;rep.height, n);
+       swapl(&amp;rep.window, n);
+       swapl(&amp;rep.screen, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&amp;rep);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRXineramaIsActive(ClientPtr client)
+{
+    xXineramaIsActiveReply	rep;
+
+    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
+	
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.state = RRXineramaScreenActive (screenInfo.screens[RR_XINERAMA_SCREEN]);
+    if(client-&gt;swapped) {
+	register int n;
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.state, n);
+    }
+    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &amp;rep);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRXineramaQueryScreens(ClientPtr client)
+{
+    xXineramaQueryScreensReply	rep;
+    ScreenPtr	pScreen = screenInfo.screens[RR_XINERAMA_SCREEN];
+
+    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
+
+    if (RRXineramaScreenActive (pScreen))
+    {
+	rrScrPriv(pScreen);
+	if (pScrPriv-&gt;numCrtcs == 0 || pScrPriv-&gt;numOutputs == 0)
+	    RRGetInfo (pScreen);
+    }
+    
+    rep.type = X_Reply;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.number = RRXineramaScreenCount (pScreen);
+    rep.length = rep.number * sz_XineramaScreenInfo &gt;&gt; 2;
+    if(client-&gt;swapped) {
+	register int n;
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.number, n);
+    }
+    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&amp;rep);
+
+    if(rep.number) {
+	rrScrPriv(pScreen);
+	xXineramaScreenInfo scratch;
+	int i;
+
+	for(i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++) {
+	    RRCrtcPtr	crtc = pScrPriv-&gt;crtcs[i];
+	    if (RRXineramaCrtcActive (crtc))
+	    {
+	        int width, height;
+		RRCrtcGetScanoutSize (crtc, &amp;width, &amp;height);
+		scratch.x_org  = crtc-&gt;x;
+		scratch.y_org  = crtc-&gt;y;
+		scratch.width  = width;
+		scratch.height = height;
+		if(client-&gt;swapped) {
+		    register int n;
+		    swaps(&amp;scratch.x_org, n);
+		    swaps(&amp;scratch.y_org, n);
+		    swaps(&amp;scratch.width, n);
+		    swaps(&amp;scratch.height, n);
+		}
+		WriteToClient(client, sz_XineramaScreenInfo, (char *)&amp;scratch);
+	    }
+	}
+    }
+
+    return client-&gt;noClientException;
+}
+
+static int
+ProcRRXineramaDispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+    switch (stuff-&gt;data) {
+	case X_PanoramiXQueryVersion:
+	     return ProcRRXineramaQueryVersion(client);
+	case X_PanoramiXGetState:
+	     return ProcRRXineramaGetState(client);
+	case X_PanoramiXGetScreenCount:
+	     return ProcRRXineramaGetScreenCount(client);
+	case X_PanoramiXGetScreenSize:
+	     return ProcRRXineramaGetScreenSize(client);
+	case X_XineramaIsActive:
+	     return ProcRRXineramaIsActive(client);
+	case X_XineramaQueryScreens:
+	     return ProcRRXineramaQueryScreens(client);
+    }
+    return BadRequest;
+}
+
+/* SProc */
+
+static int
+SProcRRXineramaQueryVersion (ClientPtr client)
+{
+    REQUEST(xPanoramiXQueryVersionReq);
+    register int n;
+    swaps(&amp;stuff-&gt;length,n);
+    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
+    return ProcRRXineramaQueryVersion(client);
+}
+
+static int
+SProcRRXineramaGetState(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetStateReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
+    swapl (&amp;stuff-&gt;window, n);
+    return ProcRRXineramaGetState(client);
+}
+
+static int
+SProcRRXineramaGetScreenCount(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenCountReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
+    swapl (&amp;stuff-&gt;window, n);
+    return ProcRRXineramaGetScreenCount(client);
+}
+
+static int
+SProcRRXineramaGetScreenSize(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenSizeReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
+    swapl (&amp;stuff-&gt;window, n);
+    swapl (&amp;stuff-&gt;screen, n);
+    return ProcRRXineramaGetScreenSize(client);
+}
+
+static int
+SProcRRXineramaIsActive(ClientPtr client)
+{
+    REQUEST(xXineramaIsActiveReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
+    return ProcRRXineramaIsActive(client);
+}
+
+static int
+SProcRRXineramaQueryScreens(ClientPtr client)
+{
+    REQUEST(xXineramaQueryScreensReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
+    return ProcRRXineramaQueryScreens(client);
+}
+
+int
+SProcRRXineramaDispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+    switch (stuff-&gt;data) {
+	case X_PanoramiXQueryVersion:
+	     return SProcRRXineramaQueryVersion(client);
+	case X_PanoramiXGetState:
+	     return SProcRRXineramaGetState(client);
+	case X_PanoramiXGetScreenCount:
+	     return SProcRRXineramaGetScreenCount(client);
+	case X_PanoramiXGetScreenSize:
+	     return SProcRRXineramaGetScreenSize(client);
+	case X_XineramaIsActive:
+	     return SProcRRXineramaIsActive(client);
+	case X_XineramaQueryScreens:
+	     return SProcRRXineramaQueryScreens(client);
+    }
+    return BadRequest;
+}
+
+static void
+RRXineramaResetProc(ExtensionEntry* extEntry)
+{
+}
+
+void
+RRXineramaExtensionInit(void)
+{
+#ifdef PANORAMIX
+    if(!noPanoramiXExtension)
+	return;
+#endif
+
+    /*
+     * Xinerama isn't capable enough to have multiple protocol screens each
+     * with their own output geometry.  So if there's more than one protocol
+     * screen, just don't even try.
+     */
+    if (screenInfo.numScreens &gt; 1)
+	return;
+
+    (void) AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0,
+			ProcRRXineramaDispatch,
+			SProcRRXineramaDispatch,
+			RRXineramaResetProc,
+			StandardMinorOpcode);
+}
diff --git a/nx-X11/programs/Xserver/randr/rrxinerama.c.NX.original b/nx-X11/programs/Xserver/randr/rrxinerama.c.NX.original
new file mode 100644
index 0000000..9f11279
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrxinerama.c.NX.original
@@ -0,0 +1,490 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+/*
+ * This Xinerama implementation comes from the SiS driver which has
+ * the following notice:
+ */
+/* 
+ * SiS driver main code
+ *
+ * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1) Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2) Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3) The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author: Thomas Winischhofer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">thomas at winischhofer.net</A>&gt;
+ *	- driver entirely rewritten since 2001, only basic structure taken from
+ *	  old code (except sis_dri.c, sis_shadow.c, sis_accel.c and parts of
+ *	  sis_dga.c; these were mostly taken over; sis_dri.c was changed for
+ *	  new versions of the DRI layer)
+ *
+ * This notice covers the entire driver code unless indicated otherwise.
+ *
+ * Formerly based on code which was
+ * 	     Copyright (C) 1998, 1999 by Alan Hourihane, Wigan, England.
+ * 	     Written by:
+ *           Alan Hourihane &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">alanh at fairlite.demon.co.uk</A>&gt;,
+ *           Mike Chapman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike at paranoia.com</A>&gt;,
+ *           Juanjo Santamarta &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">santamarta at ctv.es</A>&gt;,
+ *           Mitani Hiroshi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">hmitani at drl.mei.co.jp</A>&gt;,
+ *           David Thomas &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">davtom at dream.org.uk</A>&gt;.
+ */
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001, 2011 NoMachine, <A HREF="http://www.nomachine.com/.">http://www.nomachine.com/.</A>         */
+/*                                                                        */
+/* NX-X11, NX protocol compression and NX extensions to this software     */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check <A HREF="http://www.nomachine.com/licensing.html">http://www.nomachine.com/licensing.html</A> for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#include &quot;randrstr.h&quot;
+#include &quot;swaprep.h&quot;
+#ifndef NXAGENT_SERVER
+#include &lt;X11/extensions/panoramiXproto.h&gt;
+#else
+#include &quot;panoramiXproto.h&quot;
+#endif
+
+#define RR_XINERAMA_MAJOR_VERSION   1
+#define RR_XINERAMA_MINOR_VERSION   1
+
+/* Xinerama is not multi-screen capable; just report about screen 0 */
+#define RR_XINERAMA_SCREEN  0
+
+static int ProcRRXineramaQueryVersion(ClientPtr client);
+static int ProcRRXineramaGetState(ClientPtr client);
+static int ProcRRXineramaGetScreenCount(ClientPtr client);
+static int ProcRRXineramaGetScreenSize(ClientPtr client);
+static int ProcRRXineramaIsActive(ClientPtr client);
+static int ProcRRXineramaQueryScreens(ClientPtr client);
+static int SProcRRXineramaDispatch(ClientPtr client);
+
+/* Proc */
+
+int
+ProcRRXineramaQueryVersion(ClientPtr client)
+{
+    xPanoramiXQueryVersionReply	  rep;
+    register int		  n;
+
+    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.majorVersion = RR_XINERAMA_MAJOR_VERSION;
+    rep.minorVersion = RR_XINERAMA_MINOR_VERSION;
+    if(client-&gt;swapped) {
+        swaps(&amp;rep.sequenceNumber, n);
+        swapl(&amp;rep.length, n);
+        swaps(&amp;rep.majorVersion, n);
+        swaps(&amp;rep.minorVersion, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *)&amp;rep);
+    return (client-&gt;noClientException);
+}
+
+int
+ProcRRXineramaGetState(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetStateReq);
+    WindowPtr			pWin;
+    xPanoramiXGetStateReply	rep;
+    register int		n, rc;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    Bool			active = FALSE;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixGetAttrAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if(rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    if (pScrPriv)
+    {
+	/* XXX do we need more than this? */
+	active = TRUE;
+    }
+
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.state = active;
+    rep.window = stuff-&gt;window;
+    if(client-&gt;swapped) {
+       swaps (&amp;rep.sequenceNumber, n);
+       swapl (&amp;rep.length, n);
+       swapl (&amp;rep.window, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&amp;rep);
+    return client-&gt;noClientException;
+}
+
+static Bool
+RRXineramaCrtcActive (RRCrtcPtr crtc)
+{
+    return crtc-&gt;mode != NULL &amp;&amp; crtc-&gt;numOutputs &gt; 0;
+}
+
+static int
+RRXineramaScreenCount (ScreenPtr pScreen)
+{
+    int	i, n;
+    
+    n = 0;
+    if (rrGetScrPriv (pScreen))
+    {
+	rrScrPriv(pScreen);
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	    if (RRXineramaCrtcActive (pScrPriv-&gt;crtcs[i]))
+		n++;
+    }
+    return n;
+}
+
+static Bool
+RRXineramaScreenActive (ScreenPtr pScreen)
+{
+    return RRXineramaScreenCount (pScreen) &gt; 0;
+}
+
+int
+ProcRRXineramaGetScreenCount(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenCountReq);
+    WindowPtr				pWin;
+    xPanoramiXGetScreenCountReply	rep;
+    register int			n, rc;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixGetAttrAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+    
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.ScreenCount = RRXineramaScreenCount (pWin-&gt;drawable.pScreen);
+    rep.window = stuff-&gt;window;
+    if(client-&gt;swapped) {
+       swaps(&amp;rep.sequenceNumber, n);
+       swapl(&amp;rep.length, n);
+       swapl(&amp;rep.window, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&amp;rep);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRXineramaGetScreenSize(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenSizeReq);
+    WindowPtr				pWin, pRoot;
+    ScreenPtr				pScreen;
+    xPanoramiXGetScreenSizeReply	rep;
+    register int			n, rc;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
+    #ifndef NXAGENT_SERVER
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixGetAttrAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff-&gt;window, client, SecurityReadAccess);
+    rc = pWin ? Success : BadWindow;
+    #endif
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pRoot = WindowTable[pScreen-&gt;myNum];
+    
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.width  = pRoot-&gt;drawable.width;
+    rep.height = pRoot-&gt;drawable.height;
+    rep.window = stuff-&gt;window;
+    rep.screen = stuff-&gt;screen;
+    if(client-&gt;swapped) {
+       swaps(&amp;rep.sequenceNumber, n);
+       swapl(&amp;rep.length, n);
+       swapl(&amp;rep.width, n);
+       swapl(&amp;rep.height, n);
+       swapl(&amp;rep.window, n);
+       swapl(&amp;rep.screen, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&amp;rep);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRXineramaIsActive(ClientPtr client)
+{
+    xXineramaIsActiveReply	rep;
+
+    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
+	
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.state = RRXineramaScreenActive (screenInfo.screens[RR_XINERAMA_SCREEN]);
+    if(client-&gt;swapped) {
+	register int n;
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.state, n);
+    }
+    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &amp;rep);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRXineramaQueryScreens(ClientPtr client)
+{
+    xXineramaQueryScreensReply	rep;
+    ScreenPtr	pScreen = screenInfo.screens[RR_XINERAMA_SCREEN];
+
+    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
+
+    if (RRXineramaScreenActive (pScreen))
+    {
+	rrScrPriv(pScreen);
+	if (pScrPriv-&gt;numCrtcs == 0 || pScrPriv-&gt;numOutputs == 0)
+	    RRGetInfo (pScreen);
+    }
+    
+    rep.type = X_Reply;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.number = RRXineramaScreenCount (pScreen);
+    rep.length = rep.number * sz_XineramaScreenInfo &gt;&gt; 2;
+    if(client-&gt;swapped) {
+	register int n;
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.number, n);
+    }
+    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&amp;rep);
+
+    if(rep.number) {
+	rrScrPriv(pScreen);
+	xXineramaScreenInfo scratch;
+	int i;
+
+	for(i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++) {
+	    RRCrtcPtr	crtc = pScrPriv-&gt;crtcs[i];
+	    if (RRXineramaCrtcActive (crtc))
+	    {
+	        int width, height;
+		RRCrtcGetScanoutSize (crtc, &amp;width, &amp;height);
+		scratch.x_org  = crtc-&gt;x;
+		scratch.y_org  = crtc-&gt;y;
+		scratch.width  = width;
+		scratch.height = height;
+		if(client-&gt;swapped) {
+		    register int n;
+		    swaps(&amp;scratch.x_org, n);
+		    swaps(&amp;scratch.y_org, n);
+		    swaps(&amp;scratch.width, n);
+		    swaps(&amp;scratch.height, n);
+		}
+		WriteToClient(client, sz_XineramaScreenInfo, (char *)&amp;scratch);
+	    }
+	}
+    }
+
+    return client-&gt;noClientException;
+}
+
+static int
+ProcRRXineramaDispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+    switch (stuff-&gt;data) {
+	case X_PanoramiXQueryVersion:
+	     return ProcRRXineramaQueryVersion(client);
+	case X_PanoramiXGetState:
+	     return ProcRRXineramaGetState(client);
+	case X_PanoramiXGetScreenCount:
+	     return ProcRRXineramaGetScreenCount(client);
+	case X_PanoramiXGetScreenSize:
+	     return ProcRRXineramaGetScreenSize(client);
+	case X_XineramaIsActive:
+	     return ProcRRXineramaIsActive(client);
+	case X_XineramaQueryScreens:
+	     return ProcRRXineramaQueryScreens(client);
+    }
+    return BadRequest;
+}
+
+/* SProc */
+
+static int
+SProcRRXineramaQueryVersion (ClientPtr client)
+{
+    REQUEST(xPanoramiXQueryVersionReq);
+    register int n;
+    swaps(&amp;stuff-&gt;length,n);
+    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
+    return ProcRRXineramaQueryVersion(client);
+}
+
+static int
+SProcRRXineramaGetState(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetStateReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
+    swapl (&amp;stuff-&gt;window, n);
+    return ProcRRXineramaGetState(client);
+}
+
+static int
+SProcRRXineramaGetScreenCount(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenCountReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
+    swapl (&amp;stuff-&gt;window, n);
+    return ProcRRXineramaGetScreenCount(client);
+}
+
+static int
+SProcRRXineramaGetScreenSize(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenSizeReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
+    swapl (&amp;stuff-&gt;window, n);
+    swapl (&amp;stuff-&gt;screen, n);
+    return ProcRRXineramaGetScreenSize(client);
+}
+
+static int
+SProcRRXineramaIsActive(ClientPtr client)
+{
+    REQUEST(xXineramaIsActiveReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
+    return ProcRRXineramaIsActive(client);
+}
+
+static int
+SProcRRXineramaQueryScreens(ClientPtr client)
+{
+    REQUEST(xXineramaQueryScreensReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
+    return ProcRRXineramaQueryScreens(client);
+}
+
+int
+SProcRRXineramaDispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+    switch (stuff-&gt;data) {
+	case X_PanoramiXQueryVersion:
+	     return SProcRRXineramaQueryVersion(client);
+	case X_PanoramiXGetState:
+	     return SProcRRXineramaGetState(client);
+	case X_PanoramiXGetScreenCount:
+	     return SProcRRXineramaGetScreenCount(client);
+	case X_PanoramiXGetScreenSize:
+	     return SProcRRXineramaGetScreenSize(client);
+	case X_XineramaIsActive:
+	     return SProcRRXineramaIsActive(client);
+	case X_XineramaQueryScreens:
+	     return SProcRRXineramaQueryScreens(client);
+    }
+    return BadRequest;
+}
+
+static void
+RRXineramaResetProc(ExtensionEntry* extEntry)
+{
+}
+
+void
+RRXineramaExtensionInit(void)
+{
+#ifdef PANORAMIX
+    if(!noPanoramiXExtension)
+	return;
+#endif
+
+    /*
+     * Xinerama isn't capable enough to have multiple protocol screens each
+     * with their own output geometry.  So if there's more than one protocol
+     * screen, just don't even try.
+     */
+    if (screenInfo.numScreens &gt; 1)
+	return;
+
+    (void) AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0,
+			ProcRRXineramaDispatch,
+			SProcRRXineramaDispatch,
+			RRXineramaResetProc,
+			StandardMinorOpcode);
+}
diff --git a/nx-X11/programs/Xserver/randr/rrxinerama.c.X.original b/nx-X11/programs/Xserver/randr/rrxinerama.c.X.original
new file mode 100644
index 0000000..e6acd5e
--- /dev/null
+++ b/nx-X11/programs/Xserver/randr/rrxinerama.c.X.original
@@ -0,0 +1,454 @@
+/*
+ * Copyright &#169; 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided &quot;as
+ * is&quot; without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+/*
+ * This Xinerama implementation comes from the SiS driver which has
+ * the following notice:
+ */
+/* 
+ * SiS driver main code
+ *
+ * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1) Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2) Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3) The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author: Thomas Winischhofer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">thomas at winischhofer.net</A>&gt;
+ *	- driver entirely rewritten since 2001, only basic structure taken from
+ *	  old code (except sis_dri.c, sis_shadow.c, sis_accel.c and parts of
+ *	  sis_dga.c; these were mostly taken over; sis_dri.c was changed for
+ *	  new versions of the DRI layer)
+ *
+ * This notice covers the entire driver code unless indicated otherwise.
+ *
+ * Formerly based on code which was
+ * 	     Copyright (C) 1998, 1999 by Alan Hourihane, Wigan, England.
+ * 	     Written by:
+ *           Alan Hourihane &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">alanh at fairlite.demon.co.uk</A>&gt;,
+ *           Mike Chapman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">mike at paranoia.com</A>&gt;,
+ *           Juanjo Santamarta &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">santamarta at ctv.es</A>&gt;,
+ *           Mitani Hiroshi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">hmitani at drl.mei.co.jp</A>&gt;,
+ *           David Thomas &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/x2go-commits">davtom at dream.org.uk</A>&gt;.
+ */
+
+#include &quot;randrstr.h&quot;
+#include &quot;swaprep.h&quot;
+#include &lt;X11/extensions/panoramiXproto.h&gt;
+
+#define RR_XINERAMA_MAJOR_VERSION   1
+#define RR_XINERAMA_MINOR_VERSION   1
+
+/* Xinerama is not multi-screen capable; just report about screen 0 */
+#define RR_XINERAMA_SCREEN  0
+
+static int ProcRRXineramaQueryVersion(ClientPtr client);
+static int ProcRRXineramaGetState(ClientPtr client);
+static int ProcRRXineramaGetScreenCount(ClientPtr client);
+static int ProcRRXineramaGetScreenSize(ClientPtr client);
+static int ProcRRXineramaIsActive(ClientPtr client);
+static int ProcRRXineramaQueryScreens(ClientPtr client);
+static int SProcRRXineramaDispatch(ClientPtr client);
+
+/* Proc */
+
+int
+ProcRRXineramaQueryVersion(ClientPtr client)
+{
+    xPanoramiXQueryVersionReply	  rep;
+    register int		  n;
+
+    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.majorVersion = RR_XINERAMA_MAJOR_VERSION;
+    rep.minorVersion = RR_XINERAMA_MINOR_VERSION;
+    if(client-&gt;swapped) {
+        swaps(&amp;rep.sequenceNumber, n);
+        swapl(&amp;rep.length, n);
+        swaps(&amp;rep.majorVersion, n);
+        swaps(&amp;rep.minorVersion, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *)&amp;rep);
+    return (client-&gt;noClientException);
+}
+
+int
+ProcRRXineramaGetState(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetStateReq);
+    WindowPtr			pWin;
+    xPanoramiXGetStateReply	rep;
+    register int		n, rc;
+    ScreenPtr			pScreen;
+    rrScrPrivPtr		pScrPriv;
+    Bool			active = FALSE;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixGetAttrAccess);
+    if(rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pScrPriv = rrGetScrPriv(pScreen);
+    if (pScrPriv)
+    {
+	/* XXX do we need more than this? */
+	active = TRUE;
+    }
+
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.state = active;
+    rep.window = stuff-&gt;window;
+    if(client-&gt;swapped) {
+       swaps (&amp;rep.sequenceNumber, n);
+       swapl (&amp;rep.length, n);
+       swapl (&amp;rep.window, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&amp;rep);
+    return client-&gt;noClientException;
+}
+
+static Bool
+RRXineramaCrtcActive (RRCrtcPtr crtc)
+{
+    return crtc-&gt;mode != NULL &amp;&amp; crtc-&gt;numOutputs &gt; 0;
+}
+
+static int
+RRXineramaScreenCount (ScreenPtr pScreen)
+{
+    int	i, n;
+    
+    n = 0;
+    if (rrGetScrPriv (pScreen))
+    {
+	rrScrPriv(pScreen);
+	for (i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++)
+	    if (RRXineramaCrtcActive (pScrPriv-&gt;crtcs[i]))
+		n++;
+    }
+    return n;
+}
+
+static Bool
+RRXineramaScreenActive (ScreenPtr pScreen)
+{
+    return RRXineramaScreenCount (pScreen) &gt; 0;
+}
+
+int
+ProcRRXineramaGetScreenCount(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenCountReq);
+    WindowPtr				pWin;
+    xPanoramiXGetScreenCountReply	rep;
+    register int			n, rc;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixGetAttrAccess);
+    if (rc != Success)
+	return rc;
+    
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.ScreenCount = RRXineramaScreenCount (pWin-&gt;drawable.pScreen);
+    rep.window = stuff-&gt;window;
+    if(client-&gt;swapped) {
+       swaps(&amp;rep.sequenceNumber, n);
+       swapl(&amp;rep.length, n);
+       swapl(&amp;rep.window, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&amp;rep);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRXineramaGetScreenSize(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenSizeReq);
+    WindowPtr				pWin, pRoot;
+    ScreenPtr				pScreen;
+    xPanoramiXGetScreenSizeReply	rep;
+    register int			n, rc;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
+    rc = dixLookupWindow(&amp;pWin, stuff-&gt;window, client, DixGetAttrAccess);
+    if (rc != Success)
+	return rc;
+
+    pScreen = pWin-&gt;drawable.pScreen;
+    pRoot = WindowTable[pScreen-&gt;myNum];
+    
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.width  = pRoot-&gt;drawable.width;
+    rep.height = pRoot-&gt;drawable.height;
+    rep.window = stuff-&gt;window;
+    rep.screen = stuff-&gt;screen;
+    if(client-&gt;swapped) {
+       swaps(&amp;rep.sequenceNumber, n);
+       swapl(&amp;rep.length, n);
+       swapl(&amp;rep.width, n);
+       swapl(&amp;rep.height, n);
+       swapl(&amp;rep.window, n);
+       swapl(&amp;rep.screen, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&amp;rep);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRXineramaIsActive(ClientPtr client)
+{
+    xXineramaIsActiveReply	rep;
+
+    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
+	
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.state = RRXineramaScreenActive (screenInfo.screens[RR_XINERAMA_SCREEN]);
+    if(client-&gt;swapped) {
+	register int n;
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.state, n);
+    }
+    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &amp;rep);
+    return client-&gt;noClientException;
+}
+
+int
+ProcRRXineramaQueryScreens(ClientPtr client)
+{
+    xXineramaQueryScreensReply	rep;
+    ScreenPtr	pScreen = screenInfo.screens[RR_XINERAMA_SCREEN];
+
+    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
+
+    if (RRXineramaScreenActive (pScreen))
+    {
+	rrScrPriv(pScreen);
+	if (pScrPriv-&gt;numCrtcs == 0 || pScrPriv-&gt;numOutputs == 0)
+	    RRGetInfo (pScreen);
+    }
+    
+    rep.type = X_Reply;
+    rep.sequenceNumber = client-&gt;sequence;
+    rep.number = RRXineramaScreenCount (pScreen);
+    rep.length = rep.number * sz_XineramaScreenInfo &gt;&gt; 2;
+    if(client-&gt;swapped) {
+	register int n;
+	swaps(&amp;rep.sequenceNumber, n);
+	swapl(&amp;rep.length, n);
+	swapl(&amp;rep.number, n);
+    }
+    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&amp;rep);
+
+    if(rep.number) {
+	rrScrPriv(pScreen);
+	xXineramaScreenInfo scratch;
+	int i;
+
+	for(i = 0; i &lt; pScrPriv-&gt;numCrtcs; i++) {
+	    RRCrtcPtr	crtc = pScrPriv-&gt;crtcs[i];
+	    if (RRXineramaCrtcActive (crtc))
+	    {
+	        int width, height;
+		RRCrtcGetScanoutSize (crtc, &amp;width, &amp;height);
+		scratch.x_org  = crtc-&gt;x;
+		scratch.y_org  = crtc-&gt;y;
+		scratch.width  = width;
+		scratch.height = height;
+		if(client-&gt;swapped) {
+		    register int n;
+		    swaps(&amp;scratch.x_org, n);
+		    swaps(&amp;scratch.y_org, n);
+		    swaps(&amp;scratch.width, n);
+		    swaps(&amp;scratch.height, n);
+		}
+		WriteToClient(client, sz_XineramaScreenInfo, (char *)&amp;scratch);
+	    }
+	}
+    }
+
+    return client-&gt;noClientException;
+}
+
+static int
+ProcRRXineramaDispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+    switch (stuff-&gt;data) {
+	case X_PanoramiXQueryVersion:
+	     return ProcRRXineramaQueryVersion(client);
+	case X_PanoramiXGetState:
+	     return ProcRRXineramaGetState(client);
+	case X_PanoramiXGetScreenCount:
+	     return ProcRRXineramaGetScreenCount(client);
+	case X_PanoramiXGetScreenSize:
+	     return ProcRRXineramaGetScreenSize(client);
+	case X_XineramaIsActive:
+	     return ProcRRXineramaIsActive(client);
+	case X_XineramaQueryScreens:
+	     return ProcRRXineramaQueryScreens(client);
+    }
+    return BadRequest;
+}
+
+/* SProc */
+
+static int
+SProcRRXineramaQueryVersion (ClientPtr client)
+{
+    REQUEST(xPanoramiXQueryVersionReq);
+    register int n;
+    swaps(&amp;stuff-&gt;length,n);
+    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
+    return ProcRRXineramaQueryVersion(client);
+}
+
+static int
+SProcRRXineramaGetState(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetStateReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
+    swapl (&amp;stuff-&gt;window, n);
+    return ProcRRXineramaGetState(client);
+}
+
+static int
+SProcRRXineramaGetScreenCount(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenCountReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
+    swapl (&amp;stuff-&gt;window, n);
+    return ProcRRXineramaGetScreenCount(client);
+}
+
+static int
+SProcRRXineramaGetScreenSize(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenSizeReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
+    swapl (&amp;stuff-&gt;window, n);
+    swapl (&amp;stuff-&gt;screen, n);
+    return ProcRRXineramaGetScreenSize(client);
+}
+
+static int
+SProcRRXineramaIsActive(ClientPtr client)
+{
+    REQUEST(xXineramaIsActiveReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
+    return ProcRRXineramaIsActive(client);
+}
+
+static int
+SProcRRXineramaQueryScreens(ClientPtr client)
+{
+    REQUEST(xXineramaQueryScreensReq);
+    register int n;
+    swaps (&amp;stuff-&gt;length, n);
+    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
+    return ProcRRXineramaQueryScreens(client);
+}
+
+int
+SProcRRXineramaDispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+    switch (stuff-&gt;data) {
+	case X_PanoramiXQueryVersion:
+	     return SProcRRXineramaQueryVersion(client);
+	case X_PanoramiXGetState:
+	     return SProcRRXineramaGetState(client);
+	case X_PanoramiXGetScreenCount:
+	     return SProcRRXineramaGetScreenCount(client);
+	case X_PanoramiXGetScreenSize:
+	     return SProcRRXineramaGetScreenSize(client);
+	case X_XineramaIsActive:
+	     return SProcRRXineramaIsActive(client);
+	case X_XineramaQueryScreens:
+	     return SProcRRXineramaQueryScreens(client);
+    }
+    return BadRequest;
+}
+
+static void
+RRXineramaResetProc(ExtensionEntry* extEntry)
+{
+}
+
+void
+RRXineramaExtensionInit(void)
+{
+#ifdef PANORAMIX
+    if(!noPanoramiXExtension)
+	return;
+#endif
+
+    /*
+     * Xinerama isn't capable enough to have multiple protocol screens each
+     * with their own output geometry.  So if there's more than one protocol
+     * screen, just don't even try.
+     */
+    if (screenInfo.numScreens &gt; 1)
+	return;
+
+    (void) AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0,
+			ProcRRXineramaDispatch,
+			SProcRRXineramaDispatch,
+			RRXineramaResetProc,
+			StandardMinorOpcode);
+}


hooks/post-receive
-- 
nx-libs.git (NX (redistributed))

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;nx-libs.git&quot; (NX (redistributed)).

</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011663.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	redist-client/3.5.0.15-2-ge3ba4bd
</A></li>
	<LI>Next message: <A HREF="011656.html">[X2Go-Commits] nx-libs.git - build-main (branch) updated:	redist-client/3.5.0.15-7-g380d239
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11694">[ date ]</a>
              <a href="thread.html#11694">[ thread ]</a>
              <a href="subject.html#11694">[ subject ]</a>
              <a href="author.html#11694">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/x2go-commits">More information about the X2Go-commits
mailing list</a><br>
</body></html>
